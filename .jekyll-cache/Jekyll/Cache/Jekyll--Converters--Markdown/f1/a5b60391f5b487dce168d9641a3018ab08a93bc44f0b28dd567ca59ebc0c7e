I"y<p>Recently in my series on C++ <code class="language-plaintext highlighter-rouge">algorithms</code>, <a href="http://sandordargo.com/blog/2020/01/29/stl-alogorithms-tutorial-part-9-replace">I presented the different <code class="language-plaintext highlighter-rouge">replace</code> functions</a> and said that they will replace all the matching elements. If you want to replace only one element or <code class="language-plaintext highlighter-rouge">n</code> elements, you have to find another way.</p>

<p>But whatâ€™s that other way?
<!--more--></p>

<h2 id="mutable-lambdas-scanning-all-the-way-through">Mutable lambdas scanning all the way through</h2>

<p>One of the readers, <a href="http://disq.us/p/27hkkfl">Ali, left his solution in the comments section</a>. Thank you, Ali!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre></td><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">replace_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">](</span><span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span><span class="k">return</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;},</span> <span class="mi">42</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>This is definitely something we can do, and if rename variable <code class="language-plaintext highlighter-rouge">i</code> to something like <code class="language-plaintext highlighter-rouge">alreadyReplaced</code>, it becomes even more readable.</p>

<p>Of course, we can slightly change the solution to use a named lambda or even a function object keeping it essentially the same.</p>

<p>They still share the same common disadvantage. They will iterate through the whole input container. This might or might not be an issue depending on your use case, the size of the container, etc. But if you have a container of thousands of elements or more, itâ€™ll likely be a problem.</p>

<p>In addition, using <code class="language-plaintext highlighter-rouge">mutable</code> in lambdas are not very elegant. In a functional programming style - and thatâ€™s pretty much what the STL is about -, a function should always produce the same output given the same input. If we have mutable lambdas, most probably itâ€™ll not be the case (or the mutable would be completely superfluous).</p>

<h2 id="still-mutable-but-throwing">Still mutable, but throwing</h2>

<p>If we accept to have a <code class="language-plaintext highlighter-rouge">mutable</code> lambda and while we avoid scanning all the elements after having replaced enough of them, we could also throw an exception. If you came to C++ after having coded in Python, this might seem completely valid for you, but in C++ itâ€™s not the best idea to use exceptions in a nominal control flow. And letâ€™s be fair, throwing an exception if you replaced <code class="language-plaintext highlighter-rouge">n</code> elements when you wanted to replace exactly <code class="language-plaintext highlighter-rouge">n</code> elements, itâ€™s not an exceptional event.</p>

<p>But letâ€™s see how it would be used.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre></td><td class="rouge-code"><pre><span class="k">try</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">replace_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">](</span><span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="k">mutable</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">invalid_argument</span><span class="p">{</span><span class="s">"Already replaced "</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">i</span><span class="p">)</span> <span class="o">+</span> <span class="s">" elements"</span><span class="p">};</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="err">Â </span> <span class="k">return</span> <span class="n">number</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="n">i</span><span class="o">++</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">;</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="p">},</span> <span class="mi">42</span><span class="p">);</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Done with replacing: "</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>At the end of the article, weâ€™ll see what <a href="http://quick-bench.com/">Quick Bench</a> says about the performance of the different versions.</p>

<p>Whatever we are going to see performance-wise, there might be other restrictions in your project. You might discourage/ban the usage of exceptions in your code like Google used to do. You also have to consider those.</p>

<p>Now, letâ€™s look for another solution.</p>

<h2 id="use-other-stl-algorithms">Use other STL algorithms</h2>

<p>If we wanted to use only algorithms we could do something similar:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">pos</span><span class="p">,</span> <span class="n">pos</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>First, we find the first occurrence of 4, which is the element we look for and then we call the replace algorithm on that exact position.</p>

<p>The good parts are that we use only STL algorithms, so we stay on the same level of abstraction and in the same style. On the other hand, we have that small, but still existing overhead that comes with calling an algorithm, plus we make an extra comparison whereas we could write only this:</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre></td><td class="rouge-code"><pre><span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> <span class="o">*</span><span class="n">pos</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>If we want to replace the <code class="language-plaintext highlighter-rouge">n</code> first elements, we have to repeat the same block n times.</p>

<p>In C++, there is nothing like <code class="language-plaintext highlighter-rouge">n.times</code> in Ruby, so we have to use a for loop here.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre></td><td class="rouge-code"><pre><span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="k">auto</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="o">*</span><span class="n">pos</span><span class="o">=</span><span class="mi">42</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Each time we look for an element that matches our predicate, then we replace it by 42.</p>

<p>This is not efficient because we always look from the beginning of the input container, whereas we know that there should be no elements matching before what we already replaced. (For simplicity, we ignore the case of concurrent updates in this article).</p>

<p>To overcome this deficiency, we can create a variable <code class="language-plaintext highlighter-rouge">begin</code> that will mark the beginning point of our search. Before we start the loop, it points to the beginning of the container and then at each iteration it is updated with the result of <code class="language-plaintext highlighter-rouge">std::find</code>. And in fact, it would be correct to advance the <code class="language-plaintext highlighter-rouge">begin</code> variable by one before starting over with the next iteration as we donâ€™t need to compare against what we just updated.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre></td><td class="rouge-code"><pre><span class="cp">#include &lt;algorithm&gt;
#include &lt;iostream&gt;
#include &lt;vector&gt;
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">auto</span> <span class="n">begin</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> 
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" copied numbers: "</span><span class="p">;</span>
<span class="err">Â </span> <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">number</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">number</span><span class="p">;</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

<span class="err">Â </span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>At this point, it seems we have something useable, and readable. Letâ€™s move it to its own function.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre></td><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="nf">replace_n</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">begin</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">end</span><span class="p">,</span> <span class="kt">int</span> <span class="n">oldValue</span><span class="p">,</span> <span class="kt">int</span> <span class="n">newValue</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="k">return</span> <span class="n">begin</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">9</span><span class="p">,</span> <span class="mi">10</span> <span class="p">};</span>
<span class="err">Â </span> <span class="n">replace_n</span><span class="p">(</span><span class="n">numbers</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">numbers</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>

</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now itâ€™s quite neat, both the naming and the interface matches what we are used in the STL.</p>

<p>The only problem is that this function is not at all reusable. Both the container and the contained types are fixed. Letâ€™s change this!</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre></td><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Iter</span><span class="p">&gt;</span>
<span class="n">Iter</span> <span class="nf">replace_n</span><span class="p">(</span><span class="n">Iter</span> <span class="n">begin</span><span class="p">,</span> <span class="n">Iter</span> <span class="n">end</span><span class="p">,</span> <span class="n">T</span> <span class="n">oldValue</span><span class="p">,</span> <span class="n">T</span> <span class="n">newValue</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">begin</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mi">4</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">replace</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span> <span class="n">begin</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">42</span><span class="p">);</span>
<span class="err">Â </span> <span class="err">Â </span> <span class="n">std</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="n">begin</span><span class="p">,</span><span class="mi">1</span><span class="p">);</span>
<span class="err">Â </span> <span class="p">}</span>
<span class="err">Â </span> <span class="k">return</span> <span class="n">begin</span><span class="p">;</span>
<span class="p">}</span>
</pre></td></tr></tbody></table></code></pre></div></div>

<p>Now we have something that we can use on any iterable container with any type that defines an <code class="language-plaintext highlighter-rouge">operator==</code>. The only problem here is that <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">Iter</code> doesnâ€™t have to correspond to each other. In practice, it means that you can pass in a vector of integers while you want to change a string value with another string.</p>

<p>With type traits or concepts this problem is solvable, but it goes beyond the scope of this article. We stop at this point, with this implementation.</p>

<h2 id="performance">Performance</h2>

<p>Where do we stand performance-wise?</p>

<p>The pictures are always showing the unoptimized values.</p>

<p>With a small number of elements (100) the fastest is our final solution. Itâ€™s about 10% better than the original one using mutable lambdas and 40% better than the throwing one. Using optimization the difference between mutable and templated vanishes.</p>

<p><img src="/assets/img/replace-n-100.png" alt="replaceN with 100 elements" /></p>

<p>On a thousand elements, the effect of scans kicks in and makes throwing a bit faster than the mutable version. But that difference goes away with optimization. The final templated solution beats the others by 10-20 percent.</p>

<p><img src="/assets/img/replace-n-1000.png" alt="replaceN with 1000 elements" /></p>

<p>When moving up to 10000 elements, the difference between the mutable and the throwing version stabilizes, with the templating still a little bit faster.</p>

<p><img src="/assets/img/replace-n-10000.png" alt="replaceN with 10000 elements" /></p>

<p>What we can see is that these differences are not significant. You wonâ€™t solve bottleneck issues, but in all cases, our final solution was at least a little bit faster than the others.</p>

<h2 id="conclusion">Conclusion</h2>

<p>The problem we solved today is how to replace not all but just <code class="language-plaintext highlighter-rouge">n</code> elements of a container. We started with a quite concise solution where we still used <code class="language-plaintext highlighter-rouge">std::replace</code> with a mutable lambda that can count how many elements were already replaced. Sadly, it continues the iteration even after having replaced enough elements.</p>

<p>This problem we could solve by throwing an exception, even though in C++ this is clearly not the best way to go. Exceptions are for exceptional events not for general control flow.</p>

<p>Using <code class="language-plaintext highlighter-rouge">std::find</code> within a for loop solved all our issues. No extra scans, no exceptions. The price is a raw loop. Thanks to the lack of extra scans and exceptions, itâ€™s also faster than the others, even though the differences are not significant.</p>

<p>Given all that we saw, I would go with the final solution if I needed a <code class="language-plaintext highlighter-rouge">replace_n</code> functionality.</p>

<p>Happy coding!</p>

<p><em>P.S. We can achieve the same output with the ranges library, but thatâ€™s a story for another day</em></p>
:ET