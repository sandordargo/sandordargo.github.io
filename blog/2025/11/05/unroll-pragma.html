<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Pragma unroll" /><meta property="og:locale" content="en_US" /><meta name="description" content="After conferences, I often write a couple of short articles about features or techniques I learned about, even if I don’t always find them particularly useful in my own work. At a recent talk, Andrei Alexandrescu mentioned the unroll pragma. I knew what loop unrolling was, but I had never used it and had never seen the pragma before. So let’s dive into it. What is loop unrolling? Loop unrolling is a performance optimization technique that reduces the overhead of loop control instructions and can improve opportunities for parallel execution. Normally, when a loop runs, three things happen in addition to executing the loop body: the loop counter is incremented, the loop condition is checked, and the program jumps back to the start of the loop. With loop unrolling, multiple iterations of the loop body are combined into one. In some cases, the loop can even be completely unrolled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 std::array&lt;int, 8&gt; arr{1, 2, 3, 4, 5, 6, 7, 8}; // loop without unroll for (int i = 0; i &lt; 8; i++) { arr[i] *= 2; } // loop unrolled by factor of 2 for (int i = 0; i &lt; 8; i+=2) { arr[i] *= 2; arr[i+1] *= 2; } // loop fully unrolled arr[0] *= 2; arr[1] *= 2; arr[2] *= 2; arr[3] *= 2; arr[4] *= 2; arr[5] *= 2; arr[6] *= 2; arr[7] *= 2; arr[8] *= 2; The benefits of loop unrolling include: less time spent on increments and condition checks, potentially better instruction pipelining on modern CPUs, and easier vectorization, since compilers can take advantage of SIMD instructions more effectively. There are three main ways loop unrolling can happen: Manual unrolling: as shown above. In practice, you should almost never do this, unless you are writing extremely performance-critical code and know exactly what you’re doing. Compiler-driven unrolling: the compiler decides when and how much to unroll, often guided by optimization flags. As Steve Downey said at CppCon2025, most days the compiler is smarter than us. Compiler-directed unrolling: the developer can hint to the compiler—through pragmas—that unrolling is preferable in certain cases. When you do loop unrolling, there are a couple of benefits: Less time is spent on increment and conditions checks arguably modern CPUs can take benefit of longer bodies and pipeline instruction unrolling also enables using vectorization, compilers can take advantage of SIMD instructions more easily What are pragmas? A pragma stands for “pragmatic information”. It is a special instruction for the compiler. Pragmas don’t change the logic of your program but can influence the compiler’s behavior, usually for optimization or platform-specific adjustments. They follow the syntax: 1 #pragma &lt;instruction&gt; Pragmas are compiler-specific and not standardized. If a compiler doesn’t support a pragma, it simply ignores it. This means your code will still compile, though the pragma may have no effect. In practice, pragmas give developers fine-grained control over compiler behavior, especially for performance tuning. They are powerful, but using them too heavily can reduce portability. What is pragma unroll? #pragma unroll is a compiler directive that hints to the compiler that a loop should be unrolled a certain number of times, or as much as possible. Its exact syntax and behavior depend on the compiler. From what I’ve found, it is most impactful in GPU programming, and the exact syntax #pragma unroll is primarily associated with NVIDIA’s CUDA compiler (NVCC). The example I saw at CppCon in Alexandrescu’s talk also used this specific syntax, which makes sense since he works at NVIDIA. NVCC In CUDA, you can write: 1 2 3 4 #pragma unroll 2 for (int i = 0; i &lt; 8; i++) { arr[i] *= 2; } The above would produce something equivalent to: 1 2 3 4 5 for (int i = 0; i &lt; 8; i += 2) { arr[i] *= 2; arr[i+1] *= 2; } #pragma unroll 8 would fully unroll the loop. #pragma unroll (without a number) leaves it up to the compiler to decide the level of unrolling. Clang Clang offers more fine-grained control with several options: #pragma clang loop unroll(disable|enable) – disable or enable loop unrolling, #pragma clang loop unroll(full) – request full unrolling, #pragma clang loop unroll_count(N) – request unrolling by N. Even without these pragmas, Clang already performs aggressive unrolling at -O2 and especially at -O3. GCC GCC provides #pragma GCC unroll N. If N is 0 or 1, no unrolling happens. Like Clang, GCC enables some unrolling with -O2 and -O3. The -funroll-loops compiler flag can explicitly force more unrolling. MSVC MSVC does not provide a pragma for loop unrolling. It has other loop-related pragmas (such as #pragma loop for hints on parallelization and vectorization), but loop unrolling must be left to the compiler’s own heuristics. Conclusion Loop unrolling is a well-known optimization technique that reduces loop overhead and can unlock better performance through pipelining and vectorization. While you can always unroll loops manually, it’s almost always better to leave this job to the compiler, which can make smarter, context-aware decisions. Pragmas like #pragma unroll (and their compiler-specific variants) allow developers to guide the compiler in cases where performance is critical—especially in GPU programming. However, overuse can lead to code bloat and reduced portability. As with most optimizations, start by trusting the compiler. Only reach for pragmas like unroll if you’ve measured a performance bottleneck and are confident that the hint will help. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="After conferences, I often write a couple of short articles about features or techniques I learned about, even if I don’t always find them particularly useful in my own work. At a recent talk, Andrei Alexandrescu mentioned the unroll pragma. I knew what loop unrolling was, but I had never used it and had never seen the pragma before. So let’s dive into it. What is loop unrolling? Loop unrolling is a performance optimization technique that reduces the overhead of loop control instructions and can improve opportunities for parallel execution. Normally, when a loop runs, three things happen in addition to executing the loop body: the loop counter is incremented, the loop condition is checked, and the program jumps back to the start of the loop. With loop unrolling, multiple iterations of the loop body are combined into one. In some cases, the loop can even be completely unrolled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 std::array&lt;int, 8&gt; arr{1, 2, 3, 4, 5, 6, 7, 8}; // loop without unroll for (int i = 0; i &lt; 8; i++) { arr[i] *= 2; } // loop unrolled by factor of 2 for (int i = 0; i &lt; 8; i+=2) { arr[i] *= 2; arr[i+1] *= 2; } // loop fully unrolled arr[0] *= 2; arr[1] *= 2; arr[2] *= 2; arr[3] *= 2; arr[4] *= 2; arr[5] *= 2; arr[6] *= 2; arr[7] *= 2; arr[8] *= 2; The benefits of loop unrolling include: less time spent on increments and condition checks, potentially better instruction pipelining on modern CPUs, and easier vectorization, since compilers can take advantage of SIMD instructions more effectively. There are three main ways loop unrolling can happen: Manual unrolling: as shown above. In practice, you should almost never do this, unless you are writing extremely performance-critical code and know exactly what you’re doing. Compiler-driven unrolling: the compiler decides when and how much to unroll, often guided by optimization flags. As Steve Downey said at CppCon2025, most days the compiler is smarter than us. Compiler-directed unrolling: the developer can hint to the compiler—through pragmas—that unrolling is preferable in certain cases. When you do loop unrolling, there are a couple of benefits: Less time is spent on increment and conditions checks arguably modern CPUs can take benefit of longer bodies and pipeline instruction unrolling also enables using vectorization, compilers can take advantage of SIMD instructions more easily What are pragmas? A pragma stands for “pragmatic information”. It is a special instruction for the compiler. Pragmas don’t change the logic of your program but can influence the compiler’s behavior, usually for optimization or platform-specific adjustments. They follow the syntax: 1 #pragma &lt;instruction&gt; Pragmas are compiler-specific and not standardized. If a compiler doesn’t support a pragma, it simply ignores it. This means your code will still compile, though the pragma may have no effect. In practice, pragmas give developers fine-grained control over compiler behavior, especially for performance tuning. They are powerful, but using them too heavily can reduce portability. What is pragma unroll? #pragma unroll is a compiler directive that hints to the compiler that a loop should be unrolled a certain number of times, or as much as possible. Its exact syntax and behavior depend on the compiler. From what I’ve found, it is most impactful in GPU programming, and the exact syntax #pragma unroll is primarily associated with NVIDIA’s CUDA compiler (NVCC). The example I saw at CppCon in Alexandrescu’s talk also used this specific syntax, which makes sense since he works at NVIDIA. NVCC In CUDA, you can write: 1 2 3 4 #pragma unroll 2 for (int i = 0; i &lt; 8; i++) { arr[i] *= 2; } The above would produce something equivalent to: 1 2 3 4 5 for (int i = 0; i &lt; 8; i += 2) { arr[i] *= 2; arr[i+1] *= 2; } #pragma unroll 8 would fully unroll the loop. #pragma unroll (without a number) leaves it up to the compiler to decide the level of unrolling. Clang Clang offers more fine-grained control with several options: #pragma clang loop unroll(disable|enable) – disable or enable loop unrolling, #pragma clang loop unroll(full) – request full unrolling, #pragma clang loop unroll_count(N) – request unrolling by N. Even without these pragmas, Clang already performs aggressive unrolling at -O2 and especially at -O3. GCC GCC provides #pragma GCC unroll N. If N is 0 or 1, no unrolling happens. Like Clang, GCC enables some unrolling with -O2 and -O3. The -funroll-loops compiler flag can explicitly force more unrolling. MSVC MSVC does not provide a pragma for loop unrolling. It has other loop-related pragmas (such as #pragma loop for hints on parallelization and vectorization), but loop unrolling must be left to the compiler’s own heuristics. Conclusion Loop unrolling is a well-known optimization technique that reduces loop overhead and can unlock better performance through pipelining and vectorization. While you can always unroll loops manually, it’s almost always better to leave this job to the compiler, which can make smarter, context-aware decisions. Pragmas like #pragma unroll (and their compiler-specific variants) allow developers to guide the compiler in cases where performance is critical—especially in GPU programming. However, overuse can lead to code bloat and reduced portability. As with most optimizations, start by trusting the compiler. Only reach for pragmas like unroll if you’ve measured a performance bottleneck and are confident that the hint will help. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/11/05/unroll-pragma" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/11/05/unroll-pragma" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-11-05T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Pragma unroll" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-11-05T00:00:00+01:00","datePublished":"2025-11-05T00:00:00+01:00","description":"After conferences, I often write a couple of short articles about features or techniques I learned about, even if I don’t always find them particularly useful in my own work. At a recent talk, Andrei Alexandrescu mentioned the unroll pragma. I knew what loop unrolling was, but I had never used it and had never seen the pragma before. So let’s dive into it. What is loop unrolling? Loop unrolling is a performance optimization technique that reduces the overhead of loop control instructions and can improve opportunities for parallel execution. Normally, when a loop runs, three things happen in addition to executing the loop body: the loop counter is incremented, the loop condition is checked, and the program jumps back to the start of the loop. With loop unrolling, multiple iterations of the loop body are combined into one. In some cases, the loop can even be completely unrolled. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 std::array&lt;int, 8&gt; arr{1, 2, 3, 4, 5, 6, 7, 8}; // loop without unroll for (int i = 0; i &lt; 8; i++) { arr[i] *= 2; } // loop unrolled by factor of 2 for (int i = 0; i &lt; 8; i+=2) { arr[i] *= 2; arr[i+1] *= 2; } // loop fully unrolled arr[0] *= 2; arr[1] *= 2; arr[2] *= 2; arr[3] *= 2; arr[4] *= 2; arr[5] *= 2; arr[6] *= 2; arr[7] *= 2; arr[8] *= 2; The benefits of loop unrolling include: less time spent on increments and condition checks, potentially better instruction pipelining on modern CPUs, and easier vectorization, since compilers can take advantage of SIMD instructions more effectively. There are three main ways loop unrolling can happen: Manual unrolling: as shown above. In practice, you should almost never do this, unless you are writing extremely performance-critical code and know exactly what you’re doing. Compiler-driven unrolling: the compiler decides when and how much to unroll, often guided by optimization flags. As Steve Downey said at CppCon2025, most days the compiler is smarter than us. Compiler-directed unrolling: the developer can hint to the compiler—through pragmas—that unrolling is preferable in certain cases. When you do loop unrolling, there are a couple of benefits: Less time is spent on increment and conditions checks arguably modern CPUs can take benefit of longer bodies and pipeline instruction unrolling also enables using vectorization, compilers can take advantage of SIMD instructions more easily What are pragmas? A pragma stands for “pragmatic information”. It is a special instruction for the compiler. Pragmas don’t change the logic of your program but can influence the compiler’s behavior, usually for optimization or platform-specific adjustments. They follow the syntax: 1 #pragma &lt;instruction&gt; Pragmas are compiler-specific and not standardized. If a compiler doesn’t support a pragma, it simply ignores it. This means your code will still compile, though the pragma may have no effect. In practice, pragmas give developers fine-grained control over compiler behavior, especially for performance tuning. They are powerful, but using them too heavily can reduce portability. What is pragma unroll? #pragma unroll is a compiler directive that hints to the compiler that a loop should be unrolled a certain number of times, or as much as possible. Its exact syntax and behavior depend on the compiler. From what I’ve found, it is most impactful in GPU programming, and the exact syntax #pragma unroll is primarily associated with NVIDIA’s CUDA compiler (NVCC). The example I saw at CppCon in Alexandrescu’s talk also used this specific syntax, which makes sense since he works at NVIDIA. NVCC In CUDA, you can write: 1 2 3 4 #pragma unroll 2 for (int i = 0; i &lt; 8; i++) { arr[i] *= 2; } The above would produce something equivalent to: 1 2 3 4 5 for (int i = 0; i &lt; 8; i += 2) { arr[i] *= 2; arr[i+1] *= 2; } #pragma unroll 8 would fully unroll the loop. #pragma unroll (without a number) leaves it up to the compiler to decide the level of unrolling. Clang Clang offers more fine-grained control with several options: #pragma clang loop unroll(disable|enable) – disable or enable loop unrolling, #pragma clang loop unroll(full) – request full unrolling, #pragma clang loop unroll_count(N) – request unrolling by N. Even without these pragmas, Clang already performs aggressive unrolling at -O2 and especially at -O3. GCC GCC provides #pragma GCC unroll N. If N is 0 or 1, no unrolling happens. Like Clang, GCC enables some unrolling with -O2 and -O3. The -funroll-loops compiler flag can explicitly force more unrolling. MSVC MSVC does not provide a pragma for loop unrolling. It has other loop-related pragmas (such as #pragma loop for hints on parallelization and vectorization), but loop unrolling must be left to the compiler’s own heuristics. Conclusion Loop unrolling is a well-known optimization technique that reduces loop overhead and can unlock better performance through pipelining and vectorization. While you can always unroll loops manually, it’s almost always better to leave this job to the compiler, which can make smarter, context-aware decisions. Pragmas like #pragma unroll (and their compiler-specific variants) allow developers to guide the compiler in cases where performance is critical—especially in GPU programming. However, overuse can lead to code bloat and reduced portability. As with most optimizations, start by trusting the compiler. Only reach for pragmas like unroll if you’ve measured a performance bottleneck and are confident that the hint will help. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Pragma unroll","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/11/05/unroll-pragma"},"url":"https://www.sandordargo.com/blog/2025/11/05/unroll-pragma"}</script><title>Pragma unroll | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/05"> 05 </a> </span> <span>Pragma unroll</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Pragma unroll</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 5, 2025, 12:00 AM +0100" prep="on" > Nov 5, 2025 <i class="unloaded">2025-11-05T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="936 words">5 min</span></div></div><div class="post-content"><p>After conferences, I often write a couple of short articles about features or techniques I learned about, even if I don’t always find them particularly useful in my own work.</p><p>At a recent talk, <a href="https://erdani.org/">Andrei Alexandrescu</a> mentioned the <code class="language-plaintext highlighter-rouge">unroll</code> <em>pragma</em>. I knew what loop unrolling was, but I had never used it and had never seen the pragma before. So let’s dive into it.</p><h2 id="what-is-loop-unrolling">What is loop unrolling?</h2><p>Loop unrolling is a performance optimization technique that reduces the overhead of loop control instructions and can improve opportunities for parallel execution.</p><p>Normally, when a loop runs, three things happen in addition to executing the loop body:</p><ul><li>the loop counter is incremented,<li>the loop condition is checked,<li>and the program jumps back to the start of the loop.</ul><p>With loop unrolling, multiple iterations of the loop body are combined into one. In some cases, the loop can even be completely unrolled.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">};</span>

<span class="c1">// loop without unroll</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// loop unrolled by factor of 2</span>
<span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">+=</span><span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// loop fully unrolled</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="n">arr</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
</pre></table></code></div></div><p>The benefits of loop unrolling include:</p><ul><li>less time spent on increments and condition checks,<li>potentially better instruction pipelining on modern CPUs,<li>and easier vectorization, since compilers can take advantage of SIMD instructions more effectively.</ul><p>There are three main ways loop unrolling can happen:</p><ul><li><strong>Manual unrolling</strong>: as shown above. In practice, you should almost never do this, unless you are writing extremely performance-critical code and know exactly what you’re doing.<li><strong>Compiler-driven unrolling</strong>: the compiler decides when and how much to unroll, often guided by optimization flags. As <a href="https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025#my-favourite-ideas">Steve Downey said at CppCon2025</a>, most days the compiler is smarter than us.<li><strong>Compiler-directed unrolling</strong>: the developer can hint to the compiler—through pragmas—that unrolling is preferable in certain cases.</ul><p>When you do loop unrolling, there are a couple of benefits:</p><ul><li>Less time is spent on increment and conditions checks<li>arguably modern CPUs can take benefit of longer bodies and pipeline instruction<li>unrolling also enables using vectorization, compilers can take advantage of SIMD instructions more easily</ul><h2 id="what-are-pragmas">What are pragmas?</h2><p>A pragma stands for “pragmatic information”. It is a special instruction for the compiler. Pragmas don’t change the logic of your program but can influence the compiler’s behavior, usually for optimization or platform-specific adjustments.</p><p>They follow the syntax:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#pragma &lt;instruction&gt;
</span></pre></table></code></div></div><p>Pragmas are compiler-specific and not standardized. If a compiler doesn’t support a <code class="language-plaintext highlighter-rouge">pragma</code>, it simply ignores it. This means your code will still compile, though the <code class="language-plaintext highlighter-rouge">pragma</code> may have no effect.</p><p>In practice, pragmas give developers fine-grained control over compiler behavior, especially for performance tuning. They are powerful, but using them too heavily can reduce portability.</p><h2 id="what-is-pragma-unroll">What is <code class="language-plaintext highlighter-rouge">pragma unroll</code>?</h2><p><code class="language-plaintext highlighter-rouge">#pragma unroll</code> is a compiler directive that hints to the compiler that a loop should be unrolled a certain number of times, or as much as possible. Its exact syntax and behavior depend on the compiler.</p><p>From what I’ve found, it is most impactful in GPU programming, and the exact syntax <code class="language-plaintext highlighter-rouge">#pragma unroll</code> is primarily associated with NVIDIA’s CUDA compiler (NVCC). The example I saw at CppCon in Alexandrescu’s talk also used this specific syntax, which makes sense since he works at NVIDIA.</p><h3 id="nvcc">NVCC</h3><p>In CUDA, you can write:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="cp">#pragma unroll 2
</span><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The above would produce something equivalent to:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">arr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">#pragma unroll 8</code> would fully unroll the loop.</p><p><code class="language-plaintext highlighter-rouge">#pragma unroll</code> (without a number) leaves it up to the compiler to decide the level of unrolling.</p><h3 id="clang">Clang</h3><p>Clang offers more fine-grained control with several options:</p><ul><li><code class="language-plaintext highlighter-rouge">#pragma clang loop unroll(disable|enable)</code> – disable or enable loop unrolling,<li><code class="language-plaintext highlighter-rouge">#pragma clang loop unroll(full)</code> – request full unrolling,<li><code class="language-plaintext highlighter-rouge">#pragma clang loop unroll_count(N)</code> – request unrolling by <code class="language-plaintext highlighter-rouge">N</code>.</ul><p>Even without these pragmas, Clang already performs aggressive unrolling at <code class="language-plaintext highlighter-rouge">-O2</code> and especially at <code class="language-plaintext highlighter-rouge">-O3</code>.</p><h3 id="gcc">GCC</h3><p>GCC provides <code class="language-plaintext highlighter-rouge">#pragma GCC unroll N.</code></p><p>If <code class="language-plaintext highlighter-rouge">N</code> is 0 or 1, no unrolling happens.</p><p>Like Clang, GCC enables some unrolling with <code class="language-plaintext highlighter-rouge">-O2</code> and <code class="language-plaintext highlighter-rouge">-O3</code>.</p><p>The <code class="language-plaintext highlighter-rouge">-funroll-loops</code> compiler flag can explicitly force more unrolling.</p><h3 id="msvc">MSVC</h3><p>MSVC does not provide a <code class="language-plaintext highlighter-rouge">pragma</code> for loop unrolling. It has other loop-related pragmas (such as <code class="language-plaintext highlighter-rouge">#pragma loop</code> for hints on parallelization and vectorization), but loop unrolling must be left to the compiler’s own heuristics.</p><h2 id="conclusion">Conclusion</h2><p>Loop unrolling is a well-known optimization technique that reduces loop overhead and can unlock better performance through pipelining and vectorization. While you can always unroll loops manually, it’s almost always better to leave this job to the compiler, which can make smarter, context-aware decisions.</p><p>Pragmas like <code class="language-plaintext highlighter-rouge">#pragma unroll</code> (and their compiler-specific variants) allow developers to guide the compiler in cases where performance is critical—especially in GPU programming. However, overuse can lead to code bloat and reduced portability.</p><p>As with most optimizations, start by trusting the compiler. Only reach for pragmas like <code class="language-plaintext highlighter-rouge">unroll</code> if you’ve measured a performance bottleneck and are confident that the hint will help.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/optimization/" class="post-tag no-text-decoration" >optimization</a> <a href="/tags/loops/" class="post-tag no-text-decoration" >loops</a> <a href="/tags/pragmas/" class="post-tag no-text-decoration" >pragmas</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Pragma unroll - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/11/05/unroll-pragma" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Pragma unroll - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/11/05/unroll-pragma" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Pragma unroll - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/11/05/unroll-pragma" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Pragma unroll - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/11/05/unroll-pragma" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2019/01/23/optimized-cpp"><div class="card-body"> <span class="timeago small" > Jan 23, 2019 <i class="unloaded">2019-01-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Optimized C++ by Kurt Gunteroth</h3><div class="text-muted small"><p> After I attended a training on the subject of optimizing C++, I felt I’d be interested in going a bit deeper. At least to read a bit more about this topic. So I asked the trainer for some books he’...</p></div></div></a></div><div class="card"> <a href="/blog/2025/04/16/raw-loops-for-performance"><div class="card-body"> <span class="timeago small" > Apr 16, 2025 <i class="unloaded">2025-04-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Raw loops for performance?</h3><div class="text-muted small"><p> To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I rai...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/02/statements-with-initializers-part-2-loops"><div class="card-body"> <span class="timeago small" > Nov 2, 2022 <i class="unloaded">2022-11-02T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The evolution of statements with initializers in C++ - part 2</h3><div class="text-muted small"><p> In these two articles, we see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in progra...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/10/29/three-meanings-of-reference" class="btn btn-outline-primary" prompt="Older"><p>Three Meanings of Reference</p></a> <a href="/blog/2025/11/12/trip-report-meeting-cpp-2025" class="btn btn-outline-primary" prompt="Newer"><p>Trip report: Meeting C++ 2025</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Pragma unroll'; this.page.url = 'https://www.sandordargo.com/blog/2025/11/05/unroll-pragma'; this.page.identifier = '/blog/2025/11/05/unroll-pragma'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
