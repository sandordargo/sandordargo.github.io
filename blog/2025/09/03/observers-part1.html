<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Discovering observers - part 1" /><meta property="og:locale" content="en_US" /><meta name="description" content="The goal of this mini-series is to explore the Observer Design Pattern in C++, walking through different implementations and weighing their pros and cons. First, let’s briefly recap what the observer pattern is. It belongs to the family of behavioral design patterns. As a reminder: design patterns are usually grouped into three categories: creational, structural, and behavioral. You might also have encountered the observer under other names such as listener, event subscriber, or publisher-subscriber. The central idea is simple: instead of repeatedly querying an object for information, the querying object (the observer) gets notified automatically when the information holder (the subject) changes. For example, imagine an orchestrator object that needs the latest value of a user setting. Instead of polling the setting every n milliseconds, it can subscribe to value changes and receive notifications whenever a new value is set. Using the common terminology: there is typically one publisher and one or more subscribers. Subscribers register for events or changes, and whenever an update happens, the publisher notifies them. A Simple Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // https://godbolt.org/z/Krs81Kr8x #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; class Subscriber { public: void update(std::string_view message) const { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; } }; class Publisher { public: void subscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (const auto* subscriber : _subscribers) { subscriber-&gt;update(&quot;here is a new version&quot;); } } private: std::vector&lt;Subscriber*&gt; _subscribers; }; int main() { Publisher pub; Subscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ In this simple version: We have a Publisher that can subscribe/unsubscribe Subscribers. Subscribers get notified with a message. Subscriber::update is marked as const, but in real use it probably needs to update the subscriber’s internal state and therefore be non-const. For now, we’ll keep it, and revisit this later. So what’s the problem here? There are a few: We used generic names but the implementation is tightly coupled. We can’t easily reuse the logic for different kinds of publishers/subscribers. The message type is fixed (std::string_view). Let’s start improving things. Adding Inheritance One option is to introduce inheritance and abstract base classes for publishers and subscribers. Subscriber::update becomes a pure virtual function. The non-virtual Publisher::notify delegates to a virtual function notifyOne, following the Template Method Pattern and the Non-Virtual Idiom. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // https://godbolt.org/z/371EzsGns #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(std::string_view message) = 0; }; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, &quot;here is a new version&quot;); } } private: virtual void notifyOne(Subscriber* const, std::string_view message) const = 0; std::vector&lt;Subscriber*&gt; _subscribers; }; class SettingsSubscriber : public Subscriber { public: void update(std::string_view message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; } }; class SettingsPublisher : public Publisher { public: void notifyOne(Subscriber* const subscriber, std::string_view message) const override { subscriber-&gt;update(message); } }; int main() { SettingsPublisher pub; SettingsSubscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ This version is better: reusable, extensible, and type-safe. But it still assumes all messages are std::string_view. That’s better. Introducing Templates What if we want different message types? For example: std::string_view for text updates std::pair&lt;std::string, int&gt; for key-value updates We can generalize by turning both Publisher and Subscriber into templates parameterized by the message type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // https://godbolt.org/z/ocnjf83P7 #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; template &lt;typename Message&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(Message message) = 0; }; template &lt;typename Message&gt; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, &quot;here is a new version&quot;); } } private: virtual void notifyOne(Subscriber&lt;Message&gt;* const, Message message) const = 0; std::vector&lt;Subscriber&lt;Message&gt;*&gt; _subscribers; }; template &lt;typename Message&gt; class SettingsSubscriber : public Subscriber&lt;Message&gt; { public: void update(Message message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; } }; template &lt;typename Message&gt; class SettingsPublisher : public Publisher&lt;Message&gt; { public: void notifyOne(Subscriber&lt;Message&gt;* const subscriber, Message message) const override { subscriber-&gt;update(message); } }; int main() { SettingsPublisher&lt;std::string_view&gt; pub; SettingsSubscriber&lt;std::string_view&gt; s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ This gives us flexibility, but it reveals an already - existing issue: Publisher::notify hardcodes the message. That’s not great. Pushing Messages from the Publisher A better design is to let the publisher provide the message, rather than requiring it externally. We’ll make notify(Message) protected so only the publisher itself can decide when and how to push updates. Also, we’ll let the derived publishers and subscribers to hardcode the message type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //https://godbolt.org/z/Mv7YMM3aK #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; template &lt;typename Message&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(Message message) = 0; }; template &lt;typename Message&gt; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } protected: void notify(Message message) const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, message); } } private: virtual void notifyOne(Subscriber&lt;Message&gt;* const, Message message) const = 0; std::vector&lt;Subscriber&lt;Message&gt;*&gt; _subscribers; }; using SettingsMessage = std::pair&lt;std::string, int&gt;; class SettingsSubscriber : public Subscriber&lt;SettingsMessage&gt; { public: void update(std::pair&lt;std::string, int&gt; message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message.first &lt;&lt; &quot;=&quot; &lt;&lt; message.second &lt;&lt; &#39;\n&#39;; } }; class SettingsPublisher : public Publisher&lt;SettingsMessage&gt; { public: void notifyOne(Subscriber&lt;SettingsMessage&gt;* const subscriber, SettingsMessage message) const override { subscriber-&gt;update(message); } void setSetting1(int value) { _setting1 = value; notify({&quot;setting1&quot;, _setting1}); } void setSetting2(int value) { _setting2 = value; notify({&quot;setting2&quot;, _setting2}); } private: int _setting1{0}; int _setting2{0}; }; int main() { SettingsPublisher pub; SettingsSubscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.setSetting1(42); pub.unsubscribe(&amp;s1); pub.setSetting1(51); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: setting1=42 Subscriber is getting an update: setting1=42 Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: setting1=51 */ Now the publisher controls when updates happen, and subscribers automatically get the right type of message. At this stage, we have: Generic, reusable templates for publishers and subscribers. Customizable message types (string, pair, or anything else). A publisher-driven notification system. This design is quite usable. But there’s still a limitation: what if we want one publisher to handle multiple different message types (e.g., int for one setting and bool for another)? We’ll explore this next week. Conclusion We’ve taken the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. Along the way, we: Abstracted publishers and subscribers. Introduced templates for message flexibility. Ensured publishers control when and how updates are pushed. Next time, we’ll tackle the challenge of supporting multiple message types in a single publisher. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="The goal of this mini-series is to explore the Observer Design Pattern in C++, walking through different implementations and weighing their pros and cons. First, let’s briefly recap what the observer pattern is. It belongs to the family of behavioral design patterns. As a reminder: design patterns are usually grouped into three categories: creational, structural, and behavioral. You might also have encountered the observer under other names such as listener, event subscriber, or publisher-subscriber. The central idea is simple: instead of repeatedly querying an object for information, the querying object (the observer) gets notified automatically when the information holder (the subject) changes. For example, imagine an orchestrator object that needs the latest value of a user setting. Instead of polling the setting every n milliseconds, it can subscribe to value changes and receive notifications whenever a new value is set. Using the common terminology: there is typically one publisher and one or more subscribers. Subscribers register for events or changes, and whenever an update happens, the publisher notifies them. A Simple Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // https://godbolt.org/z/Krs81Kr8x #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; class Subscriber { public: void update(std::string_view message) const { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; } }; class Publisher { public: void subscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (const auto* subscriber : _subscribers) { subscriber-&gt;update(&quot;here is a new version&quot;); } } private: std::vector&lt;Subscriber*&gt; _subscribers; }; int main() { Publisher pub; Subscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ In this simple version: We have a Publisher that can subscribe/unsubscribe Subscribers. Subscribers get notified with a message. Subscriber::update is marked as const, but in real use it probably needs to update the subscriber’s internal state and therefore be non-const. For now, we’ll keep it, and revisit this later. So what’s the problem here? There are a few: We used generic names but the implementation is tightly coupled. We can’t easily reuse the logic for different kinds of publishers/subscribers. The message type is fixed (std::string_view). Let’s start improving things. Adding Inheritance One option is to introduce inheritance and abstract base classes for publishers and subscribers. Subscriber::update becomes a pure virtual function. The non-virtual Publisher::notify delegates to a virtual function notifyOne, following the Template Method Pattern and the Non-Virtual Idiom. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // https://godbolt.org/z/371EzsGns #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(std::string_view message) = 0; }; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, &quot;here is a new version&quot;); } } private: virtual void notifyOne(Subscriber* const, std::string_view message) const = 0; std::vector&lt;Subscriber*&gt; _subscribers; }; class SettingsSubscriber : public Subscriber { public: void update(std::string_view message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; } }; class SettingsPublisher : public Publisher { public: void notifyOne(Subscriber* const subscriber, std::string_view message) const override { subscriber-&gt;update(message); } }; int main() { SettingsPublisher pub; SettingsSubscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ This version is better: reusable, extensible, and type-safe. But it still assumes all messages are std::string_view. That’s better. Introducing Templates What if we want different message types? For example: std::string_view for text updates std::pair&lt;std::string, int&gt; for key-value updates We can generalize by turning both Publisher and Subscriber into templates parameterized by the message type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // https://godbolt.org/z/ocnjf83P7 #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; template &lt;typename Message&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(Message message) = 0; }; template &lt;typename Message&gt; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, &quot;here is a new version&quot;); } } private: virtual void notifyOne(Subscriber&lt;Message&gt;* const, Message message) const = 0; std::vector&lt;Subscriber&lt;Message&gt;*&gt; _subscribers; }; template &lt;typename Message&gt; class SettingsSubscriber : public Subscriber&lt;Message&gt; { public: void update(Message message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message &lt;&lt; &#39;\n&#39;; } }; template &lt;typename Message&gt; class SettingsPublisher : public Publisher&lt;Message&gt; { public: void notifyOne(Subscriber&lt;Message&gt;* const subscriber, Message message) const override { subscriber-&gt;update(message); } }; int main() { SettingsPublisher&lt;std::string_view&gt; pub; SettingsSubscriber&lt;std::string_view&gt; s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ This gives us flexibility, but it reveals an already - existing issue: Publisher::notify hardcodes the message. That’s not great. Pushing Messages from the Publisher A better design is to let the publisher provide the message, rather than requiring it externally. We’ll make notify(Message) protected so only the publisher itself can decide when and how to push updates. Also, we’ll let the derived publishers and subscribers to hardcode the message type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //https://godbolt.org/z/Mv7YMM3aK #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; template &lt;typename Message&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(Message message) = 0; }; template &lt;typename Message&gt; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\n&quot;; std::erase(_subscribers, subscriber); } protected: void notify(Message message) const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, message); } } private: virtual void notifyOne(Subscriber&lt;Message&gt;* const, Message message) const = 0; std::vector&lt;Subscriber&lt;Message&gt;*&gt; _subscribers; }; using SettingsMessage = std::pair&lt;std::string, int&gt;; class SettingsSubscriber : public Subscriber&lt;SettingsMessage&gt; { public: void update(std::pair&lt;std::string, int&gt; message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\n&quot; &lt;&lt; message.first &lt;&lt; &quot;=&quot; &lt;&lt; message.second &lt;&lt; &#39;\n&#39;; } }; class SettingsPublisher : public Publisher&lt;SettingsMessage&gt; { public: void notifyOne(Subscriber&lt;SettingsMessage&gt;* const subscriber, SettingsMessage message) const override { subscriber-&gt;update(message); } void setSetting1(int value) { _setting1 = value; notify({&quot;setting1&quot;, _setting1}); } void setSetting2(int value) { _setting2 = value; notify({&quot;setting2&quot;, _setting2}); } private: int _setting1{0}; int _setting2{0}; }; int main() { SettingsPublisher pub; SettingsSubscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.setSetting1(42); pub.unsubscribe(&amp;s1); pub.setSetting1(51); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: setting1=42 Subscriber is getting an update: setting1=42 Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: setting1=51 */ Now the publisher controls when updates happen, and subscribers automatically get the right type of message. At this stage, we have: Generic, reusable templates for publishers and subscribers. Customizable message types (string, pair, or anything else). A publisher-driven notification system. This design is quite usable. But there’s still a limitation: what if we want one publisher to handle multiple different message types (e.g., int for one setting and bool for another)? We’ll explore this next week. Conclusion We’ve taken the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. Along the way, we: Abstracted publishers and subscribers. Introduced templates for message flexibility. Ensured publishers control when and how updates are pushed. Next time, we’ll tackle the challenge of supporting multiple message types in a single publisher. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/09/03/observers-part1" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/09/03/observers-part1" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-09-03T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Discovering observers - part 1" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-03T00:00:00+02:00","datePublished":"2025-09-03T00:00:00+02:00","description":"The goal of this mini-series is to explore the Observer Design Pattern in C++, walking through different implementations and weighing their pros and cons. First, let’s briefly recap what the observer pattern is. It belongs to the family of behavioral design patterns. As a reminder: design patterns are usually grouped into three categories: creational, structural, and behavioral. You might also have encountered the observer under other names such as listener, event subscriber, or publisher-subscriber. The central idea is simple: instead of repeatedly querying an object for information, the querying object (the observer) gets notified automatically when the information holder (the subject) changes. For example, imagine an orchestrator object that needs the latest value of a user setting. Instead of polling the setting every n milliseconds, it can subscribe to value changes and receive notifications whenever a new value is set. Using the common terminology: there is typically one publisher and one or more subscribers. Subscribers register for events or changes, and whenever an update happens, the publisher notifies them. A Simple Example 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 // https://godbolt.org/z/Krs81Kr8x #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; class Subscriber { public: void update(std::string_view message) const { std::cout &lt;&lt; &quot;Subscriber is getting an update:\\n&quot; &lt;&lt; message &lt;&lt; &#39;\\n&#39;; } }; class Publisher { public: void subscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\\n&quot;; for (const auto* subscriber : _subscribers) { subscriber-&gt;update(&quot;here is a new version&quot;); } } private: std::vector&lt;Subscriber*&gt; _subscribers; }; int main() { Publisher pub; Subscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ In this simple version: We have a Publisher that can subscribe/unsubscribe Subscribers. Subscribers get notified with a message. Subscriber::update is marked as const, but in real use it probably needs to update the subscriber’s internal state and therefore be non-const. For now, we’ll keep it, and revisit this later. So what’s the problem here? There are a few: We used generic names but the implementation is tightly coupled. We can’t easily reuse the logic for different kinds of publishers/subscribers. The message type is fixed (std::string_view). Let’s start improving things. Adding Inheritance One option is to introduce inheritance and abstract base classes for publishers and subscribers. Subscriber::update becomes a pure virtual function. The non-virtual Publisher::notify delegates to a virtual function notifyOne, following the Template Method Pattern and the Non-Virtual Idiom. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 // https://godbolt.org/z/371EzsGns #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(std::string_view message) = 0; }; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, &quot;here is a new version&quot;); } } private: virtual void notifyOne(Subscriber* const, std::string_view message) const = 0; std::vector&lt;Subscriber*&gt; _subscribers; }; class SettingsSubscriber : public Subscriber { public: void update(std::string_view message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\\n&quot; &lt;&lt; message &lt;&lt; &#39;\\n&#39;; } }; class SettingsPublisher : public Publisher { public: void notifyOne(Subscriber* const subscriber, std::string_view message) const override { subscriber-&gt;update(message); } }; int main() { SettingsPublisher pub; SettingsSubscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ This version is better: reusable, extensible, and type-safe. But it still assumes all messages are std::string_view. That’s better. Introducing Templates What if we want different message types? For example: std::string_view for text updates std::pair&lt;std::string, int&gt; for key-value updates We can generalize by turning both Publisher and Subscriber into templates parameterized by the message type: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 // https://godbolt.org/z/ocnjf83P7 #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; template &lt;typename Message&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(Message message) = 0; }; template &lt;typename Message&gt; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\\n&quot;; std::erase(_subscribers, subscriber); } void notify() const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, &quot;here is a new version&quot;); } } private: virtual void notifyOne(Subscriber&lt;Message&gt;* const, Message message) const = 0; std::vector&lt;Subscriber&lt;Message&gt;*&gt; _subscribers; }; template &lt;typename Message&gt; class SettingsSubscriber : public Subscriber&lt;Message&gt; { public: void update(Message message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\\n&quot; &lt;&lt; message &lt;&lt; &#39;\\n&#39;; } }; template &lt;typename Message&gt; class SettingsPublisher : public Publisher&lt;Message&gt; { public: void notifyOne(Subscriber&lt;Message&gt;* const subscriber, Message message) const override { subscriber-&gt;update(message); } }; int main() { SettingsPublisher&lt;std::string_view&gt; pub; SettingsSubscriber&lt;std::string_view&gt; s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.notify(); pub.unsubscribe(&amp;s1); pub.notify(); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: here is a new version Subscriber is getting an update: here is a new version Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: here is a new version */ This gives us flexibility, but it reveals an already - existing issue: Publisher::notify hardcodes the message. That’s not great. Pushing Messages from the Publisher A better design is to let the publisher provide the message, rather than requiring it externally. We’ll make notify(Message) protected so only the publisher itself can decide when and how to push updates. Also, we’ll let the derived publishers and subscribers to hardcode the message type. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 //https://godbolt.org/z/Mv7YMM3aK #include &lt;iostream&gt; #include &lt;string_view&gt; #include &lt;vector&gt; template &lt;typename Message&gt; class Subscriber { public: virtual ~Subscriber() = default; virtual void update(Message message) = 0; }; template &lt;typename Message&gt; class Publisher { public: virtual ~Publisher() = default; void subscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Got a new subscriber\\n&quot;; _subscribers.push_back(subscriber); } void unsubscribe(Subscriber&lt;Message&gt;* subscriber) { std::cout &lt;&lt; &quot;Someone unsubscribed\\n&quot;; std::erase(_subscribers, subscriber); } protected: void notify(Message message) const { std::cout &lt;&lt; &quot;Sending an update to &quot; &lt;&lt; _subscribers.size() &lt;&lt; &quot; subscriber(s)\\n&quot;; for (auto* const subscriber : _subscribers) { notifyOne(subscriber, message); } } private: virtual void notifyOne(Subscriber&lt;Message&gt;* const, Message message) const = 0; std::vector&lt;Subscriber&lt;Message&gt;*&gt; _subscribers; }; using SettingsMessage = std::pair&lt;std::string, int&gt;; class SettingsSubscriber : public Subscriber&lt;SettingsMessage&gt; { public: void update(std::pair&lt;std::string, int&gt; message) override { std::cout &lt;&lt; &quot;Subscriber is getting an update:\\n&quot; &lt;&lt; message.first &lt;&lt; &quot;=&quot; &lt;&lt; message.second &lt;&lt; &#39;\\n&#39;; } }; class SettingsPublisher : public Publisher&lt;SettingsMessage&gt; { public: void notifyOne(Subscriber&lt;SettingsMessage&gt;* const subscriber, SettingsMessage message) const override { subscriber-&gt;update(message); } void setSetting1(int value) { _setting1 = value; notify({&quot;setting1&quot;, _setting1}); } void setSetting2(int value) { _setting2 = value; notify({&quot;setting2&quot;, _setting2}); } private: int _setting1{0}; int _setting2{0}; }; int main() { SettingsPublisher pub; SettingsSubscriber s1, s2; pub.subscribe(&amp;s1); pub.subscribe(&amp;s2); pub.setSetting1(42); pub.unsubscribe(&amp;s1); pub.setSetting1(51); } /* Got a new subscriber Got a new subscriber Sending an update to 2 subscriber(s) Subscriber is getting an update: setting1=42 Subscriber is getting an update: setting1=42 Someone unsubscribed Sending an update to 1 subscriber(s) Subscriber is getting an update: setting1=51 */ Now the publisher controls when updates happen, and subscribers automatically get the right type of message. At this stage, we have: Generic, reusable templates for publishers and subscribers. Customizable message types (string, pair, or anything else). A publisher-driven notification system. This design is quite usable. But there’s still a limitation: what if we want one publisher to handle multiple different message types (e.g., int for one setting and bool for another)? We’ll explore this next week. Conclusion We’ve taken the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. Along the way, we: Abstracted publishers and subscribers. Introduced templates for message flexibility. Ensured publishers control when and how updates are pushed. Next time, we’ll tackle the challenge of supporting multiple message types in a single publisher. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Discovering observers - part 1","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/09/03/observers-part1"},"url":"https://www.sandordargo.com/blog/2025/09/03/observers-part1"}</script><title>Discovering observers - part 1 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/09"> 09 </a> </span> <span> <a href="/03"> 03 </a> </span> <span>Discovering observers - part 1</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Discovering observers - part 1</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 3, 2025, 12:00 AM +0200" prep="on" > Sep 3 <i class="unloaded">2025-09-03T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1718 words">9 min</span></div></div><div class="post-content"><p>The goal of this mini-series is to explore the <strong>Observer Design Pattern</strong> in C++, walking through different implementations and weighing their pros and cons.</p><p>First, let’s briefly recap what the observer pattern is. It belongs to the family of <strong>behavioral design patterns</strong>.</p><blockquote><p>As a reminder: design patterns are usually grouped into three categories: <strong>creational</strong>, <strong>structural</strong>, and <strong>behavioral</strong>.</p></blockquote><p>You might also have encountered the observer under other names such as <em>listener</em>, <em>event subscriber</em>, or <em>publisher-subscriber</em>.</p><p>The central idea is simple: instead of repeatedly querying an object for information, the querying object (the <em>observer</em>) gets notified automatically when the information holder (the <em>subject</em>) changes. For example, imagine an orchestrator object that needs the latest value of a user setting. Instead of polling the setting every <code class="language-plaintext highlighter-rouge">n</code> milliseconds, it can <em>subscribe</em> to value changes and receive notifications whenever a new value is set.</p><p>Using the common terminology: there is typically <strong>one publisher</strong> and <strong>one or more subscribers</strong>. Subscribers register for events or changes, and whenever an update happens, the publisher notifies them.</p><h2 id="a-simple-example">A Simple Example</h2><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/Krs81Kr8x</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Subscriber</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Subscriber is getting an update:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Publisher</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">subscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Got a new subscriber</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">_subscribers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unsubscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Someone unsubscribed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">_subscribers</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sending an update to "</span> <span class="o">&lt;&lt;</span> <span class="n">_subscribers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">" subscriber(s)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">*</span> <span class="n">subscriber</span> <span class="o">:</span> <span class="n">_subscribers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="s">"here is a new version"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Subscriber</span><span class="o">*&gt;</span> <span class="n">_subscribers</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Publisher</span> <span class="n">pub</span><span class="p">;</span>
    <span class="n">Subscriber</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
Got a new subscriber
Got a new subscriber
Sending an update to 2 subscriber(s)
Subscriber is getting an update:
here is a new version
Subscriber is getting an update:
here is a new version
Someone unsubscribed
Sending an update to 1 subscriber(s)
Subscriber is getting an update:
here is a new version
*/</span>
</pre></table></code></div></div><p>In this simple version:</p><ul><li>We have a <code class="language-plaintext highlighter-rouge">Publisher</code> that can subscribe/unsubscribe <code class="language-plaintext highlighter-rouge">Subscriber</code>s.<li><code class="language-plaintext highlighter-rouge">Subscriber</code>s get notified with a message.<li><code class="language-plaintext highlighter-rouge">Subscriber::update</code> is marked as <code class="language-plaintext highlighter-rouge">const</code>, but in real use it probably needs to update the subscriber’s internal state and therefore be non-<code class="language-plaintext highlighter-rouge">const</code>. For now, we’ll keep it, and revisit this later.</ul><p>So what’s the problem here?</p><p>There are a few:</p><ul><li>We used generic names but the implementation is tightly coupled.<li>We can’t easily reuse the logic for different kinds of publishers/subscribers.<li>The message type is fixed (<code class="language-plaintext highlighter-rouge">std::string_view</code>).</ul><p>Let’s start improving things.</p><h2 id="adding-inheritance">Adding Inheritance</h2><p>One option is to introduce inheritance and abstract base classes for publishers and subscribers.</p><ul><li><code class="language-plaintext highlighter-rouge">Subscriber::update</code> becomes a pure virtual function.<li>The non-virtual <code class="language-plaintext highlighter-rouge">Publisher::notify</code> delegates to a virtual function notifyOne, following <a href="https://www.sandordargo.com/blog/2022/08/24/tmp-and-nvi">the Template Method Pattern and the Non-Virtual Idiom</a>.</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/371EzsGns</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Subscriber</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Subscriber</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Publisher</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Publisher</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">subscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Got a new subscriber</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">_subscribers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unsubscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Someone unsubscribed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">_subscribers</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sending an update to "</span> <span class="o">&lt;&lt;</span> <span class="n">_subscribers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">" subscriber(s)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="k">const</span> <span class="n">subscriber</span> <span class="o">:</span> <span class="n">_subscribers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">notifyOne</span><span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="s">"here is a new version"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">notifyOne</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">*</span> <span class="k">const</span><span class="p">,</span>
                           <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Subscriber</span><span class="o">*&gt;</span> <span class="n">_subscribers</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SettingsSubscriber</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subscriber</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Subscriber is getting an update:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
<span class="k">class</span> <span class="nc">SettingsPublisher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Publisher</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">notifyOne</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">*</span> <span class="k">const</span> <span class="n">subscriber</span><span class="p">,</span>
                   <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">SettingsPublisher</span> <span class="n">pub</span><span class="p">;</span>
    <span class="n">SettingsSubscriber</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
Got a new subscriber
Got a new subscriber
Sending an update to 2 subscriber(s)
Subscriber is getting an update:
here is a new version
Subscriber is getting an update:
here is a new version
Someone unsubscribed
Sending an update to 1 subscriber(s)
Subscriber is getting an update:
here is a new version
*/</span>
</pre></table></code></div></div><p>This version is better: reusable, extensible, and type-safe.</p><p>But it still assumes all messages are <code class="language-plaintext highlighter-rouge">std::string_view</code>.</p><p>That’s better.</p><h2 id="introducing-templates">Introducing Templates</h2><p>What if we want different message types? For example:</p><ul><li><code class="language-plaintext highlighter-rouge">std::string_view</code> for text updates<li><code class="language-plaintext highlighter-rouge">std::pair&lt;std::string, int&gt;</code> for key-value updates</ul><p>We can generalize by turning both <code class="language-plaintext highlighter-rouge">Publisher</code> and <code class="language-plaintext highlighter-rouge">Subscriber</code> into templates parameterized by the message type:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/ocnjf83P7</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Subscriber</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Subscriber</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Publisher</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Publisher</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">subscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Got a new subscriber</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">_subscribers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unsubscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Someone unsubscribed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">_subscribers</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">notify</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sending an update to "</span> <span class="o">&lt;&lt;</span> <span class="n">_subscribers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">" subscriber(s)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="k">const</span> <span class="n">subscriber</span> <span class="o">:</span> <span class="n">_subscribers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">notifyOne</span><span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="s">"here is a new version"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">notifyOne</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="k">const</span><span class="p">,</span>
                           <span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*&gt;</span> <span class="n">_subscribers</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SettingsSubscriber</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Subscriber is getting an update:</span><span class="se">\n</span><span class="s">"</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">SettingsPublisher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Publisher</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">notifyOne</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">subscriber</span><span class="p">,</span>
                   <span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">SettingsPublisher</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span> <span class="n">pub</span><span class="p">;</span>
    <span class="n">SettingsSubscriber</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string_view</span><span class="o">&gt;</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">notify</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
Got a new subscriber
Got a new subscriber
Sending an update to 2 subscriber(s)
Subscriber is getting an update:
here is a new version
Subscriber is getting an update:
here is a new version
Someone unsubscribed
Sending an update to 1 subscriber(s)
Subscriber is getting an update:
here is a new version
*/</span>
</pre></table></code></div></div><p>This gives us flexibility, but it reveals an already - existing issue: <code class="language-plaintext highlighter-rouge">Publisher::notify</code> hardcodes the message. That’s not great.</p><h2 id="pushing-messages-from-the-publisher">Pushing Messages from the Publisher</h2><p>A better design is to let the publisher provide the message, rather than requiring it externally.</p><ul><li>We’ll make <code class="language-plaintext highlighter-rouge">notify(Message)</code> protected so only the publisher itself can decide when and how to push updates.<li>Also, we’ll let the derived publishers and subscribers to hardcode the message type.</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
</pre><td class="rouge-code"><pre><span class="c1">//https://godbolt.org/z/Mv7YMM3aK </span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Subscriber</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Subscriber</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Message</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Publisher</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Publisher</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="kt">void</span> <span class="n">subscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Got a new subscriber</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">_subscribers</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">unsubscribe</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="n">subscriber</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Someone unsubscribed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">_subscribers</span><span class="p">,</span> <span class="n">subscriber</span><span class="p">);</span>
    <span class="p">}</span>

   <span class="k">protected</span><span class="o">:</span>
    <span class="kt">void</span> <span class="n">notify</span><span class="p">(</span><span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Sending an update to "</span> <span class="o">&lt;&lt;</span> <span class="n">_subscribers</span><span class="p">.</span><span class="n">size</span><span class="p">()</span>
                  <span class="o">&lt;&lt;</span> <span class="s">" subscriber(s)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="k">const</span> <span class="n">subscriber</span> <span class="o">:</span> <span class="n">_subscribers</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">notifyOne</span><span class="p">(</span><span class="n">subscriber</span><span class="p">,</span> <span class="n">message</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">notifyOne</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*</span> <span class="k">const</span><span class="p">,</span>
                           <span class="n">Message</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;*&gt;</span> <span class="n">_subscribers</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">SettingsMessage</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">SettingsSubscriber</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">SettingsMessage</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">update</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">message</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Subscriber is getting an update:</span><span class="se">\n</span><span class="s">"</span>
                  <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">"="</span> <span class="o">&lt;&lt;</span> <span class="n">message</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SettingsPublisher</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Publisher</span><span class="o">&lt;</span><span class="n">SettingsMessage</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">notifyOne</span><span class="p">(</span><span class="n">Subscriber</span><span class="o">&lt;</span><span class="n">SettingsMessage</span><span class="o">&gt;*</span> <span class="k">const</span> <span class="n">subscriber</span><span class="p">,</span>
                   <span class="n">SettingsMessage</span> <span class="n">message</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">subscriber</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="n">message</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">setSetting1</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_setting1</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">notify</span><span class="p">({</span><span class="s">"setting1"</span><span class="p">,</span> <span class="n">_setting1</span><span class="p">});</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">setSetting2</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">_setting2</span> <span class="o">=</span> <span class="n">value</span><span class="p">;</span>
        <span class="n">notify</span><span class="p">({</span><span class="s">"setting2"</span><span class="p">,</span> <span class="n">_setting2</span><span class="p">});</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">_setting1</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">_setting2</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">SettingsPublisher</span> <span class="n">pub</span><span class="p">;</span>
    <span class="n">SettingsSubscriber</span> <span class="n">s1</span><span class="p">,</span> <span class="n">s2</span><span class="p">;</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">subscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s2</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">setSetting1</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">unsubscribe</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s1</span><span class="p">);</span>
    <span class="n">pub</span><span class="p">.</span><span class="n">setSetting1</span><span class="p">(</span><span class="mi">51</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
Got a new subscriber
Got a new subscriber
Sending an update to 2 subscriber(s)
Subscriber is getting an update:
setting1=42
Subscriber is getting an update:
setting1=42
Someone unsubscribed
Sending an update to 1 subscriber(s)
Subscriber is getting an update:
setting1=51
*/</span>
</pre></table></code></div></div><p>Now the publisher controls when updates happen, and subscribers automatically get the right type of message.</p><p>At this stage, we have:</p><ul><li>Generic, reusable templates for publishers and subscribers.<li>Customizable message types (string, pair, or anything else).<li>A publisher-driven notification system.</ul><p>This design is quite usable.</p><p>But there’s still a limitation: what if we want one publisher to handle multiple different message types (e.g., int for one setting and <code class="language-plaintext highlighter-rouge">bool</code> for another)?</p><p>We’ll explore this next week.</p><h2 id="conclusion">Conclusion</h2><p>We’ve taken the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. Along the way, we:</p><ul><li>Abstracted publishers and subscribers.<li>Introduced templates for message flexibility.<li>Ensured publishers control when and how updates are pushed.</ul><p>Next time, we’ll tackle the challenge of supporting multiple message types in a single publisher.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/designpatterns/" class="post-tag no-text-decoration" >designpatterns</a> <a href="/tags/observer/" class="post-tag no-text-decoration" >observer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Discovering observers - part 1 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/09/03/observers-part1" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Discovering observers - part 1 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/09/03/observers-part1" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Discovering observers - part 1 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/09/03/observers-part1" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Discovering observers - part 1 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/09/03/observers-part1" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/09/10/observers-part2"><div class="card-body"> <span class="timeago small" > Sep 10 <i class="unloaded">2025-09-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Discovering observers - part 2</h3><div class="text-muted small"><p> Last week, we took the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. We ended up with abstracted publishers and subscribers,...</p></div></div></a></div><div class="card"> <a href="/blog/2025/09/17/observers-part3"><div class="card-body"> <span class="timeago small" > Sep 17 <i class="unloaded">2025-09-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Discovering observers - part 3</h3><div class="text-muted small"><p> Over the last two weeks, we explored different implementations of the observer pattern in C++. We began with a very simple example, then evolved toward a more flexible, template- and inheritance-ba...</p></div></div></a></div><div class="card"> <a href="/blog/2023/03/15/binary-sizes-and-observer-pattern"><div class="card-body"> <span class="timeago small" > Mar 15, 2023 <i class="unloaded">2023-03-15T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The observer pattern and binary sizes</h3><div class="text-muted small"><p> In the previous article on binary sizes, we discussed how the decorator pattern’s classic and modern implementation fares in terms of binary size. We saw that the modern implementation had a smalle...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/08/27/lookup-value-in-map" class="btn btn-outline-primary" prompt="Older"><p>How to look up values in a map</p></a> <a href="/blog/2025/09/10/observers-part2" class="btn btn-outline-primary" prompt="Newer"><p>Discovering observers - part 2</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Discovering observers - part 1'; this.page.url = 'https://www.sandordargo.com/blog/2025/09/03/observers-part1'; this.page.identifier = '/blog/2025/09/03/observers-part1'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
