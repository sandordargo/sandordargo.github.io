<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Trip report: CppCon 2025" /><meta property="og:locale" content="en_US" /><meta name="description" content="A dream came true. My C++ conference journey started with CppCon. Well, almost. Back in 2019, my senior manager told me I would travel to the USA for a week to attend CppCon. In the end, cost-cutting measures changed the plan, and I was sent instead to a one-day conference within my country — CPPP. It was a wonderful event and formative in two ways: I realized that I, too, could stand on stage, share my experience, and help others grow. I also realized it’s better to carve my own path to conferences than to rely on a company sending me. In short, I learned that it’s better to be invited than to be sent. Of course, speaking at a conference is never only about speaking. It’s at least as much about attending, listening, and learning from others. For that, I’m deeply grateful — both to the organizers for putting together such a remarkable event and to my family for making it possible for me to be there. In this post, I’ll share: Thoughts on the overall conference experience. Highlights from talks and ideas that resonated with me. A few words about my own talk. I’ll update this article with links to the recordings as soon as they become available. CppCon, a conference on a different scale CppCon is simply bigger than any other C++ conference I’ve attended. A massive venue packed with people and sponsors. I logged more than 10,000 steps on the very first day — without ever leaving the resort or going to the gym. The whole experience felt like it was on another scale compared to European conferences (which I also love). But then again, that’s often the impression when you see something American from a European perspective, isn’t it? I never would have imagined a C++ conference where a live band plays while Bjarne Stroustrup himself makes final checks before stepping on stage to deliver the opening keynote. Absolutely rocks. Bjarne is ready to rock at CppCon2025 One area where I think European conferences often do better is catering. Probably it’s a matter of scale, but I really appreciate not having to think about where and what to eat. At CppCon, many sponsors hosted invitation-only lunches and dinners, which I found both interesting and unusual. That leads me to a funny story about language differences. Living in France, for me entrée clearly means a starter course — it’s the entry to a longer meal. In the US, however, it turns out entrée is a fancy way of saying “main course”. So at my first seated dinner at Aurora, I served myself only a little of the entrée, assuming I’d need room for the main course. As you can guess, I unintentionally ran a calorie deficit that day. Another thought on the venue: I hardly met anyone - especially from Europe - who liked it. I understand why, but I tend to disagree. Yes, it’s in the middle of nowhere, and visiting Downtown Denver center during the conference is out of the question. But the schedule is so packed — with regular talks, open-content sessions, fireside chats, lightning talks, and sponsored meals — you’re often booked from 7 AM to 10 PM. How could you even think about doing anything else? One more difference compared to Europe: people here seemed a bit harsher. I saw many more attendees leaving in the middle of talks than I usually do at European events — thankfully not many left mine. I don’t know if it was just coincidence or a cultural difference. All in all, it was an incredible experience to finally be at CppCon. My favourite talks I usually share my three favourite talks and three favourite ideas from a conference. Since most conferences I attend last three days, that number fits nicely. But CppCon — excluding pre- and post-conference workshops — runs for five full days. So this time, I picked five talks, one per day. They’re listed here in the chronological order of their presentation. On the very first evening, I had a great discussion with Peter Muldoon about what makes a talk truly exceptional. We came up with three essential components: The talk must share interesting ideas (they don’t even have to be technical). The presenter must deliver those ideas in an engaging way (something that’s often missing!). The talk must energize you so much that once you’re back at work, you want to try them out immediately. The talks I’ve chosen to share below satisfy at least two of these three criteria. (Sadly, I can’t return to work and experiment with C++26 contracts or reflection just yet..) The Joy of C++26 Contracts (and Some Myth-Conceptions) by Herb Sutter I wasn’t sure which talk to attend, but I chose Herb’s. It’s always a safe bet — he’s an excellent speaker and knows more about C++ than most. Plus, I wanted to deepen my understanding of contracts. I already had a general idea of what contracts are and why they’re useful, but the description of Herb’s talk promised something more — best practices and deeper insights for something that’s not even shipped yet. And indeed, I walked away with far more than I expected. Here are six key takeaways to watch out for: Don’t use contracts as program logic asserts. Otherwise, you end up duplicating work. Don’t write contract assertions with side effects. You can’t predict how many times a check will be executed. (Fortunately, most such mistakes are caught at compile time.) Avoid splitting compound conditions. Keep them together and benefit from short-circuiting. Use throwing violation handlers judiciously. Throwing during an assertion failure can be dangerous — you must ensure no other exception is being handled and no stack unwinding is in progress. Understand how build modes interact. Some enforce assertions, some ignore them, and others offer more nuanced options. They might be combined over translation units. Know which one you’re in. Be aware of the limitations of the minimal viable product arriving in C++26. This is only the beginning, not the full vision of contracts. Alex Stepanov, Generic Programming and the STL by Jon Kalb Jon Kalb, the conference chair, gave an open-content talk at 7:15 AM. Despite the early hour, dozens of people showed up for a historical session on the father of the Standard Template Library. Let me stress that historical here is not a negative label. Quite the opposite: understanding history makes it easier to grasp the present. The same applies to programming languages and libraries — it’s much easier to understand how something works if we know when, how, and why it was designed. When the STL was created in the 1980s and later submitted for standardization in the early 1990s, Object-Oriented Programming was the dominant paradigm. Committee members struggled to fully appreciate the enormous contribution Stepanov made by designing a library of generic algorithms that allowed code reuse across problems without rewrites — and without sacrificing performance. The STL is built around four main components: Algorithms: function templates that typically encapsulate loops. Containers: structures that store the data algorithms operate on. Iterators: the bridge between algorithms and containers. Callables: functions or function-like objects that customize algorithm behavior. While many of us tend to see containers as the most useful or fundamental component, Stepanov considered them mere tools to store data. For him, the true foundation were always algorithms. Jon also shared some lessons learned from the STL design. Some are obvious — like the confusing choice of names between clear and empty. Others are less well-known. For example: if unordered_* containers are hash-based, why aren’t they simply called hash_*? The answer is partly political, partly practical. Back in the pre-C++98 days, the committee couldn’t resolve all disagreements, so they left them out of the first standard. By the time they were eventually standardized, different companies had already implemented their own versions — sometimes even inside the std namespace. Choosing one over another would have broken existing code and upset vendors. The compromise was to adopt another name. How to Tame Packs, std::tuple, and the Wily std::integer_sequence by Andrei Alexandrescu Andrei Alexandrescu, author of Modern C++ Design: Generic Programming and Design Patterns Applied, is always among the best speakers at C++ conferences. I’m not sure he’d appreciate this comparison, but if there were a competition for technical stand-up comedy, he’d be a strong contender. Of course, I wouldn’t highlight his talk if it were only entertaining. It was also technically deep and complex — better described as multi-threaded. He explored in detail how to work effectively with template parameter packs and tuples. Summarizing the full content would be impossible in a few paragraphs, so I’ll just recommend watching the recording when it becomes available. Still, I want to share two points that stuck with me. First, about that “multi-threaded” aspect: while explaining template metaprogramming, Andrei was also weaving in a parallel discussion on the use of LLMs. Some attendees might have felt reassured when he said we shouldn’t rely on chatbots for programming. But his actual point was subtler: don’t use chatbots, use coding agents. Second, he reminded us why “back to basics” talks remain so important. While AI can master syntax and basic usage, humans still crave learning from humans, and real interaction matters. As he put it, coding agents are like “interns high on sugar, caffeine, and cocaine at the same time” — they can produce a lot, but their work always needs reviewing. Without a solid grasp of the basics, we simply won’t be able to do that. Mastering the Code Review Process by Peter Muldoon Unlike previous years, this time there were several talks focused on code reviews — a topic close to me as well, since it’s what I’ll be speaking about at Meeting C++ this year. While many presenters covered the technical side of code reviews, Peter took a different angle. As usual, he focused on the engineering principles behind the practice: the process of giving and receiving reviews, and how it ties back to the ultimate purpose of software engineering — delivering business value. Code reviews support that goal by improving code quality, ensuring correctness, and educating engineers. But to achieve this, they must be timely and relevant. Peter emphasized that reviews should be prioritized: it’s often more important to review and merge code than to write new code. And while it’s easy to nitpick over small details, reviews should always keep the big picture in mind. Peter Muldoon at CppCon2025 Peter also shared some practical advice: As an author: review your code yourself first. Fix warnings, ensure tests pass, and make life easy for reviewers. Use a clean title and description, highlight key points, and keep your changes small. As a reviewer: review the code, not the author. Avoid destructive comments, and clearly label your feedback. Is it a blocker that must be fixed? A consideration for improvement? A nitpick that’s just your opinion? It could also be a genuine question or even a simple kudos. A great talk with clear, actionable takeaways. Kudos, Peter! Cache Me Maybe: Using Caches to Improve Performance in Production Code! by Michelle Fae D’Souza Michelle’s talk was both fun and highly practical — she kept the suspense alive until the end with the question: cache or not to cache? And the answer, of course, depends. She walked us through how modern CPUs and memory hierarchies work, showing how much performance we can leave on the table if we ignore cache behavior. For example, replacing an unordered_map with a vector (and using indices as keys) can deliver up to a 10x speedup thanks to spatial locality: vectors use contiguous memory, while hash maps scatter their data, leading to frequent cache misses. Michelle also explored the idea of cache friendliness: How to lay out variables for better memory usage. The difference between an array of structs and a struct of arrays. Why declaration order matters—keeping variables close to where they’re used improves locality and avoids cache pollution. She even touched on some lower-level details. We learned about RDTSC, how CPUs perform out-of-order execution, and why relying on prefetching isn’t always the magic bullet. She showed how you can use memory fences to enforce ordering: any load or store after the fence will really happen after it. Both CPUs and compilers can reorder instructions, so understanding this interplay is crucial. A great reminder that sometimes the biggest optimizations don’t come from clever algorithms, but simply from arranging data in a way that works with the hardware rather than against it. My favourite ideas Now let me share five interesting ideas from five different talks. Computing power vs. human expectations (Bjarne Stroustrup) In my own talk, I pointed out that the cost of computing power is dropping on a logarithmic scale, while the cost of engineers continues to rise — albeit only linearly. Bjarne’s keynote made me reflect on that again. He emphasized that although computing power keeps getting cheaper and faster, there’s one thing moving even faster: our expectations. Every year we dream up more ambitious software, with more features and more complexity. As a result, performance still matters just as much as ever — not because hardware is lacking, but because our expectations have grown to outpace it. The best usages of std::move (Steve Downey) Steve gave a fascinating talk on std::optional&lt;T&amp;&gt;, which finally made it into the standard nine years after std::optional&lt;T&gt; was introduced. I’ll save a full deep dive into this new feature for a separate article. Here, I want to highlight one memorable insight from his talk: “the best moves are the ones we don’t have to write.” Every time we explicitly write std::move, we’re explaining something to the compiler. But in most cases, the compiler already knows better than we do. This doesn’t mean std::move is bad — far from it — but it does mean we should pause before sprinkling it everywhere. Often, the smartest move is letting the compiler handle things for us. Would you consider running away? (John Lakos) Earlier this year at C++ on Sea, I was eager to attend John Lakos’s talk. Unfortunately, I had to skip it at the last minute — since I was giving my own talk at the same time. At CppCon, though, I finally had the chance to hear him speak on What C++ Needs to Be Safe. One thought in particular stuck with me: “If C++32 was as safe as Rust, would you consider running away?” John Lakos at CppCon2025 For most of us, I think the answer is no. And there’s a lot of ongoing work to make that future possible. John himself is investing a tremendous amount of effort into safety, and with features like contracts and the introduction of erroneous behavior, the language is steadily moving in that direction. Thank you, John — and thank you to everyone pushing C++ toward a safer future. C++ might be the new lingua franca of programming languages (Herb Sutter) Herb often uses historical analogies in his talks, and as a history lover myself, I truly appreciate that. This time, he spoke about what held great empires together. Roads and commerce were of course important, but a common — often second — language was always crucial. For the Neo-Assyrian, Neo-Babylonian and Achaemenid Empires, that language was Aramaic. Later, for the Roman and Byzantine Empires, it was Koine Greek or Latin. Without a shared language, no empire could endure for centuries. Programming languages also have their own lingua franca for interoperability: C. For decades, it has served as the universal glue for foreign function interfaces. But it comes at a cost—an unsafe mix of raw pointers, unencapsulated structs, and manual lifetime management. Herb argued that with C++ static reflection, we may have the chance to move beyond this. C++ could become the new lingua franca, offering the same universality as C but at a higher level of abstraction and with far greater safety for cross-language communication. It Takes a Village (Matt Godbolt) Whether at conferences, in online chat rooms, or in the comment sections of blogs — it’s all part of our community. And building that community takes effort. It’s not the job or destiny of just a few individuals. It truly takes a village. If we want a vibrant community, we can’t just be passive members. We each have to contribute in our own way: write, speak, share feedback, and support others. That’s how the C++ community grows and thrives. My own talk Finally, let me share my own contributions to the conference. On a small negative note, I didn’t give a lightning talk this time. I usually try to, but I hadn’t prepared in advance and by the end of each day in Colorado I was simply too knackered. Note to self: prepare lightning talks ahead of time, as I usually do. So, how did my talk go — and what was it about in the first place? Once again, I came to a C++ conference to talk about clean code and performance without showing a single line of code or a performance benchmark on the slides. My main message was simple: prioritize maintainability first. It took some courage to say this one day after Vittorio Romeo delivered a keynote arguing that we should think about performance first. In my view, that’s rarely the case. If you’re writing a program for the long term, maintainability has to come first. Edit: after discussing with Vittorio and having re-watched the pre-release, I must admit that I just frowned when Vittorio said that design for performance from the start. After, there was a big “if”. If speed is such a requirement that requires up-front design. Certain performance requirements cannot be afterthoughts! Me at CppCon Clean code is really just an optimization for readability. And optimization is always about trade-offs. While clean code may not yield the absolute fastest possible program, most of us don’t need those last drops of performance. There are usually more pressing concerns: maybe binary size, maybe portability, but more often than not, readability. Especially in large organizations, where people constantly come and go, readability becomes the default priority. It’s also worth remembering that the cost of CPU cycles continues to fall, while the cost of developers keeps rising. That’s why it makes sense to optimize for developer productivity, not for CPU time. And clean, readable code directly contributes to productivity. Growing salaries, decreasing CPU costs Of course, sometimes optimization is necessary — but do it wisely. Chances are, you’ll never need the kind of low-level wizardry that the Quake developers once pulled off. In most real-world cases, focusing on higher-level optimizations — like reducing database queries or cutting down on network calls — will give you a solution that’s “fast enough”. Conclusion CppCon 2025 was everything I had hoped for and more. The scale, the talks, the people — it all reminded me why conferences matter so much. They are not just about learning new techniques or hearing the latest on upcoming C++ features, but also about the famous hallway track: connecting with others, sharing ideas, and recharging our enthusiasm for the craft. I walked away with new insights into C++26 contracts, fresh perspectives on generic programming, some serious food for thought about code reviews and even cache behavior. I also left with a stronger sense of community — the feeling that we are all contributing, in big or small ways, to the language and ecosystem we are part of. Most importantly, I came back energized. Conferences like CppCon are not just about what you learn during the week, but about how you take those lessons back home and put them into practice. I’m grateful to the organizers, the speakers, and everyone I had the chance to meet and talk to. And I’m already looking forward to the next opportunity to gather with this amazing community. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="A dream came true. My C++ conference journey started with CppCon. Well, almost. Back in 2019, my senior manager told me I would travel to the USA for a week to attend CppCon. In the end, cost-cutting measures changed the plan, and I was sent instead to a one-day conference within my country — CPPP. It was a wonderful event and formative in two ways: I realized that I, too, could stand on stage, share my experience, and help others grow. I also realized it’s better to carve my own path to conferences than to rely on a company sending me. In short, I learned that it’s better to be invited than to be sent. Of course, speaking at a conference is never only about speaking. It’s at least as much about attending, listening, and learning from others. For that, I’m deeply grateful — both to the organizers for putting together such a remarkable event and to my family for making it possible for me to be there. In this post, I’ll share: Thoughts on the overall conference experience. Highlights from talks and ideas that resonated with me. A few words about my own talk. I’ll update this article with links to the recordings as soon as they become available. CppCon, a conference on a different scale CppCon is simply bigger than any other C++ conference I’ve attended. A massive venue packed with people and sponsors. I logged more than 10,000 steps on the very first day — without ever leaving the resort or going to the gym. The whole experience felt like it was on another scale compared to European conferences (which I also love). But then again, that’s often the impression when you see something American from a European perspective, isn’t it? I never would have imagined a C++ conference where a live band plays while Bjarne Stroustrup himself makes final checks before stepping on stage to deliver the opening keynote. Absolutely rocks. Bjarne is ready to rock at CppCon2025 One area where I think European conferences often do better is catering. Probably it’s a matter of scale, but I really appreciate not having to think about where and what to eat. At CppCon, many sponsors hosted invitation-only lunches and dinners, which I found both interesting and unusual. That leads me to a funny story about language differences. Living in France, for me entrée clearly means a starter course — it’s the entry to a longer meal. In the US, however, it turns out entrée is a fancy way of saying “main course”. So at my first seated dinner at Aurora, I served myself only a little of the entrée, assuming I’d need room for the main course. As you can guess, I unintentionally ran a calorie deficit that day. Another thought on the venue: I hardly met anyone - especially from Europe - who liked it. I understand why, but I tend to disagree. Yes, it’s in the middle of nowhere, and visiting Downtown Denver center during the conference is out of the question. But the schedule is so packed — with regular talks, open-content sessions, fireside chats, lightning talks, and sponsored meals — you’re often booked from 7 AM to 10 PM. How could you even think about doing anything else? One more difference compared to Europe: people here seemed a bit harsher. I saw many more attendees leaving in the middle of talks than I usually do at European events — thankfully not many left mine. I don’t know if it was just coincidence or a cultural difference. All in all, it was an incredible experience to finally be at CppCon. My favourite talks I usually share my three favourite talks and three favourite ideas from a conference. Since most conferences I attend last three days, that number fits nicely. But CppCon — excluding pre- and post-conference workshops — runs for five full days. So this time, I picked five talks, one per day. They’re listed here in the chronological order of their presentation. On the very first evening, I had a great discussion with Peter Muldoon about what makes a talk truly exceptional. We came up with three essential components: The talk must share interesting ideas (they don’t even have to be technical). The presenter must deliver those ideas in an engaging way (something that’s often missing!). The talk must energize you so much that once you’re back at work, you want to try them out immediately. The talks I’ve chosen to share below satisfy at least two of these three criteria. (Sadly, I can’t return to work and experiment with C++26 contracts or reflection just yet..) The Joy of C++26 Contracts (and Some Myth-Conceptions) by Herb Sutter I wasn’t sure which talk to attend, but I chose Herb’s. It’s always a safe bet — he’s an excellent speaker and knows more about C++ than most. Plus, I wanted to deepen my understanding of contracts. I already had a general idea of what contracts are and why they’re useful, but the description of Herb’s talk promised something more — best practices and deeper insights for something that’s not even shipped yet. And indeed, I walked away with far more than I expected. Here are six key takeaways to watch out for: Don’t use contracts as program logic asserts. Otherwise, you end up duplicating work. Don’t write contract assertions with side effects. You can’t predict how many times a check will be executed. (Fortunately, most such mistakes are caught at compile time.) Avoid splitting compound conditions. Keep them together and benefit from short-circuiting. Use throwing violation handlers judiciously. Throwing during an assertion failure can be dangerous — you must ensure no other exception is being handled and no stack unwinding is in progress. Understand how build modes interact. Some enforce assertions, some ignore them, and others offer more nuanced options. They might be combined over translation units. Know which one you’re in. Be aware of the limitations of the minimal viable product arriving in C++26. This is only the beginning, not the full vision of contracts. Alex Stepanov, Generic Programming and the STL by Jon Kalb Jon Kalb, the conference chair, gave an open-content talk at 7:15 AM. Despite the early hour, dozens of people showed up for a historical session on the father of the Standard Template Library. Let me stress that historical here is not a negative label. Quite the opposite: understanding history makes it easier to grasp the present. The same applies to programming languages and libraries — it’s much easier to understand how something works if we know when, how, and why it was designed. When the STL was created in the 1980s and later submitted for standardization in the early 1990s, Object-Oriented Programming was the dominant paradigm. Committee members struggled to fully appreciate the enormous contribution Stepanov made by designing a library of generic algorithms that allowed code reuse across problems without rewrites — and without sacrificing performance. The STL is built around four main components: Algorithms: function templates that typically encapsulate loops. Containers: structures that store the data algorithms operate on. Iterators: the bridge between algorithms and containers. Callables: functions or function-like objects that customize algorithm behavior. While many of us tend to see containers as the most useful or fundamental component, Stepanov considered them mere tools to store data. For him, the true foundation were always algorithms. Jon also shared some lessons learned from the STL design. Some are obvious — like the confusing choice of names between clear and empty. Others are less well-known. For example: if unordered_* containers are hash-based, why aren’t they simply called hash_*? The answer is partly political, partly practical. Back in the pre-C++98 days, the committee couldn’t resolve all disagreements, so they left them out of the first standard. By the time they were eventually standardized, different companies had already implemented their own versions — sometimes even inside the std namespace. Choosing one over another would have broken existing code and upset vendors. The compromise was to adopt another name. How to Tame Packs, std::tuple, and the Wily std::integer_sequence by Andrei Alexandrescu Andrei Alexandrescu, author of Modern C++ Design: Generic Programming and Design Patterns Applied, is always among the best speakers at C++ conferences. I’m not sure he’d appreciate this comparison, but if there were a competition for technical stand-up comedy, he’d be a strong contender. Of course, I wouldn’t highlight his talk if it were only entertaining. It was also technically deep and complex — better described as multi-threaded. He explored in detail how to work effectively with template parameter packs and tuples. Summarizing the full content would be impossible in a few paragraphs, so I’ll just recommend watching the recording when it becomes available. Still, I want to share two points that stuck with me. First, about that “multi-threaded” aspect: while explaining template metaprogramming, Andrei was also weaving in a parallel discussion on the use of LLMs. Some attendees might have felt reassured when he said we shouldn’t rely on chatbots for programming. But his actual point was subtler: don’t use chatbots, use coding agents. Second, he reminded us why “back to basics” talks remain so important. While AI can master syntax and basic usage, humans still crave learning from humans, and real interaction matters. As he put it, coding agents are like “interns high on sugar, caffeine, and cocaine at the same time” — they can produce a lot, but their work always needs reviewing. Without a solid grasp of the basics, we simply won’t be able to do that. Mastering the Code Review Process by Peter Muldoon Unlike previous years, this time there were several talks focused on code reviews — a topic close to me as well, since it’s what I’ll be speaking about at Meeting C++ this year. While many presenters covered the technical side of code reviews, Peter took a different angle. As usual, he focused on the engineering principles behind the practice: the process of giving and receiving reviews, and how it ties back to the ultimate purpose of software engineering — delivering business value. Code reviews support that goal by improving code quality, ensuring correctness, and educating engineers. But to achieve this, they must be timely and relevant. Peter emphasized that reviews should be prioritized: it’s often more important to review and merge code than to write new code. And while it’s easy to nitpick over small details, reviews should always keep the big picture in mind. Peter Muldoon at CppCon2025 Peter also shared some practical advice: As an author: review your code yourself first. Fix warnings, ensure tests pass, and make life easy for reviewers. Use a clean title and description, highlight key points, and keep your changes small. As a reviewer: review the code, not the author. Avoid destructive comments, and clearly label your feedback. Is it a blocker that must be fixed? A consideration for improvement? A nitpick that’s just your opinion? It could also be a genuine question or even a simple kudos. A great talk with clear, actionable takeaways. Kudos, Peter! Cache Me Maybe: Using Caches to Improve Performance in Production Code! by Michelle Fae D’Souza Michelle’s talk was both fun and highly practical — she kept the suspense alive until the end with the question: cache or not to cache? And the answer, of course, depends. She walked us through how modern CPUs and memory hierarchies work, showing how much performance we can leave on the table if we ignore cache behavior. For example, replacing an unordered_map with a vector (and using indices as keys) can deliver up to a 10x speedup thanks to spatial locality: vectors use contiguous memory, while hash maps scatter their data, leading to frequent cache misses. Michelle also explored the idea of cache friendliness: How to lay out variables for better memory usage. The difference between an array of structs and a struct of arrays. Why declaration order matters—keeping variables close to where they’re used improves locality and avoids cache pollution. She even touched on some lower-level details. We learned about RDTSC, how CPUs perform out-of-order execution, and why relying on prefetching isn’t always the magic bullet. She showed how you can use memory fences to enforce ordering: any load or store after the fence will really happen after it. Both CPUs and compilers can reorder instructions, so understanding this interplay is crucial. A great reminder that sometimes the biggest optimizations don’t come from clever algorithms, but simply from arranging data in a way that works with the hardware rather than against it. My favourite ideas Now let me share five interesting ideas from five different talks. Computing power vs. human expectations (Bjarne Stroustrup) In my own talk, I pointed out that the cost of computing power is dropping on a logarithmic scale, while the cost of engineers continues to rise — albeit only linearly. Bjarne’s keynote made me reflect on that again. He emphasized that although computing power keeps getting cheaper and faster, there’s one thing moving even faster: our expectations. Every year we dream up more ambitious software, with more features and more complexity. As a result, performance still matters just as much as ever — not because hardware is lacking, but because our expectations have grown to outpace it. The best usages of std::move (Steve Downey) Steve gave a fascinating talk on std::optional&lt;T&amp;&gt;, which finally made it into the standard nine years after std::optional&lt;T&gt; was introduced. I’ll save a full deep dive into this new feature for a separate article. Here, I want to highlight one memorable insight from his talk: “the best moves are the ones we don’t have to write.” Every time we explicitly write std::move, we’re explaining something to the compiler. But in most cases, the compiler already knows better than we do. This doesn’t mean std::move is bad — far from it — but it does mean we should pause before sprinkling it everywhere. Often, the smartest move is letting the compiler handle things for us. Would you consider running away? (John Lakos) Earlier this year at C++ on Sea, I was eager to attend John Lakos’s talk. Unfortunately, I had to skip it at the last minute — since I was giving my own talk at the same time. At CppCon, though, I finally had the chance to hear him speak on What C++ Needs to Be Safe. One thought in particular stuck with me: “If C++32 was as safe as Rust, would you consider running away?” John Lakos at CppCon2025 For most of us, I think the answer is no. And there’s a lot of ongoing work to make that future possible. John himself is investing a tremendous amount of effort into safety, and with features like contracts and the introduction of erroneous behavior, the language is steadily moving in that direction. Thank you, John — and thank you to everyone pushing C++ toward a safer future. C++ might be the new lingua franca of programming languages (Herb Sutter) Herb often uses historical analogies in his talks, and as a history lover myself, I truly appreciate that. This time, he spoke about what held great empires together. Roads and commerce were of course important, but a common — often second — language was always crucial. For the Neo-Assyrian, Neo-Babylonian and Achaemenid Empires, that language was Aramaic. Later, for the Roman and Byzantine Empires, it was Koine Greek or Latin. Without a shared language, no empire could endure for centuries. Programming languages also have their own lingua franca for interoperability: C. For decades, it has served as the universal glue for foreign function interfaces. But it comes at a cost—an unsafe mix of raw pointers, unencapsulated structs, and manual lifetime management. Herb argued that with C++ static reflection, we may have the chance to move beyond this. C++ could become the new lingua franca, offering the same universality as C but at a higher level of abstraction and with far greater safety for cross-language communication. It Takes a Village (Matt Godbolt) Whether at conferences, in online chat rooms, or in the comment sections of blogs — it’s all part of our community. And building that community takes effort. It’s not the job or destiny of just a few individuals. It truly takes a village. If we want a vibrant community, we can’t just be passive members. We each have to contribute in our own way: write, speak, share feedback, and support others. That’s how the C++ community grows and thrives. My own talk Finally, let me share my own contributions to the conference. On a small negative note, I didn’t give a lightning talk this time. I usually try to, but I hadn’t prepared in advance and by the end of each day in Colorado I was simply too knackered. Note to self: prepare lightning talks ahead of time, as I usually do. So, how did my talk go — and what was it about in the first place? Once again, I came to a C++ conference to talk about clean code and performance without showing a single line of code or a performance benchmark on the slides. My main message was simple: prioritize maintainability first. It took some courage to say this one day after Vittorio Romeo delivered a keynote arguing that we should think about performance first. In my view, that’s rarely the case. If you’re writing a program for the long term, maintainability has to come first. Edit: after discussing with Vittorio and having re-watched the pre-release, I must admit that I just frowned when Vittorio said that design for performance from the start. After, there was a big “if”. If speed is such a requirement that requires up-front design. Certain performance requirements cannot be afterthoughts! Me at CppCon Clean code is really just an optimization for readability. And optimization is always about trade-offs. While clean code may not yield the absolute fastest possible program, most of us don’t need those last drops of performance. There are usually more pressing concerns: maybe binary size, maybe portability, but more often than not, readability. Especially in large organizations, where people constantly come and go, readability becomes the default priority. It’s also worth remembering that the cost of CPU cycles continues to fall, while the cost of developers keeps rising. That’s why it makes sense to optimize for developer productivity, not for CPU time. And clean, readable code directly contributes to productivity. Growing salaries, decreasing CPU costs Of course, sometimes optimization is necessary — but do it wisely. Chances are, you’ll never need the kind of low-level wizardry that the Quake developers once pulled off. In most real-world cases, focusing on higher-level optimizations — like reducing database queries or cutting down on network calls — will give you a solution that’s “fast enough”. Conclusion CppCon 2025 was everything I had hoped for and more. The scale, the talks, the people — it all reminded me why conferences matter so much. They are not just about learning new techniques or hearing the latest on upcoming C++ features, but also about the famous hallway track: connecting with others, sharing ideas, and recharging our enthusiasm for the craft. I walked away with new insights into C++26 contracts, fresh perspectives on generic programming, some serious food for thought about code reviews and even cache behavior. I also left with a stronger sense of community — the feeling that we are all contributing, in big or small ways, to the language and ecosystem we are part of. Most importantly, I came back energized. Conferences like CppCon are not just about what you learn during the week, but about how you take those lessons back home and put them into practice. I’m grateful to the organizers, the speakers, and everyone I had the chance to meet and talk to. And I’m already looking forward to the next opportunity to gather with this amazing community. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-09-24T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Trip report: CppCon 2025" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-09-24T22:53:32+02:00","datePublished":"2025-09-24T00:00:00+02:00","description":"A dream came true. My C++ conference journey started with CppCon. Well, almost. Back in 2019, my senior manager told me I would travel to the USA for a week to attend CppCon. In the end, cost-cutting measures changed the plan, and I was sent instead to a one-day conference within my country — CPPP. It was a wonderful event and formative in two ways: I realized that I, too, could stand on stage, share my experience, and help others grow. I also realized it’s better to carve my own path to conferences than to rely on a company sending me. In short, I learned that it’s better to be invited than to be sent. Of course, speaking at a conference is never only about speaking. It’s at least as much about attending, listening, and learning from others. For that, I’m deeply grateful — both to the organizers for putting together such a remarkable event and to my family for making it possible for me to be there. In this post, I’ll share: Thoughts on the overall conference experience. Highlights from talks and ideas that resonated with me. A few words about my own talk. I’ll update this article with links to the recordings as soon as they become available. CppCon, a conference on a different scale CppCon is simply bigger than any other C++ conference I’ve attended. A massive venue packed with people and sponsors. I logged more than 10,000 steps on the very first day — without ever leaving the resort or going to the gym. The whole experience felt like it was on another scale compared to European conferences (which I also love). But then again, that’s often the impression when you see something American from a European perspective, isn’t it? I never would have imagined a C++ conference where a live band plays while Bjarne Stroustrup himself makes final checks before stepping on stage to deliver the opening keynote. Absolutely rocks. Bjarne is ready to rock at CppCon2025 One area where I think European conferences often do better is catering. Probably it’s a matter of scale, but I really appreciate not having to think about where and what to eat. At CppCon, many sponsors hosted invitation-only lunches and dinners, which I found both interesting and unusual. That leads me to a funny story about language differences. Living in France, for me entrée clearly means a starter course — it’s the entry to a longer meal. In the US, however, it turns out entrée is a fancy way of saying “main course”. So at my first seated dinner at Aurora, I served myself only a little of the entrée, assuming I’d need room for the main course. As you can guess, I unintentionally ran a calorie deficit that day. Another thought on the venue: I hardly met anyone - especially from Europe - who liked it. I understand why, but I tend to disagree. Yes, it’s in the middle of nowhere, and visiting Downtown Denver center during the conference is out of the question. But the schedule is so packed — with regular talks, open-content sessions, fireside chats, lightning talks, and sponsored meals — you’re often booked from 7 AM to 10 PM. How could you even think about doing anything else? One more difference compared to Europe: people here seemed a bit harsher. I saw many more attendees leaving in the middle of talks than I usually do at European events — thankfully not many left mine. I don’t know if it was just coincidence or a cultural difference. All in all, it was an incredible experience to finally be at CppCon. My favourite talks I usually share my three favourite talks and three favourite ideas from a conference. Since most conferences I attend last three days, that number fits nicely. But CppCon — excluding pre- and post-conference workshops — runs for five full days. So this time, I picked five talks, one per day. They’re listed here in the chronological order of their presentation. On the very first evening, I had a great discussion with Peter Muldoon about what makes a talk truly exceptional. We came up with three essential components: The talk must share interesting ideas (they don’t even have to be technical). The presenter must deliver those ideas in an engaging way (something that’s often missing!). The talk must energize you so much that once you’re back at work, you want to try them out immediately. The talks I’ve chosen to share below satisfy at least two of these three criteria. (Sadly, I can’t return to work and experiment with C++26 contracts or reflection just yet..) The Joy of C++26 Contracts (and Some Myth-Conceptions) by Herb Sutter I wasn’t sure which talk to attend, but I chose Herb’s. It’s always a safe bet — he’s an excellent speaker and knows more about C++ than most. Plus, I wanted to deepen my understanding of contracts. I already had a general idea of what contracts are and why they’re useful, but the description of Herb’s talk promised something more — best practices and deeper insights for something that’s not even shipped yet. And indeed, I walked away with far more than I expected. Here are six key takeaways to watch out for: Don’t use contracts as program logic asserts. Otherwise, you end up duplicating work. Don’t write contract assertions with side effects. You can’t predict how many times a check will be executed. (Fortunately, most such mistakes are caught at compile time.) Avoid splitting compound conditions. Keep them together and benefit from short-circuiting. Use throwing violation handlers judiciously. Throwing during an assertion failure can be dangerous — you must ensure no other exception is being handled and no stack unwinding is in progress. Understand how build modes interact. Some enforce assertions, some ignore them, and others offer more nuanced options. They might be combined over translation units. Know which one you’re in. Be aware of the limitations of the minimal viable product arriving in C++26. This is only the beginning, not the full vision of contracts. Alex Stepanov, Generic Programming and the STL by Jon Kalb Jon Kalb, the conference chair, gave an open-content talk at 7:15 AM. Despite the early hour, dozens of people showed up for a historical session on the father of the Standard Template Library. Let me stress that historical here is not a negative label. Quite the opposite: understanding history makes it easier to grasp the present. The same applies to programming languages and libraries — it’s much easier to understand how something works if we know when, how, and why it was designed. When the STL was created in the 1980s and later submitted for standardization in the early 1990s, Object-Oriented Programming was the dominant paradigm. Committee members struggled to fully appreciate the enormous contribution Stepanov made by designing a library of generic algorithms that allowed code reuse across problems without rewrites — and without sacrificing performance. The STL is built around four main components: Algorithms: function templates that typically encapsulate loops. Containers: structures that store the data algorithms operate on. Iterators: the bridge between algorithms and containers. Callables: functions or function-like objects that customize algorithm behavior. While many of us tend to see containers as the most useful or fundamental component, Stepanov considered them mere tools to store data. For him, the true foundation were always algorithms. Jon also shared some lessons learned from the STL design. Some are obvious — like the confusing choice of names between clear and empty. Others are less well-known. For example: if unordered_* containers are hash-based, why aren’t they simply called hash_*? The answer is partly political, partly practical. Back in the pre-C++98 days, the committee couldn’t resolve all disagreements, so they left them out of the first standard. By the time they were eventually standardized, different companies had already implemented their own versions — sometimes even inside the std namespace. Choosing one over another would have broken existing code and upset vendors. The compromise was to adopt another name. How to Tame Packs, std::tuple, and the Wily std::integer_sequence by Andrei Alexandrescu Andrei Alexandrescu, author of Modern C++ Design: Generic Programming and Design Patterns Applied, is always among the best speakers at C++ conferences. I’m not sure he’d appreciate this comparison, but if there were a competition for technical stand-up comedy, he’d be a strong contender. Of course, I wouldn’t highlight his talk if it were only entertaining. It was also technically deep and complex — better described as multi-threaded. He explored in detail how to work effectively with template parameter packs and tuples. Summarizing the full content would be impossible in a few paragraphs, so I’ll just recommend watching the recording when it becomes available. Still, I want to share two points that stuck with me. First, about that “multi-threaded” aspect: while explaining template metaprogramming, Andrei was also weaving in a parallel discussion on the use of LLMs. Some attendees might have felt reassured when he said we shouldn’t rely on chatbots for programming. But his actual point was subtler: don’t use chatbots, use coding agents. Second, he reminded us why “back to basics” talks remain so important. While AI can master syntax and basic usage, humans still crave learning from humans, and real interaction matters. As he put it, coding agents are like “interns high on sugar, caffeine, and cocaine at the same time” — they can produce a lot, but their work always needs reviewing. Without a solid grasp of the basics, we simply won’t be able to do that. Mastering the Code Review Process by Peter Muldoon Unlike previous years, this time there were several talks focused on code reviews — a topic close to me as well, since it’s what I’ll be speaking about at Meeting C++ this year. While many presenters covered the technical side of code reviews, Peter took a different angle. As usual, he focused on the engineering principles behind the practice: the process of giving and receiving reviews, and how it ties back to the ultimate purpose of software engineering — delivering business value. Code reviews support that goal by improving code quality, ensuring correctness, and educating engineers. But to achieve this, they must be timely and relevant. Peter emphasized that reviews should be prioritized: it’s often more important to review and merge code than to write new code. And while it’s easy to nitpick over small details, reviews should always keep the big picture in mind. Peter Muldoon at CppCon2025 Peter also shared some practical advice: As an author: review your code yourself first. Fix warnings, ensure tests pass, and make life easy for reviewers. Use a clean title and description, highlight key points, and keep your changes small. As a reviewer: review the code, not the author. Avoid destructive comments, and clearly label your feedback. Is it a blocker that must be fixed? A consideration for improvement? A nitpick that’s just your opinion? It could also be a genuine question or even a simple kudos. A great talk with clear, actionable takeaways. Kudos, Peter! Cache Me Maybe: Using Caches to Improve Performance in Production Code! by Michelle Fae D’Souza Michelle’s talk was both fun and highly practical — she kept the suspense alive until the end with the question: cache or not to cache? And the answer, of course, depends. She walked us through how modern CPUs and memory hierarchies work, showing how much performance we can leave on the table if we ignore cache behavior. For example, replacing an unordered_map with a vector (and using indices as keys) can deliver up to a 10x speedup thanks to spatial locality: vectors use contiguous memory, while hash maps scatter their data, leading to frequent cache misses. Michelle also explored the idea of cache friendliness: How to lay out variables for better memory usage. The difference between an array of structs and a struct of arrays. Why declaration order matters—keeping variables close to where they’re used improves locality and avoids cache pollution. She even touched on some lower-level details. We learned about RDTSC, how CPUs perform out-of-order execution, and why relying on prefetching isn’t always the magic bullet. She showed how you can use memory fences to enforce ordering: any load or store after the fence will really happen after it. Both CPUs and compilers can reorder instructions, so understanding this interplay is crucial. A great reminder that sometimes the biggest optimizations don’t come from clever algorithms, but simply from arranging data in a way that works with the hardware rather than against it. My favourite ideas Now let me share five interesting ideas from five different talks. Computing power vs. human expectations (Bjarne Stroustrup) In my own talk, I pointed out that the cost of computing power is dropping on a logarithmic scale, while the cost of engineers continues to rise — albeit only linearly. Bjarne’s keynote made me reflect on that again. He emphasized that although computing power keeps getting cheaper and faster, there’s one thing moving even faster: our expectations. Every year we dream up more ambitious software, with more features and more complexity. As a result, performance still matters just as much as ever — not because hardware is lacking, but because our expectations have grown to outpace it. The best usages of std::move (Steve Downey) Steve gave a fascinating talk on std::optional&lt;T&amp;&gt;, which finally made it into the standard nine years after std::optional&lt;T&gt; was introduced. I’ll save a full deep dive into this new feature for a separate article. Here, I want to highlight one memorable insight from his talk: “the best moves are the ones we don’t have to write.” Every time we explicitly write std::move, we’re explaining something to the compiler. But in most cases, the compiler already knows better than we do. This doesn’t mean std::move is bad — far from it — but it does mean we should pause before sprinkling it everywhere. Often, the smartest move is letting the compiler handle things for us. Would you consider running away? (John Lakos) Earlier this year at C++ on Sea, I was eager to attend John Lakos’s talk. Unfortunately, I had to skip it at the last minute — since I was giving my own talk at the same time. At CppCon, though, I finally had the chance to hear him speak on What C++ Needs to Be Safe. One thought in particular stuck with me: “If C++32 was as safe as Rust, would you consider running away?” John Lakos at CppCon2025 For most of us, I think the answer is no. And there’s a lot of ongoing work to make that future possible. John himself is investing a tremendous amount of effort into safety, and with features like contracts and the introduction of erroneous behavior, the language is steadily moving in that direction. Thank you, John — and thank you to everyone pushing C++ toward a safer future. C++ might be the new lingua franca of programming languages (Herb Sutter) Herb often uses historical analogies in his talks, and as a history lover myself, I truly appreciate that. This time, he spoke about what held great empires together. Roads and commerce were of course important, but a common — often second — language was always crucial. For the Neo-Assyrian, Neo-Babylonian and Achaemenid Empires, that language was Aramaic. Later, for the Roman and Byzantine Empires, it was Koine Greek or Latin. Without a shared language, no empire could endure for centuries. Programming languages also have their own lingua franca for interoperability: C. For decades, it has served as the universal glue for foreign function interfaces. But it comes at a cost—an unsafe mix of raw pointers, unencapsulated structs, and manual lifetime management. Herb argued that with C++ static reflection, we may have the chance to move beyond this. C++ could become the new lingua franca, offering the same universality as C but at a higher level of abstraction and with far greater safety for cross-language communication. It Takes a Village (Matt Godbolt) Whether at conferences, in online chat rooms, or in the comment sections of blogs — it’s all part of our community. And building that community takes effort. It’s not the job or destiny of just a few individuals. It truly takes a village. If we want a vibrant community, we can’t just be passive members. We each have to contribute in our own way: write, speak, share feedback, and support others. That’s how the C++ community grows and thrives. My own talk Finally, let me share my own contributions to the conference. On a small negative note, I didn’t give a lightning talk this time. I usually try to, but I hadn’t prepared in advance and by the end of each day in Colorado I was simply too knackered. Note to self: prepare lightning talks ahead of time, as I usually do. So, how did my talk go — and what was it about in the first place? Once again, I came to a C++ conference to talk about clean code and performance without showing a single line of code or a performance benchmark on the slides. My main message was simple: prioritize maintainability first. It took some courage to say this one day after Vittorio Romeo delivered a keynote arguing that we should think about performance first. In my view, that’s rarely the case. If you’re writing a program for the long term, maintainability has to come first. Edit: after discussing with Vittorio and having re-watched the pre-release, I must admit that I just frowned when Vittorio said that design for performance from the start. After, there was a big “if”. If speed is such a requirement that requires up-front design. Certain performance requirements cannot be afterthoughts! Me at CppCon Clean code is really just an optimization for readability. And optimization is always about trade-offs. While clean code may not yield the absolute fastest possible program, most of us don’t need those last drops of performance. There are usually more pressing concerns: maybe binary size, maybe portability, but more often than not, readability. Especially in large organizations, where people constantly come and go, readability becomes the default priority. It’s also worth remembering that the cost of CPU cycles continues to fall, while the cost of developers keeps rising. That’s why it makes sense to optimize for developer productivity, not for CPU time. And clean, readable code directly contributes to productivity. Growing salaries, decreasing CPU costs Of course, sometimes optimization is necessary — but do it wisely. Chances are, you’ll never need the kind of low-level wizardry that the Quake developers once pulled off. In most real-world cases, focusing on higher-level optimizations — like reducing database queries or cutting down on network calls — will give you a solution that’s “fast enough”. Conclusion CppCon 2025 was everything I had hoped for and more. The scale, the talks, the people — it all reminded me why conferences matter so much. They are not just about learning new techniques or hearing the latest on upcoming C++ features, but also about the famous hallway track: connecting with others, sharing ideas, and recharging our enthusiasm for the craft. I walked away with new insights into C++26 contracts, fresh perspectives on generic programming, some serious food for thought about code reviews and even cache behavior. I also left with a stronger sense of community — the feeling that we are all contributing, in big or small ways, to the language and ecosystem we are part of. Most importantly, I came back energized. Conferences like CppCon are not just about what you learn during the week, but about how you take those lessons back home and put them into practice. I’m grateful to the organizers, the speakers, and everyone I had the chance to meet and talk to. And I’m already looking forward to the next opportunity to gather with this amazing community. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Trip report: CppCon 2025","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025"},"url":"https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025"}</script><title>Trip report: CppCon 2025 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/09"> 09 </a> </span> <span> <a href="/24"> 24 </a> </span> <span>Trip report: CppCon 2025</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Trip report: CppCon 2025</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 24, 2025, 12:00 AM +0200" prep="on" > Sep 24 <i class="unloaded">2025-09-24T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 24, 2025, 10:53 PM +0200" prefix="Updated " > Sep 24 <i class="unloaded">2025-09-24T22:53:32+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="3336 words">18 min</span></div></div><div class="post-content"><p>A dream came true. My C++ conference journey started with CppCon. Well, almost. Back in 2019, my senior manager told me I would travel to the USA for a week to attend CppCon. In the end, cost-cutting measures changed the plan, and I was sent instead to a one-day conference within my country — CPPP. <a href="https://www.sandordargo.com/blog/2019/06/26/travel-report-cppp">It was a wonderful event</a> and formative in two ways:</p><ul><li>I realized that I, too, could stand on stage, share my experience, and help others grow.<li>I also realized it’s better to carve my own path to conferences than to rely on a company sending me.<br /> In short, I learned that it’s better to be invited than to be sent.</ul><p>Of course, speaking at a conference is never only about speaking. It’s at least as much about attending, listening, and learning from others. For that, I’m deeply grateful — both to the organizers for putting together such a remarkable event and to my family for making it possible for me to be there.</p><p>In this post, I’ll share:</p><ul><li>Thoughts on the overall conference experience.<li>Highlights from talks and ideas that resonated with me.<li>A few words about my own talk.</ul><p><em>I’ll update this article with links to the recordings as soon as they become available.</em></p><h2 id="cppcon-a-conference-on-a-different-scale">CppCon, a conference on a different scale</h2><p>CppCon is simply bigger than any other C++ conference I’ve attended. A massive venue packed with people and sponsors. I logged more than 10,000 steps on the very first day — without ever leaving the resort or going to the gym.</p><p>The whole experience felt like it was on another scale compared to European conferences (which I also love). But then again, that’s often the impression when you see something American from a European perspective, isn’t it?</p><p>I never would have imagined a C++ conference where a live band plays while Bjarne Stroustrup himself makes final checks before stepping on stage to deliver the opening keynote. Absolutely rocks.</p><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/bjarne-rock-cppcon2025.jpg" alt="Bjarne is ready to rock at CppCon2025" title="Bjarne is ready to rock at CppCon2025" /> <em>Bjarne is ready to rock at CppCon2025</em></p></blockquote><p>One area where I think European conferences often do better is catering. Probably it’s a matter of scale, but I really appreciate not having to think about where and what to eat. At CppCon, many sponsors hosted invitation-only lunches and dinners, which I found both interesting and unusual.</p><p>That leads me to a funny story about language differences. Living in France, for me <em>entrée</em> clearly means a starter course — it’s the entry to a longer meal. In the US, however, it turns out <em>entrée</em> is a fancy way of saying “main course”. So at my first seated dinner at Aurora, I served myself only a little of the <em>entrée</em>, assuming I’d need room for the main course. As you can guess, I unintentionally ran a calorie deficit that day.</p><p>Another thought on the venue: I hardly met anyone - especially from Europe - who liked it. I understand why, but I tend to disagree. Yes, it’s in the middle of nowhere, and visiting Downtown Denver center during the conference is out of the question. But the schedule is so packed — with regular talks, open-content sessions, fireside chats, lightning talks, and sponsored meals — you’re often booked from 7 AM to 10 PM. How could you even think about doing anything else?</p><p>One more difference compared to Europe: people here seemed a bit harsher. I saw many more attendees leaving in the middle of talks than I usually do at European events — thankfully not many left mine. I don’t know if it was just coincidence or a cultural difference.</p><p>All in all, it was an incredible experience to finally be at CppCon.</p><h2 id="my-favourite-talks">My favourite talks</h2><p>I usually share my three favourite talks and three favourite ideas from a conference. Since most conferences I attend last three days, that number fits nicely. But CppCon — excluding pre- and post-conference workshops — runs for five full days. So this time, I picked five talks, one per day. They’re listed here in the chronological order of their presentation.</p><p>On the very first evening, I had a great discussion with <a href="https://cppcon2025.sched.com/speaker/petetheladd">Peter Muldoon</a> about what makes a talk truly exceptional. We came up with three essential components:</p><ul><li>The talk must share interesting ideas (they don’t even have to be technical).<li>The presenter must deliver those ideas in an engaging way (something that’s often missing!).<li>The talk must energize you so much that once you’re back at work, you want to try them out immediately.</ul><p>The talks I’ve chosen to share below satisfy at least two of these three criteria. (Sadly, I can’t return to work and experiment with C++26 contracts or reflection just yet..)</p><h3 id="the-joy-of-c26-contracts-and-some-myth-conceptions-by-herb-sutter">The Joy of C++26 Contracts (and Some Myth-Conceptions) by Herb Sutter</h3><p>I wasn’t sure which talk to attend, but I chose Herb’s. It’s always a safe bet — he’s an excellent speaker and knows more about C++ than most. Plus, I wanted to deepen my understanding of contracts.</p><p>I already had a general idea of what contracts are and why they’re useful, but the description of Herb’s talk promised something more — best practices and deeper insights for something that’s not even shipped yet. And indeed, I walked away with far more than I expected. Here are six key takeaways to watch out for:</p><ul><li><strong>Don’t use contracts as program logic asserts.</strong> Otherwise, you end up duplicating work.<li><strong>Don’t write contract assertions with side effects.</strong> You can’t predict how many times a check will be executed. (Fortunately, most such mistakes are caught at compile time.)<li><strong>Avoid splitting compound conditions.</strong> Keep them together and benefit from short-circuiting.<li><strong>Use throwing violation handlers judiciously.</strong> Throwing during an assertion failure can be dangerous — you must ensure no other exception is being handled and no stack unwinding is in progress.<li><strong>Understand how build modes interact.</strong> Some enforce assertions, some ignore them, and others offer more nuanced options. They might be combined over translation units. Know which one you’re in.<li><strong>Be aware of the limitations of the minimal viable product arriving in C++26.</strong> This is only the beginning, not the full vision of contracts.</ul><h3 id="alex-stepanov-generic-programming-and-the-stl-by-jon-kalb">Alex Stepanov, Generic Programming and the STL by Jon Kalb</h3><p>Jon Kalb, the conference chair, gave an open-content talk at 7:15 AM. Despite the early hour, dozens of people showed up for a historical session on the father of the Standard Template Library. Let me stress that <em>historical</em> here is not a negative label. Quite the opposite: understanding history makes it easier to grasp the present. The same applies to programming languages and libraries — it’s much easier to understand how something works if we know when, how, and why it was designed.</p><p>When the STL was created in the 1980s and later submitted for standardization in the early 1990s, Object-Oriented Programming was the dominant paradigm. Committee members struggled to fully appreciate the enormous contribution Stepanov made by designing a library of generic algorithms that allowed code reuse across problems without rewrites — and without sacrificing performance.</p><p>The STL is built around four main components:</p><ul><li><strong>Algorithms</strong>: function templates that typically encapsulate loops.<li><strong>Containers</strong>: structures that store the data algorithms operate on.<li><strong>Iterators</strong>: the bridge between algorithms and containers.<li><strong>Callables</strong>: functions or function-like objects that customize algorithm behavior.</ul><p>While many of us tend to see containers as the most useful or fundamental component, Stepanov considered them mere tools to store data. For him, the true foundation were always <strong>algorithms</strong>.</p><p>Jon also shared some lessons learned from the STL design. Some are obvious — like the confusing choice of names between <code class="language-plaintext highlighter-rouge">clear</code> and <code class="language-plaintext highlighter-rouge">empty</code>. Others are less well-known. For example: if <code class="language-plaintext highlighter-rouge">unordered_*</code> containers are hash-based, why aren’t they simply called <code class="language-plaintext highlighter-rouge">hash_*</code>? The answer is partly political, partly practical. Back in the pre-C++98 days, the committee couldn’t resolve all disagreements, so they left them out of the first standard. By the time they were eventually standardized, different companies had already implemented their own versions — sometimes even inside the <code class="language-plaintext highlighter-rouge">std</code> namespace. Choosing one over another would have broken existing code and upset vendors. The compromise was to adopt another name.</p><h3 id="how-to-tame-packs-stdtuple-and-the-wily-stdinteger_sequence-by-andrei-alexandrescu">How to Tame Packs, <code class="language-plaintext highlighter-rouge">std::tuple</code>, and the Wily <code class="language-plaintext highlighter-rouge">std::integer_sequence</code> by Andrei Alexandrescu</h3><p>Andrei Alexandrescu, author of <a href="https://amzn.to/46FqeAl"><em>Modern C++ Design: Generic Programming and Design Patterns Applied</em></a>, is always among the best speakers at C++ conferences. I’m not sure he’d appreciate this comparison, but if there were a competition for <em>technical stand-up comedy</em>, he’d be a strong contender.</p><p>Of course, I wouldn’t highlight his talk if it were only entertaining. It was also technically deep and complex — better described as <em>multi-threaded</em>. He explored in detail how to work effectively with template parameter packs and tuples. Summarizing the full content would be impossible in a few paragraphs, so I’ll just recommend watching the recording when it becomes available. Still, I want to share two points that stuck with me.</p><p>First, about that “multi-threaded” aspect: while explaining template metaprogramming, Andrei was also weaving in a parallel discussion on the use of LLMs. Some attendees might have felt reassured when he said we shouldn’t rely on chatbots for programming. But his actual point was subtler: don’t use chatbots, use <strong>coding agents</strong>.</p><p>Second, he reminded us why <em>“back to basics”</em> talks remain so important. While AI can master syntax and basic usage, humans still crave learning from humans, and real interaction matters. As he put it, coding agents are like <em>“interns high on sugar, caffeine, and cocaine at the same time”</em> — they can produce a lot, but their work always needs reviewing. Without a solid grasp of the basics, we simply won’t be able to do that.</p><h3 id="mastering-the-code-review-process-by-peter-muldoon">Mastering the Code Review Process by Peter Muldoon</h3><p>Unlike previous years, this time there were several talks focused on code reviews — a topic close to me as well, since it’s what I’ll be speaking about at <a href="https://meetingcpp.com/mcpp/schedule/talkview.php?th=c700fa9b9bd66880219928e7626e9848520b1fa9">Meeting C++</a> this year. While many presenters covered the technical side of code reviews, Peter took a different angle.</p><p>As usual, he focused on the engineering principles behind the practice: the process of giving and receiving reviews, and how it ties back to the ultimate purpose of software engineering — <strong>delivering business value</strong>.</p><p>Code reviews support that goal by improving code quality, ensuring correctness, and educating engineers. But to achieve this, they must be <strong>timely and relevant</strong>. Peter emphasized that reviews should be prioritized: it’s often more important to review and merge code than to write new code. And while it’s easy to nitpick over small details, reviews should always keep the big picture in mind.</p><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/muldoon_at_cppcon2025.jpg" alt="Peter Muldoon at CppCon2025" title="Peter Muldoon at CppCon2025" /><br /> <em>Peter Muldoon at CppCon2025</em></p></blockquote><p>Peter also shared some practical advice:</p><ul><li><strong>As an author</strong>: review your code yourself first. Fix warnings, ensure tests pass, and make life easy for reviewers. Use a clean title and description, highlight key points, and keep your changes small.<li><strong>As a reviewer</strong>: review the code, not the author. Avoid destructive comments, and clearly label your feedback. Is it a <strong>blocker</strong> that must be fixed? A <strong>consideration</strong> for improvement? A <strong>nitpick</strong> that’s just your opinion? It could also be a genuine <strong>question</strong> or even a simple <strong>kudos</strong>.</ul><p>A great talk with clear, actionable takeaways. Kudos, Peter!</p><h3 id="cache-me-maybe-using-caches-to-improve-performance-in-production-code-by-michelle-fae-dsouza">Cache Me Maybe: Using Caches to Improve Performance in Production Code! by Michelle Fae D’Souza</h3><p>Michelle’s talk was both fun and highly practical — she kept the suspense alive until the end with the question: <em>cache or not to cache?</em> And the answer, of course, depends.</p><p>She walked us through how modern CPUs and memory hierarchies work, showing how much performance we can leave on the table if we ignore cache behavior. For example, replacing an <code class="language-plaintext highlighter-rouge">unordered_map</code> with a <code class="language-plaintext highlighter-rouge">vector</code> (and using indices as keys) can deliver up to a <strong>10x speedup</strong> thanks to spatial locality: vectors use contiguous memory, while hash maps scatter their data, leading to frequent cache misses.</p><p>Michelle also explored the idea of <em>cache friendliness</em>:</p><ul><li>How to lay out variables for better memory usage.<li>The difference between an array of structs and a struct of arrays.<li>Why declaration order matters—keeping variables close to where they’re used improves locality and avoids cache pollution.</ul><p>She even touched on some lower-level details. We learned about <strong>RDTSC</strong>, how CPUs perform out-of-order execution, and why relying on prefetching isn’t always the magic bullet. She showed how you can use memory fences to enforce ordering: any load or store after the fence will really happen after it. Both CPUs and compilers can reorder instructions, so understanding this interplay is crucial.</p><p>A great reminder that sometimes the biggest optimizations don’t come from clever algorithms, but simply from arranging data in a way that works with the hardware rather than against it.</p><h2 id="my-favourite-ideas">My favourite ideas</h2><p>Now let me share five interesting ideas from five different talks.</p><h3 id="computing-power-vs-human-expectations-bjarne-stroustrup">Computing power vs. human expectations (Bjarne Stroustrup)</h3><p>In my own talk, I pointed out that the cost of computing power is dropping on a logarithmic scale, while the cost of engineers continues to rise — albeit only linearly. Bjarne’s keynote made me reflect on that again.</p><p>He emphasized that although computing power keeps getting cheaper and faster, there’s one thing moving even faster: <em>our expectations</em>. Every year we dream up more ambitious software, with more features and more complexity. As a result, performance still matters just as much as ever — not because hardware is lacking, but because our expectations have grown to outpace it.</p><h3 id="the-best-usages-of-stdmove-steve-downey">The best usages of <code class="language-plaintext highlighter-rouge">std::move</code> (Steve Downey)</h3><p>Steve gave a fascinating talk on <code class="language-plaintext highlighter-rouge">std::optional&lt;T&amp;&gt;</code>, which finally made it into the standard nine years after <code class="language-plaintext highlighter-rouge">std::optional&lt;T&gt;</code> was introduced. I’ll save a full deep dive into this new feature for a separate article.</p><p>Here, I want to highlight one memorable insight from his talk: <em>“the best <code class="language-plaintext highlighter-rouge">move</code>s are the ones we don’t have to write.”</em></p><p>Every time we explicitly write <code class="language-plaintext highlighter-rouge">std::move</code>, we’re explaining something to the compiler. But in most cases, the compiler already knows better than we do. This doesn’t mean <code class="language-plaintext highlighter-rouge">std::move</code> is bad — far from it — but it does mean we should pause before sprinkling it everywhere. Often, the smartest <code class="language-plaintext highlighter-rouge">move</code> is letting the compiler handle things for us.</p><h3 id="would-you-consider-running-away-john-lakos">Would you consider running away? (John Lakos)</h3><p>Earlier this year at <a href="https://www.sandordargo.com/blog/2025/07/02/cpponsea-trip-report">C++ on Sea</a>, I was eager to attend John Lakos’s talk. Unfortunately, I had to skip it at the last minute — since I was giving my own talk at the same time. At CppCon, though, I finally had the chance to hear him speak on <em>What C++ Needs to Be Safe</em>.</p><p>One thought in particular stuck with me:</p><blockquote><p><em>“If C++32 was as safe as Rust, would you consider running away?”</em></p></blockquote><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/lakos_at_cppcon2025.jpg" alt="John Lakos at CppCon2025" title="John Lakos at CppCon2025" /><br /> <em>John Lakos at CppCon2025</em></p></blockquote><p>For most of us, I think the answer is no. And there’s a lot of ongoing work to make that future possible. John himself is investing a tremendous amount of effort into safety, and with features like contracts and the introduction of erroneous behavior, the language is steadily moving in that direction.</p><p>Thank you, John — and thank you to everyone pushing C++ toward a safer future.</p><h3 id="c-might-be-the-new-lingua-franca-of-programming-languages-herb-sutter">C++ might be the new <em>lingua franca</em> of programming languages (Herb Sutter)</h3><p>Herb often uses historical analogies in his talks, and as a history lover myself, I truly appreciate that. This time, he spoke about what held great empires together. Roads and commerce were of course important, but a common — often second — language was always crucial. For the Neo-Assyrian, Neo-Babylonian and Achaemenid Empires, that language was Aramaic. Later, for the Roman and Byzantine Empires, it was Koine Greek or Latin. Without a shared language, no empire could endure for centuries.</p><p>Programming languages also have their own <em>lingua franca</em> for interoperability: C. For decades, it has served as the universal glue for foreign function interfaces. But it comes at a cost—an unsafe mix of raw pointers, unencapsulated structs, and manual lifetime management.</p><p>Herb argued that with <strong>C++ static reflection</strong>, we may have the chance to move beyond this. C++ could become the new lingua franca, offering the same universality as C but at a higher level of abstraction and with far greater safety for cross-language communication.</p><h3 id="it-takes-a-village-matt-godbolt">It Takes a Village (Matt Godbolt)</h3><p>Whether at conferences, in online chat rooms, or in the comment sections of blogs — it’s all part of <strong>our</strong> community. And building that community takes effort. It’s not the job or destiny of just a few individuals. It truly takes a village.</p><p>If we want a vibrant community, we can’t just be passive members. We each have to contribute in our own way: write, speak, share feedback, and support others. That’s how the C++ community grows and thrives.</p><h2 id="my-own-talk">My own talk</h2><p>Finally, let me share my own contributions to the conference. On a small negative note, I didn’t give a lightning talk this time. I usually try to, but I hadn’t prepared in advance and by the end of each day in Colorado I was simply too knackered. Note to self: prepare lightning talks ahead of time, as I usually do.</p><p>So, how did my talk go — and what was it about in the first place?</p><p>Once again, I came to a C++ conference to talk about clean code and performance without showing a single line of code or a performance benchmark on the slides. My main message was simple: <strong>prioritize maintainability first</strong>. It took some courage to say this one day after <a href="https://cppcon2025.sched.com/event/27bNZ/more-speed-simplicity-practical-data-oriented-design-in-c++">Vittorio Romeo delivered a keynote</a> arguing that we should think about performance first. In my view, that’s rarely the case. If you’re writing a program for the long term, maintainability has to come first.</p><blockquote><p><em>Edit: after discussing with Vittorio and having re-watched the <a href="https://www.youtube.com/watch?v=SzjJfKHygaQ&amp;t=4920s">pre-release</a>, I must admit that I just frowned when Vittorio said that design for performance from the start. After, there was a big “if”.</em></p><p><em>If speed is such a requirement that requires up-front design. Certain performance requirements cannot be afterthoughts!</em></p></blockquote><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/me_at_cppcon2025.jpg" alt="Me at CppCon" title="Me at CppCon" /><br /> <em>Me at CppCon</em></p></blockquote><p>Clean code is really just an optimization for readability. And optimization is always about trade-offs. While clean code may not yield the absolute fastest possible program, most of us don’t need those last drops of performance. There are usually more pressing concerns: maybe binary size, maybe portability, but more often than not, <strong>readability</strong>. Especially in large organizations, where people constantly come and go, readability becomes the default priority.</p><p>It’s also worth remembering that the cost of CPU cycles continues to fall, while the cost of developers keeps rising. That’s why it makes sense to optimize for developer productivity, not for CPU time. And clean, readable code directly contributes to productivity.</p><blockquote><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/cpu-cost-developer-salaries.png" alt="Growing salaries, decreasing CPU costs" title="Growing salaries, decreasing CPU costs" /><br /> <em>Growing salaries, decreasing CPU costs</em></p></blockquote><p>Of course, sometimes optimization is necessary — but do it wisely. Chances are, you’ll never need the kind of low-level wizardry <a href="https://www.youtube.com/watch?v=p8u_k2LIZyo">that the Quake developers once pulled off</a>. In most real-world cases, focusing on higher-level optimizations — like reducing database queries or cutting down on network calls — will give you a solution that’s “fast enough”.</p><h2 id="conclusion">Conclusion</h2><p>CppCon 2025 was everything I had hoped for and more. The scale, the talks, the people — it all reminded me why conferences matter so much. They are not just about learning new techniques or hearing the latest on upcoming C++ features, but also about the famous <em>hallway track</em>: connecting with others, sharing ideas, and recharging our enthusiasm for the craft.</p><p>I walked away with new insights into C++26 contracts, fresh perspectives on generic programming, some serious food for thought about code reviews and even cache behavior. I also left with a stronger sense of community — the feeling that we are all contributing, in big or small ways, to the language and ecosystem we are part of.</p><p>Most importantly, I came back energized. Conferences like CppCon are not just about what you learn during the week, but about how you take those lessons back home and put them into practice. I’m grateful to the organizers, the speakers, and everyone I had the chance to meet and talk to. And I’m already looking forward to the next opportunity to gather with this amazing community.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/conference/" class="post-tag no-text-decoration" >conference</a> <a href="/tags/cppcon/" class="post-tag no-text-decoration" >cppcon</a> <a href="/tags/tripreport/" class="post-tag no-text-decoration" >tripreport</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Trip report: CppCon 2025 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Trip report: CppCon 2025 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Trip report: CppCon 2025 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Trip report: CppCon 2025 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2019/06/26/travel-report-cppp"><div class="card-body"> <span class="timeago small" > Jun 26, 2019 <i class="unloaded">2019-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Travel report: CPPP 2019</h3><div class="text-muted small"><p> Right after I was returning from a three and a half weeks long road trip with destinations in 5 countries, then attending an advanced presentation skills workshop, I was finally heading to the airp...</p></div></div></a></div><div class="card"> <a href="/blog/2020/07/29/cpponsea2020-trip-report"><div class="card-body"> <span class="timeago small" > Jul 29, 2020 <i class="unloaded">2020-07-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtual Trip Report: C++ On Sea 2020</h3><div class="text-muted small"><p> Last week, I “went” to the C++ On Sea 2020, which was my second C++ conference, after CPPP 2019. I put went between quotes because as you might have guessed due to the Coronavirus, the organizers h...</p></div></div></a></div><div class="card"> <a href="/blog/2021/11/17/trip-rerport-meetingcpp-2021"><div class="card-body"> <span class="timeago small" > Nov 17, 2021 <i class="unloaded">2021-11-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip Report: Meeting C++ 2021</h3><div class="text-muted small"><p> I feel very lucky that I could attend so many C++ conferences during the last 2 years. It feels a bit strange, but without Covid, this would not have been possible. My last conference was Meeting ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/09/17/observers-part3" class="btn btn-outline-primary" prompt="Older"><p>Discovering observers - part 3</p></a> <a href="/blog/2025/10/01/cpp26-optional-of-reference" class="btn btn-outline-primary" prompt="Newer"><p>C++26: std::optional&lt;T&amp;&gt;</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Trip report: CppCon 2025'; this.page.url = 'https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025'; this.page.identifier = '/blog/2025/09/24/trip-report-cppcon-2025'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
