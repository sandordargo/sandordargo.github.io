<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++26: Deprecating or removing library features" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the previous article, we discussed what language features are removed from C++26. In this one, we are going to cover both language features that are finally removed after a few years of deprecation, and also those that are getting deprecated by C++26. As a reminder, a removal from the language usually happens in two steps. First a feature gets deprecated, meaning that its users would face compiler warnings for using deprecated features. As a next step, which in some cases never comes, the compiler support is finally removed. Remove Deprecated std::allocator Typedef From C++26 The std::allocator has a typedef that was deprecated in C++20 and now finally it’s removed. Though it’s a minor corner case, but it’s been so easy to misuse it that it was rather embarrassing for the committee, hence the removal by P2868R3. Classes deriving from std::allocator don’t synthesise the typedef member correctly and the allocator authors have to add their own typedef to ensure correct behaviour. If they knew about it… Removing function overload of std::basic_string::reserve() that takes no I just learned from P2870R3 that std::basic_string::reserve had an overload taking no arguments. As it was a poor substitute for std::basic_string::shrink_to_fit, it was deprecated in C++20. Now it’s gone. reserve used to have a default value of 0 for its sole argument turning it into a non-binding shrink_to_fit. But shrink_to_fit was introduced as an independent function in C++11 and as such this behaviour of reserve became superfluous and a “few” years later it got deprecated. If your code uses reserve() without any arguments, migration is simple, just replace it it with shrink_to_fit. Remove Deprecated Unicode Conversion Facets from C++26 The &lt;codecvt&gt; header was first provided by C++11 and then deprecated by C++17 due to its underspecification, notably a lack of error handling. It’s removed in C++26 by P2871R3. This library contained several helper classes to convert between different UTF formats. Due to the bad specification, ill-formed UTF strings could be used as an attack vector. This change is about improving language safety. Freestanding: removing std::strtok std::strtok has been part of C++ freestanding, in other words, it’s a C function and was part of C++ to help with compatibility. As std::strtok has been removed from C2X standards, C++ doesn’t need it anymore either. “A freestanding C++ implementation is mostly a superset of a freestanding C implementation, even in the “C” parts of C++. This means that a freestanding C++ implementation can not generally be built on top of a minimal freestanding C implementation. Either the C++ implementation must provide some of the C parts, or the C++ implementation will require a C implementation that provides more than the minimum.” - source Removing deprecated strstreams C++20 introduced the ability to move strings efficiently out of stringsteams and C++23 brought us the spanstream library that we already covered in C++23: The rise of new streams. Given that C++ now had superior replacements for char* stream, now they are finally removed. Why finally? Well, apparently, char* streams have been the largest and oldest deprecated feature in the standard. They were marked for future deprecation and possible removal almost 30 years ago! Yes, we are talking about C++98. Will we need to undeprecate these features? Hopefully not. Removing deprecated std::shared_ptr Atomic Access APIs C++11 introduced atomics and smart pointers. Among others, it also introduced a free function API for atomic access to shared_ptr. It was an easy-to-use API so it was deprecated by C++20, along with the introduction of its type-safe replacement std::atomic&lt;shared_ptr&lt;T&gt;&gt;. C++26 removes the deprecated API thanks to the acceptance of P2869R4. While the old API expected that the shared object is not used directly, the API made it possible which led to undefined behaviour, typically producing a data race. To deal with the deprecation, one must perform two steps: include the &lt;atomic&gt; header replace shared_ptr&lt;T&gt; with std::atomic&lt;shared_ptr&lt;T&gt;&gt; Alternatively, one might also prefer using std::atomic member functions directly, instead of using std::shared_ptr overloads. For further details check out section 5.1 in P2869R4. Removing std::wstring_convert std::wstring_convert, std::wbuffer_convert and some related helper functions were introduced by C++11, deprecated with C++17 and finally removed in C++26 by P2872R3. Have you ever used it? I haven’t heard about it before. They help conversions between normal-sized and wide strings. The reason for their removals is that they are underspecified, there are a handful of open LWG issues related to them, and improving these facilities “would require more work than the committee wishes to invest to bring it up to the desired level of”. Deprecating std::is_trivial and std::is_trivial_v When I saw this accepted proposal I was surprised. Removing std::is_trivial? Aren’t people talking so much about trivial classes? But that’s simply a sign of my shallow knowledge. The fact is that people don’t talk about trivial classes - which notion is also deprecated. People talk about trivially default constructible, trivially copyable or trivially copy assignable classes. Often these properties are not needed at the same. In addition, is_trivial doesn’t even check that the required constructors are public. Use the appropriate is_trivially_XXX checks instead of the general is_trivial, especially now that the latter is deprecated by P3247R2 Defang and deprecate std::memory_order::consume The problem of std::memory_oder::consume has been around for a decade. Its specification is not satisfactory, it’s difficult to implement and not even required by most widely-used CPU architectures. Given these problems, most academic work simply ignores its existence and uses other memory models. But even implementations mostly map it to std::memory_oder::acquire. As there is no will and consensus to improve it, the best next step is to deprecate it which P3475R1 Conclusion After having discussed last week language features removed from C++26, this week we covered what library features are removed or started their way to be removed through their deprecation. Deprecation is not always a one-way road. Next week, we’ll cover a feature that is going to be underprecated in C++26. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><meta property="og:description" content="In the previous article, we discussed what language features are removed from C++26. In this one, we are going to cover both language features that are finally removed after a few years of deprecation, and also those that are getting deprecated by C++26. As a reminder, a removal from the language usually happens in two steps. First a feature gets deprecated, meaning that its users would face compiler warnings for using deprecated features. As a next step, which in some cases never comes, the compiler support is finally removed. Remove Deprecated std::allocator Typedef From C++26 The std::allocator has a typedef that was deprecated in C++20 and now finally it’s removed. Though it’s a minor corner case, but it’s been so easy to misuse it that it was rather embarrassing for the committee, hence the removal by P2868R3. Classes deriving from std::allocator don’t synthesise the typedef member correctly and the allocator authors have to add their own typedef to ensure correct behaviour. If they knew about it… Removing function overload of std::basic_string::reserve() that takes no I just learned from P2870R3 that std::basic_string::reserve had an overload taking no arguments. As it was a poor substitute for std::basic_string::shrink_to_fit, it was deprecated in C++20. Now it’s gone. reserve used to have a default value of 0 for its sole argument turning it into a non-binding shrink_to_fit. But shrink_to_fit was introduced as an independent function in C++11 and as such this behaviour of reserve became superfluous and a “few” years later it got deprecated. If your code uses reserve() without any arguments, migration is simple, just replace it it with shrink_to_fit. Remove Deprecated Unicode Conversion Facets from C++26 The &lt;codecvt&gt; header was first provided by C++11 and then deprecated by C++17 due to its underspecification, notably a lack of error handling. It’s removed in C++26 by P2871R3. This library contained several helper classes to convert between different UTF formats. Due to the bad specification, ill-formed UTF strings could be used as an attack vector. This change is about improving language safety. Freestanding: removing std::strtok std::strtok has been part of C++ freestanding, in other words, it’s a C function and was part of C++ to help with compatibility. As std::strtok has been removed from C2X standards, C++ doesn’t need it anymore either. “A freestanding C++ implementation is mostly a superset of a freestanding C implementation, even in the “C” parts of C++. This means that a freestanding C++ implementation can not generally be built on top of a minimal freestanding C implementation. Either the C++ implementation must provide some of the C parts, or the C++ implementation will require a C implementation that provides more than the minimum.” - source Removing deprecated strstreams C++20 introduced the ability to move strings efficiently out of stringsteams and C++23 brought us the spanstream library that we already covered in C++23: The rise of new streams. Given that C++ now had superior replacements for char* stream, now they are finally removed. Why finally? Well, apparently, char* streams have been the largest and oldest deprecated feature in the standard. They were marked for future deprecation and possible removal almost 30 years ago! Yes, we are talking about C++98. Will we need to undeprecate these features? Hopefully not. Removing deprecated std::shared_ptr Atomic Access APIs C++11 introduced atomics and smart pointers. Among others, it also introduced a free function API for atomic access to shared_ptr. It was an easy-to-use API so it was deprecated by C++20, along with the introduction of its type-safe replacement std::atomic&lt;shared_ptr&lt;T&gt;&gt;. C++26 removes the deprecated API thanks to the acceptance of P2869R4. While the old API expected that the shared object is not used directly, the API made it possible which led to undefined behaviour, typically producing a data race. To deal with the deprecation, one must perform two steps: include the &lt;atomic&gt; header replace shared_ptr&lt;T&gt; with std::atomic&lt;shared_ptr&lt;T&gt;&gt; Alternatively, one might also prefer using std::atomic member functions directly, instead of using std::shared_ptr overloads. For further details check out section 5.1 in P2869R4. Removing std::wstring_convert std::wstring_convert, std::wbuffer_convert and some related helper functions were introduced by C++11, deprecated with C++17 and finally removed in C++26 by P2872R3. Have you ever used it? I haven’t heard about it before. They help conversions between normal-sized and wide strings. The reason for their removals is that they are underspecified, there are a handful of open LWG issues related to them, and improving these facilities “would require more work than the committee wishes to invest to bring it up to the desired level of”. Deprecating std::is_trivial and std::is_trivial_v When I saw this accepted proposal I was surprised. Removing std::is_trivial? Aren’t people talking so much about trivial classes? But that’s simply a sign of my shallow knowledge. The fact is that people don’t talk about trivial classes - which notion is also deprecated. People talk about trivially default constructible, trivially copyable or trivially copy assignable classes. Often these properties are not needed at the same. In addition, is_trivial doesn’t even check that the required constructors are public. Use the appropriate is_trivially_XXX checks instead of the general is_trivial, especially now that the latter is deprecated by P3247R2 Defang and deprecate std::memory_order::consume The problem of std::memory_oder::consume has been around for a decade. Its specification is not satisfactory, it’s difficult to implement and not even required by most widely-used CPU architectures. Given these problems, most academic work simply ignores its existence and uses other memory models. But even implementations mostly map it to std::memory_oder::acquire. As there is no will and consensus to improve it, the best next step is to deprecate it which P3475R1 Conclusion After having discussed last week language features removed from C++26, this week we covered what library features are removed or started their way to be removed through their deprecation. Deprecation is not always a one-way road. Next week, we’ll cover a feature that is going to be underprecated in C++26. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-03-19T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++26: Deprecating or removing library features" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-03-19T00:00:00+01:00","datePublished":"2025-03-19T00:00:00+01:00","description":"In the previous article, we discussed what language features are removed from C++26. In this one, we are going to cover both language features that are finally removed after a few years of deprecation, and also those that are getting deprecated by C++26. As a reminder, a removal from the language usually happens in two steps. First a feature gets deprecated, meaning that its users would face compiler warnings for using deprecated features. As a next step, which in some cases never comes, the compiler support is finally removed. Remove Deprecated std::allocator Typedef From C++26 The std::allocator has a typedef that was deprecated in C++20 and now finally it’s removed. Though it’s a minor corner case, but it’s been so easy to misuse it that it was rather embarrassing for the committee, hence the removal by P2868R3. Classes deriving from std::allocator don’t synthesise the typedef member correctly and the allocator authors have to add their own typedef to ensure correct behaviour. If they knew about it… Removing function overload of std::basic_string::reserve() that takes no I just learned from P2870R3 that std::basic_string::reserve had an overload taking no arguments. As it was a poor substitute for std::basic_string::shrink_to_fit, it was deprecated in C++20. Now it’s gone. reserve used to have a default value of 0 for its sole argument turning it into a non-binding shrink_to_fit. But shrink_to_fit was introduced as an independent function in C++11 and as such this behaviour of reserve became superfluous and a “few” years later it got deprecated. If your code uses reserve() without any arguments, migration is simple, just replace it it with shrink_to_fit. Remove Deprecated Unicode Conversion Facets from C++26 The &lt;codecvt&gt; header was first provided by C++11 and then deprecated by C++17 due to its underspecification, notably a lack of error handling. It’s removed in C++26 by P2871R3. This library contained several helper classes to convert between different UTF formats. Due to the bad specification, ill-formed UTF strings could be used as an attack vector. This change is about improving language safety. Freestanding: removing std::strtok std::strtok has been part of C++ freestanding, in other words, it’s a C function and was part of C++ to help with compatibility. As std::strtok has been removed from C2X standards, C++ doesn’t need it anymore either. “A freestanding C++ implementation is mostly a superset of a freestanding C implementation, even in the “C” parts of C++. This means that a freestanding C++ implementation can not generally be built on top of a minimal freestanding C implementation. Either the C++ implementation must provide some of the C parts, or the C++ implementation will require a C implementation that provides more than the minimum.” - source Removing deprecated strstreams C++20 introduced the ability to move strings efficiently out of stringsteams and C++23 brought us the spanstream library that we already covered in C++23: The rise of new streams. Given that C++ now had superior replacements for char* stream, now they are finally removed. Why finally? Well, apparently, char* streams have been the largest and oldest deprecated feature in the standard. They were marked for future deprecation and possible removal almost 30 years ago! Yes, we are talking about C++98. Will we need to undeprecate these features? Hopefully not. Removing deprecated std::shared_ptr Atomic Access APIs C++11 introduced atomics and smart pointers. Among others, it also introduced a free function API for atomic access to shared_ptr. It was an easy-to-use API so it was deprecated by C++20, along with the introduction of its type-safe replacement std::atomic&lt;shared_ptr&lt;T&gt;&gt;. C++26 removes the deprecated API thanks to the acceptance of P2869R4. While the old API expected that the shared object is not used directly, the API made it possible which led to undefined behaviour, typically producing a data race. To deal with the deprecation, one must perform two steps: include the &lt;atomic&gt; header replace shared_ptr&lt;T&gt; with std::atomic&lt;shared_ptr&lt;T&gt;&gt; Alternatively, one might also prefer using std::atomic member functions directly, instead of using std::shared_ptr overloads. For further details check out section 5.1 in P2869R4. Removing std::wstring_convert std::wstring_convert, std::wbuffer_convert and some related helper functions were introduced by C++11, deprecated with C++17 and finally removed in C++26 by P2872R3. Have you ever used it? I haven’t heard about it before. They help conversions between normal-sized and wide strings. The reason for their removals is that they are underspecified, there are a handful of open LWG issues related to them, and improving these facilities “would require more work than the committee wishes to invest to bring it up to the desired level of”. Deprecating std::is_trivial and std::is_trivial_v When I saw this accepted proposal I was surprised. Removing std::is_trivial? Aren’t people talking so much about trivial classes? But that’s simply a sign of my shallow knowledge. The fact is that people don’t talk about trivial classes - which notion is also deprecated. People talk about trivially default constructible, trivially copyable or trivially copy assignable classes. Often these properties are not needed at the same. In addition, is_trivial doesn’t even check that the required constructors are public. Use the appropriate is_trivially_XXX checks instead of the general is_trivial, especially now that the latter is deprecated by P3247R2 Defang and deprecate std::memory_order::consume The problem of std::memory_oder::consume has been around for a decade. Its specification is not satisfactory, it’s difficult to implement and not even required by most widely-used CPU architectures. Given these problems, most academic work simply ignores its existence and uses other memory models. But even implementations mostly map it to std::memory_oder::acquire. As there is no will and consensus to improve it, the best next step is to deprecate it which P3475R1 Conclusion After having discussed last week language features removed from C++26, this week we covered what library features are removed or started their way to be removed through their deprecation. Deprecation is not always a one-way road. Next week, we’ll cover a feature that is going to be underprecated in C++26. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter","headline":"C++26: Deprecating or removing library features","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features"},"url":"https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features"}</script><title>C++26: Deprecating or removing library features | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/19"> 19 </a> </span> <span>C++26: Deprecating or removing library features</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++26: Deprecating or removing library features</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 19, 2025, 12:00 AM +0100" prep="on" > Mar 19 <i class="unloaded">2025-03-19T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="995 words">5 min</span></div></div><div class="post-content"><p>In the previous article, we discussed <a href="https://www.sandordargo.com/blog/2025/03/12/cpp26-removing-language-features">what language features are removed from C++26</a>. In this one, we are going to cover both language features that are finally removed after a few years of deprecation, and also those that are getting deprecated by C++26.</p><blockquote><p>As a reminder, a removal from the language usually happens in two steps. First a feature gets deprecated, meaning that its users would face compiler warnings for using deprecated features. As a next step, which in some cases never comes, the compiler support is finally removed.</p></blockquote><h2 id="remove-deprecated-stdallocator-typedef-from-c26">Remove Deprecated <code class="language-plaintext highlighter-rouge">std::allocator</code> Typedef From C++26</h2><p>The <code class="language-plaintext highlighter-rouge">std::allocator</code> has a <code class="language-plaintext highlighter-rouge">typedef</code> that was deprecated in C++20 and now finally it’s removed. Though it’s a minor corner case, but it’s been so easy to misuse it that it was rather embarrassing for the committee, hence the removal by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2868r3.pdf">P2868R3</a>.</p><p>Classes deriving from <code class="language-plaintext highlighter-rouge">std::allocator</code> don’t synthesise the <code class="language-plaintext highlighter-rouge">typedef</code> member correctly and the allocator authors have to add their own typedef to ensure correct behaviour. If they knew about it…</p><h2 id="removing-function-overload-of-stdbasic_stringreserve-that-takes-no">Removing function overload of <code class="language-plaintext highlighter-rouge">std::basic_string::reserve()</code> that takes no</h2><p>I just learned from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2870r3.pdf">P2870R3</a> that <code class="language-plaintext highlighter-rouge">std::basic_string::reserve</code> had an overload taking no arguments. As it was a poor substitute for <code class="language-plaintext highlighter-rouge">std::basic_string::shrink_to_fit</code>, it was deprecated in C++20.</p><p>Now it’s gone.</p><p><code class="language-plaintext highlighter-rouge">reserve</code> used to have a default value of <code class="language-plaintext highlighter-rouge">0</code> for its sole argument turning it into a non-binding <code class="language-plaintext highlighter-rouge">shrink_to_fit</code>. But <code class="language-plaintext highlighter-rouge">shrink_to_fit</code> was introduced as an independent function in C++11 and as such this behaviour of <code class="language-plaintext highlighter-rouge">reserve</code> became superfluous and a “few” years later it got deprecated.</p><p>If your code uses <code class="language-plaintext highlighter-rouge">reserve()</code> without any arguments, migration is simple, just replace it it with <code class="language-plaintext highlighter-rouge">shrink_to_fit</code>.</p><h2 id="remove-deprecated-unicode-conversion-facets-from-c26">Remove Deprecated Unicode Conversion Facets from C++26</h2><p>The <code class="language-plaintext highlighter-rouge">&lt;codecvt&gt;</code> header was first provided by C++11 and then deprecated by C++17 due to its underspecification, notably a lack of error handling. It’s removed in C++26 by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2871r3.pdf">P2871R3</a>.</p><p>This library contained several helper classes to convert between different UTF formats. Due to the bad specification, ill-formed UTF strings could be used as an attack vector.</p><p>This change is about improving language safety.</p><h2 id="freestanding-removing-stdstrtok">Freestanding: removing <code class="language-plaintext highlighter-rouge">std::strtok</code></h2><p><code class="language-plaintext highlighter-rouge">std::strtok</code> has been part of C++ freestanding, in other words, it’s a C function and was part of C++ to help with compatibility. As <code class="language-plaintext highlighter-rouge">std::strtok</code> has been removed from C2X standards, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2937r0.html">C++ doesn’t need it anymore either</a>.</p><blockquote><p><em>“A freestanding C++ implementation is mostly a superset of a freestanding C implementation, even in the “C” parts of C++. This means that a freestanding C++ implementation can not generally be built on top of a minimal freestanding C implementation. Either the C++ implementation must provide some of the C parts, or the C++ implementation will require a C implementation that provides more than the minimum.”</em> - <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2338r4.html#:~:text=A%20freestanding%20C%2B%2B%20implementation%20is%20mostly%20a%20superset%20of%20a,a%20minimal%20freestanding%20C%20implementation.">source</a></p></blockquote><h2 id="removing-deprecated-strstreams">Removing deprecated <code class="language-plaintext highlighter-rouge">strstreams</code></h2><p>C++20 introduced the ability to move strings efficiently out of stringsteams and C++23 brought us the <code class="language-plaintext highlighter-rouge">spanstream</code> library that we already covered in <a href="https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement"><em>C++23: The rise of new streams</em></a>.</p><p>Given that C++ now had superior replacements for <code class="language-plaintext highlighter-rouge">char*</code> stream, now they are finally removed.</p><p>Why finally?</p><p>Well, apparently, <code class="language-plaintext highlighter-rouge">char*</code> streams have been the largest and oldest deprecated feature in the standard. They were marked for future deprecation and possible removal almost 30 years ago! Yes, we are talking about C++98.</p><p>Will we need to undeprecate these features?</p><p>Hopefully not.</p><h2 id="removing-deprecated-stdshared_ptr-atomic-access-apis">Removing deprecated <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> Atomic Access APIs</h2><p>C++11 introduced atomics and smart pointers. Among others, it also introduced a free function API for atomic access to <code class="language-plaintext highlighter-rouge">shared_ptr</code>. It was an easy-to-use API so it was deprecated by C++20, along with the introduction of its type-safe replacement <code class="language-plaintext highlighter-rouge">std::atomic&lt;shared_ptr&lt;T&gt;&gt;</code>. C++26 removes the deprecated API thanks to the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2869r4.pdf">P2869R4</a>.</p><p>While the old API expected that the shared object is not used directly, the API made it possible which led to undefined behaviour, typically producing a data race.</p><p>To deal with the deprecation, one must perform two steps:</p><ul><li>include the <code class="language-plaintext highlighter-rouge">&lt;atomic&gt;</code> header<li>replace <code class="language-plaintext highlighter-rouge">shared_ptr&lt;T&gt;</code> with <code class="language-plaintext highlighter-rouge">std::atomic&lt;shared_ptr&lt;T&gt;&gt;</code></ul><p>Alternatively, one might also prefer using <code class="language-plaintext highlighter-rouge">std::atomic</code> member functions directly, instead of using <code class="language-plaintext highlighter-rouge">std::shared_ptr</code> overloads. For further details check out section 5.1 in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2869r4.pdf">P2869R4</a>.</p><h2 id="removing-stdwstring_convert">Removing <code class="language-plaintext highlighter-rouge">std::wstring_convert</code></h2><p><code class="language-plaintext highlighter-rouge">std::wstring_convert</code>, <code class="language-plaintext highlighter-rouge">std::wbuffer_convert</code> and some related helper functions were introduced by C++11, deprecated with C++17 and finally removed in C++26 by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2872r3.pdf">P2872R3</a>. Have you ever used it? I haven’t heard about it before.</p><p>They help conversions between normal-sized and wide strings.</p><p>The reason for their removals is that they are underspecified, there are a handful of open LWG issues related to them, and improving these facilities <em>“would require more work than the committee wishes to invest to bring it up to the desired level of”</em>.</p><h2 id="deprecating-stdis_trivial-and-stdis_trivial_v">Deprecating <code class="language-plaintext highlighter-rouge">std::is_trivial</code> and <code class="language-plaintext highlighter-rouge">std::is_trivial_v</code></h2><p>When I saw this accepted proposal I was surprised. Removing <code class="language-plaintext highlighter-rouge">std::is_trivial</code>? Aren’t people talking so much about trivial classes? But that’s simply a sign of my shallow knowledge.</p><p>The fact is that people don’t talk about trivial classes - which notion is also deprecated. People talk about trivially default constructible, trivially copyable or trivially copy assignable classes. Often these properties are not needed at the same.</p><p>In addition, <code class="language-plaintext highlighter-rouge">is_trivial</code> doesn’t even check that the required constructors are public.</p><p>Use the appropriate <code class="language-plaintext highlighter-rouge">is_trivially_XXX</code> checks instead of the general <code class="language-plaintext highlighter-rouge">is_trivial</code>, especially now that the latter is deprecated by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3247r2.html">P3247R2</a></p><h2 id="defang-and-deprecate-stdmemory_orderconsume">Defang and deprecate <code class="language-plaintext highlighter-rouge">std::memory_order::consume</code></h2><p>The problem of <code class="language-plaintext highlighter-rouge">std::memory_oder::consume</code> has been around for a decade. Its specification is not satisfactory, it’s difficult to implement and not even required by most widely-used CPU architectures. Given these problems, most academic work simply ignores its existence and uses other memory models.</p><p>But even implementations mostly map it to <code class="language-plaintext highlighter-rouge">std::memory_oder::acquire</code>. As there is no will and consensus to improve it, the best next step is to deprecate it which <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3475r1.pdf">P3475R1</a></p><h2 id="conclusion">Conclusion</h2><p>After having discussed last week <a href="https://www.sandordargo.com/blog/2025/03/12/cpp26-removing-language-features">language features removed from C++26</a>, this week we covered what library features are removed or started their way to be removed through their deprecation.</p><p>Deprecation is not always a one-way road. Next week, we’ll cover a feature that is going to be underprecated in C++26. Stay tuned.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp26/" class="post-tag no-text-decoration" >cpp26</a> <a href="/tags/remove/" class="post-tag no-text-decoration" >remove</a> <a href="/tags/deprecate/" class="post-tag no-text-decoration" >deprecate</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++26: Deprecating or removing library features - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++26: Deprecating or removing library features - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++26: Deprecating or removing library features - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++26: Deprecating or removing library features - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/03/12/cpp26-removing-language-features"><div class="card-body"> <span class="timeago small" > Mar 12 <i class="unloaded">2025-03-12T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: Removing language features</h3><div class="text-muted small"><p> Probably you all heard that C++ is an ever-growing language - I wrote so many times as well. Each standard indeed comes with a great bunch of highly-anticipated features. At the same time, due to b...</p></div></div></a></div><div class="card"> <a href="/blog/2024/12/11/start-exploring-cpp26"><div class="card-body"> <span class="timeago small" > Dec 11, 2024 <i class="unloaded">2024-12-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's start exploring C++26</h3><div class="text-muted small"><p> During the last 2 years, we spent a lot of time exploring C++23 resulting in almost 40 blog posts. I’m not saying that we covered every single new language or library feature, but we covered most o...</p></div></div></a></div><div class="card"> <a href="/blog/2024/12/18/cpp26-delete-with-a-reason"><div class="card-body"> <span class="timeago small" > Dec 18, 2024 <i class="unloaded">2024-12-18T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: Delete with a reason</h3><div class="text-muted small"><p> Let’s start exploring C++26 with a simple but useful change. Thanks to Yihe Li’s proposal (2573R2), when we =delete a special member function or a function overload, we can specify a reason. This ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/03/12/cpp26-removing-language-features" class="btn btn-outline-primary" prompt="Older"><p>C++26: Removing language features</p></a> <a href="/blog/2025/03/26/cpp26-undeprecate" class="btn btn-outline-primary" prompt="Newer"><p>C++26: an undeprecated feature</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++26: Deprecating or removing library features'; this.page.url = 'https://www.sandordargo.com/blog/2025/03/19/cpp26-deprecate-remove-library-features'; this.page.identifier = '/blog/2025/03/19/cpp26-deprecate-remove-library-features'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
