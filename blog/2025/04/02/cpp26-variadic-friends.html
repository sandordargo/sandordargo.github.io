<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++26: variadic friends" /><meta property="og:locale" content="en_US" /><meta name="description" content="Up until C++23, functions, classes, function and class templates could be declared as friends. Starting from C++26, thanks to Jody Hagins’ and Arthur O’Dwyer’s proposal, P2893R3, friendship can also be granted to a pack of types. Who does a pack of friends look like? In earlier standards, we must declare friend class templates one by one, just like in the example below. 1 2 3 4 5 6 template&lt;class T=void, class U=void&gt; class Foo { friend T; friend U; }; Note the default values for the template parameters. That makes it possible to accept a variadic number of template arguments with the maximum number of arguments fixed by how many parameters we added. With C++26, that is simplified and you can directly use a pack of types with friendship granted. 1 2 3 4 template&lt;class... Ts&gt; class Foo { friend Ts...; }; Now let’s see two practical usages from the proposal. The Passkey idiom If you ever used friends you might have found it problematic that a friend declaration’s scope is for the whole class. If you declare a friend within a class, it will have access to all the private parts of the class. But what if you wanted to limit the access to a couple of member functions? One option is to move those to another class and grant friendship within that class. Though it’s highly probable that from a design perspective that’s not such a great idea. Another - more elegant solution - is the passkey idiom. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template&lt;class T&gt; class Passkey { friend T; Passkey() = default; // note that this ctor is private! }; class A; class B; class C { friend A; private: void internal(); public: void intentionalA(Passkey&lt;A&gt;); void intentionalB(Passkey&lt;B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentionalA({}); // OK c.intentionalB({}); // Error, Passkey&lt;B&gt;&#39;s constructor is inaccessible } }; class B { void m(C&amp; c) { c.intentionalB({}); // OK } }; You can see that in order to call C’s public functions, you need to pass a Passkey object specialized with the right class. But only T can instantiate Passkey&lt;T&gt; due to its private constructor combined with friendship. It seems a bit cumbersome that you need two different member functions if you want to give access to two different classes, intentionalA for A and intentionalB for B. The name could be the same, but you’d still need two function bodies (definitions) and you’d have to type out the Passkeys to avoid ambiguous function calls: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template&lt;class T&gt; class Passkey { friend T; Passkey() {} }; class A; class B; class C { friend A; private: void internal(); public: void intentional(Passkey&lt;A&gt;); void intentional(Passkey&lt;B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentional(Passkey&lt;A&gt;{}); // OK c.intentional(Passkey&lt;B&gt;{}); // Error, Passkey&lt;B&gt;&#39;s ctor is inaccessible } }; class B { void m(C&amp; c) { c.intentional(Passkey&lt;B&gt;{}); // OK } }; With variadic friends, this code can be simplified. We have to make Passkey accept a variadic number of arguments and make them all friends. Then C::intentional can accept any allowed specialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template&lt;class... T&gt; class Passkey { friend T...; Passkey() {} }; class A; class B; class C { friend A; private: void internal(); public: void intentional(Passkey&lt;A, B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentional({}); // OK } }; class B { void m(C&amp; c) { c.intentional({}); // OK } }; It’s worth noting that you don’t need access to a class’ constructor to use it as a template type parameter. Passkey&lt;A, B&gt;{} works fine for both A and B. With this change, you only need to define intentional once. CRTP and access to private parts of derived classes If you are not familiar with the Curiously Recurring Template Pattern (CRTP), read this article before moving on. When you use this pattern, it might happen that in the base class, you want to access private parts of the derived class. As you don’t want to expose those private parts, you grant friendship to the base class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // The base class template&lt;class Crtp, class MsgT&gt; class Receiver { void receive(MsgT) { static_cast&lt;Crtp*&gt;(this)-&gt;private_ += 1; } }; // The derived class template&lt;class MsgT&gt; struct Dispatcher : public Receiver&lt;Dispatcher&lt;MsgT&gt;, MsgT&gt; { //_private member exposed to the base class, called Receiver using Receiver&lt;Dispatcher, MsgT&gt;::Receiver; friend Receiver&lt;Dispatcher, MsgT&gt;; private: int private_; }; Fair enough. But what if there are several base classes? What if the Dispatcher takes a variadic number of message types, inheriting from a pack of base classes? Today, there is no nice and simple solution, because only inheritance and the using directive support pack expansion, but not friendships. With C++26, the solution is simple, because friendship can be granted to a pack of friends. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // The base class template&lt;class Crtp, class MsgT&gt; class Receiver { void receive(MsgT) { static_cast&lt;Crtp*&gt;(this)-&gt;private_ += 1; } }; // The derived class template&lt;class... MsgTs&gt; // notice the variadic template parameters struct Dispatcher : public Receiver&lt;Dispatcher&lt;MsgTs...&gt;, MsgTs&gt;... // Inheritance supports pack expansion { using Receiver&lt;Dispatcher, MsgTs&gt;::Receiver...; // The using directive support pack expansion friend Receiver&lt;Dispatcher, MsgTs&gt;...; // Error pre-C++26, accepted from C++26 private: int private_; }; Conclusion Thanks to the acceptance of P2893R3, friendship can also be granted to a pack of types. While you won’t need this feature every day, as you can see from the examples, in the right circumstances, it can significantly simplify your code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><meta property="og:description" content="Up until C++23, functions, classes, function and class templates could be declared as friends. Starting from C++26, thanks to Jody Hagins’ and Arthur O’Dwyer’s proposal, P2893R3, friendship can also be granted to a pack of types. Who does a pack of friends look like? In earlier standards, we must declare friend class templates one by one, just like in the example below. 1 2 3 4 5 6 template&lt;class T=void, class U=void&gt; class Foo { friend T; friend U; }; Note the default values for the template parameters. That makes it possible to accept a variadic number of template arguments with the maximum number of arguments fixed by how many parameters we added. With C++26, that is simplified and you can directly use a pack of types with friendship granted. 1 2 3 4 template&lt;class... Ts&gt; class Foo { friend Ts...; }; Now let’s see two practical usages from the proposal. The Passkey idiom If you ever used friends you might have found it problematic that a friend declaration’s scope is for the whole class. If you declare a friend within a class, it will have access to all the private parts of the class. But what if you wanted to limit the access to a couple of member functions? One option is to move those to another class and grant friendship within that class. Though it’s highly probable that from a design perspective that’s not such a great idea. Another - more elegant solution - is the passkey idiom. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template&lt;class T&gt; class Passkey { friend T; Passkey() = default; // note that this ctor is private! }; class A; class B; class C { friend A; private: void internal(); public: void intentionalA(Passkey&lt;A&gt;); void intentionalB(Passkey&lt;B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentionalA({}); // OK c.intentionalB({}); // Error, Passkey&lt;B&gt;&#39;s constructor is inaccessible } }; class B { void m(C&amp; c) { c.intentionalB({}); // OK } }; You can see that in order to call C’s public functions, you need to pass a Passkey object specialized with the right class. But only T can instantiate Passkey&lt;T&gt; due to its private constructor combined with friendship. It seems a bit cumbersome that you need two different member functions if you want to give access to two different classes, intentionalA for A and intentionalB for B. The name could be the same, but you’d still need two function bodies (definitions) and you’d have to type out the Passkeys to avoid ambiguous function calls: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template&lt;class T&gt; class Passkey { friend T; Passkey() {} }; class A; class B; class C { friend A; private: void internal(); public: void intentional(Passkey&lt;A&gt;); void intentional(Passkey&lt;B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentional(Passkey&lt;A&gt;{}); // OK c.intentional(Passkey&lt;B&gt;{}); // Error, Passkey&lt;B&gt;&#39;s ctor is inaccessible } }; class B { void m(C&amp; c) { c.intentional(Passkey&lt;B&gt;{}); // OK } }; With variadic friends, this code can be simplified. We have to make Passkey accept a variadic number of arguments and make them all friends. Then C::intentional can accept any allowed specialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template&lt;class... T&gt; class Passkey { friend T...; Passkey() {} }; class A; class B; class C { friend A; private: void internal(); public: void intentional(Passkey&lt;A, B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentional({}); // OK } }; class B { void m(C&amp; c) { c.intentional({}); // OK } }; It’s worth noting that you don’t need access to a class’ constructor to use it as a template type parameter. Passkey&lt;A, B&gt;{} works fine for both A and B. With this change, you only need to define intentional once. CRTP and access to private parts of derived classes If you are not familiar with the Curiously Recurring Template Pattern (CRTP), read this article before moving on. When you use this pattern, it might happen that in the base class, you want to access private parts of the derived class. As you don’t want to expose those private parts, you grant friendship to the base class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // The base class template&lt;class Crtp, class MsgT&gt; class Receiver { void receive(MsgT) { static_cast&lt;Crtp*&gt;(this)-&gt;private_ += 1; } }; // The derived class template&lt;class MsgT&gt; struct Dispatcher : public Receiver&lt;Dispatcher&lt;MsgT&gt;, MsgT&gt; { //_private member exposed to the base class, called Receiver using Receiver&lt;Dispatcher, MsgT&gt;::Receiver; friend Receiver&lt;Dispatcher, MsgT&gt;; private: int private_; }; Fair enough. But what if there are several base classes? What if the Dispatcher takes a variadic number of message types, inheriting from a pack of base classes? Today, there is no nice and simple solution, because only inheritance and the using directive support pack expansion, but not friendships. With C++26, the solution is simple, because friendship can be granted to a pack of friends. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // The base class template&lt;class Crtp, class MsgT&gt; class Receiver { void receive(MsgT) { static_cast&lt;Crtp*&gt;(this)-&gt;private_ += 1; } }; // The derived class template&lt;class... MsgTs&gt; // notice the variadic template parameters struct Dispatcher : public Receiver&lt;Dispatcher&lt;MsgTs...&gt;, MsgTs&gt;... // Inheritance supports pack expansion { using Receiver&lt;Dispatcher, MsgTs&gt;::Receiver...; // The using directive support pack expansion friend Receiver&lt;Dispatcher, MsgTs&gt;...; // Error pre-C++26, accepted from C++26 private: int private_; }; Conclusion Thanks to the acceptance of P2893R3, friendship can also be granted to a pack of types. While you won’t need this feature every day, as you can see from the examples, in the right circumstances, it can significantly simplify your code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-04-02T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++26: variadic friends" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-04-02T00:00:00+02:00","datePublished":"2025-04-02T00:00:00+02:00","description":"Up until C++23, functions, classes, function and class templates could be declared as friends. Starting from C++26, thanks to Jody Hagins’ and Arthur O’Dwyer’s proposal, P2893R3, friendship can also be granted to a pack of types. Who does a pack of friends look like? In earlier standards, we must declare friend class templates one by one, just like in the example below. 1 2 3 4 5 6 template&lt;class T=void, class U=void&gt; class Foo { friend T; friend U; }; Note the default values for the template parameters. That makes it possible to accept a variadic number of template arguments with the maximum number of arguments fixed by how many parameters we added. With C++26, that is simplified and you can directly use a pack of types with friendship granted. 1 2 3 4 template&lt;class... Ts&gt; class Foo { friend Ts...; }; Now let’s see two practical usages from the proposal. The Passkey idiom If you ever used friends you might have found it problematic that a friend declaration’s scope is for the whole class. If you declare a friend within a class, it will have access to all the private parts of the class. But what if you wanted to limit the access to a couple of member functions? One option is to move those to another class and grant friendship within that class. Though it’s highly probable that from a design perspective that’s not such a great idea. Another - more elegant solution - is the passkey idiom. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template&lt;class T&gt; class Passkey { friend T; Passkey() = default; // note that this ctor is private! }; class A; class B; class C { friend A; private: void internal(); public: void intentionalA(Passkey&lt;A&gt;); void intentionalB(Passkey&lt;B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentionalA({}); // OK c.intentionalB({}); // Error, Passkey&lt;B&gt;&#39;s constructor is inaccessible } }; class B { void m(C&amp; c) { c.intentionalB({}); // OK } }; You can see that in order to call C’s public functions, you need to pass a Passkey object specialized with the right class. But only T can instantiate Passkey&lt;T&gt; due to its private constructor combined with friendship. It seems a bit cumbersome that you need two different member functions if you want to give access to two different classes, intentionalA for A and intentionalB for B. The name could be the same, but you’d still need two function bodies (definitions) and you’d have to type out the Passkeys to avoid ambiguous function calls: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 template&lt;class T&gt; class Passkey { friend T; Passkey() {} }; class A; class B; class C { friend A; private: void internal(); public: void intentional(Passkey&lt;A&gt;); void intentional(Passkey&lt;B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentional(Passkey&lt;A&gt;{}); // OK c.intentional(Passkey&lt;B&gt;{}); // Error, Passkey&lt;B&gt;&#39;s ctor is inaccessible } }; class B { void m(C&amp; c) { c.intentional(Passkey&lt;B&gt;{}); // OK } }; With variadic friends, this code can be simplified. We have to make Passkey accept a variadic number of arguments and make them all friends. Then C::intentional can accept any allowed specialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template&lt;class... T&gt; class Passkey { friend T...; Passkey() {} }; class A; class B; class C { friend A; private: void internal(); public: void intentional(Passkey&lt;A, B&gt;); }; class A { void m(C&amp; c) { c.internal(); // OK c.intentional({}); // OK } }; class B { void m(C&amp; c) { c.intentional({}); // OK } }; It’s worth noting that you don’t need access to a class’ constructor to use it as a template type parameter. Passkey&lt;A, B&gt;{} works fine for both A and B. With this change, you only need to define intentional once. CRTP and access to private parts of derived classes If you are not familiar with the Curiously Recurring Template Pattern (CRTP), read this article before moving on. When you use this pattern, it might happen that in the base class, you want to access private parts of the derived class. As you don’t want to expose those private parts, you grant friendship to the base class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // The base class template&lt;class Crtp, class MsgT&gt; class Receiver { void receive(MsgT) { static_cast&lt;Crtp*&gt;(this)-&gt;private_ += 1; } }; // The derived class template&lt;class MsgT&gt; struct Dispatcher : public Receiver&lt;Dispatcher&lt;MsgT&gt;, MsgT&gt; { //_private member exposed to the base class, called Receiver using Receiver&lt;Dispatcher, MsgT&gt;::Receiver; friend Receiver&lt;Dispatcher, MsgT&gt;; private: int private_; }; Fair enough. But what if there are several base classes? What if the Dispatcher takes a variadic number of message types, inheriting from a pack of base classes? Today, there is no nice and simple solution, because only inheritance and the using directive support pack expansion, but not friendships. With C++26, the solution is simple, because friendship can be granted to a pack of friends. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 // The base class template&lt;class Crtp, class MsgT&gt; class Receiver { void receive(MsgT) { static_cast&lt;Crtp*&gt;(this)-&gt;private_ += 1; } }; // The derived class template&lt;class... MsgTs&gt; // notice the variadic template parameters struct Dispatcher : public Receiver&lt;Dispatcher&lt;MsgTs...&gt;, MsgTs&gt;... // Inheritance supports pack expansion { using Receiver&lt;Dispatcher, MsgTs&gt;::Receiver...; // The using directive support pack expansion friend Receiver&lt;Dispatcher, MsgTs&gt;...; // Error pre-C++26, accepted from C++26 private: int private_; }; Conclusion Thanks to the acceptance of P2893R3, friendship can also be granted to a pack of types. While you won’t need this feature every day, as you can see from the examples, in the right circumstances, it can significantly simplify your code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter","headline":"C++26: variadic friends","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends"},"url":"https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends"}</script><title>C++26: variadic friends | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/02"> 02 </a> </span> <span>C++26: variadic friends</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++26: variadic friends</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 2, 2025, 12:00 AM +0200" prep="on" > Apr 2, 2025 <i class="unloaded">2025-04-02T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1037 words">5 min</span></div></div><div class="post-content"><p>Up until C++23, functions, classes, function and class templates could be declared as friends. Starting from C++26, thanks to Jody Hagins’ and Arthur O’Dwyer’s proposal, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html">P2893R3</a>, friendship can also be granted to a <em>pack of types</em>.</p><h2 id="who-does-a-pack-of-friends-look-like">Who does a pack of friends look like?</h2><p>In earlier standards, we must declare friend class templates one by one, just like in the example below.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">=</span><span class="kt">void</span><span class="p">,</span>
         <span class="k">class</span> <span class="nc">U</span><span class="o">=</span><span class="kt">void</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">T</span><span class="p">;</span>
  <span class="k">friend</span> <span class="n">U</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Note the default values for the template parameters. That makes it possible to accept a variadic number of template arguments with the maximum number of arguments fixed by how many parameters we added.</p><p>With C++26, that is simplified and you can directly use a pack of types with friendship granted.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">Ts</span><span class="p">...;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Now let’s see two practical usages from the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html">proposal</a>.</p><h2 id="the-passkey-idiom">The Passkey idiom</h2><p>If you ever used <code class="language-plaintext highlighter-rouge">friends</code> you might have found it problematic that a friend declaration’s scope is for the whole class. If you declare a friend within a class, it will have access to all the private parts of the class. But what if you wanted to limit the access to a couple of member functions?</p><p>One option is to move those to another class and grant friendship within that class. Though it’s highly probable that from a design perspective that’s not such a great idea.</p><p>Another - more elegant solution - is the passkey idiom.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Passkey</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">T</span><span class="p">;</span>
  <span class="n">Passkey</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// note that this ctor is private!</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">A</span><span class="p">;</span>
<span class="nl">private:</span>
  <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">intentionalA</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">intentionalB</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">m</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">internal</span><span class="p">();</span> <span class="c1">// OK</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentionalA</span><span class="p">({});</span> <span class="c1">// OK</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentionalB</span><span class="p">({});</span> <span class="c1">// Error, Passkey&lt;B&gt;'s constructor is inaccessible</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">m</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentionalB</span><span class="p">({});</span> <span class="c1">// OK</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>You can see that in order to call <code class="language-plaintext highlighter-rouge">C</code>’s public functions, you need to pass a <code class="language-plaintext highlighter-rouge">Passkey</code> object specialized with the right class. But only <code class="language-plaintext highlighter-rouge">T</code> can instantiate <code class="language-plaintext highlighter-rouge">Passkey&lt;T&gt;</code> due to its private constructor combined with friendship.</p><p>It seems a bit cumbersome that you need two different member functions if you want to give access to two different classes, <code class="language-plaintext highlighter-rouge">intentionalA</code> for <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">intentionalB</code> for <code class="language-plaintext highlighter-rouge">B</code>. The name could be the same, but you’d still need two function bodies (definitions) and you’d have to type out the <code class="language-plaintext highlighter-rouge">Passkey</code>s to avoid ambiguous function calls:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Passkey</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">T</span><span class="p">;</span>
  <span class="n">Passkey</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">A</span><span class="p">;</span>
<span class="nl">private:</span>
  <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">intentional</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">intentional</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">m</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">internal</span><span class="p">();</span> <span class="c1">// OK</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentional</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">{});</span> <span class="c1">// OK</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentional</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">{});</span> <span class="c1">// Error, Passkey&lt;B&gt;'s ctor is inaccessible</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">m</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentional</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">{});</span> <span class="c1">// OK</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>With variadic friends, this code can be simplified. We have to make <code class="language-plaintext highlighter-rouge">Passkey</code> accept a variadic number of arguments and make them all friends. Then <code class="language-plaintext highlighter-rouge">C::intentional</code> can accept any allowed specialization.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Passkey</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">T</span><span class="p">...;</span>
  <span class="n">Passkey</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">B</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
  <span class="k">friend</span> <span class="n">A</span><span class="p">;</span>
<span class="nl">private:</span>
  <span class="kt">void</span> <span class="n">internal</span><span class="p">();</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">intentional</span><span class="p">(</span><span class="n">Passkey</span><span class="o">&lt;</span><span class="n">A</span><span class="p">,</span> <span class="n">B</span><span class="o">&gt;</span><span class="p">);</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">m</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">internal</span><span class="p">();</span> <span class="c1">// OK</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentional</span><span class="p">({});</span> <span class="c1">// OK</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">m</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">c</span><span class="p">.</span><span class="n">intentional</span><span class="p">({});</span> <span class="c1">// OK</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>It’s worth noting that you don’t need access to a class’ constructor to use it as a template type parameter. <code class="language-plaintext highlighter-rouge">Passkey&lt;A, B&gt;{}</code> works fine for both <code class="language-plaintext highlighter-rouge">A</code> and <code class="language-plaintext highlighter-rouge">B</code>. With this change, you only need to define <code class="language-plaintext highlighter-rouge">intentional</code> once.</p><h2 id="crtp-and-access-to-private-parts-of-derived-classes">CRTP and access to private parts of derived classes</h2><p>If you are not familiar with the <em>Curiously Recurring Template Pattern (CRTP)</em>, <a href="https://www.sandordargo.com/blog/2019/03/13/the-curiously-recurring-templatep-pattern-CRTP">read this article</a> before moving on.</p><p>When you use this pattern, it might happen that in the base class, you want to access private parts of the derived class. As you don’t want to expose those private parts, you grant friendship to the base class.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// The base class</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Crtp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">MsgT</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Receiver</span> <span class="p">{</span> 
  <span class="kt">void</span> <span class="n">receive</span><span class="p">(</span><span class="n">MsgT</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Crtp</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// The derived class</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">MsgT</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Dispatcher</span> <span class="o">:</span>
  <span class="k">public</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Dispatcher</span><span class="o">&lt;</span><span class="n">MsgT</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">MsgT</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="c1">//_private member exposed to the base class, called Receiver</span>
  <span class="k">using</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Dispatcher</span><span class="p">,</span> <span class="n">MsgT</span><span class="o">&gt;::</span><span class="n">Receiver</span><span class="p">;</span>
  <span class="k">friend</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Dispatcher</span><span class="p">,</span> <span class="n">MsgT</span><span class="o">&gt;</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">private_</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Fair enough. But what if there are several base classes? What if the <code class="language-plaintext highlighter-rouge">Dispatcher</code> takes a variadic number of message types, inheriting from a pack of base classes?</p><p>Today, there is no nice and simple solution, because only inheritance and the <code class="language-plaintext highlighter-rouge">using</code> directive support pack expansion, but not friendships. With C++26, the solution is simple, because friendship can be granted to a pack of friends.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="c1">// The base class</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Crtp</span><span class="p">,</span> <span class="k">class</span> <span class="nc">MsgT</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Receiver</span> <span class="p">{</span>
  <span class="kt">void</span> <span class="n">receive</span><span class="p">(</span><span class="n">MsgT</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Crtp</span><span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">private_</span> <span class="o">+=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// The derived class</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span><span class="o">...</span> <span class="nc">MsgTs</span><span class="p">&gt;</span> <span class="c1">// notice the variadic template parameters</span>
<span class="k">struct</span> <span class="nc">Dispatcher</span> <span class="o">:</span>
  <span class="k">public</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Dispatcher</span><span class="o">&lt;</span><span class="n">MsgTs</span><span class="p">...</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">MsgTs</span><span class="o">&gt;</span><span class="p">...</span> <span class="c1">// Inheritance supports pack expansion</span>
<span class="p">{</span>
  <span class="k">using</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Dispatcher</span><span class="p">,</span> <span class="n">MsgTs</span><span class="o">&gt;::</span><span class="n">Receiver</span><span class="p">...;</span>  <span class="c1">// The using directive support pack expansion</span>
  <span class="k">friend</span> <span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Dispatcher</span><span class="p">,</span> <span class="n">MsgTs</span><span class="o">&gt;</span><span class="p">...;</span> <span class="c1">// Error pre-C++26, accepted from C++26</span>

<span class="nl">private:</span>
  <span class="kt">int</span> <span class="n">private_</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>Thanks to the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2893r3.html">P2893R3</a>, friendship can also be granted to a <em>pack of types</em>. While you won’t need this feature every day, as you can see from the examples, in the right circumstances, it can significantly simplify your code.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp26/" class="post-tag no-text-decoration" >cpp26</a> <a href="/tags/variadic/" class="post-tag no-text-decoration" >variadic</a> <a href="/tags/friends/" class="post-tag no-text-decoration" >friends</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++26: variadic friends - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++26: variadic friends - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++26: variadic friends - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++26: variadic friends - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/12/11/start-exploring-cpp26"><div class="card-body"> <span class="timeago small" > Dec 11, 2024 <i class="unloaded">2024-12-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's start exploring C++26</h3><div class="text-muted small"><p> During the last 2 years, we spent a lot of time exploring C++23 resulting in almost 40 blog posts. I’m not saying that we covered every single new language or library feature, but we covered most o...</p></div></div></a></div><div class="card"> <a href="/blog/2024/12/18/cpp26-delete-with-a-reason"><div class="card-body"> <span class="timeago small" > Dec 18, 2024 <i class="unloaded">2024-12-18T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: Delete with a reason</h3><div class="text-muted small"><p> Let’s start exploring C++26 with a simple but useful change. Thanks to Yihe Li’s proposal (2573R2), when we =delete a special member function or a function overload, we can specify a reason. This ...</p></div></div></a></div><div class="card"> <a href="/blog/2025/01/01/cpp26-static-assert"><div class="card-body"> <span class="timeago small" > Jan 1, 2025 <i class="unloaded">2025-01-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: user-generated static_assert messages</h3><div class="text-muted small"><p> Our first quest into the world of C++26 was about =delete with an optional error message, which improves the readability of the source code and potentially the error messages. In this next part of ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/03/26/cpp26-undeprecate" class="btn btn-outline-primary" prompt="Older"><p>C++26: an undeprecated feature</p></a> <a href="/blog/2025/04/09/no-final-mock" class="btn btn-outline-primary" prompt="Newer"><p>Should you use final?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++26: variadic friends'; this.page.url = 'https://www.sandordargo.com/blog/2025/04/02/cpp26-variadic-friends'; this.page.identifier = '/blog/2025/04/02/cpp26-variadic-friends'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
