<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Raw loops for performance?" /><meta property="og:locale" content="en_US" /><meta name="description" content="To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I raised a tiny pull request. One of my pet peeves is rooted in Sean Parent’s 2013 talk at GoingNative, Seasoning C++ where he advocated for no raw loops. When I saw this loop, I started to think about how to replace it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; struct FromData { // ... std::string title; int amount; }; struct Widget { // ... std::list&lt;FromData&gt; data; }; struct ToData { // ... std::string title; int amount; }; struct Response { // ... std::vector&lt;ToData&gt; data; }; Response foo(Widget widget) { std::vector&lt;ToData&gt; transformed_data; for (const auto&amp; element : widget.data) { transformed_data.push_back( {.title = element.title, .amount = element.amount * 42}); } Response response; // ... response.data = transformed_data; return response; } int main() { Widget widget{.data = { {&quot;a&quot;, 1}, {&quot;b&quot;, 2}, {&quot;c&quot;, 1}, }}; auto r = foo(widget); for (const auto&amp; element : r.data) { std::cout &lt;&lt; &quot;title: &quot; &lt;&lt; element.title &lt;&lt; &quot;, amount &quot; &lt;&lt; element.amount &lt;&lt; &#39;\n&#39;; } } /* title: a, amount 42 title: b, amount 84 title: c, amount 42 */ Please note that the example is simplified and slightly changed so that it compiles on its own. Let’s focus on foo, the rest is there just to make the example compilable. It seems that we could use std::transform. But heck, we use C++20 we have ranges at our hands so let’s go with std::ranges::transform! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;ranges&gt; #include &lt;string&gt; #include &lt;vector&gt; struct FromData { // ... std::string title; int amount; }; struct Widget { // ... std::list&lt;FromData&gt; data; }; struct ToData { // ... std::string title; int amount; }; struct Response { // ... std::vector&lt;ToData&gt; data; }; Response foo(Widget widget) { const auto transformed_data = widget.data | std::views::transform([](const auto&amp; element) { return ToData{ .title = element.title, .amount = element.amount * 42 }; }); Response response; // ... response.data = {transformed_data.begin(), transformed_data.end()}; return response; } int main() { Widget widget{.data = { {&quot;a&quot;, 1}, {&quot;b&quot;, 2}, {&quot;c&quot;, 1}, }}; auto r = foo(widget); for (const auto&amp; element : r.data) { std::cout &lt;&lt; &quot;title: &quot; &lt;&lt; element.title &lt;&lt; &quot;, amount &quot; &lt;&lt; element.amount &lt;&lt; &#39;\n&#39;; } } /* title: a, amount 42 title: b, amount 84 title: c, amount 42 */ We have no more raw loops, no more initialized then modified vectors, and the result is the same. Is this better? We don’t have to modify a vector that’s definitely better. But when I proposed such a change, one of my colleagues asked a question. transformed_data became a view. When we populate response.data, do we actually copy all the elements of the view? I couldn’t answer the question with confidence, hence this article. I slightly updated both examples,and updated ToData to this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct ToData { // ... std::string title; int amount; ToData() { std::cout &lt;&lt; &quot;ToData()\n&quot;; } ToData(std::string title, int amount) : title(title), amount(amount) { std::cout &lt;&lt; &quot;ToData(std::string title, int amount)\n&quot;; } ToData(const ToData&amp; other): title(other.title), amount(other.amount) { std::cout &lt;&lt; &quot;ToData(const ToData&amp; other)\n&quot;; } ToData&amp; operator=(const ToData&amp; other) { std::cout &lt;&lt; &quot;ToData&amp; operator=(const ToData&amp; other)\n&quot;; title = other.title; amount = other.amount; return *this; } ToData(ToData&amp;&amp; other) : title(std::exchange(other.title, &quot;&quot;)), amount(std::exchange(other.amount, 0)) { std::cout &lt;&lt; &quot;ToData(ToData&amp;&amp; other)\n&quot;; } ToData&amp; operator=(ToData&amp;&amp; other) { std::cout &lt;&lt; &quot;ToData&amp; operator=(ToData&amp;&amp; other)\n&quot;; title = std::exchange(other.title, &quot;&quot;); amount = std::exchange(other.amount, 0); return *this; } }; I also had to remove the usage of designed initializers as ToData is no longer an aggregate. The output for the original version using push_back is not particularly surprising. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) writing response.data ToData(const ToData&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) wrote response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 In the for loop, we construct ToData and move it, and there is also a copy construction. Before actually copying the data. On the other hand, for the version using ranges, the output is shorter and different! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 filling response.data ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) filled1 response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 Nothing actually happens within the transformation pipeline! Everything is happening lazily when we use the results of the pipeline and actually construct a vector. Then we have fewer calls than we had in the original version. Seemingly, far the ranges version has an advantage! But we all know that the original version is not optional even with a raw loop. Let’s use emplace_back! Oh and we also forgot about calling std::vector&lt;T&gt;::reserve to avoid reallocations! Here is the code producing the below output. 1 2 3 4 5 6 7 8 9 10 11 ToData(std::string title, int amount) ToData(std::string title, int amount) ToData(std::string title, int amount) writing response.data ToData(const ToData&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) wrote response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 Now the raw loop version has an advantage! In this version, for each item, we have a constructor and a copy while in the ranges version, we also have an extra move! Note that since C++23, you can also use std::ranges::to&lt;std::vector&lt;Todata&gt;&gt; to construct the final vector, but it didn’t result in any difference in terms of the number of special member function calls. Is that so bad? Probably not. Move operations are cheap, that’s why they were introduced! Probably this is just an acceptable price to pay for more readable code. But our “more readable code” also features a lambda so let’s just say that we have assumptions. Let’s also run benchmarks. Based on Quick Bench, the enhanced raw loop version is about 20% faster on Clang than the raw loop version. The results are slightly different with GCC, but the raw loop version is still 10% faster. It’s also worth noting that the original version with a push_back and without the reserve is 20-30% slower than the other two versions! By adding the reserve but still using push_back, the code is between the ranges and the raw loop with emplace_back version. What does this mean in real life? It depends. You must measure. Don’t forget about Amdahl’s law which says that “the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used.” If this happens to be a bottleneck, use the emplace_back version without hesitation and don’t forget about reserving enough space in memory for all the elements. I think you have no reason to use the push_back version and definitely not without calling reserve. Otherwise, if you write code where you also do some network calls or read from the database or from the filesystem, these differences are negligible and you should go with the version that you find the most readable. That’s up to you. Conclusion Using ranges or algorithms has several advantages over raw loops, notably readability. On the other hand, as we’ve just seen, sheer performance is not necessarily among those advantages. Using ranges can be slightly slower than a raw loop version. But that’s not necessarily a problem, it really depends on your use case. Most probably it won’t make a bit difference. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><meta property="og:description" content="To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I raised a tiny pull request. One of my pet peeves is rooted in Sean Parent’s 2013 talk at GoingNative, Seasoning C++ where he advocated for no raw loops. When I saw this loop, I started to think about how to replace it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; struct FromData { // ... std::string title; int amount; }; struct Widget { // ... std::list&lt;FromData&gt; data; }; struct ToData { // ... std::string title; int amount; }; struct Response { // ... std::vector&lt;ToData&gt; data; }; Response foo(Widget widget) { std::vector&lt;ToData&gt; transformed_data; for (const auto&amp; element : widget.data) { transformed_data.push_back( {.title = element.title, .amount = element.amount * 42}); } Response response; // ... response.data = transformed_data; return response; } int main() { Widget widget{.data = { {&quot;a&quot;, 1}, {&quot;b&quot;, 2}, {&quot;c&quot;, 1}, }}; auto r = foo(widget); for (const auto&amp; element : r.data) { std::cout &lt;&lt; &quot;title: &quot; &lt;&lt; element.title &lt;&lt; &quot;, amount &quot; &lt;&lt; element.amount &lt;&lt; &#39;\n&#39;; } } /* title: a, amount 42 title: b, amount 84 title: c, amount 42 */ Please note that the example is simplified and slightly changed so that it compiles on its own. Let’s focus on foo, the rest is there just to make the example compilable. It seems that we could use std::transform. But heck, we use C++20 we have ranges at our hands so let’s go with std::ranges::transform! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;ranges&gt; #include &lt;string&gt; #include &lt;vector&gt; struct FromData { // ... std::string title; int amount; }; struct Widget { // ... std::list&lt;FromData&gt; data; }; struct ToData { // ... std::string title; int amount; }; struct Response { // ... std::vector&lt;ToData&gt; data; }; Response foo(Widget widget) { const auto transformed_data = widget.data | std::views::transform([](const auto&amp; element) { return ToData{ .title = element.title, .amount = element.amount * 42 }; }); Response response; // ... response.data = {transformed_data.begin(), transformed_data.end()}; return response; } int main() { Widget widget{.data = { {&quot;a&quot;, 1}, {&quot;b&quot;, 2}, {&quot;c&quot;, 1}, }}; auto r = foo(widget); for (const auto&amp; element : r.data) { std::cout &lt;&lt; &quot;title: &quot; &lt;&lt; element.title &lt;&lt; &quot;, amount &quot; &lt;&lt; element.amount &lt;&lt; &#39;\n&#39;; } } /* title: a, amount 42 title: b, amount 84 title: c, amount 42 */ We have no more raw loops, no more initialized then modified vectors, and the result is the same. Is this better? We don’t have to modify a vector that’s definitely better. But when I proposed such a change, one of my colleagues asked a question. transformed_data became a view. When we populate response.data, do we actually copy all the elements of the view? I couldn’t answer the question with confidence, hence this article. I slightly updated both examples,and updated ToData to this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct ToData { // ... std::string title; int amount; ToData() { std::cout &lt;&lt; &quot;ToData()\n&quot;; } ToData(std::string title, int amount) : title(title), amount(amount) { std::cout &lt;&lt; &quot;ToData(std::string title, int amount)\n&quot;; } ToData(const ToData&amp; other): title(other.title), amount(other.amount) { std::cout &lt;&lt; &quot;ToData(const ToData&amp; other)\n&quot;; } ToData&amp; operator=(const ToData&amp; other) { std::cout &lt;&lt; &quot;ToData&amp; operator=(const ToData&amp; other)\n&quot;; title = other.title; amount = other.amount; return *this; } ToData(ToData&amp;&amp; other) : title(std::exchange(other.title, &quot;&quot;)), amount(std::exchange(other.amount, 0)) { std::cout &lt;&lt; &quot;ToData(ToData&amp;&amp; other)\n&quot;; } ToData&amp; operator=(ToData&amp;&amp; other) { std::cout &lt;&lt; &quot;ToData&amp; operator=(ToData&amp;&amp; other)\n&quot;; title = std::exchange(other.title, &quot;&quot;); amount = std::exchange(other.amount, 0); return *this; } }; I also had to remove the usage of designed initializers as ToData is no longer an aggregate. The output for the original version using push_back is not particularly surprising. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) writing response.data ToData(const ToData&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) wrote response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 In the for loop, we construct ToData and move it, and there is also a copy construction. Before actually copying the data. On the other hand, for the version using ranges, the output is shorter and different! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 filling response.data ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) filled1 response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 Nothing actually happens within the transformation pipeline! Everything is happening lazily when we use the results of the pipeline and actually construct a vector. Then we have fewer calls than we had in the original version. Seemingly, far the ranges version has an advantage! But we all know that the original version is not optional even with a raw loop. Let’s use emplace_back! Oh and we also forgot about calling std::vector&lt;T&gt;::reserve to avoid reallocations! Here is the code producing the below output. 1 2 3 4 5 6 7 8 9 10 11 ToData(std::string title, int amount) ToData(std::string title, int amount) ToData(std::string title, int amount) writing response.data ToData(const ToData&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) wrote response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 Now the raw loop version has an advantage! In this version, for each item, we have a constructor and a copy while in the ranges version, we also have an extra move! Note that since C++23, you can also use std::ranges::to&lt;std::vector&lt;Todata&gt;&gt; to construct the final vector, but it didn’t result in any difference in terms of the number of special member function calls. Is that so bad? Probably not. Move operations are cheap, that’s why they were introduced! Probably this is just an acceptable price to pay for more readable code. But our “more readable code” also features a lambda so let’s just say that we have assumptions. Let’s also run benchmarks. Based on Quick Bench, the enhanced raw loop version is about 20% faster on Clang than the raw loop version. The results are slightly different with GCC, but the raw loop version is still 10% faster. It’s also worth noting that the original version with a push_back and without the reserve is 20-30% slower than the other two versions! By adding the reserve but still using push_back, the code is between the ranges and the raw loop with emplace_back version. What does this mean in real life? It depends. You must measure. Don’t forget about Amdahl’s law which says that “the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used.” If this happens to be a bottleneck, use the emplace_back version without hesitation and don’t forget about reserving enough space in memory for all the elements. I think you have no reason to use the push_back version and definitely not without calling reserve. Otherwise, if you write code where you also do some network calls or read from the database or from the filesystem, these differences are negligible and you should go with the version that you find the most readable. That’s up to you. Conclusion Using ranges or algorithms has several advantages over raw loops, notably readability. On the other hand, as we’ve just seen, sheer performance is not necessarily among those advantages. Using ranges can be slightly slower than a raw loop version. But that’s not necessarily a problem, it really depends on your use case. Most probably it won’t make a bit difference. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-04-16T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Raw loops for performance?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-04-21T07:03:00+02:00","datePublished":"2025-04-16T00:00:00+02:00","description":"To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I raised a tiny pull request. One of my pet peeves is rooted in Sean Parent’s 2013 talk at GoingNative, Seasoning C++ where he advocated for no raw loops. When I saw this loop, I started to think about how to replace it: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;string&gt; #include &lt;vector&gt; struct FromData { // ... std::string title; int amount; }; struct Widget { // ... std::list&lt;FromData&gt; data; }; struct ToData { // ... std::string title; int amount; }; struct Response { // ... std::vector&lt;ToData&gt; data; }; Response foo(Widget widget) { std::vector&lt;ToData&gt; transformed_data; for (const auto&amp; element : widget.data) { transformed_data.push_back( {.title = element.title, .amount = element.amount * 42}); } Response response; // ... response.data = transformed_data; return response; } int main() { Widget widget{.data = { {&quot;a&quot;, 1}, {&quot;b&quot;, 2}, {&quot;c&quot;, 1}, }}; auto r = foo(widget); for (const auto&amp; element : r.data) { std::cout &lt;&lt; &quot;title: &quot; &lt;&lt; element.title &lt;&lt; &quot;, amount &quot; &lt;&lt; element.amount &lt;&lt; &#39;\\n&#39;; } } /* title: a, amount 42 title: b, amount 84 title: c, amount 42 */ Please note that the example is simplified and slightly changed so that it compiles on its own. Let’s focus on foo, the rest is there just to make the example compilable. It seems that we could use std::transform. But heck, we use C++20 we have ranges at our hands so let’s go with std::ranges::transform! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include &lt;iostream&gt; #include &lt;list&gt; #include &lt;ranges&gt; #include &lt;string&gt; #include &lt;vector&gt; struct FromData { // ... std::string title; int amount; }; struct Widget { // ... std::list&lt;FromData&gt; data; }; struct ToData { // ... std::string title; int amount; }; struct Response { // ... std::vector&lt;ToData&gt; data; }; Response foo(Widget widget) { const auto transformed_data = widget.data | std::views::transform([](const auto&amp; element) { return ToData{ .title = element.title, .amount = element.amount * 42 }; }); Response response; // ... response.data = {transformed_data.begin(), transformed_data.end()}; return response; } int main() { Widget widget{.data = { {&quot;a&quot;, 1}, {&quot;b&quot;, 2}, {&quot;c&quot;, 1}, }}; auto r = foo(widget); for (const auto&amp; element : r.data) { std::cout &lt;&lt; &quot;title: &quot; &lt;&lt; element.title &lt;&lt; &quot;, amount &quot; &lt;&lt; element.amount &lt;&lt; &#39;\\n&#39;; } } /* title: a, amount 42 title: b, amount 84 title: c, amount 42 */ We have no more raw loops, no more initialized then modified vectors, and the result is the same. Is this better? We don’t have to modify a vector that’s definitely better. But when I proposed such a change, one of my colleagues asked a question. transformed_data became a view. When we populate response.data, do we actually copy all the elements of the view? I couldn’t answer the question with confidence, hence this article. I slightly updated both examples,and updated ToData to this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 struct ToData { // ... std::string title; int amount; ToData() { std::cout &lt;&lt; &quot;ToData()\\n&quot;; } ToData(std::string title, int amount) : title(title), amount(amount) { std::cout &lt;&lt; &quot;ToData(std::string title, int amount)\\n&quot;; } ToData(const ToData&amp; other): title(other.title), amount(other.amount) { std::cout &lt;&lt; &quot;ToData(const ToData&amp; other)\\n&quot;; } ToData&amp; operator=(const ToData&amp; other) { std::cout &lt;&lt; &quot;ToData&amp; operator=(const ToData&amp; other)\\n&quot;; title = other.title; amount = other.amount; return *this; } ToData(ToData&amp;&amp; other) : title(std::exchange(other.title, &quot;&quot;)), amount(std::exchange(other.amount, 0)) { std::cout &lt;&lt; &quot;ToData(ToData&amp;&amp; other)\\n&quot;; } ToData&amp; operator=(ToData&amp;&amp; other) { std::cout &lt;&lt; &quot;ToData&amp; operator=(ToData&amp;&amp; other)\\n&quot;; title = std::exchange(other.title, &quot;&quot;); amount = std::exchange(other.amount, 0); return *this; } }; I also had to remove the usage of designed initializers as ToData is no longer an aggregate. The output for the original version using push_back is not particularly surprising. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) writing response.data ToData(const ToData&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) wrote response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 In the for loop, we construct ToData and move it, and there is also a copy construction. Before actually copying the data. On the other hand, for the version using ranges, the output is shorter and different! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 filling response.data ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(std::string title, int amount) ToData(ToData&amp;&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) filled1 response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 Nothing actually happens within the transformation pipeline! Everything is happening lazily when we use the results of the pipeline and actually construct a vector. Then we have fewer calls than we had in the original version. Seemingly, far the ranges version has an advantage! But we all know that the original version is not optional even with a raw loop. Let’s use emplace_back! Oh and we also forgot about calling std::vector&lt;T&gt;::reserve to avoid reallocations! Here is the code producing the below output. 1 2 3 4 5 6 7 8 9 10 11 ToData(std::string title, int amount) ToData(std::string title, int amount) ToData(std::string title, int amount) writing response.data ToData(const ToData&amp; other) ToData(const ToData&amp; other) ToData(const ToData&amp; other) wrote response.data title: a, amount 42 title: b, amount 84 title: c, amount 42 Now the raw loop version has an advantage! In this version, for each item, we have a constructor and a copy while in the ranges version, we also have an extra move! Note that since C++23, you can also use std::ranges::to&lt;std::vector&lt;Todata&gt;&gt; to construct the final vector, but it didn’t result in any difference in terms of the number of special member function calls. Is that so bad? Probably not. Move operations are cheap, that’s why they were introduced! Probably this is just an acceptable price to pay for more readable code. But our “more readable code” also features a lambda so let’s just say that we have assumptions. Let’s also run benchmarks. Based on Quick Bench, the enhanced raw loop version is about 20% faster on Clang than the raw loop version. The results are slightly different with GCC, but the raw loop version is still 10% faster. It’s also worth noting that the original version with a push_back and without the reserve is 20-30% slower than the other two versions! By adding the reserve but still using push_back, the code is between the ranges and the raw loop with emplace_back version. What does this mean in real life? It depends. You must measure. Don’t forget about Amdahl’s law which says that “the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used.” If this happens to be a bottleneck, use the emplace_back version without hesitation and don’t forget about reserving enough space in memory for all the elements. I think you have no reason to use the push_back version and definitely not without calling reserve. Otherwise, if you write code where you also do some network calls or read from the database or from the filesystem, these differences are negligible and you should go with the version that you find the most readable. That’s up to you. Conclusion Using ranges or algorithms has several advantages over raw loops, notably readability. On the other hand, as we’ve just seen, sheer performance is not necessarily among those advantages. Using ranges can be slightly slower than a raw loop version. But that’s not necessarily a problem, it really depends on your use case. Most probably it won’t make a bit difference. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter","headline":"Raw loops for performance?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance"},"url":"https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance"}</script><title>Raw loops for performance? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/16"> 16 </a> </span> <span>Raw loops for performance?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Raw loops for performance?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 16, 2025, 12:00 AM +0200" prep="on" > Apr 16, 2025 <i class="unloaded">2025-04-16T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Apr 21, 2025, 7:03 AM +0200" prefix="Updated " > Apr 21, 2025 <i class="unloaded">2025-04-21T07:03:00+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1460 words">8 min</span></div></div><div class="post-content"><p>To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I raised a tiny pull request. One of my pet peeves is rooted in Sean Parent’s 2013 talk at GoingNative, <a href="https://www.youtube.com/watch?v=W2tWOdzgXHA">Seasoning C++</a> where he advocated for <strong><em>no raw loops</em></strong>.</p><p>When I saw this loop, I started to think about how to replace it:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">FromData</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">amount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">FromData</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">ToData</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">amount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Response</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ToData</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Response</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Widget</span> <span class="n">widget</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ToData</span><span class="o">&gt;</span> <span class="n">transformed_data</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">element</span> <span class="o">:</span> <span class="n">widget</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">transformed_data</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span>
            <span class="p">{.</span><span class="n">title</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="p">.</span><span class="n">amount</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">amount</span> <span class="o">*</span> <span class="mi">42</span><span class="p">});</span>
    <span class="p">}</span>
    <span class="n">Response</span> <span class="n">response</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">response</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="n">transformed_data</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Widget</span> <span class="n">widget</span><span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
                      <span class="p">{</span><span class="s">"b"</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
                      <span class="p">{</span><span class="s">"c"</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
                  <span class="p">}};</span>

    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">widget</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">element</span> <span class="o">:</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"title: "</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">.</span><span class="n">title</span> <span class="o">&lt;&lt;</span> <span class="s">", amount "</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">.</span><span class="n">amount</span>
                  <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/*
title: a, amount 42
title: b, amount 84
title: c, amount 42
*/</span>
</pre></table></code></div></div><p><em>Please note that the example is simplified and slightly changed so that it compiles on its own.</em></p><p>Let’s focus on <code class="language-plaintext highlighter-rouge">foo</code>, the rest is there just to make the example compilable.</p><p>It seems that we could use <code class="language-plaintext highlighter-rouge">std::transform</code>. But heck, we use C++20 we have ranges at our hands so let’s go with <code class="language-plaintext highlighter-rouge">std::ranges::transform</code>!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;list&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ranges&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">FromData</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">amount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">FromData</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">ToData</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">amount</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Response</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ToData</span><span class="o">&gt;</span> <span class="n">data</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Response</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Widget</span> <span class="n">widget</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">auto</span> <span class="n">transformed_data</span> <span class="o">=</span> <span class="n">widget</span><span class="p">.</span><span class="n">data</span>
                    <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">transform</span><span class="p">([](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">element</span><span class="p">)</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="n">ToData</span><span class="p">{</span>
                            <span class="p">.</span><span class="n">title</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">title</span><span class="p">,</span>
                            <span class="p">.</span><span class="n">amount</span> <span class="o">=</span> <span class="n">element</span><span class="p">.</span><span class="n">amount</span> <span class="o">*</span> <span class="mi">42</span>
                        <span class="p">};</span>
                    <span class="p">});</span>
    <span class="n">Response</span> <span class="n">response</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">response</span><span class="p">.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">transformed_data</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">transformed_data</span><span class="p">.</span><span class="n">end</span><span class="p">()};</span>

    <span class="k">return</span> <span class="n">response</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Widget</span> <span class="n">widget</span><span class="p">{.</span><span class="n">data</span> <span class="o">=</span> <span class="p">{</span>
                      <span class="p">{</span><span class="s">"a"</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
                      <span class="p">{</span><span class="s">"b"</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span>
                      <span class="p">{</span><span class="s">"c"</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span>
                  <span class="p">}};</span>

    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="n">widget</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">element</span> <span class="o">:</span> <span class="n">r</span><span class="p">.</span><span class="n">data</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"title: "</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">.</span><span class="n">title</span> <span class="o">&lt;&lt;</span> <span class="s">", amount "</span> <span class="o">&lt;&lt;</span> <span class="n">element</span><span class="p">.</span><span class="n">amount</span>
                  <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
title: a, amount 42
title: b, amount 84
title: c, amount 42
*/</span>
</pre></table></code></div></div><p>We have no more raw loops, no more <a href="https://www.sandordargo.com/blog/2020/08/26/effective-stl#what-will-you-learn"><em>initialized then modified</em></a> vectors, and the result is the same.</p><p>Is this better?</p><p>We don’t have to modify a vector that’s definitely better. But when I proposed such a change, one of my colleagues asked a question.</p><p><em><code class="language-plaintext highlighter-rouge">transformed_data</code> became a view. When we populate <code class="language-plaintext highlighter-rouge">response.data</code>, do we actually copy all the elements of the view?</em></p><p>I couldn’t answer the question with confidence, hence this article.</p><p>I slightly updated both examples,and updated <code class="language-plaintext highlighter-rouge">ToData</code> to this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">ToData</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">amount</span><span class="p">;</span>

    <span class="n">ToData</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ToData()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ToData</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">title</span><span class="p">,</span> <span class="kt">int</span> <span class="n">amount</span><span class="p">)</span> <span class="o">:</span> <span class="n">title</span><span class="p">(</span><span class="n">title</span><span class="p">),</span> <span class="n">amount</span><span class="p">(</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ToData(std::string title, int amount)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ToData</span><span class="p">(</span><span class="k">const</span> <span class="n">ToData</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span><span class="o">:</span> <span class="n">title</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">title</span><span class="p">),</span> <span class="n">amount</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">amount</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ToData(const ToData&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ToData</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ToData</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ToData&amp; operator=(const ToData&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">title</span><span class="p">;</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">amount</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ToData</span><span class="p">(</span><span class="n">ToData</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">title</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="s">""</span><span class="p">)),</span>
          <span class="n">amount</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">amount</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ToData(ToData&amp;&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">ToData</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ToData</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ToData&amp; operator=(ToData&amp;&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="n">title</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">title</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
        <span class="n">amount</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">exchange</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">amount</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>I also had to remove the usage of designed initializers as <code class="language-plaintext highlighter-rouge">ToData</code> is no longer an aggregate.</p><p><a href="https://godbolt.org/z/d4cWGYca7">The output for the original version using <code class="language-plaintext highlighter-rouge">push_back</code></a> is not particularly surprising.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre>ToData(std::string title, int amount)
ToData(ToData&amp;&amp; other)
ToData(std::string title, int amount)
ToData(ToData&amp;&amp; other)
ToData(const ToData&amp; other)
ToData(std::string title, int amount)
ToData(ToData&amp;&amp; other)
ToData(const ToData&amp; other)
ToData(const ToData&amp; other)
writing response.data
ToData(const ToData&amp; other)
ToData(const ToData&amp; other)
ToData(const ToData&amp; other)
wrote response.data
title: a, amount 42
title: b, amount 84
title: c, amount 42
</pre></table></code></div></div><p>In the for loop, we construct <code class="language-plaintext highlighter-rouge">ToData</code> and move it, and there is also a copy construction. Before actually copying the data.</p><p>On the other hand, <a href="https://godbolt.org/z/Mbhr7xhx7">for the version using ranges, the output is shorter and different</a>!</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre>filling response.data
ToData(std::string title, int amount)
ToData(ToData&amp;&amp; other)
ToData(std::string title, int amount)
ToData(ToData&amp;&amp; other)
ToData(const ToData&amp; other)
ToData(std::string title, int amount)
ToData(ToData&amp;&amp; other)
ToData(const ToData&amp; other)
ToData(const ToData&amp; other)
filled1 response.data
title: a, amount 42
title: b, amount 84
title: c, amount 42
</pre></table></code></div></div><p>Nothing actually happens within the transformation pipeline! Everything is happening lazily when we use the results of the pipeline and actually construct a <code class="language-plaintext highlighter-rouge">vector</code>. Then we have fewer calls than we had in the original version. Seemingly, far the ranges version has an advantage!</p><p>But we all know that the original version is not optional even with a raw loop. Let’s use <code class="language-plaintext highlighter-rouge">emplace_back</code>! Oh and we also forgot about calling <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;::reserve</code> to avoid reallocations! <a href="https://godbolt.org/z/WMEnE3drP">Here is the code producing the below output.</a></p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>ToData(std::string title, int amount)
ToData(std::string title, int amount)
ToData(std::string title, int amount)
writing response.data
ToData(const ToData&amp; other)
ToData(const ToData&amp; other)
ToData(const ToData&amp; other)
wrote response.data
title: a, amount 42
title: b, amount 84
title: c, amount 42
</pre></table></code></div></div><p>Now the raw loop version has an advantage! In this version, for each item, we have a constructor and a copy while in the ranges version, we also have an extra move!</p><blockquote><p>Note that since C++23, you can also use <code class="language-plaintext highlighter-rouge">std::ranges::to&lt;std::vector&lt;Todata&gt;&gt;</code> to construct the final <code class="language-plaintext highlighter-rouge">vector</code>, but it didn’t result in any difference in terms of the number of special member function calls.</p></blockquote><p>Is that so bad? Probably not. Move operations are cheap, that’s why they were introduced! Probably this is just an acceptable price to pay for more readable code. But our “more readable code” also features a lambda so let’s just say that we have assumptions.</p><p>Let’s also run benchmarks.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/raw_loops_for_performance.png" alt="Benchmarks from QuickBench" /></p><p>Based on <a href="https://quick-bench.com/q/VNAWCklfHw8xikUiWty_YvNe-6Q">Quick Bench</a>, the enhanced raw loop version is about 20% faster on Clang than the raw loop version. The results are slightly different with GCC, but the raw loop version is still 10% faster. It’s also worth noting that the original version with a <code class="language-plaintext highlighter-rouge">push_back</code> and without the <code class="language-plaintext highlighter-rouge">reserve</code> is 20-30% slower than the other two versions! By adding the <code class="language-plaintext highlighter-rouge">reserve</code> but still using <code class="language-plaintext highlighter-rouge">push_back</code>, the code is between the ranges and the raw loop with <code class="language-plaintext highlighter-rouge">emplace_back</code> version.</p><p>What does this mean in real life?</p><p>It depends. You must measure. Don’t forget about <a href="https://en.wikipedia.org/wiki/Amdahl%27s_law">Amdahl’s law</a> which says that <em>“the overall performance improvement gained by optimizing a single part of a system is limited by the fraction of time that the improved part is actually used.”</em></p><p>If this happens to be a bottleneck, use the <code class="language-plaintext highlighter-rouge">emplace_back</code> version without hesitation and don’t forget about reserving enough space in memory for all the elements.</p><p>I think you have no reason to use the <code class="language-plaintext highlighter-rouge">push_back</code> version and definitely not without calling <code class="language-plaintext highlighter-rouge">reserve</code>.</p><p>Otherwise, if you write code where you also do some network calls or read from the database or from the filesystem, these differences are negligible and you should go with the version that you find the most readable.</p><p>That’s up to you.</p><h2 id="conclusion">Conclusion</h2><p>Using ranges or algorithms has <a href="https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms">several advantages over raw loops</a>, notably readability. On the other hand, as we’ve just seen, sheer performance is not necessarily among those advantages. Using ranges can be slightly slower than a raw loop version. But that’s not necessarily a problem, it really depends on your use case. Most probably it won’t make a bit difference.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/ranges/" class="post-tag no-text-decoration" >ranges</a> <a href="/tags/loops/" class="post-tag no-text-decoration" >loops</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Raw loops for performance? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Raw loops for performance? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Raw loops for performance? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Raw loops for performance? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/04/13/first-company-project-experience-with-cpp20"><div class="card-body"> <span class="timeago small" > Apr 13, 2022 <i class="unloaded">2022-04-13T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My first work experience with C++20</h3><div class="text-muted small"><p> I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in...</p></div></div></a></div><div class="card"> <a href="/blog/2025/05/21/cpp23-from-range-constructors"><div class="card-body"> <span class="timeago small" > May 21, 2025 <i class="unloaded">2025-05-21T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Constructing Containers from Ranges in C++23</h3><div class="text-muted small"><p> I’ve written plenty on this blog about standard algorithms, but far less about ranges. That’s mostly because, although I’ve had production-ready compilers with C++20 ranges since late 2021, the ori...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/15/evolution-of-enums"><div class="card-body"> <span class="timeago small" > Feb 15, 2023 <i class="unloaded">2023-02-15T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The evolution of enums</h3><div class="text-muted small"><p> Constants are great. Types are great. Constants of a specific type are really great. This is why enum classes are just fantastic. Last year, we talked about why we should avoid using boolean funct...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/04/09/no-final-mock" class="btn btn-outline-primary" prompt="Older"><p>Should you use final?</p></a> <a href="/blog/2025/04/23/cpp26-constexpr-language-changes" class="btn btn-outline-primary" prompt="Newer"><p>C++26: more constexpr in the core language</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Raw loops for performance?'; this.page.url = 'https://www.sandordargo.com/blog/2025/04/16/raw-loops-for-performance'; this.page.identifier = '/blog/2025/04/16/raw-loops-for-performance'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
