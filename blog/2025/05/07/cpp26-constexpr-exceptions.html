<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++26: constexpr exceptions" /><meta property="og:locale" content="en_US" /><meta name="description" content="In recent weeks, we’ve explored language features and library features becoming constexpr in C++26. Those articles weren’t exhaustive — I deliberately left out one major topic: exceptions. Starting with C++26, it will become possible to throw exceptions during constant evaluation. This capability is enabled through both language and library changes. Given the significance of this feature, it deserves its own dedicated post. P3068R6: Allowing exception throwing in constant-evaluation The proposal for static reflection suggested allowing exceptions in constant-evaluated code, and P3068R6 brings that feature to life. constexpr exceptions are conceptually similar to constexpr allocations. Just as a constexpr string can’t escape constant evaluation and reach runtime, constexpr exceptions also have to remain within compile-time code. Previously, using throw in a constexpr context caused a compilation error. With C++26, such code can now compile — unless an exception is actually thrown and left uncaught, in which case a compile-time error is still issued. But the error now provides more meaningful diagnostics. While no compiler supports this at the time of writing, we can walk through an example from the proposal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 constexpr unsigned divide(unsigned n, unsigned d) { if (d == 0u) { throw invalid_argument{&quot;division by zero&quot;}; } return n / d; } // 1) constexpr auto b = divide(5, 0); // BEFORE: compilation error due reaching a throw expression // AFTER: still a compilation error but due the uncaught exception constexpr std::optional&lt;unsigned&gt; checked_divide(unsigned n, unsigned d) { try { return divide(n, d); } catch (...) { return std::nullopt; } } // 2) constexpr auto a = checked_divide(5, 0); // BEFORE: compilation error // AFTER: std::nullopt value In example 1), divide(5, 0) throws at compile time, but since the exception is uncaught, we get a compile-time error. In example 2), checked_divide catches the exception and returns a valid value — std::nullopt. This is now allowed in constant expressions. This opens up more expressive compile-time code with proper error handling paths. Can’t wait to see this in action! P3378R2: constexpr exception types Allowing exceptions in constexpr code is great — but without constexpr-enabled exception types, the usefulness would be limited. P3378R2, authored by Hana Dusíková, brings over a dozen exception types into the constexpr world. The paper is quite readable once you’ve wrapped your head around constexpr exception throwing. Here are some key takeaways: It doesn’t yet propose making all exception types constexpr, but that is the long-term goal. Future proposals involving constexpr functionality should ensure any associated exceptions are constexpr-friendly. Even std::runtime_error becomes constexpr, which is notable because it’s a common base class for many derived exceptions like std::out_of_range. Here is the list of exception types becoming constexpr-friendly: std::logic_error std::domain_error std::invalid_argument std::length_error std::out_of_range std::runtime_error std::range_error std::overflow_error std::underflow_error std::bad_optional_access std::bad_variant_access std::bad_expected_access std::format_error Conclusion C++26 is taking another big step forward in making compile-time programming more powerful and expressive. With the ability to throw and catch exceptions during constant evaluation — and with many standard exception types gaining constexpr support — developers will be able to write safer, more robust code that’s fully evaluable at compile time. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In recent weeks, we’ve explored language features and library features becoming constexpr in C++26. Those articles weren’t exhaustive — I deliberately left out one major topic: exceptions. Starting with C++26, it will become possible to throw exceptions during constant evaluation. This capability is enabled through both language and library changes. Given the significance of this feature, it deserves its own dedicated post. P3068R6: Allowing exception throwing in constant-evaluation The proposal for static reflection suggested allowing exceptions in constant-evaluated code, and P3068R6 brings that feature to life. constexpr exceptions are conceptually similar to constexpr allocations. Just as a constexpr string can’t escape constant evaluation and reach runtime, constexpr exceptions also have to remain within compile-time code. Previously, using throw in a constexpr context caused a compilation error. With C++26, such code can now compile — unless an exception is actually thrown and left uncaught, in which case a compile-time error is still issued. But the error now provides more meaningful diagnostics. While no compiler supports this at the time of writing, we can walk through an example from the proposal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 constexpr unsigned divide(unsigned n, unsigned d) { if (d == 0u) { throw invalid_argument{&quot;division by zero&quot;}; } return n / d; } // 1) constexpr auto b = divide(5, 0); // BEFORE: compilation error due reaching a throw expression // AFTER: still a compilation error but due the uncaught exception constexpr std::optional&lt;unsigned&gt; checked_divide(unsigned n, unsigned d) { try { return divide(n, d); } catch (...) { return std::nullopt; } } // 2) constexpr auto a = checked_divide(5, 0); // BEFORE: compilation error // AFTER: std::nullopt value In example 1), divide(5, 0) throws at compile time, but since the exception is uncaught, we get a compile-time error. In example 2), checked_divide catches the exception and returns a valid value — std::nullopt. This is now allowed in constant expressions. This opens up more expressive compile-time code with proper error handling paths. Can’t wait to see this in action! P3378R2: constexpr exception types Allowing exceptions in constexpr code is great — but without constexpr-enabled exception types, the usefulness would be limited. P3378R2, authored by Hana Dusíková, brings over a dozen exception types into the constexpr world. The paper is quite readable once you’ve wrapped your head around constexpr exception throwing. Here are some key takeaways: It doesn’t yet propose making all exception types constexpr, but that is the long-term goal. Future proposals involving constexpr functionality should ensure any associated exceptions are constexpr-friendly. Even std::runtime_error becomes constexpr, which is notable because it’s a common base class for many derived exceptions like std::out_of_range. Here is the list of exception types becoming constexpr-friendly: std::logic_error std::domain_error std::invalid_argument std::length_error std::out_of_range std::runtime_error std::range_error std::overflow_error std::underflow_error std::bad_optional_access std::bad_variant_access std::bad_expected_access std::format_error Conclusion C++26 is taking another big step forward in making compile-time programming more powerful and expressive. With the ability to throw and catch exceptions during constant evaluation — and with many standard exception types gaining constexpr support — developers will be able to write safer, more robust code that’s fully evaluable at compile time. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-05-07T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++26: constexpr exceptions" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-05-07T00:00:00+02:00","datePublished":"2025-05-07T00:00:00+02:00","description":"In recent weeks, we’ve explored language features and library features becoming constexpr in C++26. Those articles weren’t exhaustive — I deliberately left out one major topic: exceptions. Starting with C++26, it will become possible to throw exceptions during constant evaluation. This capability is enabled through both language and library changes. Given the significance of this feature, it deserves its own dedicated post. P3068R6: Allowing exception throwing in constant-evaluation The proposal for static reflection suggested allowing exceptions in constant-evaluated code, and P3068R6 brings that feature to life. constexpr exceptions are conceptually similar to constexpr allocations. Just as a constexpr string can’t escape constant evaluation and reach runtime, constexpr exceptions also have to remain within compile-time code. Previously, using throw in a constexpr context caused a compilation error. With C++26, such code can now compile — unless an exception is actually thrown and left uncaught, in which case a compile-time error is still issued. But the error now provides more meaningful diagnostics. While no compiler supports this at the time of writing, we can walk through an example from the proposal: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 constexpr unsigned divide(unsigned n, unsigned d) { if (d == 0u) { throw invalid_argument{&quot;division by zero&quot;}; } return n / d; } // 1) constexpr auto b = divide(5, 0); // BEFORE: compilation error due reaching a throw expression // AFTER: still a compilation error but due the uncaught exception constexpr std::optional&lt;unsigned&gt; checked_divide(unsigned n, unsigned d) { try { return divide(n, d); } catch (...) { return std::nullopt; } } // 2) constexpr auto a = checked_divide(5, 0); // BEFORE: compilation error // AFTER: std::nullopt value In example 1), divide(5, 0) throws at compile time, but since the exception is uncaught, we get a compile-time error. In example 2), checked_divide catches the exception and returns a valid value — std::nullopt. This is now allowed in constant expressions. This opens up more expressive compile-time code with proper error handling paths. Can’t wait to see this in action! P3378R2: constexpr exception types Allowing exceptions in constexpr code is great — but without constexpr-enabled exception types, the usefulness would be limited. P3378R2, authored by Hana Dusíková, brings over a dozen exception types into the constexpr world. The paper is quite readable once you’ve wrapped your head around constexpr exception throwing. Here are some key takeaways: It doesn’t yet propose making all exception types constexpr, but that is the long-term goal. Future proposals involving constexpr functionality should ensure any associated exceptions are constexpr-friendly. Even std::runtime_error becomes constexpr, which is notable because it’s a common base class for many derived exceptions like std::out_of_range. Here is the list of exception types becoming constexpr-friendly: std::logic_error std::domain_error std::invalid_argument std::length_error std::out_of_range std::runtime_error std::range_error std::overflow_error std::underflow_error std::bad_optional_access std::bad_variant_access std::bad_expected_access std::format_error Conclusion C++26 is taking another big step forward in making compile-time programming more powerful and expressive. With the ability to throw and catch exceptions during constant evaluation — and with many standard exception types gaining constexpr support — developers will be able to write safer, more robust code that’s fully evaluable at compile time. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++26: constexpr exceptions","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions"},"url":"https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions"}</script><title>C++26: constexpr exceptions | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/07"> 07 </a> </span> <span>C++26: constexpr exceptions</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++26: constexpr exceptions</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 7, 2025, 12:00 AM +0200" prep="on" > May 7 <i class="unloaded">2025-05-07T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="547 words">3 min</span></div></div><div class="post-content"><p>In recent weeks, we’ve explored <a href="https://www.sandordargo.com/blog/2025/04/23/cpp26-constexpr-language-changes">language features</a> and <a href="https://www.sandordargo.com/blog/2025/04/30/cpp26-constexpr-library-changes">library features</a> becoming <code class="language-plaintext highlighter-rouge">constexpr</code> in C++26. Those articles weren’t exhaustive — I deliberately left out one major topic: exceptions.</p><p>Starting with C++26, it will become possible to throw exceptions during constant evaluation. This capability is enabled through both language and library changes. Given the significance of this feature, it deserves its own dedicated post.</p><h2 id="p3068r6-allowing-exception-throwing-in-constant-evaluation"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r6.html">P3068R6</a>: Allowing exception throwing in constant-evaluation</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2996r2.html">The proposal for static reflection</a> suggested allowing exceptions in constant-evaluated code, and <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p3068r6.html">P3068R6</a> brings that feature to life.</p><p><code class="language-plaintext highlighter-rouge">constexpr</code> exceptions are conceptually similar to <code class="language-plaintext highlighter-rouge">constexpr</code> allocations. Just as a <code class="language-plaintext highlighter-rouge">constexpr string</code> can’t escape constant evaluation and reach runtime, <code class="language-plaintext highlighter-rouge">constexpr</code> exceptions also have to remain within compile-time code.</p><p>Previously, using <code class="language-plaintext highlighter-rouge">throw</code> in a <code class="language-plaintext highlighter-rouge">constexpr</code> context caused a compilation error. With C++26, such code can now compile — unless an exception is actually thrown and left uncaught, in which case a compile-time error is still issued. But the error now provides more meaningful diagnostics.</p><p>While no compiler supports this at the time of writing, we can walk through an example from the proposal:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="kt">unsigned</span> <span class="nf">divide</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">if</span> <span class="p">(</span><span class="n">d</span> <span class="o">==</span> <span class="mi">0u</span><span class="p">)</span> <span class="p">{</span>
		<span class="k">throw</span> <span class="n">invalid_argument</span><span class="p">{</span><span class="s">"division by zero"</span><span class="p">};</span>
	<span class="p">}</span>
	<span class="k">return</span> <span class="n">n</span> <span class="o">/</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// 1)</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">divide</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// BEFORE: compilation error due reaching a throw expression</span>
								 <span class="c1">// AFTER: still a compilation error but due the uncaught exception</span>

<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span> <span class="n">checked_divide</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">n</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">try</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">divide</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
	<span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
		<span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// 2)</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="n">checked_divide</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span> <span class="c1">// BEFORE: compilation error</span>
									     <span class="c1">// AFTER: std::nullopt value</span>
</pre></table></code></div></div><p>In example <code class="language-plaintext highlighter-rouge">1)</code>, <code class="language-plaintext highlighter-rouge">divide(5, 0)</code> throws at compile time, but since the exception is uncaught, we get a compile-time error. In example <code class="language-plaintext highlighter-rouge">2)</code>, <code class="language-plaintext highlighter-rouge">checked_divide</code> catches the exception and returns a valid value — <code class="language-plaintext highlighter-rouge">std::nullopt</code>. This is now allowed in constant expressions.</p><p>This opens up more expressive compile-time code with proper error handling paths. Can’t wait to see this in action!</p><h2 id="p3378r2-constexpr-exception-types"><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3378r2.html">P3378R2</a>: <code class="language-plaintext highlighter-rouge">constexpr</code> exception types</h2><p>Allowing exceptions in <code class="language-plaintext highlighter-rouge">constexpr</code> code is great — but without <code class="language-plaintext highlighter-rouge">constexpr</code>-enabled exception types, the usefulness would be limited. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p3378r2.html">P3378R2</a>, authored by Hana Dusíková, brings over a dozen exception types into the constexpr world.</p><p>The paper is quite readable once you’ve wrapped your head around <code class="language-plaintext highlighter-rouge">constexpr</code> exception throwing. Here are some key takeaways:</p><ul><li>It doesn’t yet propose making all exception types <code class="language-plaintext highlighter-rouge">constexpr</code>, but that is the long-term goal.<li>Future proposals involving <code class="language-plaintext highlighter-rouge">constexpr</code> functionality should ensure any associated exceptions are <code class="language-plaintext highlighter-rouge">constexpr</code>-friendly.<li>Even <code class="language-plaintext highlighter-rouge">std::runtime_error</code> becomes constexpr, which is notable because it’s a common base class for many derived exceptions like <code class="language-plaintext highlighter-rouge">std::out_of_range</code>.</ul><p>Here is the list of exception types becoming <code class="language-plaintext highlighter-rouge">constexpr</code>-friendly:</p><ul><li><code class="language-plaintext highlighter-rouge">std::logic_error</code><li><code class="language-plaintext highlighter-rouge">std::domain_error</code><li><code class="language-plaintext highlighter-rouge">std::invalid_argument</code><li><code class="language-plaintext highlighter-rouge">std::length_error</code><li><code class="language-plaintext highlighter-rouge">std::out_of_range</code><li><code class="language-plaintext highlighter-rouge">std::runtime_error</code><li><code class="language-plaintext highlighter-rouge">std::range_error</code><li><code class="language-plaintext highlighter-rouge">std::overflow_error</code><li><code class="language-plaintext highlighter-rouge">std::underflow_error</code><li><code class="language-plaintext highlighter-rouge">std::bad_optional_access</code><li><code class="language-plaintext highlighter-rouge">std::bad_variant_access</code><li><code class="language-plaintext highlighter-rouge">std::bad_expected_access</code><li><code class="language-plaintext highlighter-rouge">std::format_error</code></ul><h2 id="conclusion">Conclusion</h2><p>C++26 is taking another big step forward in making compile-time programming more powerful and expressive. With the ability to <code class="language-plaintext highlighter-rouge">throw</code> and <code class="language-plaintext highlighter-rouge">catch</code> exceptions during constant evaluation — and with many standard exception types gaining <code class="language-plaintext highlighter-rouge">constexpr</code> support — developers will be able to write safer, more robust code that’s fully evaluable at compile time.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp26/" class="post-tag no-text-decoration" >cpp26</a> <a href="/tags/constexpr/" class="post-tag no-text-decoration" >constexpr</a> <a href="/tags/standardlibrary/" class="post-tag no-text-decoration" >standardlibrary</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++26: constexpr exceptions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++26: constexpr exceptions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++26: constexpr exceptions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++26: constexpr exceptions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/04/30/cpp26-constexpr-library-changes"><div class="card-body"> <span class="timeago small" > Apr 30 <i class="unloaded">2025-04-30T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: more constexpr in the standard library</h3><div class="text-muted small"><p> Last week, we discussed language features that are becoming constexpr in C++26. Today, let’s turn our attention to the standard library features that will soon be usable at compile time. One topic ...</p></div></div></a></div><div class="card"> <a href="/blog/2025/04/23/cpp26-constexpr-language-changes"><div class="card-body"> <span class="timeago small" > Apr 23 <i class="unloaded">2025-04-23T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: more constexpr in the core language</h3><div class="text-muted small"><p> Since constexpr was added to the language in C++11, its scope has been gradually expanded. In the beginning, we couldn’t even use if, else or loops, which were changed in C++14. C++17 added support...</p></div></div></a></div><div class="card"> <a href="/blog/2024/01/03/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Jan 3, 2024 <i class="unloaded">2024-01-03T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/04/30/cpp26-constexpr-library-changes" class="btn btn-outline-primary" prompt="Older"><p>C++26: more constexpr in the standard library</p></a> <a href="/blog/2025/05/14/friend-self" class="btn btn-outline-primary" prompt="Newer"><p>Declaring a friendship to self</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++26: constexpr exceptions'; this.page.url = 'https://www.sandordargo.com/blog/2025/05/07/cpp26-constexpr-exceptions'; this.page.identifier = '/blog/2025/05/07/cpp26-constexpr-exceptions'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
