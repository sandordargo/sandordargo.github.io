<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="How to look up values in a map" /><meta property="og:locale" content="en_US" /><meta name="description" content="Whether you’re in a coding interview or writing production code, you’ll eventually face the question: What’s the right way to look up values in a std::map or std::unordered_map? For simplicity, we’ll refer to both containers as maps in this post. Let’s explore the different options — along with their pros and cons. operator[] Using operator[] is the old-fashioned way to access elements of a map. It takes a key and returns a reference to the corresponding value. The complexity is log(n) for std::map and average constant time (with worst-case linear) for std::unordered_map. However, there’s a big caveat. What if the key is not present in the map? Unlike a vector — where accessing an invalid index with operator[] leads to undefined behavior — a map will instead insert a new entry with the given key and a default-constructed value. This side effect makes operator[] unsafe for lookups where insertion is not desired. That’s also why you can’t use operator[] on a const map: 1 2 3 4 5 6 #include &lt;map&gt; int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; return squares[2]; // ERROR: passing &#39;const std::map&lt;int, int&gt;&#39; as &#39;this&#39; argument discards qualifiers } Too bad. We need an alternative! at() The at() method comes in rescue. Like operator[], it provides efficient access, but unlike operator[], it never inserts a new element. Instead, it throws a std::out_of_range exception if the key is not found. That makes it suitable for use with const maps: 1 2 3 4 5 6 #include &lt;map&gt; int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; return squares.at(2); } To use at() safely, we either have to ensure that the key is present or wrap the lookup in a try-catch block. Look at these two wrappers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;map&gt; #include &lt;optional&gt; #include &lt;stdexcept&gt; std::optional&lt;int&gt; lookupAtContains(const std::map&lt;int, int&gt; &amp;map, int key) { if (map.contains(key)) { return map.at(key); } return std::nullopt; } std::optional&lt;int&gt; lookupAtTryCatch(const std::map&lt;int, int&gt; &amp;map, int key) { try { return map.at(key); } catch (const std::out_of_range&amp; err) { return std::nullopt; } } Both are safe to use, and both have some downsides. The first one, lookupAtContains, is not thread-safe. What if the key is removed between the contains() and the at() calls? But maybe, we don’t have such requirements. The other problem is efficiency. The key is looked up twice. By the way, such a lookup wrapper can be used with operator[] as well. Though in case of problems, I think an uncaught exception is still better than undefined behaviour. The downside of the second alternative is the use of exceptions. Maybe you don’t allow them in your codebase. Maybe you’re worried about the performance penalties. You might say that exceptions are a zero cost abstraction if they are not called. But that’s not entirely true. They have zero cost only at runtime. At compile-time, you have to pay for generating the necessary information to deal with exceptions. Besides, not finding a key in a map is clearly not an exceptional case. std::find Yet another option is to use the find() method. 1 2 3 4 5 int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; auto maybe_entry = squares.find(2); return maybe_entry != squares.end() ? maybe_entry-&gt;second : -1; } It’s great that it works on const containers, but it’s simply ugly. You get back an iterator to the entry with the key if the key is present or an iterator pointing past the end of the container if the key is not present. Then deal with it. We really need a wrapper with this solution. 1 2 3 4 5 6 7 std::optional&lt;int&gt; lookupFind(const std::map&lt;int, int&gt; &amp;map, int key) { auto maybe_entry = map.find(key); if (maybe_entry == map.end()) { return std::nullopt; } return maybe_entry-&gt;second; } This still has the problem of thread-safety, but that might not be a problem if you work with a single thread. On the bright side, now we look up the key only once! But this solution really needs a wrapper if we want to use it in a readable way. Is double lookup really an issue? It depends. There’s definitely a performance hit when using contains() followed by at(). Benchmarks show that lookupAtContains is around 60% slower than lookupFind when the key is present: Even worse, lookupAtTryCatch is orders of magnitude slower when the key is missing, due to exception overhead: That said, the performance hit of the double lookup only matters when this code runs in a hot path. In most applications, the difference will be negligible compared to other bottlenecks - such as exception handling, I/O, etc. Choose clarity over premature optimization — unless you’re in performance - critical territory. Conclusion Looking up values in a map isn’t as trivial as it seems. Here’s a summary of your choices: Use operator[] if you want insertion on missing keys and you’re not dealing with const maps. Use at() for safe, non-inserting access — especially with const maps — but be mindful of exceptions. Use find() for full control and better performance — at the cost of a more verbose syntax. If you’re building a utility or reusable component, wrapping find() in a helper like lookupFind() strikes the best balance between safety, performance, and clarity. Ultimately, pick the approach that fits your context — readability, performance, and codebase conventions all matter. Which one do you use most often — and why? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><meta property="og:description" content="Whether you’re in a coding interview or writing production code, you’ll eventually face the question: What’s the right way to look up values in a std::map or std::unordered_map? For simplicity, we’ll refer to both containers as maps in this post. Let’s explore the different options — along with their pros and cons. operator[] Using operator[] is the old-fashioned way to access elements of a map. It takes a key and returns a reference to the corresponding value. The complexity is log(n) for std::map and average constant time (with worst-case linear) for std::unordered_map. However, there’s a big caveat. What if the key is not present in the map? Unlike a vector — where accessing an invalid index with operator[] leads to undefined behavior — a map will instead insert a new entry with the given key and a default-constructed value. This side effect makes operator[] unsafe for lookups where insertion is not desired. That’s also why you can’t use operator[] on a const map: 1 2 3 4 5 6 #include &lt;map&gt; int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; return squares[2]; // ERROR: passing &#39;const std::map&lt;int, int&gt;&#39; as &#39;this&#39; argument discards qualifiers } Too bad. We need an alternative! at() The at() method comes in rescue. Like operator[], it provides efficient access, but unlike operator[], it never inserts a new element. Instead, it throws a std::out_of_range exception if the key is not found. That makes it suitable for use with const maps: 1 2 3 4 5 6 #include &lt;map&gt; int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; return squares.at(2); } To use at() safely, we either have to ensure that the key is present or wrap the lookup in a try-catch block. Look at these two wrappers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;map&gt; #include &lt;optional&gt; #include &lt;stdexcept&gt; std::optional&lt;int&gt; lookupAtContains(const std::map&lt;int, int&gt; &amp;map, int key) { if (map.contains(key)) { return map.at(key); } return std::nullopt; } std::optional&lt;int&gt; lookupAtTryCatch(const std::map&lt;int, int&gt; &amp;map, int key) { try { return map.at(key); } catch (const std::out_of_range&amp; err) { return std::nullopt; } } Both are safe to use, and both have some downsides. The first one, lookupAtContains, is not thread-safe. What if the key is removed between the contains() and the at() calls? But maybe, we don’t have such requirements. The other problem is efficiency. The key is looked up twice. By the way, such a lookup wrapper can be used with operator[] as well. Though in case of problems, I think an uncaught exception is still better than undefined behaviour. The downside of the second alternative is the use of exceptions. Maybe you don’t allow them in your codebase. Maybe you’re worried about the performance penalties. You might say that exceptions are a zero cost abstraction if they are not called. But that’s not entirely true. They have zero cost only at runtime. At compile-time, you have to pay for generating the necessary information to deal with exceptions. Besides, not finding a key in a map is clearly not an exceptional case. std::find Yet another option is to use the find() method. 1 2 3 4 5 int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; auto maybe_entry = squares.find(2); return maybe_entry != squares.end() ? maybe_entry-&gt;second : -1; } It’s great that it works on const containers, but it’s simply ugly. You get back an iterator to the entry with the key if the key is present or an iterator pointing past the end of the container if the key is not present. Then deal with it. We really need a wrapper with this solution. 1 2 3 4 5 6 7 std::optional&lt;int&gt; lookupFind(const std::map&lt;int, int&gt; &amp;map, int key) { auto maybe_entry = map.find(key); if (maybe_entry == map.end()) { return std::nullopt; } return maybe_entry-&gt;second; } This still has the problem of thread-safety, but that might not be a problem if you work with a single thread. On the bright side, now we look up the key only once! But this solution really needs a wrapper if we want to use it in a readable way. Is double lookup really an issue? It depends. There’s definitely a performance hit when using contains() followed by at(). Benchmarks show that lookupAtContains is around 60% slower than lookupFind when the key is present: Even worse, lookupAtTryCatch is orders of magnitude slower when the key is missing, due to exception overhead: That said, the performance hit of the double lookup only matters when this code runs in a hot path. In most applications, the difference will be negligible compared to other bottlenecks - such as exception handling, I/O, etc. Choose clarity over premature optimization — unless you’re in performance - critical territory. Conclusion Looking up values in a map isn’t as trivial as it seems. Here’s a summary of your choices: Use operator[] if you want insertion on missing keys and you’re not dealing with const maps. Use at() for safe, non-inserting access — especially with const maps — but be mindful of exceptions. Use find() for full control and better performance — at the cost of a more verbose syntax. If you’re building a utility or reusable component, wrapping find() in a helper like lookupFind() strikes the best balance between safety, performance, and clarity. Ultimately, pick the approach that fits your context — readability, performance, and codebase conventions all matter. Which one do you use most often — and why? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-08-27T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="How to look up values in a map" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-27T00:00:00+02:00","datePublished":"2025-08-27T00:00:00+02:00","description":"Whether you’re in a coding interview or writing production code, you’ll eventually face the question: What’s the right way to look up values in a std::map or std::unordered_map? For simplicity, we’ll refer to both containers as maps in this post. Let’s explore the different options — along with their pros and cons. operator[] Using operator[] is the old-fashioned way to access elements of a map. It takes a key and returns a reference to the corresponding value. The complexity is log(n) for std::map and average constant time (with worst-case linear) for std::unordered_map. However, there’s a big caveat. What if the key is not present in the map? Unlike a vector — where accessing an invalid index with operator[] leads to undefined behavior — a map will instead insert a new entry with the given key and a default-constructed value. This side effect makes operator[] unsafe for lookups where insertion is not desired. That’s also why you can’t use operator[] on a const map: 1 2 3 4 5 6 #include &lt;map&gt; int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; return squares[2]; // ERROR: passing &#39;const std::map&lt;int, int&gt;&#39; as &#39;this&#39; argument discards qualifiers } Too bad. We need an alternative! at() The at() method comes in rescue. Like operator[], it provides efficient access, but unlike operator[], it never inserts a new element. Instead, it throws a std::out_of_range exception if the key is not found. That makes it suitable for use with const maps: 1 2 3 4 5 6 #include &lt;map&gt; int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; return squares.at(2); } To use at() safely, we either have to ensure that the key is present or wrap the lookup in a try-catch block. Look at these two wrappers: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;map&gt; #include &lt;optional&gt; #include &lt;stdexcept&gt; std::optional&lt;int&gt; lookupAtContains(const std::map&lt;int, int&gt; &amp;map, int key) { if (map.contains(key)) { return map.at(key); } return std::nullopt; } std::optional&lt;int&gt; lookupAtTryCatch(const std::map&lt;int, int&gt; &amp;map, int key) { try { return map.at(key); } catch (const std::out_of_range&amp; err) { return std::nullopt; } } Both are safe to use, and both have some downsides. The first one, lookupAtContains, is not thread-safe. What if the key is removed between the contains() and the at() calls? But maybe, we don’t have such requirements. The other problem is efficiency. The key is looked up twice. By the way, such a lookup wrapper can be used with operator[] as well. Though in case of problems, I think an uncaught exception is still better than undefined behaviour. The downside of the second alternative is the use of exceptions. Maybe you don’t allow them in your codebase. Maybe you’re worried about the performance penalties. You might say that exceptions are a zero cost abstraction if they are not called. But that’s not entirely true. They have zero cost only at runtime. At compile-time, you have to pay for generating the necessary information to deal with exceptions. Besides, not finding a key in a map is clearly not an exceptional case. std::find Yet another option is to use the find() method. 1 2 3 4 5 int main() { const std::map&lt;int, int&gt; squares{ {1, 1}, {2, 4}, {3, 3} }; auto maybe_entry = squares.find(2); return maybe_entry != squares.end() ? maybe_entry-&gt;second : -1; } It’s great that it works on const containers, but it’s simply ugly. You get back an iterator to the entry with the key if the key is present or an iterator pointing past the end of the container if the key is not present. Then deal with it. We really need a wrapper with this solution. 1 2 3 4 5 6 7 std::optional&lt;int&gt; lookupFind(const std::map&lt;int, int&gt; &amp;map, int key) { auto maybe_entry = map.find(key); if (maybe_entry == map.end()) { return std::nullopt; } return maybe_entry-&gt;second; } This still has the problem of thread-safety, but that might not be a problem if you work with a single thread. On the bright side, now we look up the key only once! But this solution really needs a wrapper if we want to use it in a readable way. Is double lookup really an issue? It depends. There’s definitely a performance hit when using contains() followed by at(). Benchmarks show that lookupAtContains is around 60% slower than lookupFind when the key is present: Even worse, lookupAtTryCatch is orders of magnitude slower when the key is missing, due to exception overhead: That said, the performance hit of the double lookup only matters when this code runs in a hot path. In most applications, the difference will be negligible compared to other bottlenecks - such as exception handling, I/O, etc. Choose clarity over premature optimization — unless you’re in performance - critical territory. Conclusion Looking up values in a map isn’t as trivial as it seems. Here’s a summary of your choices: Use operator[] if you want insertion on missing keys and you’re not dealing with const maps. Use at() for safe, non-inserting access — especially with const maps — but be mindful of exceptions. Use find() for full control and better performance — at the cost of a more verbose syntax. If you’re building a utility or reusable component, wrapping find() in a helper like lookupFind() strikes the best balance between safety, performance, and clarity. Ultimately, pick the approach that fits your context — readability, performance, and codebase conventions all matter. Which one do you use most often — and why? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter","headline":"How to look up values in a map","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map"},"url":"https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map"}</script><title>How to look up values in a map | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/08"> 08 </a> </span> <span> <a href="/27"> 27 </a> </span> <span>How to look up values in a map</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>How to look up values in a map</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 27, 2025, 12:00 AM +0200" prep="on" > Aug 27, 2025 <i class="unloaded">2025-08-27T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="939 words">5 min</span></div></div><div class="post-content"><p>Whether you’re in a coding interview or writing production code, you’ll eventually face the question: <em>What’s the right way to look up values in a <code class="language-plaintext highlighter-rouge">std::map</code> or <code class="language-plaintext highlighter-rouge">std::unordered_map</code>?</em> For simplicity, we’ll refer to both containers as <em>maps</em> in this post.</p><p>Let’s explore the different options — along with their pros and cons.</p><h2 id="operator"><code class="language-plaintext highlighter-rouge">operator[]</code></h2><p>Using <code class="language-plaintext highlighter-rouge">operator[]</code> is the old-fashioned way to access elements of a map. It takes a key and returns a reference to the corresponding value. The complexity is <em>log(n)</em> for <code class="language-plaintext highlighter-rouge">std::map</code> and <em>average constant time</em> (with worst-case linear) for <code class="language-plaintext highlighter-rouge">std::unordered_map</code>.</p><p>However, there’s a big caveat.</p><p>What if the key is not present in the map?</p><p>Unlike a <code class="language-plaintext highlighter-rouge">vector</code> — where accessing an invalid index with <code class="language-plaintext highlighter-rouge">operator[]</code> leads to undefined behavior — a <code class="language-plaintext highlighter-rouge">map</code> will instead insert a new entry with the given key and a default-constructed value. This side effect makes <code class="language-plaintext highlighter-rouge">operator[]</code> unsafe for lookups where insertion is not desired.</p><p>That’s also why you <strong>can’t use <code class="language-plaintext highlighter-rouge">operator[]</code> on a <code class="language-plaintext highlighter-rouge">const</code> map</strong>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">squares</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">};</span>
    <span class="k">return</span> <span class="n">squares</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span> <span class="c1">// ERROR: passing 'const std::map&lt;int, int&gt;' as 'this' argument discards qualifiers</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Too bad. We need an alternative!</p><h2 id="at"><code class="language-plaintext highlighter-rouge">at()</code></h2><p>The <code class="language-plaintext highlighter-rouge">at()</code> method comes in rescue. Like <code class="language-plaintext highlighter-rouge">operator[]</code>, it provides efficient access, but unlike <code class="language-plaintext highlighter-rouge">operator[]</code>, it never inserts a new element. Instead, it throws a <code class="language-plaintext highlighter-rouge">std::out_of_range</code> exception if the key is not found. That makes it suitable for use with const maps:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">squares</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">};</span>
    <span class="k">return</span> <span class="n">squares</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To use <code class="language-plaintext highlighter-rouge">at()</code> safely, we either have to ensure that the key is present or wrap the lookup in a try-catch block.</p><p>Look at these two wrappers:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stdexcept&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lookupAtContains</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">map</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">key</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
<span class="p">}</span> 

<span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lookupAtTryCatch</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">try</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">map</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">out_of_range</span><span class="o">&amp;</span> <span class="n">err</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Both are safe to use, and both have some downsides.</p><p>The first one, <code class="language-plaintext highlighter-rouge">lookupAtContains</code>, is not thread-safe. What if the key is removed between the <code class="language-plaintext highlighter-rouge">contains()</code> and the <code class="language-plaintext highlighter-rouge">at()</code> calls? But maybe, we don’t have such requirements. The other problem is efficiency. The key is looked up twice. By the way, such a lookup wrapper can be used with <code class="language-plaintext highlighter-rouge">operator[]</code> as well. Though in case of problems, I think an uncaught exception is still better than undefined behaviour.</p><p>The downside of the second alternative is the use of exceptions. Maybe you don’t allow them in your codebase. Maybe you’re worried about the performance penalties. You might say that exceptions are a zero cost abstraction if they are not called. But that’s not entirely true. <a href="https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions">They have zero cost only at runtime</a>. At compile-time, you have to pay for generating the necessary information to deal with exceptions. Besides, not finding a key in a map is clearly not an exceptional case.</p><h2 id="stdfind"><code class="language-plaintext highlighter-rouge">std::find</code></h2><p>Yet another option is to use the <code class="language-plaintext highlighter-rouge">find()</code> method.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">squares</span><span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">maybe_entry</span> <span class="o">=</span> <span class="n">squares</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">maybe_entry</span> <span class="o">!=</span> <span class="n">squares</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="n">maybe_entry</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s great that it works on <code class="language-plaintext highlighter-rouge">const</code> containers, but it’s simply ugly. You get back an iterator to the entry with the key if the key is present or an iterator pointing past the end of the container if the key is not present. Then deal with it.</p><p>We really need a wrapper with this solution.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">lookupFind</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">map</span><span class="p">,</span> <span class="kt">int</span> <span class="n">key</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">maybe_entry</span> <span class="o">=</span> <span class="n">map</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">key</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">maybe_entry</span> <span class="o">==</span> <span class="n">map</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maybe_entry</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This still has the problem of thread-safety, but that might not be a problem if you work with a single thread.</p><p>On the bright side, now we look up the key only once! But this solution really needs a wrapper if we want to use it in a readable way.</p><h2 id="is-double-lookup-really-an-issue">Is double lookup really an issue?</h2><p>It depends. There’s definitely a performance hit when using <code class="language-plaintext highlighter-rouge">contains()</code> followed by <code class="language-plaintext highlighter-rouge">at()</code>. <a href="https://quick-bench.com/q/WVRxStqOIsYWYlDHuTLixa34bYU">Benchmarks</a> show that <code class="language-plaintext highlighter-rouge">lookupAtContains</code> is around 60% slower than lookupFind when the key is present:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/lookup_key_found.png" alt="Performance comparison when key found" /></p><p>Even worse, <code class="language-plaintext highlighter-rouge">lookupAtTryCatch</code> is <a href="https://quick-bench.com/q/2CtXkOZPw1u6pMb8sLJRPyhNOhE">orders of magnitude slower</a> when the key is missing, due to exception overhead:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/lookup_key_not_found.png" alt="Performance comparison when key not found" /></p><p>That said, the performance hit of the double lookup only matters when this code runs in a hot path. In most applications, the difference will be negligible compared to other bottlenecks - such as exception handling, I/O, etc. Choose clarity over premature optimization — unless you’re in performance - critical territory.</p><h2 id="conclusion">Conclusion</h2><p>Looking up values in a <code class="language-plaintext highlighter-rouge">map</code> isn’t as trivial as it seems. Here’s a summary of your choices:</p><ul><li>Use <code class="language-plaintext highlighter-rouge">operator[]</code> if you want insertion on missing keys and you’re not dealing with const maps.<li>Use <code class="language-plaintext highlighter-rouge">at()</code> for safe, non-inserting access — especially with <code class="language-plaintext highlighter-rouge">const</code> maps — but be mindful of exceptions.<li>Use <code class="language-plaintext highlighter-rouge">find()</code> for full control and better performance — at the cost of a more verbose syntax. If you’re building a utility or reusable component, wrapping <code class="language-plaintext highlighter-rouge">find()</code> in a helper like <code class="language-plaintext highlighter-rouge">lookupFind()</code> strikes the best balance between safety, performance, and clarity.</ul><p>Ultimately, pick the approach that fits your context — readability, performance, and codebase conventions all matter.</p><p>Which one do you use most often — and why?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/map/" class="post-tag no-text-decoration" >map</a> <a href="/tags/unordered-map/" class="post-tag no-text-decoration" >unordered_map</a> <a href="/tags/lookup/" class="post-tag no-text-decoration" >lookup</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=How to look up values in a map - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=How to look up values in a map - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=How to look up values in a map - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=How to look up values in a map - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/07/10/cpponsea2024-trip-report"><div class="card-body"> <span class="timeago small" > Jul 10, 2024 <i class="unloaded">2024-07-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: C++ On Sea 2024</h3><div class="text-muted small"><p> Last week, between the 3rd and 5th of July, I had the privilege to attend and present at C++ on Sea 2024 for the 5th time in a row! I’m grateful that the organizers accepted me not simply as a spe...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/24/5-reasons-not-to-talk-about-politics-at-work"><div class="card-body"> <span class="timeago small" > Jul 24, 2024 <i class="unloaded">2024-07-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5 reasons why politics will ruin your career hopes</h3><div class="text-muted small"><p> I’m not apolitical, I do have my opinion and quite a strong one. Yet, I don’t let it interfere with my job. I don’t think that one should talk about his or her political agenda at work or that one ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/14/learn-cpp-by-frances-buontempo"><div class="card-body"> <span class="timeago small" > Aug 14, 2024 <i class="unloaded">2024-08-14T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Learn C++ by Example by Frances Buontempo</h3><div class="text-muted small"><p> I know Fran from C++ On Sea where she hosted lightning talk nights for the last two years. She recently asked me if I would be interested in reading her book, Learn C++ by Example. It was on my rad...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/08/20/cpp26-P2841" class="btn btn-outline-primary" prompt="Older"><p>C++26: Concept and variable-template template-parameters</p></a> <a href="/blog/2025/09/03/observers-part1" class="btn btn-outline-primary" prompt="Newer"><p>Discovering observers - part 1</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'How to look up values in a map'; this.page.url = 'https://www.sandordargo.com/blog/2025/08/27/lookup-value-in-map'; this.page.identifier = '/blog/2025/08/27/lookup-value-in-map'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
