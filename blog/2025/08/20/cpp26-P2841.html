<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++26: Concept and variable-template template-parameters" /><meta property="og:locale" content="en_US" /><meta name="description" content="Last week, we discussed why we should sometimes use remove_cvref_t on our template parameters before applying concepts to them. We also saw that the solution is not super readable because we lose access to the terse, shorthand syntax. If only we could use concepts as template parameters! Fortunately, P2841R7 comes to the rescue—and it has been recently accepted as part of C++26. At first glance, the proposal may look daunting — it’s nearly 40 pages long. But don’t worry. First, it’s a very readable document filled with clear and detailed explanations. Second, about half of it consists of wording changes. Let’s dive in. Concepts as template template parameters C++ already allows passing templates as template parameters, but only if they are class templates. A common reason for doing this is to allow higher-level abstractions. For instance, you may want to pass in a container template like std::vector, without specifying the type it contains. Jason Turner explains this well in C++ Weekly - Ep 368 - The Power of template-template Parameters: A Basic Guide, but here’s his example for quick reference: 1 2 3 4 5 6 7 8 9 10 11 template&lt;template &lt;typename Contained, typename Alloc = std::allocator&lt;Contained&gt;&gt; typename ResultType&gt; auto get_data() { ResultType&lt;double&gt; result; // ... return result; } int main() { auto data = get_data&lt;std::vector&gt;(); } With a simpler signature like template&lt;typename ResultType&gt; auto get_data(), we couldn’t pass in std::vector, because it’s not a complete type — it’s a template. Thanks to template-template parameters, we can pass a class template to another template. Unfortunately, until now this technique has not worked with variable templates or concepts. Yet the motivation for passing a concept as a template argument is similar to why we pass class templates: to enable high-level, expressive constructs. Last week, we had this function template: 1 2 3 template&lt;typename Q&gt; requires Quantity&lt;std::remove_cvref_t&lt;Q&gt;&gt; void foo(Q&amp;&amp; q); With concept template-template parameters, we can introduce a helper concept — in other words a concept adaptor — to improve readability: 1 2 3 template &lt;typename T, &lt;template &lt;typename&gt; concept C&gt; concept decays_to = C&lt;std::decay_t&lt;T&gt;&gt;; This allows us to rewrite our function more clearly: 1 2 template &lt;decays_to&lt;Quantity&gt; Q&gt; void foo(Q&amp;&amp; q); The proposal includes several other examples that would come in handy. Variable template-template parameters As of C++23, we cannot have variable template-template parameters. Although workarounds exist — such as wrapping variables inside structs with a value member to use them as type template-template parameters — they are verbose, hard to read, and may negatively impact performance. In fact, most standard type traits are defined as both types and _v variables. According to the proposal’s performance benchmarks, using variable templates can have significant benefits for compile-time performance and memory usage. The difference in the code example that paper brings is small: 1 2 3 4 5 6 // Before template &lt;template &lt;typename&gt; typename p, typename... Ts&gt; constexpr std::size_t count_if_v = (... + p&lt;Ts&gt;::value); // After template &lt;template &lt;typename&gt; auto p, typename... Ts&gt; constexpr std::size_t count_if_v = (... + p&lt;Ts&gt;); By eliminating ::value, we avoid the overhead of instantiating a class template for each Ts — a seemingly small change with meaningful impact. The syntactic details The reason concept and variable template-template parameters appear together in this proposal is not coincidental. While they were previously proposed separately, they are both essential for supporting Universal Template Parameters, proposed in P1985R3. The proposal discussed here (P2841R7) is actually a subset of P1985R3. For a “universal template parameter” to live up to its name, it must support a broad set of possible template argument forms — including types, class templates, concepts, and variable templates. Here’s how we used to specify a class-only template-template parameter: 1 2 3 template&lt; template &lt;typename T&gt; typename TT &gt; With the new proposal, we can now include concepts and variable templates using the concept and auto keywords respectively: 1 2 3 4 5 template&lt; template &lt;typename T&gt; typename TT, template &lt;typename T&gt; concept C, template &lt;typename T&gt; auto VT &gt; There are many more interesting aspects — like subsumption — but I’ll leave those for another article to keep this one focused and digestible. Conclusion The acceptance of P2841R7 into C++26 is one of those quiet but powerful improvements. It lets us write cleaner, more flexible, and easier-to-read templates by allowing both concepts and variable templates as template-template parameters. This might seem like a niche feature, but if you’ve ever wrestled with awkward template syntax or boilerplate wrappers just to pass around concepts or traits, you’ll appreciate what this unlocks. It brings us one step closer to writing the kind of expressive, high-level C++ that feels more natural—without sacrificing performance. It’s a great step forward for anyone who enjoys modern C++ and wants more elegant tools for metaprogramming. And let’s be honest — less ::value clutter never hurt anyone. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Last week, we discussed why we should sometimes use remove_cvref_t on our template parameters before applying concepts to them. We also saw that the solution is not super readable because we lose access to the terse, shorthand syntax. If only we could use concepts as template parameters! Fortunately, P2841R7 comes to the rescue—and it has been recently accepted as part of C++26. At first glance, the proposal may look daunting — it’s nearly 40 pages long. But don’t worry. First, it’s a very readable document filled with clear and detailed explanations. Second, about half of it consists of wording changes. Let’s dive in. Concepts as template template parameters C++ already allows passing templates as template parameters, but only if they are class templates. A common reason for doing this is to allow higher-level abstractions. For instance, you may want to pass in a container template like std::vector, without specifying the type it contains. Jason Turner explains this well in C++ Weekly - Ep 368 - The Power of template-template Parameters: A Basic Guide, but here’s his example for quick reference: 1 2 3 4 5 6 7 8 9 10 11 template&lt;template &lt;typename Contained, typename Alloc = std::allocator&lt;Contained&gt;&gt; typename ResultType&gt; auto get_data() { ResultType&lt;double&gt; result; // ... return result; } int main() { auto data = get_data&lt;std::vector&gt;(); } With a simpler signature like template&lt;typename ResultType&gt; auto get_data(), we couldn’t pass in std::vector, because it’s not a complete type — it’s a template. Thanks to template-template parameters, we can pass a class template to another template. Unfortunately, until now this technique has not worked with variable templates or concepts. Yet the motivation for passing a concept as a template argument is similar to why we pass class templates: to enable high-level, expressive constructs. Last week, we had this function template: 1 2 3 template&lt;typename Q&gt; requires Quantity&lt;std::remove_cvref_t&lt;Q&gt;&gt; void foo(Q&amp;&amp; q); With concept template-template parameters, we can introduce a helper concept — in other words a concept adaptor — to improve readability: 1 2 3 template &lt;typename T, &lt;template &lt;typename&gt; concept C&gt; concept decays_to = C&lt;std::decay_t&lt;T&gt;&gt;; This allows us to rewrite our function more clearly: 1 2 template &lt;decays_to&lt;Quantity&gt; Q&gt; void foo(Q&amp;&amp; q); The proposal includes several other examples that would come in handy. Variable template-template parameters As of C++23, we cannot have variable template-template parameters. Although workarounds exist — such as wrapping variables inside structs with a value member to use them as type template-template parameters — they are verbose, hard to read, and may negatively impact performance. In fact, most standard type traits are defined as both types and _v variables. According to the proposal’s performance benchmarks, using variable templates can have significant benefits for compile-time performance and memory usage. The difference in the code example that paper brings is small: 1 2 3 4 5 6 // Before template &lt;template &lt;typename&gt; typename p, typename... Ts&gt; constexpr std::size_t count_if_v = (... + p&lt;Ts&gt;::value); // After template &lt;template &lt;typename&gt; auto p, typename... Ts&gt; constexpr std::size_t count_if_v = (... + p&lt;Ts&gt;); By eliminating ::value, we avoid the overhead of instantiating a class template for each Ts — a seemingly small change with meaningful impact. The syntactic details The reason concept and variable template-template parameters appear together in this proposal is not coincidental. While they were previously proposed separately, they are both essential for supporting Universal Template Parameters, proposed in P1985R3. The proposal discussed here (P2841R7) is actually a subset of P1985R3. For a “universal template parameter” to live up to its name, it must support a broad set of possible template argument forms — including types, class templates, concepts, and variable templates. Here’s how we used to specify a class-only template-template parameter: 1 2 3 template&lt; template &lt;typename T&gt; typename TT &gt; With the new proposal, we can now include concepts and variable templates using the concept and auto keywords respectively: 1 2 3 4 5 template&lt; template &lt;typename T&gt; typename TT, template &lt;typename T&gt; concept C, template &lt;typename T&gt; auto VT &gt; There are many more interesting aspects — like subsumption — but I’ll leave those for another article to keep this one focused and digestible. Conclusion The acceptance of P2841R7 into C++26 is one of those quiet but powerful improvements. It lets us write cleaner, more flexible, and easier-to-read templates by allowing both concepts and variable templates as template-template parameters. This might seem like a niche feature, but if you’ve ever wrestled with awkward template syntax or boilerplate wrappers just to pass around concepts or traits, you’ll appreciate what this unlocks. It brings us one step closer to writing the kind of expressive, high-level C++ that feels more natural—without sacrificing performance. It’s a great step forward for anyone who enjoys modern C++ and wants more elegant tools for metaprogramming. And let’s be honest — less ::value clutter never hurt anyone. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-08-20T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++26: Concept and variable-template template-parameters" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-20T00:00:00+02:00","datePublished":"2025-08-20T00:00:00+02:00","description":"Last week, we discussed why we should sometimes use remove_cvref_t on our template parameters before applying concepts to them. We also saw that the solution is not super readable because we lose access to the terse, shorthand syntax. If only we could use concepts as template parameters! Fortunately, P2841R7 comes to the rescue—and it has been recently accepted as part of C++26. At first glance, the proposal may look daunting — it’s nearly 40 pages long. But don’t worry. First, it’s a very readable document filled with clear and detailed explanations. Second, about half of it consists of wording changes. Let’s dive in. Concepts as template template parameters C++ already allows passing templates as template parameters, but only if they are class templates. A common reason for doing this is to allow higher-level abstractions. For instance, you may want to pass in a container template like std::vector, without specifying the type it contains. Jason Turner explains this well in C++ Weekly - Ep 368 - The Power of template-template Parameters: A Basic Guide, but here’s his example for quick reference: 1 2 3 4 5 6 7 8 9 10 11 template&lt;template &lt;typename Contained, typename Alloc = std::allocator&lt;Contained&gt;&gt; typename ResultType&gt; auto get_data() { ResultType&lt;double&gt; result; // ... return result; } int main() { auto data = get_data&lt;std::vector&gt;(); } With a simpler signature like template&lt;typename ResultType&gt; auto get_data(), we couldn’t pass in std::vector, because it’s not a complete type — it’s a template. Thanks to template-template parameters, we can pass a class template to another template. Unfortunately, until now this technique has not worked with variable templates or concepts. Yet the motivation for passing a concept as a template argument is similar to why we pass class templates: to enable high-level, expressive constructs. Last week, we had this function template: 1 2 3 template&lt;typename Q&gt; requires Quantity&lt;std::remove_cvref_t&lt;Q&gt;&gt; void foo(Q&amp;&amp; q); With concept template-template parameters, we can introduce a helper concept — in other words a concept adaptor — to improve readability: 1 2 3 template &lt;typename T, &lt;template &lt;typename&gt; concept C&gt; concept decays_to = C&lt;std::decay_t&lt;T&gt;&gt;; This allows us to rewrite our function more clearly: 1 2 template &lt;decays_to&lt;Quantity&gt; Q&gt; void foo(Q&amp;&amp; q); The proposal includes several other examples that would come in handy. Variable template-template parameters As of C++23, we cannot have variable template-template parameters. Although workarounds exist — such as wrapping variables inside structs with a value member to use them as type template-template parameters — they are verbose, hard to read, and may negatively impact performance. In fact, most standard type traits are defined as both types and _v variables. According to the proposal’s performance benchmarks, using variable templates can have significant benefits for compile-time performance and memory usage. The difference in the code example that paper brings is small: 1 2 3 4 5 6 // Before template &lt;template &lt;typename&gt; typename p, typename... Ts&gt; constexpr std::size_t count_if_v = (... + p&lt;Ts&gt;::value); // After template &lt;template &lt;typename&gt; auto p, typename... Ts&gt; constexpr std::size_t count_if_v = (... + p&lt;Ts&gt;); By eliminating ::value, we avoid the overhead of instantiating a class template for each Ts — a seemingly small change with meaningful impact. The syntactic details The reason concept and variable template-template parameters appear together in this proposal is not coincidental. While they were previously proposed separately, they are both essential for supporting Universal Template Parameters, proposed in P1985R3. The proposal discussed here (P2841R7) is actually a subset of P1985R3. For a “universal template parameter” to live up to its name, it must support a broad set of possible template argument forms — including types, class templates, concepts, and variable templates. Here’s how we used to specify a class-only template-template parameter: 1 2 3 template&lt; template &lt;typename T&gt; typename TT &gt; With the new proposal, we can now include concepts and variable templates using the concept and auto keywords respectively: 1 2 3 4 5 template&lt; template &lt;typename T&gt; typename TT, template &lt;typename T&gt; concept C, template &lt;typename T&gt; auto VT &gt; There are many more interesting aspects — like subsumption — but I’ll leave those for another article to keep this one focused and digestible. Conclusion The acceptance of P2841R7 into C++26 is one of those quiet but powerful improvements. It lets us write cleaner, more flexible, and easier-to-read templates by allowing both concepts and variable templates as template-template parameters. This might seem like a niche feature, but if you’ve ever wrestled with awkward template syntax or boilerplate wrappers just to pass around concepts or traits, you’ll appreciate what this unlocks. It brings us one step closer to writing the kind of expressive, high-level C++ that feels more natural—without sacrificing performance. It’s a great step forward for anyone who enjoys modern C++ and wants more elegant tools for metaprogramming. And let’s be honest — less ::value clutter never hurt anyone. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++26: Concept and variable-template template-parameters","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841"},"url":"https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841"}</script><title>C++26: Concept and variable-template template-parameters | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/08"> 08 </a> </span> <span> <a href="/20"> 20 </a> </span> <span>C++26: Concept and variable-template template-parameters</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++26: Concept and variable-template template-parameters</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 20, 2025, 12:00 AM +0200" prep="on" > Aug 20 <i class="unloaded">2025-08-20T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="822 words">4 min</span></div></div><div class="post-content"><p>Last week, <a href="https://www.sandordargo.com/blog/2025/08/13/use-concepts-with-remove_cvref">we discussed why we should sometimes use <code class="language-plaintext highlighter-rouge">remove_cvref_t</code> on our template parameters before applying concepts to them</a>. We also saw that the solution is not super readable because we lose access to the terse, shorthand syntax.</p><p>If only we could use concepts as template parameters!</p><p>Fortunately, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r7.pdf">P2841R7</a> comes to the rescue—and it has been recently accepted as part of C++26.</p><p>At first glance, the proposal may look daunting — it’s nearly 40 pages long. But don’t worry. First, it’s a very readable document filled with clear and detailed explanations. Second, about half of it consists of wording changes.</p><p>Let’s dive in.</p><h2 id="concepts-as-template-template-parameters">Concepts as template template parameters</h2><p>C++ already allows passing templates as template parameters, but only if they are class templates. A common reason for doing this is to allow higher-level abstractions. For instance, you may want to pass in a container template like <code class="language-plaintext highlighter-rouge">std::vector</code>, without specifying the type it contains.</p><p>Jason Turner explains this well in <a href="https://www.youtube.com/watch?v=s6Cub7EFLXo">C++ Weekly - Ep 368 - The Power of template-template Parameters: A Basic Guide</a>, but here’s his example for quick reference:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Contained</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">Alloc</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">allocator</span><span class="o">&lt;</span><span class="n">Contained</span><span class="p">&gt;&gt;</span>
		 <span class="k">typename</span> <span class="n">ResultType</span><span class="o">&gt;</span>
<span class="k">auto</span> <span class="nf">get_data</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">ResultType</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">result</span><span class="p">;</span>
	<span class="c1">// ...</span>
	<span class="k">return</span> <span class="n">result</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">auto</span> <span class="n">data</span> <span class="o">=</span> <span class="n">get_data</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With a simpler signature like <code class="language-plaintext highlighter-rouge">template&lt;typename ResultType&gt; auto get_data()</code>, we couldn’t pass in <code class="language-plaintext highlighter-rouge">std::vector</code>, because it’s not a complete type — it’s a template. Thanks to template-template parameters, we can pass a class template to another template.</p><p>Unfortunately, until now this technique has not worked with variable templates or concepts. Yet the motivation for passing a concept as a template argument is similar to why we pass class templates: to enable high-level, expressive constructs.</p><p>Last week, we had this function template:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Q</span><span class="p">&gt;</span>
 <span class="k">requires</span> <span class="n">Quantity</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">remove_cvref_t</span><span class="o">&lt;</span><span class="n">Q</span><span class="o">&gt;&gt;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Q</span><span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">);</span>
</pre></table></code></div></div><p>With concept template-template parameters, we can introduce a helper concept — in other words a concept adaptor — to improve readability:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span>
		 <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">concept</span> <span class="n">C</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">decays_to</span> <span class="o">=</span> <span class="n">C</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>This allows us to rewrite our function more clearly:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">decays_to</span><span class="o">&lt;</span><span class="n">Quantity</span><span class="p">&gt;</span> <span class="n">Q</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">Q</span><span class="o">&amp;&amp;</span> <span class="n">q</span><span class="p">);</span>
</pre></table></code></div></div><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r7.pdf">The proposal</a> includes several other examples that would come in handy.</p><h2 id="variable-template-template-parameters">Variable template-template parameters</h2><p>As of C++23, we cannot have variable template-template parameters. Although workarounds exist — such as wrapping variables inside structs with a <code class="language-plaintext highlighter-rouge">value</code> member to use them as type template-template parameters — they are verbose, hard to read, and may negatively impact performance.</p><p>In fact, most standard type traits are defined as both types and <code class="language-plaintext highlighter-rouge">_v</code> variables. According to the proposal’s performance benchmarks, using variable templates can have significant benefits for compile-time performance and memory usage.</p><p>The difference in the code example that paper brings is small:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="c1">// Before</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">p</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count_if_v</span> <span class="o">=</span> <span class="p">(...</span> <span class="o">+</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;::</span><span class="n">value</span><span class="p">);</span>
<span class="c1">// After </span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="p">&gt;</span> <span class="k">auto</span> <span class="n">p</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Ts</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">count_if_v</span> <span class="o">=</span> <span class="p">(...</span> <span class="o">+</span> <span class="n">p</span><span class="o">&lt;</span><span class="n">Ts</span><span class="o">&gt;</span><span class="p">);</span>
</pre></table></code></div></div><p>By eliminating <code class="language-plaintext highlighter-rouge">::value</code>, we avoid the overhead of instantiating a class template for each <code class="language-plaintext highlighter-rouge">Ts</code> — a seemingly small change with meaningful impact.</p><h2 id="the-syntactic-details">The syntactic details</h2><p>The reason concept and variable template-template parameters appear together in this proposal is not coincidental. While they were previously proposed separately, they are both essential for supporting Universal Template Parameters, proposed in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1985r3.pdf">P1985R3</a>.</p><p>The proposal discussed here (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r7.pdf">P2841R7</a>) is actually a subset of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1985r3.pdf">P1985R3</a>. For a “universal template parameter” to live up to its name, it must support a broad set of possible template argument forms — including types, class templates, concepts, and variable templates.</p><p>Here’s how we used to specify a class-only template-template parameter:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span>
	<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">TT</span>
<span class="p">&gt;</span>
</pre></table></code></div></div><p>With the new proposal, we can now include concepts and variable templates using the concept and auto keywords respectively:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span>
	<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">typename</span> <span class="nc">TT</span><span class="p">,</span>
	<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">concept</span> <span class="n">C</span><span class="p">,</span>
	<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">auto</span> <span class="n">VT</span>
<span class="p">&gt;</span>
</pre></table></code></div></div><p>There are many more interesting aspects — like subsumption — but I’ll leave those for another article to keep this one focused and digestible.</p><h2 id="conclusion">Conclusion</h2><p>The acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2025/p2841r7.pdf">P2841R7</a> into C++26 is one of those quiet but powerful improvements. It lets us write cleaner, more flexible, and easier-to-read templates by allowing both concepts and variable templates as template-template parameters.</p><p>This might seem like a niche feature, but if you’ve ever wrestled with awkward template syntax or boilerplate wrappers just to pass around concepts or traits, you’ll appreciate what this unlocks. It brings us one step closer to writing the kind of expressive, high-level C++ that feels more natural—without sacrificing performance.</p><p>It’s a great step forward for anyone who enjoys modern C++ and wants more elegant tools for metaprogramming. And let’s be honest — less <code class="language-plaintext highlighter-rouge">::value</code> clutter never hurt anyone.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp26/" class="post-tag no-text-decoration" >cpp26</a> <a href="/tags/concepts/" class="post-tag no-text-decoration" >concepts</a> <a href="/tags/templates/" class="post-tag no-text-decoration" >templates</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++26: Concept and variable-template template-parameters - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++26: Concept and variable-template template-parameters - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++26: Concept and variable-template template-parameters - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++26: Concept and variable-template template-parameters - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/01/22/cpp26-pack-indexing"><div class="card-body"> <span class="timeago small" > Jan 22 <i class="unloaded">2025-01-22T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: pack indexing</h3><div class="text-muted small"><p> C++11 introduced parameter packs to provide a safer way to pass an undefined number of parameters to functions instead of relying on variadic functions. While packs are a useful feature, and since...</p></div></div></a></div><div class="card"> <a href="/blog/2025/02/05/cpp26-erroneous-behaviour"><div class="card-body"> <span class="timeago small" > Feb 5 <i class="unloaded">2025-02-05T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: erroneous behaviour</h3><div class="text-muted small"><p> If you pick a random talk at a C++ conference these days, there is a fair chance that the speaker will mention safety at least a couple of times. It’s probably fine like that. The committee and the...</p></div></div></a></div><div class="card"> <a href="/blog/2021/06/16/multiple-destructors-with-cpp-concepts"><div class="card-body"> <span class="timeago small" > Jun 16, 2021 <i class="unloaded">2021-06-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Multiple destructors with C++ concepts</h3><div class="text-muted small"><p> We probably all learnt that one cannot overload the destructor. Hence I write about “the” destructor and a destructor… After all, it has no return type and it doesn’t take parameters. It’s also not...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/08/13/use-concepts-with-remove_cvref" class="btn btn-outline-primary" prompt="Older"><p>Use concepts with std::remove_cvref_t</p></a> <a href="/blog/2025/08/27/lookup-value-in-map" class="btn btn-outline-primary" prompt="Newer"><p>How to look up values in a map</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++26: Concept and variable-template template-parameters'; this.page.url = 'https://www.sandordargo.com/blog/2025/08/20/cpp26-P2841'; this.page.identifier = '/blog/2025/08/20/cpp26-P2841'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
