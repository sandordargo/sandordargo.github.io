<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++26: std::format improvements (Part 2)" /><meta property="og:locale" content="en_US" /><meta name="description" content="In Part 1, we explored the improvements C++26 brings to std::format ‚Äî from better to_string behavior to compile-time safety checks. In this part, we look at runtime formatting, defect fixes, and support for new types like std::filesystem::path. Runtime format strings P2216R3 brought quite some improvements to std::format, including compile-time checking for format strings. Sadly, in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version, std::vformat: 1 std::vformat(str, std::make_format_args(42)); Using two different APIs is not a great user experience, moreover, std::vformat was designed to be used by formatting function writers and not by end users. In addition, you might run into undefined behaviour, detailed in the next section. To overcome this situation, P2918R2 adds std::runtime_format so you can mark format strings that are only available at run-time. As such you can opt out of compile-time format strings checks. This makes the API cleaner and the user code will read better as it shows better the intentions. 1 2 3 4 5 // Before: std::vformat(str, std::make_format_args(42)); // After: std::format(std::runtime_format(str), 42); This change is already available in GCC 14 and Clang 18. DR20: std::make_format_args now accepts only lvalue references instead of forwarding references P2905R2 fixes unintended consequences of P2216R3 std::format improvements. It offered checking format strings at compile-time (as we‚Äôve just seen), so in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version: std::vformat. The problem is that in innocent-looking code, like below, users face undefined behaviour as format arguments store references to temporaries which are destroyed before use: 1 2 3 4 std::string str = &quot;{}&quot;; std::filesystem::path path = &quot;path/etic/experience&quot;; auto args = std::make_format_args(path.string()); std::string msg = std::vformat(str, args); The fix is that std::make_format_args should take lvalue references instead of forwarding references, rejecting code like the above. It‚Äôs been already implemented in fmt and this is knowingly and deliberately a breaking change. Luckily, this defectous feature hasn‚Äôt been widely used. This fix is already available in all the three major compilers, GCC 14, Clang 18 and MSVC 19.40. DR20: Fix formatting of code units as integers P2909R4 fixes a defect report. An earlier proposal introduced a bug into how chars are formatted. Whether char is signed or unsigned is implementation defined and std::format (through std::to_chars) always promotes a char to an int - which is always signed. As char is always used as a code unit type in std::format (and in other text processing facilities) - and a sometimes signed integer output has been surprising to the users. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 for (char c : std::string(&quot;ü§∑&quot;)) { std::print(&quot;\\x{:02x}&quot;, c); } /* output is either this \xf0\x9f\xa4\xb7 or this \x-10\x-61\x-5c\x-49 */ The fix proposed by the author, Victor Zverovich, is to always convert a character type to the unsigned version of it when it‚Äôs getting formatted. Though it‚Äôs not the goal, it results in the same behaviour as printf has. This fix is already available in all the three major compilers, GCC 13.3, Clang 18 and MSVC 19.40. std::formatter&lt;std::filesystem::path&gt; Thanks to P2845R8m we will be able to print our standard paths nicely formatted. Wasn‚Äôt that available already? Not yet. Although P1636 already proposed formatters for library types, std::filesystem::path was removed because of some issues which are solved by now by the current proposal. The previously proposed formatter always printed paths quoted. That is not always suitable for paths, notably when the path is a multiline one: 1 2 3 4 5 6 std::cout &lt;&lt; std::format(&quot;{}&quot;, std::filesystem::path(&quot;multi\nline&quot;)); /* The below output is not a valid C++ string &quot;multi line&quot; */ In the end end, a formatter is being added as per P2286, and by default it doesn‚Äôt print paths quoted. But it also adds a ‚Äúdebug format specifier‚Äù where control characters are escaped and the output is quoted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto p = std::filesystem::path(&quot;/usr/bin&quot;); std::cout &lt;&lt; std::format(&quot;{}&quot;, p); // output: // /usr/bin auto p = std::filesystem::path(&quot;multi\nline&quot;); std::cout &lt;&lt; std::format(&quot;{}&quot;, p); // output: // multi // line auto p = std::filesystem::path(&quot;multi\nline&quot;); std::cout &lt;&lt; std::format(&quot;{:?}&quot;, p); // output: // &quot;multi\nline&quot; The other problem was UTF-8 encoding on certain platforms when intermediary conversion are performed. The problem has been earlier solved by P2093R14 which is now applied here as well. As a result paths with UTF-8 as a literal encoding will be printed as one would expect. This change is not yet available in any of three major compilers. Conclusion C++26 makes std::format more robust with safer, and cleaner API. The changes might look small in isolation, but together, they significantly improve the day-to-day developer experience. If you missed Part 1, check it out here. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let‚Äôs connect on Twitter!" /><meta property="og:description" content="In Part 1, we explored the improvements C++26 brings to std::format ‚Äî from better to_string behavior to compile-time safety checks. In this part, we look at runtime formatting, defect fixes, and support for new types like std::filesystem::path. Runtime format strings P2216R3 brought quite some improvements to std::format, including compile-time checking for format strings. Sadly, in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version, std::vformat: 1 std::vformat(str, std::make_format_args(42)); Using two different APIs is not a great user experience, moreover, std::vformat was designed to be used by formatting function writers and not by end users. In addition, you might run into undefined behaviour, detailed in the next section. To overcome this situation, P2918R2 adds std::runtime_format so you can mark format strings that are only available at run-time. As such you can opt out of compile-time format strings checks. This makes the API cleaner and the user code will read better as it shows better the intentions. 1 2 3 4 5 // Before: std::vformat(str, std::make_format_args(42)); // After: std::format(std::runtime_format(str), 42); This change is already available in GCC 14 and Clang 18. DR20: std::make_format_args now accepts only lvalue references instead of forwarding references P2905R2 fixes unintended consequences of P2216R3 std::format improvements. It offered checking format strings at compile-time (as we‚Äôve just seen), so in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version: std::vformat. The problem is that in innocent-looking code, like below, users face undefined behaviour as format arguments store references to temporaries which are destroyed before use: 1 2 3 4 std::string str = &quot;{}&quot;; std::filesystem::path path = &quot;path/etic/experience&quot;; auto args = std::make_format_args(path.string()); std::string msg = std::vformat(str, args); The fix is that std::make_format_args should take lvalue references instead of forwarding references, rejecting code like the above. It‚Äôs been already implemented in fmt and this is knowingly and deliberately a breaking change. Luckily, this defectous feature hasn‚Äôt been widely used. This fix is already available in all the three major compilers, GCC 14, Clang 18 and MSVC 19.40. DR20: Fix formatting of code units as integers P2909R4 fixes a defect report. An earlier proposal introduced a bug into how chars are formatted. Whether char is signed or unsigned is implementation defined and std::format (through std::to_chars) always promotes a char to an int - which is always signed. As char is always used as a code unit type in std::format (and in other text processing facilities) - and a sometimes signed integer output has been surprising to the users. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 for (char c : std::string(&quot;ü§∑&quot;)) { std::print(&quot;\\x{:02x}&quot;, c); } /* output is either this \xf0\x9f\xa4\xb7 or this \x-10\x-61\x-5c\x-49 */ The fix proposed by the author, Victor Zverovich, is to always convert a character type to the unsigned version of it when it‚Äôs getting formatted. Though it‚Äôs not the goal, it results in the same behaviour as printf has. This fix is already available in all the three major compilers, GCC 13.3, Clang 18 and MSVC 19.40. std::formatter&lt;std::filesystem::path&gt; Thanks to P2845R8m we will be able to print our standard paths nicely formatted. Wasn‚Äôt that available already? Not yet. Although P1636 already proposed formatters for library types, std::filesystem::path was removed because of some issues which are solved by now by the current proposal. The previously proposed formatter always printed paths quoted. That is not always suitable for paths, notably when the path is a multiline one: 1 2 3 4 5 6 std::cout &lt;&lt; std::format(&quot;{}&quot;, std::filesystem::path(&quot;multi\nline&quot;)); /* The below output is not a valid C++ string &quot;multi line&quot; */ In the end end, a formatter is being added as per P2286, and by default it doesn‚Äôt print paths quoted. But it also adds a ‚Äúdebug format specifier‚Äù where control characters are escaped and the output is quoted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto p = std::filesystem::path(&quot;/usr/bin&quot;); std::cout &lt;&lt; std::format(&quot;{}&quot;, p); // output: // /usr/bin auto p = std::filesystem::path(&quot;multi\nline&quot;); std::cout &lt;&lt; std::format(&quot;{}&quot;, p); // output: // multi // line auto p = std::filesystem::path(&quot;multi\nline&quot;); std::cout &lt;&lt; std::format(&quot;{:?}&quot;, p); // output: // &quot;multi\nline&quot; The other problem was UTF-8 encoding on certain platforms when intermediary conversion are performed. The problem has been earlier solved by P2093R14 which is now applied here as well. As a result paths with UTF-8 as a literal encoding will be printed as one would expect. This change is not yet available in any of three major compilers. Conclusion C++26 makes std::format more robust with safer, and cleaner API. The changes might look small in isolation, but together, they significantly improve the day-to-day developer experience. If you missed Part 1, check it out here. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let‚Äôs connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2" /><meta property="og:site_name" content="Sandor Dargo‚Äôs Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-16T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++26: std::format improvements (Part 2)" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-16T00:00:00+02:00","datePublished":"2025-07-16T00:00:00+02:00","description":"In Part 1, we explored the improvements C++26 brings to std::format ‚Äî from better to_string behavior to compile-time safety checks. In this part, we look at runtime formatting, defect fixes, and support for new types like std::filesystem::path. Runtime format strings P2216R3 brought quite some improvements to std::format, including compile-time checking for format strings. Sadly, in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version, std::vformat: 1 std::vformat(str, std::make_format_args(42)); Using two different APIs is not a great user experience, moreover, std::vformat was designed to be used by formatting function writers and not by end users. In addition, you might run into undefined behaviour, detailed in the next section. To overcome this situation, P2918R2 adds std::runtime_format so you can mark format strings that are only available at run-time. As such you can opt out of compile-time format strings checks. This makes the API cleaner and the user code will read better as it shows better the intentions. 1 2 3 4 5 // Before: std::vformat(str, std::make_format_args(42)); // After: std::format(std::runtime_format(str), 42); This change is already available in GCC 14 and Clang 18. DR20: std::make_format_args now accepts only lvalue references instead of forwarding references P2905R2 fixes unintended consequences of P2216R3 std::format improvements. It offered checking format strings at compile-time (as we‚Äôve just seen), so in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version: std::vformat. The problem is that in innocent-looking code, like below, users face undefined behaviour as format arguments store references to temporaries which are destroyed before use: 1 2 3 4 std::string str = &quot;{}&quot;; std::filesystem::path path = &quot;path/etic/experience&quot;; auto args = std::make_format_args(path.string()); std::string msg = std::vformat(str, args); The fix is that std::make_format_args should take lvalue references instead of forwarding references, rejecting code like the above. It‚Äôs been already implemented in fmt and this is knowingly and deliberately a breaking change. Luckily, this defectous feature hasn‚Äôt been widely used. This fix is already available in all the three major compilers, GCC 14, Clang 18 and MSVC 19.40. DR20: Fix formatting of code units as integers P2909R4 fixes a defect report. An earlier proposal introduced a bug into how chars are formatted. Whether char is signed or unsigned is implementation defined and std::format (through std::to_chars) always promotes a char to an int - which is always signed. As char is always used as a code unit type in std::format (and in other text processing facilities) - and a sometimes signed integer output has been surprising to the users. Here is an example: 1 2 3 4 5 6 7 8 9 10 11 for (char c : std::string(&quot;ü§∑&quot;)) { std::print(&quot;\\\\x{:02x}&quot;, c); } /* output is either this \\xf0\\x9f\\xa4\\xb7 or this \\x-10\\x-61\\x-5c\\x-49 */ The fix proposed by the author, Victor Zverovich, is to always convert a character type to the unsigned version of it when it‚Äôs getting formatted. Though it‚Äôs not the goal, it results in the same behaviour as printf has. This fix is already available in all the three major compilers, GCC 13.3, Clang 18 and MSVC 19.40. std::formatter&lt;std::filesystem::path&gt; Thanks to P2845R8m we will be able to print our standard paths nicely formatted. Wasn‚Äôt that available already? Not yet. Although P1636 already proposed formatters for library types, std::filesystem::path was removed because of some issues which are solved by now by the current proposal. The previously proposed formatter always printed paths quoted. That is not always suitable for paths, notably when the path is a multiline one: 1 2 3 4 5 6 std::cout &lt;&lt; std::format(&quot;{}&quot;, std::filesystem::path(&quot;multi\\nline&quot;)); /* The below output is not a valid C++ string &quot;multi line&quot; */ In the end end, a formatter is being added as per P2286, and by default it doesn‚Äôt print paths quoted. But it also adds a ‚Äúdebug format specifier‚Äù where control characters are escaped and the output is quoted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 auto p = std::filesystem::path(&quot;/usr/bin&quot;); std::cout &lt;&lt; std::format(&quot;{}&quot;, p); // output: // /usr/bin auto p = std::filesystem::path(&quot;multi\\nline&quot;); std::cout &lt;&lt; std::format(&quot;{}&quot;, p); // output: // multi // line auto p = std::filesystem::path(&quot;multi\\nline&quot;); std::cout &lt;&lt; std::format(&quot;{:?}&quot;, p); // output: // &quot;multi\\nline&quot; The other problem was UTF-8 encoding on certain platforms when intermediary conversion are performed. The problem has been earlier solved by P2093R14 which is now applied here as well. As a result paths with UTF-8 as a literal encoding will be printed as one would expect. This change is not yet available in any of three major compilers. Conclusion C++26 makes std::format more robust with safer, and cleaner API. The changes might look small in isolation, but together, they significantly improve the day-to-day developer experience. If you missed Part 1, check it out here. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let‚Äôs connect on Twitter!","headline":"C++26: std::format improvements (Part 2)","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2"},"url":"https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2"}</script><title>C++26: std::format improvements (Part 2) | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG ‚Ä∫ <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/16"> 16 </a> </span> <span>C++26: std::format improvements (Part 2)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++26: std::format improvements (Part 2)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 16, 2025, 12:00 AM +0200" prep="on" > Jul 16, 2025 <i class="unloaded">2025-07-16T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="814 words">4 min</span></div></div><div class="post-content"><p>In <a href="https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1">Part 1</a>, we explored the improvements C++26 brings to <code class="language-plaintext highlighter-rouge">std::format</code> ‚Äî from better <code class="language-plaintext highlighter-rouge">to_string</code> behavior to compile-time safety checks. In this part, we look at runtime formatting, defect fixes, and support for new types like <code class="language-plaintext highlighter-rouge">std::filesystem::path</code>.</p><h2 id="runtime-format-strings">Runtime format strings</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2216r3.html">P2216R3</a> brought quite some improvements to <code class="language-plaintext highlighter-rouge">std::format</code>, including compile-time checking for format strings. Sadly, in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version, <a href="https://en.cppreference.com/w/cpp/utility/format/vformat.html">std::vformat</a>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vformat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_format_args</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
</pre></table></code></div></div><p>Using two different APIs is not a great user experience, moreover, <code class="language-plaintext highlighter-rouge">std::vformat</code> was designed to be used by formatting function writers and not by end users. In addition, you might run into undefined behaviour, detailed in the next section.</p><p>To overcome this situation, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2918r2.html">P2918R2</a> adds <a href="https://en.cppreference.com/w/cpp/utility/format/runtime_format.html"><code class="language-plaintext highlighter-rouge">std::runtime_format</code></a> so you can mark format strings that are only available at run-time. As such you can opt out of compile-time format strings checks. This makes the API cleaner and the user code will read better as it shows better the intentions.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="c1">// Before:</span>
<span class="n">std</span><span class="o">::</span><span class="n">vformat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_format_args</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>

<span class="c1">// After:</span>
<span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">runtime_format</span><span class="p">(</span><span class="n">str</span><span class="p">),</span> <span class="mi">42</span><span class="p">);</span>
</pre></table></code></div></div><p>This change is already available in GCC 14 and Clang 18.</p><h2 id="dr20-stdmake_format_args-now-accepts-only-lvalue-references-instead-of-forwarding-references">DR20: <code class="language-plaintext highlighter-rouge">std::make_format_args</code> now accepts only lvalue references instead of forwarding references</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2905r2.html">P2905R2</a> fixes unintended consequences of <em><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2216r3.html">P2216R3</a> std::format improvements</em>. It offered checking format strings at compile-time (as we‚Äôve just seen), so in use cases where format strings were only available at runtime, users had to go with the type-erased formatting version: <a href="https://en.cppreference.com/w/cpp/utility/format/vformat.html">std::vformat</a>.</p><p>The problem is that in innocent-looking code, like below, users face undefined behaviour as format arguments store references to temporaries which are destroyed before use:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="s">"{}"</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">path</span> <span class="o">=</span> <span class="s">"path/etic/experience"</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">args</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_format_args</span><span class="p">(</span><span class="n">path</span><span class="p">.</span><span class="n">string</span><span class="p">());</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">msg</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vformat</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">args</span><span class="p">);</span>
</pre></table></code></div></div><p>The fix is that <code class="language-plaintext highlighter-rouge">std::make_format_args</code> should take lvalue references instead of forwarding references, rejecting code like the above. It‚Äôs been already implemented in <code class="language-plaintext highlighter-rouge">fmt</code> and this is knowingly and deliberately a breaking change. Luckily, this defectous feature hasn‚Äôt been widely used.</p><p>This fix is already available in all the three major compilers, GCC 14, Clang 18 and MSVC 19.40.</p><h2 id="dr20-fix-formatting-of-code-units-as-integers">DR20: Fix formatting of code units as integers</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2909r4.html">P2909R4</a> fixes a defect report. An earlier proposal introduced a bug into how <code class="language-plaintext highlighter-rouge">char</code>s are formatted. Whether <code class="language-plaintext highlighter-rouge">char</code> is signed or unsigned is implementation defined and <code class="language-plaintext highlighter-rouge">std::format</code> (through <code class="language-plaintext highlighter-rouge">std::to_chars</code>) always promotes a <code class="language-plaintext highlighter-rouge">char</code> to an <code class="language-plaintext highlighter-rouge">int</code> - which is always signed.</p><p>As <code class="language-plaintext highlighter-rouge">char</code> is always used as a code unit type in <code class="language-plaintext highlighter-rouge">std::format</code> (and in other text processing facilities) - and a sometimes signed integer output has been surprising to the users. Here is an example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"ü§∑"</span><span class="p">))</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">print</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">x{:02x}"</span><span class="p">,</span> <span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cm">/*
output is either this
\xf0\x9f\xa4\xb7

or this
\x-10\x-61\x-5c\x-49
*/</span>
</pre></table></code></div></div><p>The fix proposed by the author, <a href="https://vitaut.net/">Victor Zverovich</a>, is to always convert a character type to the unsigned version of it when it‚Äôs getting formatted. Though it‚Äôs not the goal, it results in the same behaviour as <code class="language-plaintext highlighter-rouge">printf</code> has.</p><p>This fix is already available in all the three major compilers, GCC 13.3, Clang 18 and MSVC 19.40.</p><h2 id="stdformatterstdfilesystempath"><code class="language-plaintext highlighter-rouge">std::formatter&lt;std::filesystem::path&gt;</code></h2><p>Thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2024/p2845r8.html">P2845R8</a>m we will be able to print our standard paths nicely formatted.</p><p>Wasn‚Äôt that available already?</p><p>Not yet. Although <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p1636r2.pdf">P1636</a> already proposed formatters for library types, <code class="language-plaintext highlighter-rouge">std::filesystem::path</code> was removed because of some issues which are solved by now by the current proposal.</p><p>The previously proposed formatter always printed paths quoted. That is not always suitable for paths, notably when the path is a multiline one:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="s">"multi</span><span class="se">\n</span><span class="s">line"</span><span class="p">));</span>
<span class="cm">/*
The below output is not a valid C++ string
"multi
line"
*/</span>
</pre></table></code></div></div><p>In the end end, a formatter is being added as per <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2286r8.html#filesystempath">P2286</a>, and by default it doesn‚Äôt print paths quoted. But it also adds a ‚Äúdebug format specifier‚Äù where control characters are escaped and the output is quoted.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="s">"/usr/bin"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="c1">// output:</span>
<span class="c1">// /usr/bin</span>

<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="s">"multi</span><span class="se">\n</span><span class="s">line"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{}"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="c1">// output:</span>
<span class="c1">// multi</span>
<span class="c1">// line</span>
<span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="s">"multi</span><span class="se">\n</span><span class="s">line"</span><span class="p">);</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:?}"</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
<span class="c1">// output: </span>
<span class="c1">// "multi\nline"</span>
</pre></table></code></div></div><p>The other problem was UTF-8 encoding on certain platforms when intermediary conversion are performed. The problem has been earlier solved by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2093r14.html">P2093R14</a> which is now applied here as well. As a result paths with UTF-8 as a literal encoding will be printed as one would expect.</p><p>This change is not yet available in any of three major compilers.</p><h2 id="conclusion">Conclusion</h2><p>C++26 makes <code class="language-plaintext highlighter-rouge">std::format</code> more robust with safer, and cleaner API. The changes might look small in isolation, but together, they significantly improve the day-to-day developer experience.</p><p>If you missed Part 1, check it out <a href="https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1">here</a>.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let‚Äôs connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp26/" class="post-tag no-text-decoration" >cpp26</a> <a href="/tags/format/" class="post-tag no-text-decoration" >format</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++26: std::format improvements (Part 2) - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++26: std::format improvements (Part 2) - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++26: std::format improvements (Part 2) - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++26: std::format improvements (Part 2) - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/07/09/cpp26-format-part-1"><div class="card-body"> <span class="timeago small" > Jul 9, 2025 <i class="unloaded">2025-07-09T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: std::format improvement (Part 1)</h3><div class="text-muted small"><p> C++26 brings a series of improvements to std::format, continuing the work started in C++20 and refined in C++23. These changes improve formatting consistency, runtime safety, and user ergonomics. T...</p></div></div></a></div><div class="card"> <a href="/blog/2024/05/29/cpp23-chrono"><div class="card-body"> <span class="timeago small" > May 29, 2024 <i class="unloaded">2024-05-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: chrono related changes</h3><div class="text-muted small"><p> Let‚Äôs continue with what is changing in C++23. This time, let‚Äôs look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one...</p></div></div></a></div><div class="card"> <a href="/blog/2024/12/11/start-exploring-cpp26"><div class="card-body"> <span class="timeago small" > Dec 11, 2024 <i class="unloaded">2024-12-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's start exploring C++26</h3><div class="text-muted small"><p> During the last 2 years, we spent a lot of time exploring C++23 resulting in almost 40 blog posts. I‚Äôm not saying that we covered every single new language or library feature, but we covered most o...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/07/09/cpp26-format-part-1" class="btn btn-outline-primary" prompt="Older"><p>C++26: std::format improvement (Part 1)</p></a> <a href="/blog/2025/07/23/format-your-own-type-part-1" class="btn btn-outline-primary" prompt="Newer"><p>Format your own type (Part 1)</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++26: std::format improvements (Part 2)'; this.page.url = 'https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2'; this.page.identifier = '/blog/2025/07/16/cpp26-format-part-2'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> ¬© 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
