<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++26: std::format improvement (Part 1)" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++26 brings a series of improvements to std::format, continuing the work started in C++20 and refined in C++23. These changes improve formatting consistency, runtime safety, and user ergonomics. There are so many of these updates, that I decided to divide them into two articles. Arithmetic overloads of std::to_string and std::to_wstring use std::format P2587R3 by Victor Zverovich proposes replacing sprintf with std::format in the arithmetic overloads of std::to_string and std::to_wstring. The motivation? std::to_string has long been known to produce not-so-great and misleading results (differing from iostreams), especially with floating-point values. std::to_string uses the global C locale. In practice, it’s unlocalized. Also, it often places the decimal points to suboptimal places: 1 2 std::cout &lt;&lt; std::to_string(-1e-7); // prints: -0.000000 std::cout &lt;&lt; std::to_string(0.42); // prints: 0.420000 These outputs are imprecise and often unnecessary. By leveraging std::format (and ultimately std::to_chars), we now get clearer, shorter representations. The representations of floating-point overloads become also unlocalized and use the shortest decimal representations. As a result, the above outputs would change as follow: 1 2 std::cout &lt;&lt; std::to_string(-1e-7); // prints: -1e-7 std::cout &lt;&lt; std::to_string(0.42); // prints: 0.42 This change has some effects on existing code. When std::to_string is used with floating-point arguments, the output becomes more precise and/or shorter. Also, when the C locale is explicitly set, the decimal point will no longer be localized. But such usage seems very low. This change is already available in GCC 14. Type checking format args While std::format already performs compile-time checks for format strings, certain errors — particularly those involving dynamic formatting specifications like width or precision — can still lead to runtime errors. For example: 1 std::format(&quot;{:&gt;{}}&quot;, &quot;hello&quot;, &quot;10&quot;); // Runtime error In this case, the dynamic width specifier {} expects an integral type, but receives a const char*, leading to a runtime error. P2757R3 suggests enhancing the basic_format_parse_context to access the types of format arguments during compile-time parsing. This change allows the compiler to detect mismatches between format specifiers and argument types, turning potential runtime errors into compile-time errors. The {fmt} library already implements a similar feature through its compile_parse_context, which stores type-erased information about argument types to facilitate compile-time checks. This change is already available in GCC 15. Formatting pointers P2510R3 makes pointer types compatible with std::format. There is nothing new under the sun in a sense that the options are already available for integer types. While for integer types we already had a rich selection of formatting options, for pointer types it’s been not the case. We either had to compromise or use some tricks. Like using reinterpret_cast&lt;uintptr_t&gt; or writing a custom formatter. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;format&gt; int main() { auto ptr = new int(42); std::cout &lt;&lt; &amp;ptr &lt;&lt; &#39;\n&#39;; // std::cout &lt;&lt; std::format(&quot;{:#018x}&quot;, ptr) &lt;&lt; &#39;\n&#39;; // error in C++23 std::cout &lt;&lt; std::format(&quot;{:#018x}&quot;, reinterpret_cast&lt;uintptr_t&gt;(ptr)) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::format(&quot;{:#018X}&quot;, reinterpret_cast&lt;uintptr_t&gt;(ptr)) &lt;&lt; &#39;\n&#39;; delete ptr; } With this proposal two kinds of formatting will be available for pointer types: zero padding, so std::format(&quot;{:018}&quot;, ptr); would result in an output like 0x00007ffe0325c4e4 lower/uppercase output with p or P, so std::format(&quot;{:P}&quot;, ptr); would result in output like 0X7FFE0325C4E4 This change is already available in all the three major compilers, GCC 15, Clang 17 and MSVC 19.40. Member std::basic_format_arg::visit() P2637R3 brings member visit functions. Up until now, std::visit and std::visit_format_arg were only available as free standing functions. For std::visit_format_arg, the main reason was to mimic std::visit. For std::visit, the reason was the need to forward constness and value categories. But with C++23’s deducing this, these requirements can be satisfied by member functions. Have you already used std::basic_format_arg? It was introduced by C++20 and it provides access to a formatting arguments. It behaves like a variant of most of the builtin types, plus some more. Let’s have a look at the examples from the standard how this proposal changes the code we have to write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Before: auto format(S s, format_context&amp; ctx) { int width = visit_format_arg([](auto value) -&gt; int { if constexpr (!is_integral_v&lt;decltype(value)&gt;) throw format_error(&quot;width is not integral&quot;); else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max()) throw format_error(&quot;invalid width&quot;); else return value; }, ctx.arg(width_arg_id)); return format_to(ctx.out(), &quot;{0:x&lt;{1}}&quot;, s.value, width); } // After: auto format(S s, format_context&amp; ctx) { int width = ctx.arg(width_arg_id).visit([](auto value) -&gt; int { if constexpr (!is_integral_v&lt;decltype(value)&gt;) throw format_error(&quot;width is not integral&quot;); else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max()) throw format_error(&quot;invalid width&quot;); else return value; }); return format_to(ctx.out(), &quot;{0:x&lt;{1}}&quot;, s.value, width); } This change is already available in GCC 15 and Clang 18/19 (std::variant/stdbasic_format_arg). Conclusion C++26 is shaping up to be a great release for anyone using std::format. Whether it’s more accurate outputs, safer templates, or simpler code, these updates make it even easier to use. Stay tuned for Part 2, where we’ll explore runtime formatting improvements, fixes for undefined behavior, and new formatters for standard types like std::filesystem::path. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="C++26 brings a series of improvements to std::format, continuing the work started in C++20 and refined in C++23. These changes improve formatting consistency, runtime safety, and user ergonomics. There are so many of these updates, that I decided to divide them into two articles. Arithmetic overloads of std::to_string and std::to_wstring use std::format P2587R3 by Victor Zverovich proposes replacing sprintf with std::format in the arithmetic overloads of std::to_string and std::to_wstring. The motivation? std::to_string has long been known to produce not-so-great and misleading results (differing from iostreams), especially with floating-point values. std::to_string uses the global C locale. In practice, it’s unlocalized. Also, it often places the decimal points to suboptimal places: 1 2 std::cout &lt;&lt; std::to_string(-1e-7); // prints: -0.000000 std::cout &lt;&lt; std::to_string(0.42); // prints: 0.420000 These outputs are imprecise and often unnecessary. By leveraging std::format (and ultimately std::to_chars), we now get clearer, shorter representations. The representations of floating-point overloads become also unlocalized and use the shortest decimal representations. As a result, the above outputs would change as follow: 1 2 std::cout &lt;&lt; std::to_string(-1e-7); // prints: -1e-7 std::cout &lt;&lt; std::to_string(0.42); // prints: 0.42 This change has some effects on existing code. When std::to_string is used with floating-point arguments, the output becomes more precise and/or shorter. Also, when the C locale is explicitly set, the decimal point will no longer be localized. But such usage seems very low. This change is already available in GCC 14. Type checking format args While std::format already performs compile-time checks for format strings, certain errors — particularly those involving dynamic formatting specifications like width or precision — can still lead to runtime errors. For example: 1 std::format(&quot;{:&gt;{}}&quot;, &quot;hello&quot;, &quot;10&quot;); // Runtime error In this case, the dynamic width specifier {} expects an integral type, but receives a const char*, leading to a runtime error. P2757R3 suggests enhancing the basic_format_parse_context to access the types of format arguments during compile-time parsing. This change allows the compiler to detect mismatches between format specifiers and argument types, turning potential runtime errors into compile-time errors. The {fmt} library already implements a similar feature through its compile_parse_context, which stores type-erased information about argument types to facilitate compile-time checks. This change is already available in GCC 15. Formatting pointers P2510R3 makes pointer types compatible with std::format. There is nothing new under the sun in a sense that the options are already available for integer types. While for integer types we already had a rich selection of formatting options, for pointer types it’s been not the case. We either had to compromise or use some tricks. Like using reinterpret_cast&lt;uintptr_t&gt; or writing a custom formatter. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;format&gt; int main() { auto ptr = new int(42); std::cout &lt;&lt; &amp;ptr &lt;&lt; &#39;\n&#39;; // std::cout &lt;&lt; std::format(&quot;{:#018x}&quot;, ptr) &lt;&lt; &#39;\n&#39;; // error in C++23 std::cout &lt;&lt; std::format(&quot;{:#018x}&quot;, reinterpret_cast&lt;uintptr_t&gt;(ptr)) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::format(&quot;{:#018X}&quot;, reinterpret_cast&lt;uintptr_t&gt;(ptr)) &lt;&lt; &#39;\n&#39;; delete ptr; } With this proposal two kinds of formatting will be available for pointer types: zero padding, so std::format(&quot;{:018}&quot;, ptr); would result in an output like 0x00007ffe0325c4e4 lower/uppercase output with p or P, so std::format(&quot;{:P}&quot;, ptr); would result in output like 0X7FFE0325C4E4 This change is already available in all the three major compilers, GCC 15, Clang 17 and MSVC 19.40. Member std::basic_format_arg::visit() P2637R3 brings member visit functions. Up until now, std::visit and std::visit_format_arg were only available as free standing functions. For std::visit_format_arg, the main reason was to mimic std::visit. For std::visit, the reason was the need to forward constness and value categories. But with C++23’s deducing this, these requirements can be satisfied by member functions. Have you already used std::basic_format_arg? It was introduced by C++20 and it provides access to a formatting arguments. It behaves like a variant of most of the builtin types, plus some more. Let’s have a look at the examples from the standard how this proposal changes the code we have to write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Before: auto format(S s, format_context&amp; ctx) { int width = visit_format_arg([](auto value) -&gt; int { if constexpr (!is_integral_v&lt;decltype(value)&gt;) throw format_error(&quot;width is not integral&quot;); else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max()) throw format_error(&quot;invalid width&quot;); else return value; }, ctx.arg(width_arg_id)); return format_to(ctx.out(), &quot;{0:x&lt;{1}}&quot;, s.value, width); } // After: auto format(S s, format_context&amp; ctx) { int width = ctx.arg(width_arg_id).visit([](auto value) -&gt; int { if constexpr (!is_integral_v&lt;decltype(value)&gt;) throw format_error(&quot;width is not integral&quot;); else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max()) throw format_error(&quot;invalid width&quot;); else return value; }); return format_to(ctx.out(), &quot;{0:x&lt;{1}}&quot;, s.value, width); } This change is already available in GCC 15 and Clang 18/19 (std::variant/stdbasic_format_arg). Conclusion C++26 is shaping up to be a great release for anyone using std::format. Whether it’s more accurate outputs, safer templates, or simpler code, these updates make it even easier to use. Stay tuned for Part 2, where we’ll explore runtime formatting improvements, fixes for undefined behavior, and new formatters for standard types like std::filesystem::path. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-09T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++26: std::format improvement (Part 1)" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-07-09T00:00:00+02:00","datePublished":"2025-07-09T00:00:00+02:00","description":"C++26 brings a series of improvements to std::format, continuing the work started in C++20 and refined in C++23. These changes improve formatting consistency, runtime safety, and user ergonomics. There are so many of these updates, that I decided to divide them into two articles. Arithmetic overloads of std::to_string and std::to_wstring use std::format P2587R3 by Victor Zverovich proposes replacing sprintf with std::format in the arithmetic overloads of std::to_string and std::to_wstring. The motivation? std::to_string has long been known to produce not-so-great and misleading results (differing from iostreams), especially with floating-point values. std::to_string uses the global C locale. In practice, it’s unlocalized. Also, it often places the decimal points to suboptimal places: 1 2 std::cout &lt;&lt; std::to_string(-1e-7); // prints: -0.000000 std::cout &lt;&lt; std::to_string(0.42); // prints: 0.420000 These outputs are imprecise and often unnecessary. By leveraging std::format (and ultimately std::to_chars), we now get clearer, shorter representations. The representations of floating-point overloads become also unlocalized and use the shortest decimal representations. As a result, the above outputs would change as follow: 1 2 std::cout &lt;&lt; std::to_string(-1e-7); // prints: -1e-7 std::cout &lt;&lt; std::to_string(0.42); // prints: 0.42 This change has some effects on existing code. When std::to_string is used with floating-point arguments, the output becomes more precise and/or shorter. Also, when the C locale is explicitly set, the decimal point will no longer be localized. But such usage seems very low. This change is already available in GCC 14. Type checking format args While std::format already performs compile-time checks for format strings, certain errors — particularly those involving dynamic formatting specifications like width or precision — can still lead to runtime errors. For example: 1 std::format(&quot;{:&gt;{}}&quot;, &quot;hello&quot;, &quot;10&quot;); // Runtime error In this case, the dynamic width specifier {} expects an integral type, but receives a const char*, leading to a runtime error. P2757R3 suggests enhancing the basic_format_parse_context to access the types of format arguments during compile-time parsing. This change allows the compiler to detect mismatches between format specifiers and argument types, turning potential runtime errors into compile-time errors. The {fmt} library already implements a similar feature through its compile_parse_context, which stores type-erased information about argument types to facilitate compile-time checks. This change is already available in GCC 15. Formatting pointers P2510R3 makes pointer types compatible with std::format. There is nothing new under the sun in a sense that the options are already available for integer types. While for integer types we already had a rich selection of formatting options, for pointer types it’s been not the case. We either had to compromise or use some tricks. Like using reinterpret_cast&lt;uintptr_t&gt; or writing a custom formatter. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;format&gt; int main() { auto ptr = new int(42); std::cout &lt;&lt; &amp;ptr &lt;&lt; &#39;\\n&#39;; // std::cout &lt;&lt; std::format(&quot;{:#018x}&quot;, ptr) &lt;&lt; &#39;\\n&#39;; // error in C++23 std::cout &lt;&lt; std::format(&quot;{:#018x}&quot;, reinterpret_cast&lt;uintptr_t&gt;(ptr)) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::format(&quot;{:#018X}&quot;, reinterpret_cast&lt;uintptr_t&gt;(ptr)) &lt;&lt; &#39;\\n&#39;; delete ptr; } With this proposal two kinds of formatting will be available for pointer types: zero padding, so std::format(&quot;{:018}&quot;, ptr); would result in an output like 0x00007ffe0325c4e4 lower/uppercase output with p or P, so std::format(&quot;{:P}&quot;, ptr); would result in output like 0X7FFE0325C4E4 This change is already available in all the three major compilers, GCC 15, Clang 17 and MSVC 19.40. Member std::basic_format_arg::visit() P2637R3 brings member visit functions. Up until now, std::visit and std::visit_format_arg were only available as free standing functions. For std::visit_format_arg, the main reason was to mimic std::visit. For std::visit, the reason was the need to forward constness and value categories. But with C++23’s deducing this, these requirements can be satisfied by member functions. Have you already used std::basic_format_arg? It was introduced by C++20 and it provides access to a formatting arguments. It behaves like a variant of most of the builtin types, plus some more. Let’s have a look at the examples from the standard how this proposal changes the code we have to write: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 // Before: auto format(S s, format_context&amp; ctx) { int width = visit_format_arg([](auto value) -&gt; int { if constexpr (!is_integral_v&lt;decltype(value)&gt;) throw format_error(&quot;width is not integral&quot;); else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max()) throw format_error(&quot;invalid width&quot;); else return value; }, ctx.arg(width_arg_id)); return format_to(ctx.out(), &quot;{0:x&lt;{1}}&quot;, s.value, width); } // After: auto format(S s, format_context&amp; ctx) { int width = ctx.arg(width_arg_id).visit([](auto value) -&gt; int { if constexpr (!is_integral_v&lt;decltype(value)&gt;) throw format_error(&quot;width is not integral&quot;); else if (value &lt; 0 || value &gt; numeric_limits&lt;int&gt;::max()) throw format_error(&quot;invalid width&quot;); else return value; }); return format_to(ctx.out(), &quot;{0:x&lt;{1}}&quot;, s.value, width); } This change is already available in GCC 15 and Clang 18/19 (std::variant/stdbasic_format_arg). Conclusion C++26 is shaping up to be a great release for anyone using std::format. Whether it’s more accurate outputs, safer templates, or simpler code, these updates make it even easier to use. Stay tuned for Part 2, where we’ll explore runtime formatting improvements, fixes for undefined behavior, and new formatters for standard types like std::filesystem::path. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++26: std::format improvement (Part 1)","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1"},"url":"https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1"}</script><title>C++26: std::format improvement (Part 1) | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/09"> 09 </a> </span> <span>C++26: std::format improvement (Part 1)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++26: std::format improvement (Part 1)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 9, 2025, 12:00 AM +0200" prep="on" > Jul 9, 2025 <i class="unloaded">2025-07-09T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="855 words">4 min</span></div></div><div class="post-content"><p>C++26 brings a series of improvements to <code class="language-plaintext highlighter-rouge">std::format</code>, continuing the work started in C++20 and refined in C++23. These changes improve formatting consistency, runtime safety, and user ergonomics. There are so many of these updates, that I decided to divide them into two articles.</p><h2 id="arithmetic-overloads-of-stdto_string-and-stdto_wstring-use-stdformat">Arithmetic overloads of <code class="language-plaintext highlighter-rouge">std::to_string</code> and <code class="language-plaintext highlighter-rouge">std::to_wstring</code> use <code class="language-plaintext highlighter-rouge">std::format</code></h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2587r3.html">P2587R3</a> by Victor Zverovich proposes replacing <code class="language-plaintext highlighter-rouge">sprintf</code> with <code class="language-plaintext highlighter-rouge">std::format</code> in the arithmetic overloads of <code class="language-plaintext highlighter-rouge">std::to_string</code> and <code class="language-plaintext highlighter-rouge">std::to_wstring</code>.</p><p>The motivation?</p><p><code class="language-plaintext highlighter-rouge">std::to_string</code> has long been known to produce not-so-great and misleading results (differing from <code class="language-plaintext highlighter-rouge">iostreams</code>), especially with floating-point values. <code class="language-plaintext highlighter-rouge">std::to_string</code> uses the global C locale. In practice, it’s unlocalized. Also, it often places the decimal points to suboptimal places:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="o">-</span><span class="mf">1e-7</span><span class="p">);</span>  <span class="c1">// prints: -0.000000</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="mf">0.42</span><span class="p">);</span> <span class="c1">// prints: 0.420000</span>
</pre></table></code></div></div><p>These outputs are imprecise and often unnecessary. By leveraging <code class="language-plaintext highlighter-rouge">std::format</code> (and ultimately <code class="language-plaintext highlighter-rouge">std::to_chars</code>), we now get clearer, shorter representations. The representations of floating-point overloads become also unlocalized and use the shortest decimal representations.</p><p>As a result, the above outputs would change as follow:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="o">-</span><span class="mf">1e-7</span><span class="p">);</span>  <span class="c1">// prints: -1e-7</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="mf">0.42</span><span class="p">);</span> <span class="c1">// prints: 0.42</span>
</pre></table></code></div></div><p>This change has some effects on existing code. When <code class="language-plaintext highlighter-rouge">std::to_string</code> is used with floating-point arguments, the output becomes more precise and/or shorter. Also, when the C locale is explicitly set, the decimal point will no longer be localized. But such usage seems very low.</p><p>This change is already available in GCC 14.</p><h2 id="type-checking-format-args">Type checking format args</h2><p>While <code class="language-plaintext highlighter-rouge">std::format</code> already performs compile-time checks for format strings, certain errors — particularly those involving dynamic formatting specifications like width or precision — can still lead to runtime errors.</p><p>For example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:&gt;{}}"</span><span class="p">,</span> <span class="s">"hello"</span><span class="p">,</span> <span class="s">"10"</span><span class="p">);</span> <span class="c1">// Runtime error</span>
</pre></table></code></div></div><p>In this case, the dynamic width specifier <code class="language-plaintext highlighter-rouge">{}</code> expects an integral type, but receives a <code class="language-plaintext highlighter-rouge">const char*</code>, leading to a runtime error.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2757r3.html">P2757R3</a> suggests enhancing the <code class="language-plaintext highlighter-rouge">basic_format_parse_context</code> to access the types of format arguments during compile-time parsing. This change allows the compiler to detect mismatches between format specifiers and argument types, turning potential runtime errors into compile-time errors.</p><p>The <code class="language-plaintext highlighter-rouge">{fmt}</code> library already implements a similar feature through its compile_parse_context, which stores type-erased information about argument types to facilitate compile-time checks.</p><p>This change is already available in GCC 15.</p><h2 id="formatting-pointers">Formatting pointers</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2510r3.pdf">P2510R3</a> makes pointer types compatible with <code class="language-plaintext highlighter-rouge">std::format</code>. There is nothing new under the sun in a sense that the options are already available for integer types.</p><p>While for integer types we already had a rich selection of formatting options, for pointer types it’s been not the case. We either had to compromise or use some tricks. Like using <code class="language-plaintext highlighter-rouge">reinterpret_cast&lt;uintptr_t&gt;</code> or writing a custom formatter.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> 
    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">(</span><span class="mi">42</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">ptr</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::cout &lt;&lt; std::format("{:#018x}", ptr) &lt;&lt; '\n'; // error in C++23</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:#018x}"</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:#018X}"</span><span class="p">,</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">uintptr_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ptr</span><span class="p">))</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
<span class="p">}</span> 
</pre></table></code></div></div><p>With this proposal two kinds of formatting will be available for pointer types:</p><ul><li>zero padding, so <code class="language-plaintext highlighter-rouge">std::format("{:018}", ptr);</code> would result in an output like <code class="language-plaintext highlighter-rouge">0x00007ffe0325c4e4</code><li>lower/uppercase output with <code class="language-plaintext highlighter-rouge">p</code> or <code class="language-plaintext highlighter-rouge">P</code>, so <code class="language-plaintext highlighter-rouge">std::format("{:P}", ptr);</code> would result in output like <code class="language-plaintext highlighter-rouge">0X7FFE0325C4E4</code></ul><p>This change is already available in all the three major compilers, GCC 15, Clang 17 and MSVC 19.40.</p><h2 id="member-stdbasic_format_argvisit">Member <code class="language-plaintext highlighter-rouge">std::basic_format_arg::visit()</code></h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2023/p2637r3.html">P2637R3</a> brings member <code class="language-plaintext highlighter-rouge">visit</code> functions. Up until now, <code class="language-plaintext highlighter-rouge">std::visit</code> and <code class="language-plaintext highlighter-rouge">std::visit_format_arg</code> were only available as free standing functions.</p><p>For <code class="language-plaintext highlighter-rouge">std::visit_format_arg</code>, the main reason was to mimic <code class="language-plaintext highlighter-rouge">std::visit</code>. For <code class="language-plaintext highlighter-rouge">std::visit</code>, the reason was the need to forward constness and value categories. But with <a href="https://www.sandordargo.com/blog/2022/02/16/deducing-this-cpp23">C++23’s deducing <code class="language-plaintext highlighter-rouge">this</code></a>, these requirements can be satisfied by member functions.</p><blockquote><p>Have you already used <code class="language-plaintext highlighter-rouge">std::basic_format_arg</code>? It was introduced by C++20 and it provides access to a formatting arguments. It behaves like a variant of most of the builtin types, plus some more.</p></blockquote><p>Let’s have a look at the examples from the standard how this proposal changes the code we have to write:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="c1">// Before:</span>
<span class="k">auto</span> <span class="nf">format</span><span class="p">(</span><span class="n">S</span> <span class="n">s</span><span class="p">,</span> <span class="n">format_context</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">visit_format_arg</span><span class="p">([](</span><span class="k">auto</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="o">!</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span>
      <span class="k">throw</span> <span class="n">format_error</span><span class="p">(</span><span class="s">"width is not integral"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span>
      <span class="k">throw</span> <span class="n">format_error</span><span class="p">(</span><span class="s">"invalid width"</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">},</span> <span class="n">ctx</span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">width_arg_id</span><span class="p">));</span>
  <span class="k">return</span> <span class="nf">format_to</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">out</span><span class="p">(),</span> <span class="s">"{0:x&lt;{1}}"</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// After:</span>
<span class="k">auto</span> <span class="nf">format</span><span class="p">(</span><span class="n">S</span> <span class="n">s</span><span class="p">,</span> <span class="n">format_context</span><span class="o">&amp;</span> <span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">width</span> <span class="o">=</span> <span class="n">ctx</span><span class="p">.</span><span class="n">arg</span><span class="p">(</span><span class="n">width_arg_id</span><span class="p">).</span><span class="n">visit</span><span class="p">([](</span><span class="k">auto</span> <span class="n">value</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="o">!</span><span class="n">is_integral_v</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">value</span><span class="p">)</span><span class="o">&gt;</span><span class="p">)</span>
      <span class="k">throw</span> <span class="n">format_error</span><span class="p">(</span><span class="s">"width is not integral"</span><span class="p">);</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">value</span> <span class="o">&gt;</span> <span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">())</span>
      <span class="k">throw</span> <span class="n">format_error</span><span class="p">(</span><span class="s">"invalid width"</span><span class="p">);</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">value</span><span class="p">;</span>
    <span class="p">});</span>
  <span class="k">return</span> <span class="nf">format_to</span><span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">out</span><span class="p">(),</span> <span class="s">"{0:x&lt;{1}}"</span><span class="p">,</span> <span class="n">s</span><span class="p">.</span><span class="n">value</span><span class="p">,</span> <span class="n">width</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This change is already available in GCC 15 and Clang 18/19 (<code class="language-plaintext highlighter-rouge">std::variant</code>/<code class="language-plaintext highlighter-rouge">stdbasic_format_arg</code>).</p><h2 id="conclusion">Conclusion</h2><p>C++26 is shaping up to be a great release for anyone using <code class="language-plaintext highlighter-rouge">std::format</code>. Whether it’s more accurate outputs, safer templates, or simpler code, these updates make it even easier to use.</p><p>Stay tuned for Part 2, where we’ll explore runtime formatting improvements, fixes for undefined behavior, and new formatters for standard types like <code class="language-plaintext highlighter-rouge">std::filesystem::path</code>.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp26/" class="post-tag no-text-decoration" >cpp26</a> <a href="/tags/format/" class="post-tag no-text-decoration" >format</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++26: std::format improvement (Part 1) - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++26: std::format improvement (Part 1) - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++26: std::format improvement (Part 1) - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++26: std::format improvement (Part 1) - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/07/16/cpp26-format-part-2"><div class="card-body"> <span class="timeago small" > Jul 16, 2025 <i class="unloaded">2025-07-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: std::format improvements (Part 2)</h3><div class="text-muted small"><p> In Part 1, we explored the improvements C++26 brings to std::format — from better to_string behavior to compile-time safety checks. In this part, we look at runtime formatting, defect fixes, and su...</p></div></div></a></div><div class="card"> <a href="/blog/2024/05/29/cpp23-chrono"><div class="card-body"> <span class="timeago small" > May 29, 2024 <i class="unloaded">2024-05-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: chrono related changes</h3><div class="text-muted small"><p> Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one...</p></div></div></a></div><div class="card"> <a href="/blog/2024/12/11/start-exploring-cpp26"><div class="card-body"> <span class="timeago small" > Dec 11, 2024 <i class="unloaded">2024-12-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's start exploring C++26</h3><div class="text-muted small"><p> During the last 2 years, we spent a lot of time exploring C++23 resulting in almost 40 blog posts. I’m not saying that we covered every single new language or library feature, but we covered most o...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/07/02/cpponsea-trip-report" class="btn btn-outline-primary" prompt="Older"><p>Trip report: C++ On Sea 2025</p></a> <a href="/blog/2025/07/16/cpp26-format-part-2" class="btn btn-outline-primary" prompt="Newer"><p>C++26: std::format improvements (Part 2)</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++26: std::format improvement (Part 1)'; this.page.url = 'https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1'; this.page.identifier = '/blog/2025/07/09/cpp26-format-part-1'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
