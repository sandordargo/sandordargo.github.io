<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Format your own type (Part 1)" /><meta property="og:locale" content="en_US" /><meta name="description" content="I recently published two posts about how C++26 improves std::format and the related facilities. (If you missed them, here are Part 1 and Part 2). Now it’s time to explore how you can format your own types using std::format. But let’s start from the beginning. Print to the console with std::format std::format was introduced in C++20 and is based on Victor Zverovich’s &lt;fmt&gt; library, which in turn was inspired by Python’s string formatting capabilities. Let’s skip the fancy formatting options and simply see how to interpolate values using std::format. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string language{&quot;C++&quot;}; int version{20}; std::cout &lt;&lt; std::format(&quot;{}{} is fun&quot;, language, version) &lt;&lt; &#39;\n&#39;; } /* C++20 is fun */ That was easy. Now imagine you want to print your own type. That won’t work by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; // ERROR } You’ll see a long error message, but the essential part is this: 1 2 /opt/compiler-explorer/gcc-trunk-20250609/include/c++/16.0.0/format:4995:10: error: static assertion failed: std::formatter must be specialized for each type being formatted 4995 | (is_default_constructible_v&lt;formatter&lt;_Args, _CharT&gt;&gt; &amp;&amp; ...), We need to specialize std::formatter. Specialize std::formatter the easy way To create a valid specialization, we need two methods with specific signatures: parse format The parse method processes format specifiers, and format generates the formatted output. Here is a minimal but working example, something we can survive with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; template &lt;&gt; struct std::formatter&lt;ProgrammingLanguage&gt; { std::formatter&lt;std::string&gt; _formatter; constexpr auto parse(std::format_parse_context&amp; parse_context) { return _formatter.parse(parse_context); } auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { std::string output = std::format(&quot;{}{}&quot;, programming_language.name, programming_language.version); return _formatter.format(output, format_context); } }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; } parse is as simple as it gets, it simply delegates parsing format_parse_context to the member formatter of a string. format is a bit more interesting. First of all, we mark it auto to avoid typing the return type, which is std::format_context::iterator. In this example, we opted for a simple implementation where we take members of an instance of ProgrammingLanguage and use them directly to create a string. A more sophisticated formatter Sometimes simple output isn’t enough. Consider this: For C++, “C++20” looks fine. But for Python, “Python312” is not ideal — we’d prefer “Python 3.12”. This means we want: A space between name and version for some languages Support for complex version numbers Let’s first handle spaces. We want this: 1 2 3 4 5 ProgrammingLanguage cpp{&quot;C++&quot;, 20}; ProgrammingLanguage python{&quot;Python&quot;, 312}; std::cout &lt;&lt; std::format(&quot;{:%n%v} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; // C++20 is fun std::cout &lt;&lt; std::format(&quot;{:%n %v} is fun&quot;, python) &lt;&lt; &#39;\n&#39;; // Python 312 is fun But how to handle the formatters? In parse() we can assume that our parse_context begins at a { and we need to return an iterator to the closing brace (}). All what’s inside we save into a member string (&quot;:%n%v&quot; and &quot;:%n %v&quot; in the above example). That’s what we’ll have to interpret while formatting. 1 2 3 4 5 constexpr auto parse(std::format_parse_context&amp; parse_context) { auto it = std::ranges::find(parse_context, &#39;}&#39;); _attributes = std::string(parse_context.begin(), it); return it; } The role of format() is to actually go through the _attributes string and format the output accordingly. Let’s have a look at the below piece of code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { auto out = format_context.out(); for (auto n = 0u; n &lt; _attributes.size() - 1; ++n) { if (_attributes[n] == &#39;%&#39;) { switch (_attributes[++n]) { case &#39;n&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.name); break; case &#39;v&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.version); break; case &#39;%&#39;: out = std::format_to(out, &quot;%&quot;); break; } } else { out = std::format_to(out, &quot;{}&quot;, _attributes[n]); } } return out; } The idea is to iterate over the attributes string and if a character is % then we interpret the next character as a formatter and increment the iteration further. %n will be interpreted as a name, %v as a version and %% is escaped to %. If a character is not % we just add it to the output. Are we good? The problem is that if we try to print something without any formatters, we won’t get anything! Worse than that std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; results in a segmentation fault. The reason of the segmentation fault is this for loop control: 1 for (auto n = 0u; n &lt; _attributes.size() - 1; ++n) If _attributes.size() is 0, then subtracting 1 from it won’t result in -1, but in std::numeric_limits&lt;unsigned int&gt;::max() - 1, which is a fairly big number. And there we have a problem. We can fix it by modifying the comparison to n &lt;= _attributes.size(); Now std::format(&quot;{} is fun&quot;, cpp) results in an empty string. Not ideal. Let’s handle empty attributes separately, as a default case. 1 2 3 4 5 if (_attributes.empty()) { out = std::format_to(out, &quot;{}{}&quot;, programming_language.name, programming_language.version); return out; } That’s pretty similar to what we had in the previous example. Our code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // https://godbolt.org/z/sTnKoz7c6 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; template &lt;&gt; struct std::formatter&lt;ProgrammingLanguage&gt; { std::string _attributes; constexpr auto parse(std::format_parse_context&amp; parse_context) { auto it = std::ranges::find(parse_context, &#39;}&#39;); _attributes = std::string(parse_context.begin(), it); return it; } auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { auto out = format_context.out(); if (_attributes.empty()) { out = std::format_to(out, &quot;{}{}&quot;, programming_language.name, programming_language.version); return out; } for (auto n = 0u; n &lt;= _attributes.size(); ++n) { if (_attributes[n] == &#39;%&#39;) { switch (_attributes[++n]) { case &#39;n&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.name); break; case &#39;v&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.version); break; case &#39;%&#39;: out = std::format_to(out, &quot;%&quot;); break; } } else { out = std::format_to(out, &quot;{}&quot;, _attributes[n]); } } return out; } }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; ProgrammingLanguage python{&quot;Python&quot;, 312}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::format(&quot;{:%n%v} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::format(&quot;{:%n %v} is fun&quot;, python) &lt;&lt; &#39;\n&#39;; } /* C++20 is fun C++20 is fun Python 312 is fun */ We will continue next week to handle multi-number versions. Conclusion We’ve seen how to make std::format work with your custom types — from basic support to handling user-defined format strings. This not only makes your code cleaner but also enables richer formatting capabilities tailored to your domain. In the next article, we’ll take this one step further by implementing support for more complex version formats, such as 3.12 instead of just 312, and explore how to integrate conditional formatting logic based on the language type. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I recently published two posts about how C++26 improves std::format and the related facilities. (If you missed them, here are Part 1 and Part 2). Now it’s time to explore how you can format your own types using std::format. But let’s start from the beginning. Print to the console with std::format std::format was introduced in C++20 and is based on Victor Zverovich’s &lt;fmt&gt; library, which in turn was inspired by Python’s string formatting capabilities. Let’s skip the fancy formatting options and simply see how to interpolate values using std::format. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string language{&quot;C++&quot;}; int version{20}; std::cout &lt;&lt; std::format(&quot;{}{} is fun&quot;, language, version) &lt;&lt; &#39;\n&#39;; } /* C++20 is fun */ That was easy. Now imagine you want to print your own type. That won’t work by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; // ERROR } You’ll see a long error message, but the essential part is this: 1 2 /opt/compiler-explorer/gcc-trunk-20250609/include/c++/16.0.0/format:4995:10: error: static assertion failed: std::formatter must be specialized for each type being formatted 4995 | (is_default_constructible_v&lt;formatter&lt;_Args, _CharT&gt;&gt; &amp;&amp; ...), We need to specialize std::formatter. Specialize std::formatter the easy way To create a valid specialization, we need two methods with specific signatures: parse format The parse method processes format specifiers, and format generates the formatted output. Here is a minimal but working example, something we can survive with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; template &lt;&gt; struct std::formatter&lt;ProgrammingLanguage&gt; { std::formatter&lt;std::string&gt; _formatter; constexpr auto parse(std::format_parse_context&amp; parse_context) { return _formatter.parse(parse_context); } auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { std::string output = std::format(&quot;{}{}&quot;, programming_language.name, programming_language.version); return _formatter.format(output, format_context); } }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; } parse is as simple as it gets, it simply delegates parsing format_parse_context to the member formatter of a string. format is a bit more interesting. First of all, we mark it auto to avoid typing the return type, which is std::format_context::iterator. In this example, we opted for a simple implementation where we take members of an instance of ProgrammingLanguage and use them directly to create a string. A more sophisticated formatter Sometimes simple output isn’t enough. Consider this: For C++, “C++20” looks fine. But for Python, “Python312” is not ideal — we’d prefer “Python 3.12”. This means we want: A space between name and version for some languages Support for complex version numbers Let’s first handle spaces. We want this: 1 2 3 4 5 ProgrammingLanguage cpp{&quot;C++&quot;, 20}; ProgrammingLanguage python{&quot;Python&quot;, 312}; std::cout &lt;&lt; std::format(&quot;{:%n%v} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; // C++20 is fun std::cout &lt;&lt; std::format(&quot;{:%n %v} is fun&quot;, python) &lt;&lt; &#39;\n&#39;; // Python 312 is fun But how to handle the formatters? In parse() we can assume that our parse_context begins at a { and we need to return an iterator to the closing brace (}). All what’s inside we save into a member string (&quot;:%n%v&quot; and &quot;:%n %v&quot; in the above example). That’s what we’ll have to interpret while formatting. 1 2 3 4 5 constexpr auto parse(std::format_parse_context&amp; parse_context) { auto it = std::ranges::find(parse_context, &#39;}&#39;); _attributes = std::string(parse_context.begin(), it); return it; } The role of format() is to actually go through the _attributes string and format the output accordingly. Let’s have a look at the below piece of code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { auto out = format_context.out(); for (auto n = 0u; n &lt; _attributes.size() - 1; ++n) { if (_attributes[n] == &#39;%&#39;) { switch (_attributes[++n]) { case &#39;n&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.name); break; case &#39;v&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.version); break; case &#39;%&#39;: out = std::format_to(out, &quot;%&quot;); break; } } else { out = std::format_to(out, &quot;{}&quot;, _attributes[n]); } } return out; } The idea is to iterate over the attributes string and if a character is % then we interpret the next character as a formatter and increment the iteration further. %n will be interpreted as a name, %v as a version and %% is escaped to %. If a character is not % we just add it to the output. Are we good? The problem is that if we try to print something without any formatters, we won’t get anything! Worse than that std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; results in a segmentation fault. The reason of the segmentation fault is this for loop control: 1 for (auto n = 0u; n &lt; _attributes.size() - 1; ++n) If _attributes.size() is 0, then subtracting 1 from it won’t result in -1, but in std::numeric_limits&lt;unsigned int&gt;::max() - 1, which is a fairly big number. And there we have a problem. We can fix it by modifying the comparison to n &lt;= _attributes.size(); Now std::format(&quot;{} is fun&quot;, cpp) results in an empty string. Not ideal. Let’s handle empty attributes separately, as a default case. 1 2 3 4 5 if (_attributes.empty()) { out = std::format_to(out, &quot;{}{}&quot;, programming_language.name, programming_language.version); return out; } That’s pretty similar to what we had in the previous example. Our code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // https://godbolt.org/z/sTnKoz7c6 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; template &lt;&gt; struct std::formatter&lt;ProgrammingLanguage&gt; { std::string _attributes; constexpr auto parse(std::format_parse_context&amp; parse_context) { auto it = std::ranges::find(parse_context, &#39;}&#39;); _attributes = std::string(parse_context.begin(), it); return it; } auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { auto out = format_context.out(); if (_attributes.empty()) { out = std::format_to(out, &quot;{}{}&quot;, programming_language.name, programming_language.version); return out; } for (auto n = 0u; n &lt;= _attributes.size(); ++n) { if (_attributes[n] == &#39;%&#39;) { switch (_attributes[++n]) { case &#39;n&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.name); break; case &#39;v&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.version); break; case &#39;%&#39;: out = std::format_to(out, &quot;%&quot;); break; } } else { out = std::format_to(out, &quot;{}&quot;, _attributes[n]); } } return out; } }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; ProgrammingLanguage python{&quot;Python&quot;, 312}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::format(&quot;{:%n%v} is fun&quot;, cpp) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::format(&quot;{:%n %v} is fun&quot;, python) &lt;&lt; &#39;\n&#39;; } /* C++20 is fun C++20 is fun Python 312 is fun */ We will continue next week to handle multi-number versions. Conclusion We’ve seen how to make std::format work with your custom types — from basic support to handling user-defined format strings. This not only makes your code cleaner but also enables richer formatting capabilities tailored to your domain. In the next article, we’ll take this one step further by implementing support for more complex version formats, such as 3.12 instead of just 312, and explore how to integrate conditional formatting logic based on the language type. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-07-23T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Format your own type (Part 1)" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-08-02T22:45:51+02:00","datePublished":"2025-07-23T00:00:00+02:00","description":"I recently published two posts about how C++26 improves std::format and the related facilities. (If you missed them, here are Part 1 and Part 2). Now it’s time to explore how you can format your own types using std::format. But let’s start from the beginning. Print to the console with std::format std::format was introduced in C++20 and is based on Victor Zverovich’s &lt;fmt&gt; library, which in turn was inspired by Python’s string formatting capabilities. Let’s skip the fancy formatting options and simply see how to interpolate values using std::format. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::string language{&quot;C++&quot;}; int version{20}; std::cout &lt;&lt; std::format(&quot;{}{} is fun&quot;, language, version) &lt;&lt; &#39;\\n&#39;; } /* C++20 is fun */ That was easy. Now imagine you want to print your own type. That won’t work by default. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\\n&#39;; // ERROR } You’ll see a long error message, but the essential part is this: 1 2 /opt/compiler-explorer/gcc-trunk-20250609/include/c++/16.0.0/format:4995:10: error: static assertion failed: std::formatter must be specialized for each type being formatted 4995 | (is_default_constructible_v&lt;formatter&lt;_Args, _CharT&gt;&gt; &amp;&amp; ...), We need to specialize std::formatter. Specialize std::formatter the easy way To create a valid specialization, we need two methods with specific signatures: parse format The parse method processes format specifiers, and format generates the formatted output. Here is a minimal but working example, something we can survive with: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; template &lt;&gt; struct std::formatter&lt;ProgrammingLanguage&gt; { std::formatter&lt;std::string&gt; _formatter; constexpr auto parse(std::format_parse_context&amp; parse_context) { return _formatter.parse(parse_context); } auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { std::string output = std::format(&quot;{}{}&quot;, programming_language.name, programming_language.version); return _formatter.format(output, format_context); } }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\\n&#39;; } parse is as simple as it gets, it simply delegates parsing format_parse_context to the member formatter of a string. format is a bit more interesting. First of all, we mark it auto to avoid typing the return type, which is std::format_context::iterator. In this example, we opted for a simple implementation where we take members of an instance of ProgrammingLanguage and use them directly to create a string. A more sophisticated formatter Sometimes simple output isn’t enough. Consider this: For C++, “C++20” looks fine. But for Python, “Python312” is not ideal — we’d prefer “Python 3.12”. This means we want: A space between name and version for some languages Support for complex version numbers Let’s first handle spaces. We want this: 1 2 3 4 5 ProgrammingLanguage cpp{&quot;C++&quot;, 20}; ProgrammingLanguage python{&quot;Python&quot;, 312}; std::cout &lt;&lt; std::format(&quot;{:%n%v} is fun&quot;, cpp) &lt;&lt; &#39;\\n&#39;; // C++20 is fun std::cout &lt;&lt; std::format(&quot;{:%n %v} is fun&quot;, python) &lt;&lt; &#39;\\n&#39;; // Python 312 is fun But how to handle the formatters? In parse() we can assume that our parse_context begins at a { and we need to return an iterator to the closing brace (}). All what’s inside we save into a member string (&quot;:%n%v&quot; and &quot;:%n %v&quot; in the above example). That’s what we’ll have to interpret while formatting. 1 2 3 4 5 constexpr auto parse(std::format_parse_context&amp; parse_context) { auto it = std::ranges::find(parse_context, &#39;}&#39;); _attributes = std::string(parse_context.begin(), it); return it; } The role of format() is to actually go through the _attributes string and format the output accordingly. Let’s have a look at the below piece of code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { auto out = format_context.out(); for (auto n = 0u; n &lt; _attributes.size() - 1; ++n) { if (_attributes[n] == &#39;%&#39;) { switch (_attributes[++n]) { case &#39;n&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.name); break; case &#39;v&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.version); break; case &#39;%&#39;: out = std::format_to(out, &quot;%&quot;); break; } } else { out = std::format_to(out, &quot;{}&quot;, _attributes[n]); } } return out; } The idea is to iterate over the attributes string and if a character is % then we interpret the next character as a formatter and increment the iteration further. %n will be interpreted as a name, %v as a version and %% is escaped to %. If a character is not % we just add it to the output. Are we good? The problem is that if we try to print something without any formatters, we won’t get anything! Worse than that std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\\n&#39;; results in a segmentation fault. The reason of the segmentation fault is this for loop control: 1 for (auto n = 0u; n &lt; _attributes.size() - 1; ++n) If _attributes.size() is 0, then subtracting 1 from it won’t result in -1, but in std::numeric_limits&lt;unsigned int&gt;::max() - 1, which is a fairly big number. And there we have a problem. We can fix it by modifying the comparison to n &lt;= _attributes.size(); Now std::format(&quot;{} is fun&quot;, cpp) results in an empty string. Not ideal. Let’s handle empty attributes separately, as a default case. 1 2 3 4 5 if (_attributes.empty()) { out = std::format_to(out, &quot;{}{}&quot;, programming_language.name, programming_language.version); return out; } That’s pretty similar to what we had in the previous example. Our code looks like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 // https://godbolt.org/z/sTnKoz7c6 #include &lt;format&gt; #include &lt;iostream&gt; #include &lt;string&gt; struct ProgrammingLanguage { std::string name; int version{0}; }; template &lt;&gt; struct std::formatter&lt;ProgrammingLanguage&gt; { std::string _attributes; constexpr auto parse(std::format_parse_context&amp; parse_context) { auto it = std::ranges::find(parse_context, &#39;}&#39;); _attributes = std::string(parse_context.begin(), it); return it; } auto format(const ProgrammingLanguage&amp; programming_language, std::format_context&amp; format_context) const { auto out = format_context.out(); if (_attributes.empty()) { out = std::format_to(out, &quot;{}{}&quot;, programming_language.name, programming_language.version); return out; } for (auto n = 0u; n &lt;= _attributes.size(); ++n) { if (_attributes[n] == &#39;%&#39;) { switch (_attributes[++n]) { case &#39;n&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.name); break; case &#39;v&#39;: out = std::format_to(out, &quot;{}&quot;, programming_language.version); break; case &#39;%&#39;: out = std::format_to(out, &quot;%&quot;); break; } } else { out = std::format_to(out, &quot;{}&quot;, _attributes[n]); } } return out; } }; int main() { ProgrammingLanguage cpp{&quot;C++&quot;, 20}; ProgrammingLanguage python{&quot;Python&quot;, 312}; std::cout &lt;&lt; std::format(&quot;{} is fun&quot;, cpp) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::format(&quot;{:%n%v} is fun&quot;, cpp) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::format(&quot;{:%n %v} is fun&quot;, python) &lt;&lt; &#39;\\n&#39;; } /* C++20 is fun C++20 is fun Python 312 is fun */ We will continue next week to handle multi-number versions. Conclusion We’ve seen how to make std::format work with your custom types — from basic support to handling user-defined format strings. This not only makes your code cleaner but also enables richer formatting capabilities tailored to your domain. In the next article, we’ll take this one step further by implementing support for more complex version formats, such as 3.12 instead of just 312, and explore how to integrate conditional formatting logic based on the language type. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Format your own type (Part 1)","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1"},"url":"https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1"}</script><title>Format your own type (Part 1) | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/23"> 23 </a> </span> <span>Format your own type (Part 1)</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Format your own type (Part 1)</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 23, 2025, 12:00 AM +0200" prep="on" > Jul 23 <i class="unloaded">2025-07-23T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Aug 2, 2025, 10:45 PM +0200" prefix="Updated " > Aug 2 <i class="unloaded">2025-08-02T22:45:51+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1273 words">7 min</span></div></div><div class="post-content"><p>I recently published two posts about how C++26 improves <code class="language-plaintext highlighter-rouge">std::format</code> and the related facilities. (If you missed them, here are <a href="https://www.sandordargo.com/blog/2025/07/09/cpp26-format-part-1">Part 1</a> and <a href="https://www.sandordargo.com/blog/2025/07/16/cpp26-format-part-2">Part 2</a>). Now it’s time to explore how you can <strong>format your own types</strong> using <code class="language-plaintext highlighter-rouge">std::format</code>.</p><p>But let’s start from the beginning.</p><h2 id="print-to-the-console-with-stdformat">Print to the console with <code class="language-plaintext highlighter-rouge">std::format</code></h2><p><code class="language-plaintext highlighter-rouge">std::format</code> was introduced in C++20 and is based on Victor Zverovich’s <code class="language-plaintext highlighter-rouge">&lt;fmt&gt;</code> library, which in turn was inspired by Python’s string formatting capabilities.</p><p>Let’s skip the fancy formatting options and simply see how to interpolate values using <code class="language-plaintext highlighter-rouge">std::format</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">language</span><span class="p">{</span><span class="s">"C++"</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">{</span><span class="mi">20</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{}{} is fun"</span><span class="p">,</span> <span class="n">language</span><span class="p">,</span> <span class="n">version</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
C++20 is fun
*/</span>
</pre></table></code></div></div><p>That was easy.</p><p>Now imagine you want to print your own type. That won’t work by default.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">ProgrammingLanguage</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ProgrammingLanguage</span> <span class="n">cpp</span><span class="p">{</span><span class="s">"C++"</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{} is fun"</span><span class="p">,</span> <span class="n">cpp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// ERROR</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You’ll see a long error message, but the essential part is this:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>/opt/compiler-explorer/gcc-trunk-20250609/include/c++/16.0.0/format:4995:10: error: static assertion failed: std::formatter must be specialized for each type being formatted
 4995 |         (is_default_constructible_v&lt;formatter&lt;_Args, _CharT&gt;&gt; &amp;&amp; ...),
</pre></table></code></div></div><p>We need to specialize <code class="language-plaintext highlighter-rouge">std::formatter</code>.</p><h2 id="specialize-stdformatter-the-easy-way">Specialize <code class="language-plaintext highlighter-rouge">std::formatter</code> the easy way</h2><p>To create a valid specialization, we need two methods with specific signatures:</p><ul><li><code class="language-plaintext highlighter-rouge">parse</code><li><code class="language-plaintext highlighter-rouge">format</code></ul><p>The <code class="language-plaintext highlighter-rouge">parse</code> method processes format specifiers, and <code class="language-plaintext highlighter-rouge">format</code> generates the formatted output.</p><p>Here is a minimal but working example, something we can survive with:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">ProgrammingLanguage</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">formatter</span><span class="o">&lt;</span><span class="n">ProgrammingLanguage</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">formatter</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">_formatter</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">format_parse_context</span><span class="o">&amp;</span> <span class="n">parse_context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">_formatter</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">parse_context</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">format</span><span class="p">(</span><span class="k">const</span> <span class="n">ProgrammingLanguage</span><span class="o">&amp;</span> <span class="n">programming_language</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">format_context</span><span class="o">&amp;</span> <span class="n">format_context</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">output</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{}{}"</span><span class="p">,</span> <span class="n">programming_language</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
                                         <span class="n">programming_language</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">_formatter</span><span class="p">.</span><span class="n">format</span><span class="p">(</span><span class="n">output</span><span class="p">,</span> <span class="n">format_context</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ProgrammingLanguage</span> <span class="n">cpp</span><span class="p">{</span><span class="s">"C++"</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{} is fun"</span><span class="p">,</span> <span class="n">cpp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">parse</code> is as simple as it gets, it simply delegates parsing <code class="language-plaintext highlighter-rouge">format_parse_context</code> to the member formatter of a <code class="language-plaintext highlighter-rouge">string</code>.</p><p><code class="language-plaintext highlighter-rouge">format</code> is a bit more interesting. First of all, we mark it <code class="language-plaintext highlighter-rouge">auto</code> to avoid typing the return type, which is <code class="language-plaintext highlighter-rouge">std::format_context::iterator</code>. In this example, we opted for a simple implementation where we take members of an instance of <code class="language-plaintext highlighter-rouge">ProgrammingLanguage</code> and use them directly to create a string.</p><h2 id="a-more-sophisticated-formatter">A more sophisticated formatter</h2><p>Sometimes simple output isn’t enough. Consider this:</p><ul><li>For C++, “C++20” looks fine.<li>But for Python, “Python312” is not ideal — we’d prefer “Python 3.12”.</ul><p>This means we want:</p><ul><li>A space between name and version for some languages<li>Support for complex version numbers</ul><p>Let’s first handle spaces.</p><p>We want this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">ProgrammingLanguage</span> <span class="n">cpp</span><span class="p">{</span><span class="s">"C++"</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
<span class="n">ProgrammingLanguage</span> <span class="n">python</span><span class="p">{</span><span class="s">"Python"</span><span class="p">,</span> <span class="mi">312</span><span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%n%v} is fun"</span><span class="p">,</span> <span class="n">cpp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>  <span class="c1">// C++20 is fun</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%n %v} is fun"</span><span class="p">,</span> <span class="n">python</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>  <span class="c1">// Python 312 is fun</span>
</pre></table></code></div></div><p>But how to handle the formatters?</p><p>In <code class="language-plaintext highlighter-rouge">parse()</code> we can assume that our <code class="language-plaintext highlighter-rouge">parse_context</code> begins at a <code class="language-plaintext highlighter-rouge">{</code> and we need to return an iterator to the closing brace (<code class="language-plaintext highlighter-rouge">}</code>). All what’s inside we save into a member string (<code class="language-plaintext highlighter-rouge">":%n%v"</code> and <code class="language-plaintext highlighter-rouge">":%n %v"</code> in the above example). That’s what we’ll have to interpret while formatting.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">format_parse_context</span><span class="o">&amp;</span> <span class="n">parse_context</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">parse_context</span><span class="p">,</span> <span class="sc">'}'</span><span class="p">);</span>
    <span class="n">_attributes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">parse_context</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">it</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The role of <code class="language-plaintext highlighter-rouge">format()</code> is to actually go through the <code class="language-plaintext highlighter-rouge">_attributes</code> string and format the output accordingly.</p><p>Let’s have a look at the below piece of code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="nf">format</span><span class="p">(</span><span class="k">const</span> <span class="n">ProgrammingLanguage</span><span class="o">&amp;</span> <span class="n">programming_language</span><span class="p">,</span>
            <span class="n">std</span><span class="o">::</span><span class="n">format_context</span><span class="o">&amp;</span> <span class="n">format_context</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">format_context</span><span class="p">.</span><span class="n">out</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">_attributes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_attributes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'%'</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">switch</span> <span class="p">(</span><span class="n">_attributes</span><span class="p">[</span><span class="o">++</span><span class="n">n</span><span class="p">])</span> <span class="p">{</span>
                <span class="k">case</span> <span class="sc">'n'</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span>
                                         <span class="n">programming_language</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'v'</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span>
                                         <span class="n">programming_language</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
                <span class="k">case</span> <span class="sc">'%'</span><span class="p">:</span>
                    <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"%"</span><span class="p">);</span>
                    <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">_attributes</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The idea is to iterate over the attributes string and if a character is <code class="language-plaintext highlighter-rouge">%</code> then we interpret the next character as a formatter and increment the iteration further. <code class="language-plaintext highlighter-rouge">%n</code> will be interpreted as a name, <code class="language-plaintext highlighter-rouge">%v</code> as a version and <code class="language-plaintext highlighter-rouge">%%</code> is escaped to <code class="language-plaintext highlighter-rouge">%</code>. If a character is not <code class="language-plaintext highlighter-rouge">%</code> we just add it to the output.</p><p>Are we good?</p><p>The problem is that if we try to print something without any formatters, we won’t get anything! Worse than that <code class="language-plaintext highlighter-rouge">std::cout &lt;&lt; std::format("{} is fun", cpp) &lt;&lt; '\n';</code> results in a segmentation fault.</p><p>The reason of the segmentation fault is this <code class="language-plaintext highlighter-rouge">for</code> loop control:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;</span> <span class="n">_attributes</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span>
</pre></table></code></div></div><p>If <code class="language-plaintext highlighter-rouge">_attributes.size()</code> is <code class="language-plaintext highlighter-rouge">0</code>, then subtracting <code class="language-plaintext highlighter-rouge">1</code> from it won’t result in <code class="language-plaintext highlighter-rouge">-1</code>, but in <code class="language-plaintext highlighter-rouge">std::numeric_limits&lt;unsigned int&gt;::max() - 1</code>, which is a fairly big number. And there we have a problem.</p><p>We can fix it by modifying the comparison to <code class="language-plaintext highlighter-rouge">n &lt;= _attributes.size();</code></p><p>Now <code class="language-plaintext highlighter-rouge">std::format("{} is fun", cpp)</code> results in an empty string. Not ideal.</p><p>Let’s handle empty attributes separately, as a default case.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">_attributes</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}{}"</span><span class="p">,</span> <span class="n">programming_language</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
                         <span class="n">programming_language</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That’s pretty similar to what we had in the previous example. Our code looks like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/sTnKoz7c6</span>
<span class="cp">#include</span> <span class="cpf">&lt;format&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">ProgrammingLanguage</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">version</span><span class="p">{</span><span class="mi">0</span><span class="p">};</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">std</span><span class="o">::</span><span class="n">formatter</span><span class="o">&lt;</span><span class="n">ProgrammingLanguage</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">_attributes</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">parse</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">format_parse_context</span><span class="o">&amp;</span> <span class="n">parse_context</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">parse_context</span><span class="p">,</span> <span class="sc">'}'</span><span class="p">);</span>
        <span class="n">_attributes</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">parse_context</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">it</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">it</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="nf">format</span><span class="p">(</span><span class="k">const</span> <span class="n">ProgrammingLanguage</span><span class="o">&amp;</span> <span class="n">programming_language</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">format_context</span><span class="o">&amp;</span> <span class="n">format_context</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">out</span> <span class="o">=</span> <span class="n">format_context</span><span class="p">.</span><span class="n">out</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_attributes</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}{}"</span><span class="p">,</span> <span class="n">programming_language</span><span class="p">.</span><span class="n">name</span><span class="p">,</span>
                                 <span class="n">programming_language</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">;</span> <span class="n">n</span> <span class="o">&lt;=</span> <span class="n">_attributes</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_attributes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">==</span> <span class="sc">'%'</span><span class="p">)</span> <span class="p">{</span>
                <span class="k">switch</span> <span class="p">(</span><span class="n">_attributes</span><span class="p">[</span><span class="o">++</span><span class="n">n</span><span class="p">])</span> <span class="p">{</span>
                    <span class="k">case</span> <span class="sc">'n'</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span>
                                             <span class="n">programming_language</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'v'</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span>
                                             <span class="n">programming_language</span><span class="p">.</span><span class="n">version</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                    <span class="k">case</span> <span class="sc">'%'</span><span class="p">:</span>
                        <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"%"</span><span class="p">);</span>
                        <span class="k">break</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format_to</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s">"{}"</span><span class="p">,</span> <span class="n">_attributes</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ProgrammingLanguage</span> <span class="n">cpp</span><span class="p">{</span><span class="s">"C++"</span><span class="p">,</span> <span class="mi">20</span><span class="p">};</span>
    <span class="n">ProgrammingLanguage</span> <span class="n">python</span><span class="p">{</span><span class="s">"Python"</span><span class="p">,</span> <span class="mi">312</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{} is fun"</span><span class="p">,</span> <span class="n">cpp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%n%v} is fun"</span><span class="p">,</span> <span class="n">cpp</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%n %v} is fun"</span><span class="p">,</span> <span class="n">python</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
C++20 is fun
C++20 is fun
Python 312 is fun
*/</span>
</pre></table></code></div></div><p>We will continue next week to handle multi-number versions.</p><h2 id="conclusion">Conclusion</h2><p>We’ve seen how to make <code class="language-plaintext highlighter-rouge">std::format</code> work with your custom types — from basic support to handling user-defined format strings. This not only makes your code cleaner but also enables richer formatting capabilities tailored to your domain.</p><p>In the next article, we’ll take this one step further by implementing support for more complex version formats, such as <em>3.12</em> instead of just <em>312</em>, and explore how to integrate conditional formatting logic based on the language type.</p><p>Stay tuned!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/format/" class="post-tag no-text-decoration" >format</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Format your own type (Part 1) - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Format your own type (Part 1) - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Format your own type (Part 1) - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Format your own type (Part 1) - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/05/29/cpp23-chrono"><div class="card-body"> <span class="timeago small" > May 29, 2024 <i class="unloaded">2024-05-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: chrono related changes</h3><div class="text-muted small"><p> Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one...</p></div></div></a></div><div class="card"> <a href="/blog/2025/07/09/cpp26-format-part-1"><div class="card-body"> <span class="timeago small" > Jul 9 <i class="unloaded">2025-07-09T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: std::format improvement (Part 1)</h3><div class="text-muted small"><p> C++26 brings a series of improvements to std::format, continuing the work started in C++20 and refined in C++23. These changes improve formatting consistency, runtime safety, and user ergonomics. T...</p></div></div></a></div><div class="card"> <a href="/blog/2025/07/16/cpp26-format-part-2"><div class="card-body"> <span class="timeago small" > Jul 16 <i class="unloaded">2025-07-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: std::format improvements (Part 2)</h3><div class="text-muted small"><p> In Part 1, we explored the improvements C++26 brings to std::format — from better to_string behavior to compile-time safety checks. In this part, we look at runtime formatting, defect fixes, and su...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/07/16/cpp26-format-part-2" class="btn btn-outline-primary" prompt="Older"><p>C++26: std::format improvements (Part 2)</p></a> <a href="/blog/2025/07/30/format-your-own-type-part-2" class="btn btn-outline-primary" prompt="Newer"><p>Format your own type (Part 2)</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Format your own type (Part 1)'; this.page.url = 'https://www.sandordargo.com/blog/2025/07/23/format-your-own-type-part-1'; this.page.identifier = '/blog/2025/07/23/format-your-own-type-part-1'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
