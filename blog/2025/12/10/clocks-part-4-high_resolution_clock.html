<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Time in C++: std::chrono::high_resolution_clock — Myths and Realities" /><meta property="og:locale" content="en_US" /><meta name="description" content="If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like many things in C++, the details matter. In the earlier parts of this series, we looked at system_clock as the wall-clock time source, and at steady_clock as the reliable choice for measuring intervals. This time, we’ll tackle the so-called “high-resolution” clock, separate fact from myth, and see why it’s not always the right choice — even when you think you need precision. What “high resolution” actually means A clock’s resolution (or precision) is the granularity of its tick period — i.e., the smallest representable step in time for that clock’s time_point. In &lt;chrono&gt; it’s exposed via Clock::period, a std::ratio. Notice an important difference. I didn’t mention accuracy, only precision. A clock might represent nanoseconds, but still be inaccurate due to hardware or OS scheduling. A higher resolution doesn’t necessarily mean better measurement. For timing, stability and monotonicity matter much more than how fine-grained the tick is. You can inspect a clock’s nominal resolution at compile time: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // https://godbolt.org/z/WMsWzETd7 #include &lt;chrono&gt; #include &lt;iostream&gt; template &lt;typename Clock&gt; void print_resolution(const char* name) { long double ns_per_tick = (1&#39;000&#39;000&#39;000 * Clock::period::num) / Clock::period::den; std::cout &lt;&lt; name &lt;&lt; &quot; tick: ~&quot; &lt;&lt; ns_per_tick &lt;&lt; &quot; ns\n&quot;; } int main() { print_resolution&lt;std::chrono::system_clock&gt;(&quot;system_clock&quot;); print_resolution&lt;std::chrono::steady_clock&gt;(&quot;steady_clock&quot;); print_resolution&lt;std::chrono::high_resolution_clock&gt;(&quot;high_resolution_clock&quot;); } /* Output on compiler explorer: system_clock tick: ~1 ns steady_clock tick: ~1 ns high_resolution_clock tick: ~1 ns */ With the above piece of code, you can get the theoretical granularity. The effective resolution depends on your platform and runtime conditions — so don’t assume nanoseconds mean nanosecond accuracy. The platform-dependent nature (aliasing) The C++ standard deliberately leaves std::chrono::high_resolution_clock open: it represents “clocks with the shortest tick period.” It also says, that in practice, it “may be a synonym for system_clock or steady_clock”. To find out which one you’re dealing with, you can use this piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://godbolt.org/z/MGM6WWjev #include &lt;chrono&gt; #include &lt;iostream&gt; #include &lt;type_traits&gt; int main() { using std::chrono::high_resolution_clock; std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;high_resolution_clock is steady? &quot; &lt;&lt; high_resolution_clock::is_steady &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;high_resolution_clock == steady_clock? &quot; &lt;&lt; std::is_same_v&lt;high_resolution_clock, std::chrono::steady_clock&gt; &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;high_resolution_clock == system_clock? &quot; &lt;&lt; std::is_same_v&lt;high_resolution_clock, std::chrono::system_clock&gt; &lt;&lt; &quot;\n&quot;; } /* Possible output: high_resolution_clock is steady? false high_resolution_clock == steady_clock? false high_resolution_clock == system_clock? true */ If it aliases system_clock - as for me -, it may jump forward or backward when the system time changes (for example, due to daylight savings adjustments). If it aliases steady_clock, then it’s monotonic — but at that point, you might as well use steady_clock directly for clarity and portability. Why it’s not always the best for timing When measuring durations (timeouts, benchmarks, etc.), you generally care about two things: Monotonicity – time should never go backwards. Stability – intervals should be consistent and unaffected by clock corrections. steady_clock guarantees both with its steadiness. high_resolution_clock, however, makes no such guarantee — it might be steady on one system and wall-clock based on another. That alone is enough reason to avoid it in portable timing code. Stick with: std::chrono::steady_clock for intervals and durations, std::chrono::system_clock for human-readable timestamps. Only use high_resolution_clock if you’ve confirmed (through traits or testing) that it’s stable and gives you a measurable benefit on your target platform. When high_resolution_clock might actually be better There are a few rare cases where std::chrono::high_resolution_clock does live up to its name. On some platforms, it’s not just an alias, but a truly finer-grained and still steady timer. For example, older Windows implementations sometimes mapped it to QueryPerformanceCounter, and some Linux libcs use a raw hardware timer (CLOCK_MONOTONIC_RAW) under the hood, which can give slightly higher resolution or lower jitter than steady_clock. If you check and find that: 1 2 3 std::chrono::high_resolution_clock::is_steady &amp;&amp; !std::is_same_v&lt;std::chrono::high_resolution_clock, std::chrono::steady_clock&gt; then it might offer a measurable benefit — especially for microbenchmarks or other extremely fine-grained measurements. Just keep in mind that these differences are platform-specific and often negligible in real code. Unless you’ve confirmed both steadiness and higher precision through testing, steady_clock remains the safer and more portable choice. Conclusion std::chrono::high_resolution_clock sounds impressive, but in practice it’s more of a naming illusion than a guarantee. On most systems, it’s just an alias to either system_clock or steady_clock, offering no real advantage — and sometimes even less reliability. That said, there are cases where it genuinely wraps a finer-grained hardware timer. If you’ve verified that it’s steady and distinct from steady_clock, it can be handy for very short performance measurements or specialized use cases. For everything else, stick to the proven pair: use steady_clock for measuring intervals and system_clock for wall-clock timestamps. Next time, we’ll look into whether it’s possible to convert time between different clocks. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like many things in C++, the details matter. In the earlier parts of this series, we looked at system_clock as the wall-clock time source, and at steady_clock as the reliable choice for measuring intervals. This time, we’ll tackle the so-called “high-resolution” clock, separate fact from myth, and see why it’s not always the right choice — even when you think you need precision. What “high resolution” actually means A clock’s resolution (or precision) is the granularity of its tick period — i.e., the smallest representable step in time for that clock’s time_point. In &lt;chrono&gt; it’s exposed via Clock::period, a std::ratio. Notice an important difference. I didn’t mention accuracy, only precision. A clock might represent nanoseconds, but still be inaccurate due to hardware or OS scheduling. A higher resolution doesn’t necessarily mean better measurement. For timing, stability and monotonicity matter much more than how fine-grained the tick is. You can inspect a clock’s nominal resolution at compile time: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // https://godbolt.org/z/WMsWzETd7 #include &lt;chrono&gt; #include &lt;iostream&gt; template &lt;typename Clock&gt; void print_resolution(const char* name) { long double ns_per_tick = (1&#39;000&#39;000&#39;000 * Clock::period::num) / Clock::period::den; std::cout &lt;&lt; name &lt;&lt; &quot; tick: ~&quot; &lt;&lt; ns_per_tick &lt;&lt; &quot; ns\n&quot;; } int main() { print_resolution&lt;std::chrono::system_clock&gt;(&quot;system_clock&quot;); print_resolution&lt;std::chrono::steady_clock&gt;(&quot;steady_clock&quot;); print_resolution&lt;std::chrono::high_resolution_clock&gt;(&quot;high_resolution_clock&quot;); } /* Output on compiler explorer: system_clock tick: ~1 ns steady_clock tick: ~1 ns high_resolution_clock tick: ~1 ns */ With the above piece of code, you can get the theoretical granularity. The effective resolution depends on your platform and runtime conditions — so don’t assume nanoseconds mean nanosecond accuracy. The platform-dependent nature (aliasing) The C++ standard deliberately leaves std::chrono::high_resolution_clock open: it represents “clocks with the shortest tick period.” It also says, that in practice, it “may be a synonym for system_clock or steady_clock”. To find out which one you’re dealing with, you can use this piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://godbolt.org/z/MGM6WWjev #include &lt;chrono&gt; #include &lt;iostream&gt; #include &lt;type_traits&gt; int main() { using std::chrono::high_resolution_clock; std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;high_resolution_clock is steady? &quot; &lt;&lt; high_resolution_clock::is_steady &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;high_resolution_clock == steady_clock? &quot; &lt;&lt; std::is_same_v&lt;high_resolution_clock, std::chrono::steady_clock&gt; &lt;&lt; &quot;\n&quot; &lt;&lt; &quot;high_resolution_clock == system_clock? &quot; &lt;&lt; std::is_same_v&lt;high_resolution_clock, std::chrono::system_clock&gt; &lt;&lt; &quot;\n&quot;; } /* Possible output: high_resolution_clock is steady? false high_resolution_clock == steady_clock? false high_resolution_clock == system_clock? true */ If it aliases system_clock - as for me -, it may jump forward or backward when the system time changes (for example, due to daylight savings adjustments). If it aliases steady_clock, then it’s monotonic — but at that point, you might as well use steady_clock directly for clarity and portability. Why it’s not always the best for timing When measuring durations (timeouts, benchmarks, etc.), you generally care about two things: Monotonicity – time should never go backwards. Stability – intervals should be consistent and unaffected by clock corrections. steady_clock guarantees both with its steadiness. high_resolution_clock, however, makes no such guarantee — it might be steady on one system and wall-clock based on another. That alone is enough reason to avoid it in portable timing code. Stick with: std::chrono::steady_clock for intervals and durations, std::chrono::system_clock for human-readable timestamps. Only use high_resolution_clock if you’ve confirmed (through traits or testing) that it’s stable and gives you a measurable benefit on your target platform. When high_resolution_clock might actually be better There are a few rare cases where std::chrono::high_resolution_clock does live up to its name. On some platforms, it’s not just an alias, but a truly finer-grained and still steady timer. For example, older Windows implementations sometimes mapped it to QueryPerformanceCounter, and some Linux libcs use a raw hardware timer (CLOCK_MONOTONIC_RAW) under the hood, which can give slightly higher resolution or lower jitter than steady_clock. If you check and find that: 1 2 3 std::chrono::high_resolution_clock::is_steady &amp;&amp; !std::is_same_v&lt;std::chrono::high_resolution_clock, std::chrono::steady_clock&gt; then it might offer a measurable benefit — especially for microbenchmarks or other extremely fine-grained measurements. Just keep in mind that these differences are platform-specific and often negligible in real code. Unless you’ve confirmed both steadiness and higher precision through testing, steady_clock remains the safer and more portable choice. Conclusion std::chrono::high_resolution_clock sounds impressive, but in practice it’s more of a naming illusion than a guarantee. On most systems, it’s just an alias to either system_clock or steady_clock, offering no real advantage — and sometimes even less reliability. That said, there are cases where it genuinely wraps a finer-grained hardware timer. If you’ve verified that it’s steady and distinct from steady_clock, it can be handy for very short performance measurements or specialized use cases. For everything else, stick to the proven pair: use steady_clock for measuring intervals and system_clock for wall-clock timestamps. Next time, we’ll look into whether it’s possible to convert time between different clocks. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-12-10T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Time in C++: std::chrono::high_resolution_clock — Myths and Realities" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-12-10T00:00:00+01:00","datePublished":"2025-12-10T00:00:00+01:00","description":"If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like many things in C++, the details matter. In the earlier parts of this series, we looked at system_clock as the wall-clock time source, and at steady_clock as the reliable choice for measuring intervals. This time, we’ll tackle the so-called “high-resolution” clock, separate fact from myth, and see why it’s not always the right choice — even when you think you need precision. What “high resolution” actually means A clock’s resolution (or precision) is the granularity of its tick period — i.e., the smallest representable step in time for that clock’s time_point. In &lt;chrono&gt; it’s exposed via Clock::period, a std::ratio. Notice an important difference. I didn’t mention accuracy, only precision. A clock might represent nanoseconds, but still be inaccurate due to hardware or OS scheduling. A higher resolution doesn’t necessarily mean better measurement. For timing, stability and monotonicity matter much more than how fine-grained the tick is. You can inspect a clock’s nominal resolution at compile time: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // https://godbolt.org/z/WMsWzETd7 #include &lt;chrono&gt; #include &lt;iostream&gt; template &lt;typename Clock&gt; void print_resolution(const char* name) { long double ns_per_tick = (1&#39;000&#39;000&#39;000 * Clock::period::num) / Clock::period::den; std::cout &lt;&lt; name &lt;&lt; &quot; tick: ~&quot; &lt;&lt; ns_per_tick &lt;&lt; &quot; ns\\n&quot;; } int main() { print_resolution&lt;std::chrono::system_clock&gt;(&quot;system_clock&quot;); print_resolution&lt;std::chrono::steady_clock&gt;(&quot;steady_clock&quot;); print_resolution&lt;std::chrono::high_resolution_clock&gt;(&quot;high_resolution_clock&quot;); } /* Output on compiler explorer: system_clock tick: ~1 ns steady_clock tick: ~1 ns high_resolution_clock tick: ~1 ns */ With the above piece of code, you can get the theoretical granularity. The effective resolution depends on your platform and runtime conditions — so don’t assume nanoseconds mean nanosecond accuracy. The platform-dependent nature (aliasing) The C++ standard deliberately leaves std::chrono::high_resolution_clock open: it represents “clocks with the shortest tick period.” It also says, that in practice, it “may be a synonym for system_clock or steady_clock”. To find out which one you’re dealing with, you can use this piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://godbolt.org/z/MGM6WWjev #include &lt;chrono&gt; #include &lt;iostream&gt; #include &lt;type_traits&gt; int main() { using std::chrono::high_resolution_clock; std::cout &lt;&lt; std::boolalpha &lt;&lt; &quot;high_resolution_clock is steady? &quot; &lt;&lt; high_resolution_clock::is_steady &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;high_resolution_clock == steady_clock? &quot; &lt;&lt; std::is_same_v&lt;high_resolution_clock, std::chrono::steady_clock&gt; &lt;&lt; &quot;\\n&quot; &lt;&lt; &quot;high_resolution_clock == system_clock? &quot; &lt;&lt; std::is_same_v&lt;high_resolution_clock, std::chrono::system_clock&gt; &lt;&lt; &quot;\\n&quot;; } /* Possible output: high_resolution_clock is steady? false high_resolution_clock == steady_clock? false high_resolution_clock == system_clock? true */ If it aliases system_clock - as for me -, it may jump forward or backward when the system time changes (for example, due to daylight savings adjustments). If it aliases steady_clock, then it’s monotonic — but at that point, you might as well use steady_clock directly for clarity and portability. Why it’s not always the best for timing When measuring durations (timeouts, benchmarks, etc.), you generally care about two things: Monotonicity – time should never go backwards. Stability – intervals should be consistent and unaffected by clock corrections. steady_clock guarantees both with its steadiness. high_resolution_clock, however, makes no such guarantee — it might be steady on one system and wall-clock based on another. That alone is enough reason to avoid it in portable timing code. Stick with: std::chrono::steady_clock for intervals and durations, std::chrono::system_clock for human-readable timestamps. Only use high_resolution_clock if you’ve confirmed (through traits or testing) that it’s stable and gives you a measurable benefit on your target platform. When high_resolution_clock might actually be better There are a few rare cases where std::chrono::high_resolution_clock does live up to its name. On some platforms, it’s not just an alias, but a truly finer-grained and still steady timer. For example, older Windows implementations sometimes mapped it to QueryPerformanceCounter, and some Linux libcs use a raw hardware timer (CLOCK_MONOTONIC_RAW) under the hood, which can give slightly higher resolution or lower jitter than steady_clock. If you check and find that: 1 2 3 std::chrono::high_resolution_clock::is_steady &amp;&amp; !std::is_same_v&lt;std::chrono::high_resolution_clock, std::chrono::steady_clock&gt; then it might offer a measurable benefit — especially for microbenchmarks or other extremely fine-grained measurements. Just keep in mind that these differences are platform-specific and often negligible in real code. Unless you’ve confirmed both steadiness and higher precision through testing, steady_clock remains the safer and more portable choice. Conclusion std::chrono::high_resolution_clock sounds impressive, but in practice it’s more of a naming illusion than a guarantee. On most systems, it’s just an alias to either system_clock or steady_clock, offering no real advantage — and sometimes even less reliability. That said, there are cases where it genuinely wraps a finer-grained hardware timer. If you’ve verified that it’s steady and distinct from steady_clock, it can be handy for very short performance measurements or specialized use cases. For everything else, stick to the proven pair: use steady_clock for measuring intervals and system_clock for wall-clock timestamps. Next time, we’ll look into whether it’s possible to convert time between different clocks. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Time in C++: std::chrono::high_resolution_clock — Myths and Realities","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock"},"url":"https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock"}</script><title>Time in C++: std::chrono::high_resolution_clock — Myths and Realities | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/10"> 10 </a> </span> <span>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 10, 2025, 12:00 AM +0100" prep="on" > Dec 10, 2025 <i class="unloaded">2025-12-10T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="850 words">4 min</span></div></div><div class="post-content"><p>If there’s one clock in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> that causes the most confusion, it’s <code class="language-plaintext highlighter-rouge">std::chrono::high_resolution_clock</code>. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like many things in C++, the details matter.</p><p>In the earlier parts of this series, we looked at <a href="https://www.sandordargo.com/blog/2025/11/26/clocks-part-2-system_clock"><code class="language-plaintext highlighter-rouge">system_clock</code> as the wall-clock time source</a>, and at <a href="https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock"><code class="language-plaintext highlighter-rouge">steady_clock</code> as the reliable choice for measuring intervals</a>. This time, we’ll tackle the so-called “high-resolution” clock, separate fact from myth, and see why it’s not always the right choice — even when you think you need precision.</p><h2 id="what-high-resolution-actually-means">What “high resolution” actually means</h2><p>A clock’s resolution (or precision) is the granularity of its tick period — i.e., the smallest representable step in time for that clock’s <code class="language-plaintext highlighter-rouge">time_point</code>. In <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> it’s exposed via <code class="language-plaintext highlighter-rouge">Clock::period</code>, a <code class="language-plaintext highlighter-rouge">std::ratio</code>.</p><p>Notice an important difference. I didn’t mention accuracy, only precision. A clock might represent nanoseconds, but still be inaccurate due to hardware or OS scheduling. A higher resolution doesn’t necessarily mean better measurement. For timing, stability and monotonicity matter much more than how fine-grained the tick is.</p><p>You can inspect a clock’s nominal resolution at compile time:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/WMsWzETd7</span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Clock</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">print_resolution</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">long</span> <span class="kt">double</span> <span class="n">ns_per_tick</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1'000'000'000</span> <span class="o">*</span> <span class="n">Clock</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">num</span><span class="p">)</span> <span class="o">/</span> <span class="n">Clock</span><span class="o">::</span><span class="n">period</span><span class="o">::</span><span class="n">den</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="s">" tick: ~"</span> <span class="o">&lt;&lt;</span> <span class="n">ns_per_tick</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">print_resolution</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"system_clock"</span><span class="p">);</span>
    <span class="n">print_resolution</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"steady_clock"</span><span class="p">);</span>
    <span class="n">print_resolution</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"high_resolution_clock"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
Output on compiler explorer:
system_clock tick: ~1 ns
steady_clock tick: ~1 ns
high_resolution_clock tick: ~1 ns 
*/</span>
</pre></table></code></div></div><p>With the above piece of code, you can get the theoretical granularity. The effective resolution depends on your platform and runtime conditions — so don’t assume nanoseconds mean nanosecond accuracy.</p><h2 id="the-platform-dependent-nature-aliasing">The platform-dependent nature (aliasing)</h2><p>The C++ standard deliberately leaves <code class="language-plaintext highlighter-rouge">std::chrono::high_resolution_clock</code> open: it represents “clocks with the shortest tick period.”</p><p>It also says, that in practice, it “may be a synonym for <code class="language-plaintext highlighter-rouge">system_clock</code> or <code class="language-plaintext highlighter-rouge">steady_clock</code>”.</p><p>To find out which one you’re dealing with, you can use this piece of code:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/MGM6WWjev</span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span> <span class="o">&lt;&lt;</span> <span class="s">"high_resolution_clock is steady? "</span>
              <span class="o">&lt;&lt;</span> <span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">is_steady</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
              <span class="o">&lt;&lt;</span> <span class="s">"high_resolution_clock == steady_clock? "</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">high_resolution_clock</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span>
              <span class="o">&lt;&lt;</span> <span class="s">"high_resolution_clock == system_clock? "</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">high_resolution_clock</span><span class="p">,</span>
                                <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* 
Possible output:
high_resolution_clock is steady? false
high_resolution_clock == steady_clock? false
high_resolution_clock == system_clock? true
*/</span>
</pre></table></code></div></div><p>If it aliases <code class="language-plaintext highlighter-rouge">system_clock</code> - as for me -, it may jump forward or backward when the system time changes (for example, due to daylight savings adjustments).</p><p>If it aliases <code class="language-plaintext highlighter-rouge">steady_clock</code>, then it’s monotonic — but at that point, you might as well use <code class="language-plaintext highlighter-rouge">steady_clock</code> directly for clarity and portability.</p><h2 id="why-its-not-always-the-best-for-timing">Why it’s not always the best for timing</h2><p>When measuring durations (timeouts, benchmarks, etc.), you generally care about two things:</p><ul><li><strong>Monotonicity</strong> – time should never go backwards.<li><strong>Stability</strong> – intervals should be consistent and unaffected by clock corrections.</ul><p><code class="language-plaintext highlighter-rouge">steady_clock</code> guarantees both with its steadiness. <code class="language-plaintext highlighter-rouge">high_resolution_clock</code>, however, makes no such guarantee — it might be steady on one system and wall-clock based on another.</p><p>That alone is enough reason to avoid it in portable timing code. Stick with:</p><ul><li><code class="language-plaintext highlighter-rouge">std::chrono::steady_clock</code> for intervals and durations,<li><code class="language-plaintext highlighter-rouge">std::chrono::system_clock</code> for human-readable timestamps.</ul><p>Only use <code class="language-plaintext highlighter-rouge">high_resolution_clock</code> if you’ve confirmed (through traits or testing) that it’s stable and gives you a measurable benefit on your target platform.</p><h2 id="when-high_resolution_clock-might-actually-be-better">When <code class="language-plaintext highlighter-rouge">high_resolution_clock</code> might actually be better</h2><p>There are a few rare cases where <code class="language-plaintext highlighter-rouge">std::chrono::high_resolution_clock</code> does live up to its name. On some platforms, it’s not just an alias, but a truly finer-grained and still steady timer.</p><p>For example, older Windows implementations sometimes mapped it to <code class="language-plaintext highlighter-rouge">QueryPerformanceCounter</code>, and some Linux libcs use a raw hardware timer (<code class="language-plaintext highlighter-rouge">CLOCK_MONOTONIC_RAW</code>) under the hood, which can give slightly higher resolution or lower jitter than <code class="language-plaintext highlighter-rouge">steady_clock</code>.</p><p>If you check and find that:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="o">::</span><span class="n">is_steady</span> <span class="o">&amp;&amp;</span>
<span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">high_resolution_clock</span><span class="p">,</span>
                <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">&gt;</span>
</pre></table></code></div></div><p>then it might offer a measurable benefit — especially for microbenchmarks or other extremely fine-grained measurements.</p><p>Just keep in mind that these differences are platform-specific and often negligible in real code. Unless you’ve confirmed both steadiness and higher precision through testing, <code class="language-plaintext highlighter-rouge">steady_clock</code> remains the safer and more portable choice.</p><h2 id="conclusion">Conclusion</h2><p><code class="language-plaintext highlighter-rouge">std::chrono::high_resolution_clock</code> sounds impressive, but in practice it’s more of a naming illusion than a guarantee. On most systems, it’s just an alias to either <code class="language-plaintext highlighter-rouge">system_clock</code> or <code class="language-plaintext highlighter-rouge">steady_clock</code>, offering no real advantage — and sometimes even less reliability.</p><p>That said, there are cases where it genuinely wraps a finer-grained hardware timer. If you’ve verified that it’s steady and distinct from <code class="language-plaintext highlighter-rouge">steady_clock</code>, it can be handy for very short performance measurements or specialized use cases.</p><p>For everything else, stick to the proven pair: <em>use <code class="language-plaintext highlighter-rouge">steady_clock</code> for measuring intervals and <code class="language-plaintext highlighter-rouge">system_clock</code> for wall-clock timestamps.</em></p><p>Next time, we’ll look into whether it’s possible to convert time between different clocks. Stay tuned.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/clocks/" class="post-tag no-text-decoration" >clocks</a> <a href="/tags/time/" class="post-tag no-text-decoration" >time</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Time in C++: std::chrono::high_resolution_clock — Myths and Realities - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Time in C++: std::chrono::high_resolution_clock — Myths and Realities - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Time in C++: std::chrono::high_resolution_clock — Myths and Realities - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Time in C++: std::chrono::high_resolution_clock — Myths and Realities - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/24/clocks-part-5-conversions"><div class="card-body"> <span class="timeago small" > Dec 24, 2025 <i class="unloaded">2025-12-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Inter-clock Conversions, Epochs, and Durations</h3><div class="text-muted small"><p> By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today,...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/07/clocks-part-6-cpp20"><div class="card-body"> <span class="timeago small" > Jan 7 <i class="unloaded">2026-01-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Additional clocks in C++20</h3><div class="text-muted small"><p> In this series, we’ve already talked about the main pillars behind &lt;chrono&gt;, the most widely used clocks, and even inter-clock conversions. Those clocks — system_clock, steady_clock, and hig...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/14/clocks-part-7-custom-clocks"><div class="card-body"> <span class="timeago small" > Jan 14 <i class="unloaded">2026-01-14T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Creating Your Own Clocks with &lt;chrono&gt;</h3><div class="text-muted small"><p> In earlier articles of this series, we walked through the foundations of &lt;chrono&gt;, explored the essential clocks (system_clock, steady_clock, high_resolution_clock), and even looked at the ex...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/12/03/clocks-part-3-steady_clock" class="btn btn-outline-primary" prompt="Older"><p>Time in C++: Understanding std::chrono::steady_clock</p></a> <a href="/blog/2025/12/17/conferences-2025" class="btn btn-outline-primary" prompt="Newer"><p>2025, A Year of Conferences</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Time in C++: std::chrono::high_resolution_clock — Myths and Realities'; this.page.url = 'https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock'; this.page.identifier = '/blog/2025/12/10/clocks-part-4-high_resolution_clock'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
