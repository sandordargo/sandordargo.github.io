<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Time in C++: Inter-clock Conversions, Epochs, and Durations" /><meta property="og:locale" content="en_US" /><meta name="description" content="By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today, we are going to talk about a subtle area: how clocks relate to each other, how epochs differ, and what happens when you - need to - convert durations. It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But &lt;chrono&gt; is designed to be type-safe, and it enforces some rules that prevent accidental misuse. Once you understand why those rules exist, time handling in C++ starts to feel much safer — and your tests get more reliable too. And It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But when it comes to converting between clocks, the reality is much messier. Different clocks have different epochs, different guarantees, and sometimes completely different purposes. &lt;chrono&gt; doesn’t stop you from doing conversions just to be pedantic — it discourages them because many of those conversions simply don’t make sense or can silently introduce subtle bugs. Once you understand why these conversions are tricky, and why the library forces you to be explicit about them, the design choices in &lt;chrono&gt; click into place. And more importantly, you start avoiding whole classes of timing bugs — both in production and in tests. Let’s jump right into the details. Clock Epochs: Why “Zero” Isn’t Universal A time_point in &lt;chrono&gt; is always measured relative to some epoch. But here’s the catch: each clock defines its own epoch. std::chrono::system_clock uses the Unix epoch (1 January 1970 UTC). std::chrono::steady_clock uses an unspecified monotonic epoch. Its zero might be system boot time, or something entirely different. std::chrono::high_resolution_clock is usually just an alias to either system_clock or steady_clock. This means: You cannot meaningfully compare time_points from different clocks. If you try to subtract a steady_clock::time_point from a system_clock::time_point, you’re effectively asking: “What is the difference between 1970-01-01 and some arbitrary boot-time counter?” The answer, of course, is: it depends on the machine, the OS, and maybe even the phase of the moon… :) Even tests can fall into this trap. If a test assumes that steady_clock starts at zero or that its epoch is stable across runs or platforms, that test becomes brittle. When you need deterministic behavior, it’s best to use controllable test clocks — or simply avoid exposing epochs at all. Converting Between Clocks: What You Can (and Can’t) Do Converting between clocks is tricky because their epochs differ—sometimes radically. For years, the standard library offered no built-in mechanism to transform a time_point from one clock into another. That changed with C++20: we now have clock_cast and custom clock_time_conversion specializations, which allow well-defined conversions when clocks have a meaningful relationship. At the same time, many clocks (such as system_clock and steady_clock) still cannot be safely converted because they measure fundamentally different notions of time. For those cases, you must fall back to a manual correlation technique, understanding that the result is only an approximation. Let’s look at both. Standard-Supported Conversions (clock_cast and clock_time_conversion) C++20 introduced std::chrono::clock_cast, which allows converting a time_point from one clock to another when the conversion is defined. A conversion is defined if: The clocks have a known, stable mathematical relationship A clock_time_conversion&lt;FromClock, ToClock&gt; specialization exists The standard library already provides such conversions between the following pairs: system_clock utc_clock tai_clock gps_clock file_clock Custom clocks if clock_time_conversion is soecified These clocks share known epochs and offsets (e.g., TAI is always 37 seconds ahead of UTC at the moment of writing), so the library can safely compute conversions. More on some C++20 clocks next week. Example: converting utc_clock to tai_clock: 1 2 3 4 using namespace std::chrono; auto utc_now = utc_clock::now(); auto tai_now = clock_cast&lt;tai_clock&gt;(utc_now); Here the result is well-defined and stable, because the relationship between TAI and UTC is part of the standard, not dependent on your system’s wall clock or boot time. You can also define your own conversions by providing a clock_time_conversion specialization for your custom clocks. This is particularly useful for: virtual/test clocks simulated clocks domain-specific clocks (e.g., frame counters, monotonic-but-shifted clocks) As soon as the specialization exists, clock_cast becomes available. Manual Correlation (When No Meaningful Conversion Exists) For clocks that don’t have a fixed mathematical relationship — like system_clock and steady_clock — the standard cannot give you a correct conversion. Their epochs differ and their behavior differs; one jumps, one doesn’t. In these cases, you can only estimate a conversion using a manual correlation pattern: 1 2 3 4 5 auto system_now = std::chrono::system_clock::now(); auto steady_now = std::chrono::steady_clock::now(); // The offset lets you map steady to system later on. auto offset = system_now - steady_now; From here, you can convert from steady time to approximate system time: 1 auto estimated_system_time = some_steady_tp + offset; This is useful, for example, when you measure an event duration with steady_clock (which is good for accuracy), but still want to log a human-readable timestamps. However, there’s a big caveat! If system_clock jumps (e.g. due to NTP sync or to manual clock change), your offset becomes invalid. If you rely on this relationship for long-running processes, you’re essentially betting that the wall clock won’t move. That’s a dangerous bet. Testing-wise, this is exactly the kind of logic that benefits from dependency injection: give the code two controllable clocks and make the conversion behavior explicit. Tests shouldn’t rely on the real-world relationship between clocks; they should verify your conversion math. Duration Casting and Precision Durations seem simple — just a number plus a unit. But converting between units introduces subtle precision issues. On the one hand, casting to a coarser unit truncates: 1 2 3 4 using namespace std::chrono_literals; auto ns = 1500ns; // 1500 nanoseconds auto us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(ns); // us == 1 microsecond (the remaining 500ns are lost) On the other hand, casting to a finer unit introduces “imaginary precision”: 1 2 3 std::chrono::milliseconds ms{1}; auto ns2 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(ms); // ns2 == 1&#39;000&#39;000ns, but we didn&#39;t *measure* at nanosecond precision C++20 gives us chrono::floor, ceil, and round, which make intent clear and help you see where you’re losing information. We are explicit in this lossy cast: we choose to lose 499ns, and that’s fine as long as it’s intentional. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://godbolt.org/z/K7GPdKMn9 using namespace std::chrono_literals; auto original = 1499ns; // Round to the *nearest* microsecond auto rounded_us = std::chrono::round&lt;std::chrono::microseconds&gt;(original); // rounded_us == 1us // We&#39;ve effectively decided that 1499ns ≈ 1µs // The remaining 499ns are gone by design. std::cout &lt;&lt; original.count() &lt;&lt; &quot;ns\n&quot;; std::cout &lt;&lt; rounded_us.count() &lt;&lt; &quot;us\n&quot;; /* 1499ns 1us */ Overflow, Underflow, and Representation Limits Another subtle danger lies in subtraction or conversion involving very large durations. Imagine you accidentally subtract two system_clock time_points taken decades apart, or you add a huge duration that exceeds 64-bit limits. Normally, modern platforms give you plenty of room, but it’s not infinite. As there is almost always an integer type behind std::chrono::duration&lt;Rep, Period&gt;’s Rep, there is a risk of signed integer overflow and therefore undefined behaviour. Yet, it’s useful to use signed integer types as Rep, because negative durations can happen legitimetly or they can show a logic error that would be otherwise hard to spot. Conclusion Inter-clock conversions turn out to be one of the trickiest parts of working with &lt;chrono&gt;. Clocks have different epochs, some jump while others don’t, and durations behave differently depending on how you convert them. But with the right mental model — and a few best practices — you can write robust, portable, and testable time-handling code. Always measure intervals using one clock, preferably use steady_clock Convert to human-readable preresentations only at the boundary Never assume epochs are related. Even if two timestamps “look close”, you can’t rely on any stable relationship between clocks. Keep rounding and precision choices explicit. Use floor, ceil or round to do so. Don’t validate clocks, validate your logic. Get those right, and suddenly time in C++ becomes a lot less mysterious. Next week, we’ll talk about some additional clocks introduced by C++20. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today, we are going to talk about a subtle area: how clocks relate to each other, how epochs differ, and what happens when you - need to - convert durations. It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But &lt;chrono&gt; is designed to be type-safe, and it enforces some rules that prevent accidental misuse. Once you understand why those rules exist, time handling in C++ starts to feel much safer — and your tests get more reliable too. And It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But when it comes to converting between clocks, the reality is much messier. Different clocks have different epochs, different guarantees, and sometimes completely different purposes. &lt;chrono&gt; doesn’t stop you from doing conversions just to be pedantic — it discourages them because many of those conversions simply don’t make sense or can silently introduce subtle bugs. Once you understand why these conversions are tricky, and why the library forces you to be explicit about them, the design choices in &lt;chrono&gt; click into place. And more importantly, you start avoiding whole classes of timing bugs — both in production and in tests. Let’s jump right into the details. Clock Epochs: Why “Zero” Isn’t Universal A time_point in &lt;chrono&gt; is always measured relative to some epoch. But here’s the catch: each clock defines its own epoch. std::chrono::system_clock uses the Unix epoch (1 January 1970 UTC). std::chrono::steady_clock uses an unspecified monotonic epoch. Its zero might be system boot time, or something entirely different. std::chrono::high_resolution_clock is usually just an alias to either system_clock or steady_clock. This means: You cannot meaningfully compare time_points from different clocks. If you try to subtract a steady_clock::time_point from a system_clock::time_point, you’re effectively asking: “What is the difference between 1970-01-01 and some arbitrary boot-time counter?” The answer, of course, is: it depends on the machine, the OS, and maybe even the phase of the moon… :) Even tests can fall into this trap. If a test assumes that steady_clock starts at zero or that its epoch is stable across runs or platforms, that test becomes brittle. When you need deterministic behavior, it’s best to use controllable test clocks — or simply avoid exposing epochs at all. Converting Between Clocks: What You Can (and Can’t) Do Converting between clocks is tricky because their epochs differ—sometimes radically. For years, the standard library offered no built-in mechanism to transform a time_point from one clock into another. That changed with C++20: we now have clock_cast and custom clock_time_conversion specializations, which allow well-defined conversions when clocks have a meaningful relationship. At the same time, many clocks (such as system_clock and steady_clock) still cannot be safely converted because they measure fundamentally different notions of time. For those cases, you must fall back to a manual correlation technique, understanding that the result is only an approximation. Let’s look at both. Standard-Supported Conversions (clock_cast and clock_time_conversion) C++20 introduced std::chrono::clock_cast, which allows converting a time_point from one clock to another when the conversion is defined. A conversion is defined if: The clocks have a known, stable mathematical relationship A clock_time_conversion&lt;FromClock, ToClock&gt; specialization exists The standard library already provides such conversions between the following pairs: system_clock utc_clock tai_clock gps_clock file_clock Custom clocks if clock_time_conversion is soecified These clocks share known epochs and offsets (e.g., TAI is always 37 seconds ahead of UTC at the moment of writing), so the library can safely compute conversions. More on some C++20 clocks next week. Example: converting utc_clock to tai_clock: 1 2 3 4 using namespace std::chrono; auto utc_now = utc_clock::now(); auto tai_now = clock_cast&lt;tai_clock&gt;(utc_now); Here the result is well-defined and stable, because the relationship between TAI and UTC is part of the standard, not dependent on your system’s wall clock or boot time. You can also define your own conversions by providing a clock_time_conversion specialization for your custom clocks. This is particularly useful for: virtual/test clocks simulated clocks domain-specific clocks (e.g., frame counters, monotonic-but-shifted clocks) As soon as the specialization exists, clock_cast becomes available. Manual Correlation (When No Meaningful Conversion Exists) For clocks that don’t have a fixed mathematical relationship — like system_clock and steady_clock — the standard cannot give you a correct conversion. Their epochs differ and their behavior differs; one jumps, one doesn’t. In these cases, you can only estimate a conversion using a manual correlation pattern: 1 2 3 4 5 auto system_now = std::chrono::system_clock::now(); auto steady_now = std::chrono::steady_clock::now(); // The offset lets you map steady to system later on. auto offset = system_now - steady_now; From here, you can convert from steady time to approximate system time: 1 auto estimated_system_time = some_steady_tp + offset; This is useful, for example, when you measure an event duration with steady_clock (which is good for accuracy), but still want to log a human-readable timestamps. However, there’s a big caveat! If system_clock jumps (e.g. due to NTP sync or to manual clock change), your offset becomes invalid. If you rely on this relationship for long-running processes, you’re essentially betting that the wall clock won’t move. That’s a dangerous bet. Testing-wise, this is exactly the kind of logic that benefits from dependency injection: give the code two controllable clocks and make the conversion behavior explicit. Tests shouldn’t rely on the real-world relationship between clocks; they should verify your conversion math. Duration Casting and Precision Durations seem simple — just a number plus a unit. But converting between units introduces subtle precision issues. On the one hand, casting to a coarser unit truncates: 1 2 3 4 using namespace std::chrono_literals; auto ns = 1500ns; // 1500 nanoseconds auto us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(ns); // us == 1 microsecond (the remaining 500ns are lost) On the other hand, casting to a finer unit introduces “imaginary precision”: 1 2 3 std::chrono::milliseconds ms{1}; auto ns2 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(ms); // ns2 == 1&#39;000&#39;000ns, but we didn&#39;t *measure* at nanosecond precision C++20 gives us chrono::floor, ceil, and round, which make intent clear and help you see where you’re losing information. We are explicit in this lossy cast: we choose to lose 499ns, and that’s fine as long as it’s intentional. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://godbolt.org/z/K7GPdKMn9 using namespace std::chrono_literals; auto original = 1499ns; // Round to the *nearest* microsecond auto rounded_us = std::chrono::round&lt;std::chrono::microseconds&gt;(original); // rounded_us == 1us // We&#39;ve effectively decided that 1499ns ≈ 1µs // The remaining 499ns are gone by design. std::cout &lt;&lt; original.count() &lt;&lt; &quot;ns\n&quot;; std::cout &lt;&lt; rounded_us.count() &lt;&lt; &quot;us\n&quot;; /* 1499ns 1us */ Overflow, Underflow, and Representation Limits Another subtle danger lies in subtraction or conversion involving very large durations. Imagine you accidentally subtract two system_clock time_points taken decades apart, or you add a huge duration that exceeds 64-bit limits. Normally, modern platforms give you plenty of room, but it’s not infinite. As there is almost always an integer type behind std::chrono::duration&lt;Rep, Period&gt;’s Rep, there is a risk of signed integer overflow and therefore undefined behaviour. Yet, it’s useful to use signed integer types as Rep, because negative durations can happen legitimetly or they can show a logic error that would be otherwise hard to spot. Conclusion Inter-clock conversions turn out to be one of the trickiest parts of working with &lt;chrono&gt;. Clocks have different epochs, some jump while others don’t, and durations behave differently depending on how you convert them. But with the right mental model — and a few best practices — you can write robust, portable, and testable time-handling code. Always measure intervals using one clock, preferably use steady_clock Convert to human-readable preresentations only at the boundary Never assume epochs are related. Even if two timestamps “look close”, you can’t rely on any stable relationship between clocks. Keep rounding and precision choices explicit. Use floor, ceil or round to do so. Don’t validate clocks, validate your logic. Get those right, and suddenly time in C++ becomes a lot less mysterious. Next week, we’ll talk about some additional clocks introduced by C++20. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-12-24T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Time in C++: Inter-clock Conversions, Epochs, and Durations" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-07T22:35:59+01:00","datePublished":"2025-12-24T00:00:00+01:00","description":"By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today, we are going to talk about a subtle area: how clocks relate to each other, how epochs differ, and what happens when you - need to - convert durations. It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But &lt;chrono&gt; is designed to be type-safe, and it enforces some rules that prevent accidental misuse. Once you understand why those rules exist, time handling in C++ starts to feel much safer — and your tests get more reliable too. And It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But when it comes to converting between clocks, the reality is much messier. Different clocks have different epochs, different guarantees, and sometimes completely different purposes. &lt;chrono&gt; doesn’t stop you from doing conversions just to be pedantic — it discourages them because many of those conversions simply don’t make sense or can silently introduce subtle bugs. Once you understand why these conversions are tricky, and why the library forces you to be explicit about them, the design choices in &lt;chrono&gt; click into place. And more importantly, you start avoiding whole classes of timing bugs — both in production and in tests. Let’s jump right into the details. Clock Epochs: Why “Zero” Isn’t Universal A time_point in &lt;chrono&gt; is always measured relative to some epoch. But here’s the catch: each clock defines its own epoch. std::chrono::system_clock uses the Unix epoch (1 January 1970 UTC). std::chrono::steady_clock uses an unspecified monotonic epoch. Its zero might be system boot time, or something entirely different. std::chrono::high_resolution_clock is usually just an alias to either system_clock or steady_clock. This means: You cannot meaningfully compare time_points from different clocks. If you try to subtract a steady_clock::time_point from a system_clock::time_point, you’re effectively asking: “What is the difference between 1970-01-01 and some arbitrary boot-time counter?” The answer, of course, is: it depends on the machine, the OS, and maybe even the phase of the moon… :) Even tests can fall into this trap. If a test assumes that steady_clock starts at zero or that its epoch is stable across runs or platforms, that test becomes brittle. When you need deterministic behavior, it’s best to use controllable test clocks — or simply avoid exposing epochs at all. Converting Between Clocks: What You Can (and Can’t) Do Converting between clocks is tricky because their epochs differ—sometimes radically. For years, the standard library offered no built-in mechanism to transform a time_point from one clock into another. That changed with C++20: we now have clock_cast and custom clock_time_conversion specializations, which allow well-defined conversions when clocks have a meaningful relationship. At the same time, many clocks (such as system_clock and steady_clock) still cannot be safely converted because they measure fundamentally different notions of time. For those cases, you must fall back to a manual correlation technique, understanding that the result is only an approximation. Let’s look at both. Standard-Supported Conversions (clock_cast and clock_time_conversion) C++20 introduced std::chrono::clock_cast, which allows converting a time_point from one clock to another when the conversion is defined. A conversion is defined if: The clocks have a known, stable mathematical relationship A clock_time_conversion&lt;FromClock, ToClock&gt; specialization exists The standard library already provides such conversions between the following pairs: system_clock utc_clock tai_clock gps_clock file_clock Custom clocks if clock_time_conversion is soecified These clocks share known epochs and offsets (e.g., TAI is always 37 seconds ahead of UTC at the moment of writing), so the library can safely compute conversions. More on some C++20 clocks next week. Example: converting utc_clock to tai_clock: 1 2 3 4 using namespace std::chrono; auto utc_now = utc_clock::now(); auto tai_now = clock_cast&lt;tai_clock&gt;(utc_now); Here the result is well-defined and stable, because the relationship between TAI and UTC is part of the standard, not dependent on your system’s wall clock or boot time. You can also define your own conversions by providing a clock_time_conversion specialization for your custom clocks. This is particularly useful for: virtual/test clocks simulated clocks domain-specific clocks (e.g., frame counters, monotonic-but-shifted clocks) As soon as the specialization exists, clock_cast becomes available. Manual Correlation (When No Meaningful Conversion Exists) For clocks that don’t have a fixed mathematical relationship — like system_clock and steady_clock — the standard cannot give you a correct conversion. Their epochs differ and their behavior differs; one jumps, one doesn’t. In these cases, you can only estimate a conversion using a manual correlation pattern: 1 2 3 4 5 auto system_now = std::chrono::system_clock::now(); auto steady_now = std::chrono::steady_clock::now(); // The offset lets you map steady to system later on. auto offset = system_now - steady_now; From here, you can convert from steady time to approximate system time: 1 auto estimated_system_time = some_steady_tp + offset; This is useful, for example, when you measure an event duration with steady_clock (which is good for accuracy), but still want to log a human-readable timestamps. However, there’s a big caveat! If system_clock jumps (e.g. due to NTP sync or to manual clock change), your offset becomes invalid. If you rely on this relationship for long-running processes, you’re essentially betting that the wall clock won’t move. That’s a dangerous bet. Testing-wise, this is exactly the kind of logic that benefits from dependency injection: give the code two controllable clocks and make the conversion behavior explicit. Tests shouldn’t rely on the real-world relationship between clocks; they should verify your conversion math. Duration Casting and Precision Durations seem simple — just a number plus a unit. But converting between units introduces subtle precision issues. On the one hand, casting to a coarser unit truncates: 1 2 3 4 using namespace std::chrono_literals; auto ns = 1500ns; // 1500 nanoseconds auto us = std::chrono::duration_cast&lt;std::chrono::microseconds&gt;(ns); // us == 1 microsecond (the remaining 500ns are lost) On the other hand, casting to a finer unit introduces “imaginary precision”: 1 2 3 std::chrono::milliseconds ms{1}; auto ns2 = std::chrono::duration_cast&lt;std::chrono::nanoseconds&gt;(ms); // ns2 == 1&#39;000&#39;000ns, but we didn&#39;t *measure* at nanosecond precision C++20 gives us chrono::floor, ceil, and round, which make intent clear and help you see where you’re losing information. We are explicit in this lossy cast: we choose to lose 499ns, and that’s fine as long as it’s intentional. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // https://godbolt.org/z/K7GPdKMn9 using namespace std::chrono_literals; auto original = 1499ns; // Round to the *nearest* microsecond auto rounded_us = std::chrono::round&lt;std::chrono::microseconds&gt;(original); // rounded_us == 1us // We&#39;ve effectively decided that 1499ns ≈ 1µs // The remaining 499ns are gone by design. std::cout &lt;&lt; original.count() &lt;&lt; &quot;ns\\n&quot;; std::cout &lt;&lt; rounded_us.count() &lt;&lt; &quot;us\\n&quot;; /* 1499ns 1us */ Overflow, Underflow, and Representation Limits Another subtle danger lies in subtraction or conversion involving very large durations. Imagine you accidentally subtract two system_clock time_points taken decades apart, or you add a huge duration that exceeds 64-bit limits. Normally, modern platforms give you plenty of room, but it’s not infinite. As there is almost always an integer type behind std::chrono::duration&lt;Rep, Period&gt;’s Rep, there is a risk of signed integer overflow and therefore undefined behaviour. Yet, it’s useful to use signed integer types as Rep, because negative durations can happen legitimetly or they can show a logic error that would be otherwise hard to spot. Conclusion Inter-clock conversions turn out to be one of the trickiest parts of working with &lt;chrono&gt;. Clocks have different epochs, some jump while others don’t, and durations behave differently depending on how you convert them. But with the right mental model — and a few best practices — you can write robust, portable, and testable time-handling code. Always measure intervals using one clock, preferably use steady_clock Convert to human-readable preresentations only at the boundary Never assume epochs are related. Even if two timestamps “look close”, you can’t rely on any stable relationship between clocks. Keep rounding and precision choices explicit. Use floor, ceil or round to do so. Don’t validate clocks, validate your logic. Get those right, and suddenly time in C++ becomes a lot less mysterious. Next week, we’ll talk about some additional clocks introduced by C++20. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Time in C++: Inter-clock Conversions, Epochs, and Durations","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions"},"url":"https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions"}</script><title>Time in C++: Inter-clock Conversions, Epochs, and Durations | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/24"> 24 </a> </span> <span>Time in C++: Inter-clock Conversions, Epochs, and Durations</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Time in C++: Inter-clock Conversions, Epochs, and Durations</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 24, 2025, 12:00 AM +0100" prep="on" > Dec 24, 2025 <i class="unloaded">2025-12-24T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 7, 2026, 10:35 PM +0100" prefix="Updated " > Jan 7 <i class="unloaded">2026-01-07T22:35:59+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1396 words">7 min</span></div></div><div class="post-content"><p>By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about <a href="https://www.sandordargo.com/blog/2025/11/26/clocks-part-2-system_clock">wall-clock time</a>, <a href="https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock">monotonic clocks</a>, and the myths around “<a href="https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock">high resolution</a>”. Today, we are going to talk about a subtle area: how clocks relate to each other, how epochs differ, and what happens when you - need to - convert durations.</p><p>It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> is designed to be type-safe, and it enforces some rules that prevent accidental misuse. Once you understand why those rules exist, time handling in C++ starts to feel much safer — and your tests get more reliable too. And</p><p>It sounds simple, right? A timestamp is a timestamp, and a duration is just a number of seconds - or other time units. But when it comes to converting between clocks, the reality is much messier. Different clocks have different epochs, different guarantees, and sometimes completely different purposes. <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> doesn’t stop you from doing conversions just to be pedantic — it discourages them because many of those conversions simply don’t make sense or can silently introduce subtle bugs.</p><p>Once you understand why these conversions are tricky, and why the library forces you to be explicit about them, the design choices in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> click into place. And more importantly, you start avoiding whole classes of timing bugs — both in production and in tests.</p><p>Let’s jump right into the details.</p><h2 id="clock-epochs-why-zero-isnt-universal">Clock Epochs: Why “Zero” Isn’t Universal</h2><p>A time_point in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> is always measured relative to some epoch. But here’s the catch: each clock defines its own epoch.</p><ul><li><code class="language-plaintext highlighter-rouge">std::chrono::system_clock</code> uses the Unix epoch (1 January 1970 UTC).<li><code class="language-plaintext highlighter-rouge">std::chrono::steady_clock</code> uses an unspecified monotonic epoch. Its zero might be system boot time, or something entirely different.<li><code class="language-plaintext highlighter-rouge">std::chrono::high_resolution_clock</code> is usually just an alias to either <code class="language-plaintext highlighter-rouge">system_clock</code> or <code class="language-plaintext highlighter-rouge">steady_clock</code>.</ul><p>This means:</p><blockquote><p><strong>You cannot meaningfully compare time_points from different clocks.</strong></p></blockquote><p>If you try to subtract a <code class="language-plaintext highlighter-rouge">steady_clock::time_point</code> from a <code class="language-plaintext highlighter-rouge">system_clock::time_point</code>, you’re effectively asking: <em>“What is the difference between 1970-01-01 and some arbitrary boot-time counter?”</em></p><p>The answer, of course, is: it depends on the machine, the OS, and maybe even the phase of the moon… :)</p><p>Even tests can fall into this trap. If a test assumes that <code class="language-plaintext highlighter-rouge">steady_clock</code> starts at zero or that its epoch is stable across runs or platforms, that test becomes brittle. When you need deterministic behavior, it’s best to use controllable test clocks — or simply avoid exposing epochs at all.</p><h2 id="converting-between-clocks-what-you-can-and-cant-do">Converting Between Clocks: What You Can (and Can’t) Do</h2><p>Converting between clocks is tricky because their epochs differ—sometimes radically.<br /> For years, the standard library offered <strong>no built-in mechanism</strong> to transform a <code class="language-plaintext highlighter-rouge">time_point</code> from one clock into another. That changed with C++20: we now have <strong><code class="language-plaintext highlighter-rouge">clock_cast</code></strong> and <strong>custom <code class="language-plaintext highlighter-rouge">clock_time_conversion</code> specializations</strong>, which allow <em>well-defined</em> conversions when clocks have a meaningful relationship.</p><p>At the same time, many clocks (such as <code class="language-plaintext highlighter-rouge">system_clock</code> and <code class="language-plaintext highlighter-rouge">steady_clock</code>) still <strong>cannot be safely converted</strong> because they measure fundamentally different notions of time. For those cases, you must fall back to a <strong>manual correlation technique</strong>, understanding that the result is only an approximation.</p><p>Let’s look at both.</p><h3 id="standard-supported-conversions-clock_cast-and-clock_time_conversion"><strong>Standard-Supported Conversions (<code class="language-plaintext highlighter-rouge">clock_cast</code> and <code class="language-plaintext highlighter-rouge">clock_time_conversion</code>)</strong></h3><p>C++20 introduced <code class="language-plaintext highlighter-rouge">std::chrono::clock_cast</code>, which allows converting a <code class="language-plaintext highlighter-rouge">time_point</code> from one clock to another <strong>when the conversion is defined</strong>.</p><p>A conversion is defined if:</p><ol><li>The clocks have a known, stable mathematical relationship<li>A <code class="language-plaintext highlighter-rouge">clock_time_conversion&lt;FromClock, ToClock&gt;</code> specialization exists</ol><p>The standard library already provides such conversions between the following pairs:</p><ul><li><code class="language-plaintext highlighter-rouge">system_clock</code><li><code class="language-plaintext highlighter-rouge">utc_clock</code><li><code class="language-plaintext highlighter-rouge">tai_clock</code><li><code class="language-plaintext highlighter-rouge">gps_clock</code><li><code class="language-plaintext highlighter-rouge">file_clock</code><li>Custom clocks if <code class="language-plaintext highlighter-rouge">clock_time_conversion</code> is soecified</ul><p>These clocks share known epochs and offsets (e.g., TAI is always 37 seconds ahead of UTC at the moment of writing), so the library can safely compute conversions.</p><p><em>More on some C++20 clocks next week.</em></p><p><strong>Example: converting <code class="language-plaintext highlighter-rouge">utc_clock</code> to <code class="language-plaintext highlighter-rouge">tai_clock</code>:</strong></p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="p">;</span>

<span class="k">auto</span> <span class="n">utc_now</span> <span class="o">=</span> <span class="n">utc_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">tai_now</span> <span class="o">=</span> <span class="n">clock_cast</span><span class="o">&lt;</span><span class="n">tai_clock</span><span class="o">&gt;</span><span class="p">(</span><span class="n">utc_now</span><span class="p">);</span>
</pre></table></code></div></div><p>Here the result is <strong>well-defined and stable</strong>, because the relationship between TAI and UTC is part of the standard, not dependent on your system’s wall clock or boot time.</p><p>You can also define your own conversions by providing a <code class="language-plaintext highlighter-rouge">clock_time_conversion</code> specialization for your custom clocks. This is particularly useful for:</p><ul><li>virtual/test clocks<li>simulated clocks<li>domain-specific clocks (e.g., frame counters, monotonic-but-shifted clocks)</ul><p>As soon as the specialization exists, <code class="language-plaintext highlighter-rouge">clock_cast</code> becomes available.</p><h3 id="manual-correlation-when-no-meaningful-conversion-exists">Manual Correlation (When No Meaningful Conversion Exists)</h3><p>For clocks that don’t have a fixed mathematical relationship — like <code class="language-plaintext highlighter-rouge">system_clock</code> and <code class="language-plaintext highlighter-rouge">steady_clock</code> — the standard cannot give you a correct conversion. Their epochs differ and their behavior differs; one jumps, one doesn’t.</p><p>In these cases, you can only estimate a conversion using a manual correlation pattern:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">system_now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">steady_now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

<span class="c1">// The offset lets you map steady to system later on.</span>
<span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">system_now</span> <span class="o">-</span> <span class="n">steady_now</span><span class="p">;</span>
</pre></table></code></div></div><p>From here, you can convert from steady time to <strong>approximate</strong> system time:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">estimated_system_time</span> <span class="o">=</span> <span class="n">some_steady_tp</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</pre></table></code></div></div><p>This is useful, for example, when you measure an event duration with <code class="language-plaintext highlighter-rouge">steady_clock</code> (which is good for accuracy), but still want to log a human-readable timestamps.</p><p>However, there’s a big caveat! If <code class="language-plaintext highlighter-rouge">system_clock</code> jumps (e.g. due to NTP sync or to manual clock change), your offset becomes invalid.</p><p>If you rely on this relationship for long-running processes, you’re essentially betting that the wall clock won’t move. That’s a dangerous bet.</p><p>Testing-wise, this is exactly the kind of logic that benefits from dependency injection: give the code two controllable clocks and make the conversion behavior explicit. Tests shouldn’t rely on the real-world relationship between clocks; they should verify your conversion math.</p><h2 id="duration-casting-and-precision">Duration Casting and Precision</h2><p>Durations seem simple — just a number plus a unit. But converting between units introduces subtle precision issues.</p><p>On the one hand, casting to a coarser unit truncates:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono_literals</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">ns</span> <span class="o">=</span> <span class="mx">1500ns</span><span class="p">;</span>            <span class="c1">// 1500 nanoseconds</span>
<span class="k">auto</span> <span class="n">us</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ns</span><span class="p">);</span>
<span class="c1">// us == 1 microsecond (the remaining 500ns are lost)</span>
</pre></table></code></div></div><p>On the other hand, casting to a finer unit introduces “imaginary precision”:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">ms</span><span class="p">{</span><span class="mi">1</span><span class="p">};</span>
<span class="k">auto</span> <span class="n">ns2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">nanoseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ms</span><span class="p">);</span>
<span class="c1">// ns2 == 1'000'000ns, but we didn't *measure* at nanosecond precision</span>
</pre></table></code></div></div><p>C++20 gives us <code class="language-plaintext highlighter-rouge">chrono::floor</code>, <code class="language-plaintext highlighter-rouge">ceil</code>, and <code class="language-plaintext highlighter-rouge">round</code>, which make intent clear and help you see where you’re losing information.</p><p>We are explicit in this lossy cast: we <strong>choose</strong> to lose 499ns, and that’s fine as long as it’s intentional.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/K7GPdKMn9</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono_literals</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">original</span> <span class="o">=</span> <span class="mx">1499ns</span><span class="p">;</span>

<span class="c1">// Round to the *nearest* microsecond</span>
<span class="k">auto</span> <span class="n">rounded_us</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">round</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">microseconds</span><span class="o">&gt;</span><span class="p">(</span><span class="n">original</span><span class="p">);</span>
<span class="c1">// rounded_us == 1us</span>

<span class="c1">// We've effectively decided that 1499ns ≈ 1µs</span>
<span class="c1">// The remaining 499ns are gone by design.</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">original</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rounded_us</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"us</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="cm">/*
1499ns
1us
*/</span>
</pre></table></code></div></div><h2 id="overflow-underflow-and-representation-limits">Overflow, Underflow, and Representation Limits</h2><p>Another subtle danger lies in subtraction or conversion involving very large durations.</p><p>Imagine you accidentally subtract two <code class="language-plaintext highlighter-rouge">system_clock</code> <code class="language-plaintext highlighter-rouge">time_points</code> taken decades apart, or you add a huge duration that exceeds 64-bit limits. Normally, modern platforms give you plenty of room, but it’s not infinite.</p><p>As there is almost always an integer type behind <code class="language-plaintext highlighter-rouge">std::chrono::duration&lt;Rep, Period&gt;</code>’s <code class="language-plaintext highlighter-rouge">Rep</code>, there is a risk of signed integer overflow and therefore undefined behaviour.</p><p>Yet, it’s useful to use signed integer types as <code class="language-plaintext highlighter-rouge">Rep</code>, because negative durations can happen legitimetly or they can show a logic error that would be otherwise hard to spot.</p><h2 id="conclusion">Conclusion</h2><p>Inter-clock conversions turn out to be one of the trickiest parts of working with <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code>. Clocks have different epochs, some jump while others don’t, and durations behave differently depending on how you convert them. But with the right mental model — and a few best practices — you can write robust, portable, and testable time-handling code.</p><ul><li>Always measure intervals using one clock, preferably use <code class="language-plaintext highlighter-rouge">steady_clock</code><li>Convert to human-readable preresentations only at the boundary<li>Never assume epochs are related. Even if two timestamps “look close”, you can’t rely on any stable relationship between clocks.<li>Keep rounding and precision choices explicit. Use <code class="language-plaintext highlighter-rouge">floor</code>, <code class="language-plaintext highlighter-rouge">ceil</code> or <code class="language-plaintext highlighter-rouge">round</code> to do so.<li>Don’t validate clocks, validate your logic.</ul><p>Get those right, and suddenly time in C++ becomes a lot less mysterious.</p><p>Next week, we’ll talk about some additional clocks introduced by C++20. Stay tuned!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/clocks/" class="post-tag no-text-decoration" >clocks</a> <a href="/tags/time/" class="post-tag no-text-decoration" >time</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Time in C++: Inter-clock Conversions, Epochs, and Durations - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Time in C++: Inter-clock Conversions, Epochs, and Durations - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Time in C++: Inter-clock Conversions, Epochs, and Durations - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Time in C++: Inter-clock Conversions, Epochs, and Durations - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/10/clocks-part-4-high_resolution_clock"><div class="card-body"> <span class="timeago small" > Dec 10, 2025 <i class="unloaded">2025-12-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</h3><div class="text-muted small"><p> If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like m...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/07/clocks-part-6-cpp20"><div class="card-body"> <span class="timeago small" > Jan 7 <i class="unloaded">2026-01-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Additional clocks in C++20</h3><div class="text-muted small"><p> In this series, we’ve already talked about the main pillars behind &lt;chrono&gt;, the most widely used clocks, and even inter-clock conversions. Those clocks — system_clock, steady_clock, and hig...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/14/clocks-part-7-custom-clocks"><div class="card-body"> <span class="timeago small" > Jan 14 <i class="unloaded">2026-01-14T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Creating Your Own Clocks with &lt;chrono&gt;</h3><div class="text-muted small"><p> In earlier articles of this series, we walked through the foundations of &lt;chrono&gt;, explored the essential clocks (system_clock, steady_clock, high_resolution_clock), and even looked at the ex...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/12/17/conferences-2025" class="btn btn-outline-primary" prompt="Older"><p>2025, A Year of Conferences</p></a> <a href="/blog/2025/12/31/2025-in-review" class="btn btn-outline-primary" prompt="Newer"><p>2025: A year with many faces</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Time in C++: Inter-clock Conversions, Epochs, and Durations'; this.page.url = 'https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions'; this.page.identifier = '/blog/2025/12/24/clocks-part-5-conversions'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
