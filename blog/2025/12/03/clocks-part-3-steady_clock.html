<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Time in C++: Understanding std::chrono::steady_clock" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the previous articles, we explored what clocks are in general and took a closer look at std::chrono::system_clock, the one that represents the wall-clock or calendar time. Now let’s move to another important one: std::chrono::steady_clock. At first sight, the difference between steady_clock and system_clock might not be obvious. They both give you a time_point, and you can use both to measure durations. But under the hood, they behave quite differently — and those differences make steady_clock the right choice for measuring intervals and durations. Monotonic behavior — and why it matters A key property of std::chrono::steady_clock is that it is monotonic. That means its time never goes backwards — ever. If you query it twice, the second call will always give you a time point greater than or equal to the first. This makes it ideal for measuring elapsed time or performance because you’ll never be surprised by sudden jumps or adjustments. On the contrary, system_clock represents the “real-world” wall clock. If your operating system synchronizes time, system_clock might jump forward or backward — and your elapsed-time calculations would instantly become meaningless. 1 2 3 4 5 6 auto start = std::chrono::steady_clock::now(); // ... run something ... auto end = std::chrono::steady_clock::now(); std::chrono::duration&lt;double&gt; elapsed = end - start; std::cout &lt;&lt; &quot;Elapsed time: &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot; seconds\n&quot;; With steady_clock, you can safely rely on this difference to measure real elapsed time, even if the system clock is adjusted while your code runs. Measuring performance, timeouts, and delays Whenever your goal is to measure how long something takes — for example, a function call, a loop, or a timeout — steady_clock should be your default choice. That’s also why you’ll see it used in many standard library facilities.For example, std::jthread::wait_for use steady_clock for timing out, because it must behave predictably even if the system time changes. The only thing steady_clock cannot tell you is what time it is. There’s no correlation between its time points and wall-clock time — only differences between them matter. If you want to print a human-readable timestamp or log an event, use system_clock. If you want to measure how long something took or schedule something to happen after a certain delay, use steady_clock. Testing angle — deterministic simulations and virtual time The monotonic nature of steady_clock also makes it a great fit for testing, especially when you want deterministic control over time. Imagine you’re testing a retry mechanism or a timeout. You don’t really want your test to sleep for 5 seconds — that would inacceptably slow for your suite. Instead, you can abstract time behind an interface and simulate or mock a clock. Here is a simple sketch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Clock { using time_point = std::chrono::steady_clock::time_point; virtual time_point now() const = 0; virtual ~Clock() = default; }; struct RealClock : Clock { time_point now() const override { return std::chrono::steady_clock::now(); } }; struct FakeClock : Clock { time_point current{}; time_point now() const override { return current; } void advance(std::chrono::milliseconds delta) { current += delta; } }; In your production code, - unsurprisingly - you use RealClock. In tests, you use FakeClock and manually advance the “time” which means that no real waiting involved to deterministicly forwarding the time. 1 2 3 4 5 FakeClock clock; auto start = clock.now(); clock.advance(1s); auto end = clock.now(); assert(end - start == 1s); This pattern is particularly helpful in simulations, retry logic, or event scheduling where reproducibility matters. You can “fast-forward” time without making your tests actually take time. Conclusion Today, we talked about std::chrono::steady_clock which a tool that it essential for reliable time measurement. It’s main characteristic is its monotonic behaviour, meaning it never goes backwards. This makes it the perfect choice when you care about how much time has passed, not what the current time is. Such cases are benchmarking code, waiting on a timeout, or simulating delays. Unlike system_clock, it doesn’t try to align with the wall clock. There’s no concept of “now” in the human sense — just a steady, ever-increasing counter of time. In tests, this predictability opens up great opportunities. By wrapping or mocking steady_clock, you can advance “time” however you like, making your tests both fast and deterministic. In short, steady_clock isn’t about when something happens — it’s about how long it takes. Next week, we’ll talk about the high_resolution_clock. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In the previous articles, we explored what clocks are in general and took a closer look at std::chrono::system_clock, the one that represents the wall-clock or calendar time. Now let’s move to another important one: std::chrono::steady_clock. At first sight, the difference between steady_clock and system_clock might not be obvious. They both give you a time_point, and you can use both to measure durations. But under the hood, they behave quite differently — and those differences make steady_clock the right choice for measuring intervals and durations. Monotonic behavior — and why it matters A key property of std::chrono::steady_clock is that it is monotonic. That means its time never goes backwards — ever. If you query it twice, the second call will always give you a time point greater than or equal to the first. This makes it ideal for measuring elapsed time or performance because you’ll never be surprised by sudden jumps or adjustments. On the contrary, system_clock represents the “real-world” wall clock. If your operating system synchronizes time, system_clock might jump forward or backward — and your elapsed-time calculations would instantly become meaningless. 1 2 3 4 5 6 auto start = std::chrono::steady_clock::now(); // ... run something ... auto end = std::chrono::steady_clock::now(); std::chrono::duration&lt;double&gt; elapsed = end - start; std::cout &lt;&lt; &quot;Elapsed time: &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot; seconds\n&quot;; With steady_clock, you can safely rely on this difference to measure real elapsed time, even if the system clock is adjusted while your code runs. Measuring performance, timeouts, and delays Whenever your goal is to measure how long something takes — for example, a function call, a loop, or a timeout — steady_clock should be your default choice. That’s also why you’ll see it used in many standard library facilities.For example, std::jthread::wait_for use steady_clock for timing out, because it must behave predictably even if the system time changes. The only thing steady_clock cannot tell you is what time it is. There’s no correlation between its time points and wall-clock time — only differences between them matter. If you want to print a human-readable timestamp or log an event, use system_clock. If you want to measure how long something took or schedule something to happen after a certain delay, use steady_clock. Testing angle — deterministic simulations and virtual time The monotonic nature of steady_clock also makes it a great fit for testing, especially when you want deterministic control over time. Imagine you’re testing a retry mechanism or a timeout. You don’t really want your test to sleep for 5 seconds — that would inacceptably slow for your suite. Instead, you can abstract time behind an interface and simulate or mock a clock. Here is a simple sketch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Clock { using time_point = std::chrono::steady_clock::time_point; virtual time_point now() const = 0; virtual ~Clock() = default; }; struct RealClock : Clock { time_point now() const override { return std::chrono::steady_clock::now(); } }; struct FakeClock : Clock { time_point current{}; time_point now() const override { return current; } void advance(std::chrono::milliseconds delta) { current += delta; } }; In your production code, - unsurprisingly - you use RealClock. In tests, you use FakeClock and manually advance the “time” which means that no real waiting involved to deterministicly forwarding the time. 1 2 3 4 5 FakeClock clock; auto start = clock.now(); clock.advance(1s); auto end = clock.now(); assert(end - start == 1s); This pattern is particularly helpful in simulations, retry logic, or event scheduling where reproducibility matters. You can “fast-forward” time without making your tests actually take time. Conclusion Today, we talked about std::chrono::steady_clock which a tool that it essential for reliable time measurement. It’s main characteristic is its monotonic behaviour, meaning it never goes backwards. This makes it the perfect choice when you care about how much time has passed, not what the current time is. Such cases are benchmarking code, waiting on a timeout, or simulating delays. Unlike system_clock, it doesn’t try to align with the wall clock. There’s no concept of “now” in the human sense — just a steady, ever-increasing counter of time. In tests, this predictability opens up great opportunities. By wrapping or mocking steady_clock, you can advance “time” however you like, making your tests both fast and deterministic. In short, steady_clock isn’t about when something happens — it’s about how long it takes. Next week, we’ll talk about the high_resolution_clock. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-12-03T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Time in C++: Understanding std::chrono::steady_clock" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-12-03T00:00:00+01:00","datePublished":"2025-12-03T00:00:00+01:00","description":"In the previous articles, we explored what clocks are in general and took a closer look at std::chrono::system_clock, the one that represents the wall-clock or calendar time. Now let’s move to another important one: std::chrono::steady_clock. At first sight, the difference between steady_clock and system_clock might not be obvious. They both give you a time_point, and you can use both to measure durations. But under the hood, they behave quite differently — and those differences make steady_clock the right choice for measuring intervals and durations. Monotonic behavior — and why it matters A key property of std::chrono::steady_clock is that it is monotonic. That means its time never goes backwards — ever. If you query it twice, the second call will always give you a time point greater than or equal to the first. This makes it ideal for measuring elapsed time or performance because you’ll never be surprised by sudden jumps or adjustments. On the contrary, system_clock represents the “real-world” wall clock. If your operating system synchronizes time, system_clock might jump forward or backward — and your elapsed-time calculations would instantly become meaningless. 1 2 3 4 5 6 auto start = std::chrono::steady_clock::now(); // ... run something ... auto end = std::chrono::steady_clock::now(); std::chrono::duration&lt;double&gt; elapsed = end - start; std::cout &lt;&lt; &quot;Elapsed time: &quot; &lt;&lt; elapsed.count() &lt;&lt; &quot; seconds\\n&quot;; With steady_clock, you can safely rely on this difference to measure real elapsed time, even if the system clock is adjusted while your code runs. Measuring performance, timeouts, and delays Whenever your goal is to measure how long something takes — for example, a function call, a loop, or a timeout — steady_clock should be your default choice. That’s also why you’ll see it used in many standard library facilities.For example, std::jthread::wait_for use steady_clock for timing out, because it must behave predictably even if the system time changes. The only thing steady_clock cannot tell you is what time it is. There’s no correlation between its time points and wall-clock time — only differences between them matter. If you want to print a human-readable timestamp or log an event, use system_clock. If you want to measure how long something took or schedule something to happen after a certain delay, use steady_clock. Testing angle — deterministic simulations and virtual time The monotonic nature of steady_clock also makes it a great fit for testing, especially when you want deterministic control over time. Imagine you’re testing a retry mechanism or a timeout. You don’t really want your test to sleep for 5 seconds — that would inacceptably slow for your suite. Instead, you can abstract time behind an interface and simulate or mock a clock. Here is a simple sketch: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 struct Clock { using time_point = std::chrono::steady_clock::time_point; virtual time_point now() const = 0; virtual ~Clock() = default; }; struct RealClock : Clock { time_point now() const override { return std::chrono::steady_clock::now(); } }; struct FakeClock : Clock { time_point current{}; time_point now() const override { return current; } void advance(std::chrono::milliseconds delta) { current += delta; } }; In your production code, - unsurprisingly - you use RealClock. In tests, you use FakeClock and manually advance the “time” which means that no real waiting involved to deterministicly forwarding the time. 1 2 3 4 5 FakeClock clock; auto start = clock.now(); clock.advance(1s); auto end = clock.now(); assert(end - start == 1s); This pattern is particularly helpful in simulations, retry logic, or event scheduling where reproducibility matters. You can “fast-forward” time without making your tests actually take time. Conclusion Today, we talked about std::chrono::steady_clock which a tool that it essential for reliable time measurement. It’s main characteristic is its monotonic behaviour, meaning it never goes backwards. This makes it the perfect choice when you care about how much time has passed, not what the current time is. Such cases are benchmarking code, waiting on a timeout, or simulating delays. Unlike system_clock, it doesn’t try to align with the wall clock. There’s no concept of “now” in the human sense — just a steady, ever-increasing counter of time. In tests, this predictability opens up great opportunities. By wrapping or mocking steady_clock, you can advance “time” however you like, making your tests both fast and deterministic. In short, steady_clock isn’t about when something happens — it’s about how long it takes. Next week, we’ll talk about the high_resolution_clock. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Time in C++: Understanding std::chrono::steady_clock","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock"},"url":"https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock"}</script><title>Time in C++: Understanding std::chrono::steady_clock | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/03"> 03 </a> </span> <span>Time in C++: Understanding std::chrono::steady_clock</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Time in C++: Understanding std::chrono::steady_clock</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 3, 2025, 12:00 AM +0100" prep="on" > Dec 3, 2025 <i class="unloaded">2025-12-03T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="757 words">4 min</span></div></div><div class="post-content"><p>In the previous articles, we <a href="https://www.sandordargo.com/blog/2025/11/19/clocks-part-1-intro-to-chrono">explored what clocks are in general</a> and <a href="https://www.sandordargo.com/blog/2025/11/26/clocks-part-2-system_clock">took a closer look at <code class="language-plaintext highlighter-rouge">std::chrono::system_clock</code></a>, the one that represents the wall-clock or calendar time.<br /> Now let’s move to another important one: <code class="language-plaintext highlighter-rouge">std::chrono::steady_clock</code>.</p><p>At first sight, the difference between <code class="language-plaintext highlighter-rouge">steady_clock</code> and <code class="language-plaintext highlighter-rouge">system_clock</code> might not be obvious. They both give you a <code class="language-plaintext highlighter-rouge">time_point</code>, and you can use both to measure durations. But under the hood, they behave quite differently — and those differences make <code class="language-plaintext highlighter-rouge">steady_clock</code> the right choice for measuring <strong>intervals</strong> and <strong>durations</strong>.</p><h2 id="monotonic-behavior--and-why-it-matters">Monotonic behavior — and why it matters</h2><p>A key property of <code class="language-plaintext highlighter-rouge">std::chrono::steady_clock</code> is that it is <strong>monotonic</strong>. That means its time never goes backwards — ever. If you query it twice, the second call will always give you a time point greater than or equal to the first.</p><p>This makes it ideal for measuring <strong>elapsed time</strong> or <strong>performance</strong> because you’ll never be surprised by sudden jumps or adjustments.</p><p>On the contrary, <code class="language-plaintext highlighter-rouge">system_clock</code> represents the “real-world” wall clock. If your operating system synchronizes time, <code class="language-plaintext highlighter-rouge">system_clock</code> might jump forward or backward — and your elapsed-time calculations would instantly become meaningless.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="c1">// ... run something ...</span>
<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

<span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span> <span class="n">elapsed</span> <span class="o">=</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Elapsed time: "</span> <span class="o">&lt;&lt;</span> <span class="n">elapsed</span><span class="p">.</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" seconds</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
</pre></table></code></div></div><p>With <code class="language-plaintext highlighter-rouge">steady_clock</code>, you can safely rely on this difference to measure real elapsed time, even if the system clock is adjusted while your code runs.</p><h2 id="measuring-performance-timeouts-and-delays">Measuring performance, timeouts, and delays</h2><p>Whenever your goal is to measure how long something takes — for example, a function call, a loop, or a timeout — <code class="language-plaintext highlighter-rouge">steady_clock</code> should be your default choice.</p><p>That’s also why you’ll see it used in many standard library facilities.For example, <code class="language-plaintext highlighter-rouge">std::jthread::wait_for</code> use <code class="language-plaintext highlighter-rouge">steady_clock</code> for timing out, because it must behave predictably even if the system time changes.</p><p>The only thing <code class="language-plaintext highlighter-rouge">steady_clock</code> cannot tell you is what time it is. There’s no correlation between its time points and wall-clock time — only differences between them matter. If you want to print a human-readable timestamp or log an event, use <code class="language-plaintext highlighter-rouge">system_clock</code>. If you want to measure how long something took or schedule something to happen after a certain delay, use <code class="language-plaintext highlighter-rouge">steady_clock</code>.</p><h2 id="testing-angle--deterministic-simulations-and-virtual-time">Testing angle — deterministic simulations and virtual time</h2><p>The monotonic nature of <code class="language-plaintext highlighter-rouge">steady_clock</code> also makes it a great fit for testing, especially when you want deterministic control over time.</p><p>Imagine you’re testing a retry mechanism or a timeout. You don’t really want your test to sleep for 5 seconds — that would inacceptably slow for your suite. Instead, you can abstract time behind an interface and simulate or mock a clock.</p><p>Here is a simple sketch:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Clock</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Clock</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">RealClock</span> <span class="o">:</span> <span class="n">Clock</span> <span class="p">{</span>
    <span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">FakeClock</span> <span class="o">:</span> <span class="n">Clock</span> <span class="p">{</span>
    <span class="n">time_point</span> <span class="n">current</span><span class="p">{};</span>
    <span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">current</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">void</span> <span class="nf">advance</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">milliseconds</span> <span class="n">delta</span><span class="p">)</span> <span class="p">{</span> <span class="n">current</span> <span class="o">+=</span> <span class="n">delta</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In your production code, - unsurprisingly - you use <code class="language-plaintext highlighter-rouge">RealClock</code>. In tests, you use <code class="language-plaintext highlighter-rouge">FakeClock</code> and manually advance the “time” which means that no real waiting involved to deterministicly forwarding the time.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">FakeClock</span> <span class="n">clock</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">start</span> <span class="o">=</span> <span class="n">clock</span><span class="p">.</span><span class="n">now</span><span class="p">();</span>
<span class="n">clock</span><span class="p">.</span><span class="n">advance</span><span class="p">(</span><span class="mx">1s</span><span class="p">);</span>
<span class="k">auto</span> <span class="n">end</span> <span class="o">=</span> <span class="n">clock</span><span class="p">.</span><span class="n">now</span><span class="p">();</span>
<span class="n">assert</span><span class="p">(</span><span class="n">end</span> <span class="o">-</span> <span class="n">start</span> <span class="o">==</span> <span class="mx">1s</span><span class="p">);</span>
</pre></table></code></div></div><p>This pattern is particularly helpful in <strong>simulations</strong>, <strong>retry logic</strong>, or <strong>event scheduling</strong> where reproducibility matters.</p><p>You can <em>“fast-forward”</em> time without making your tests actually take time.</p><h2 id="conclusion">Conclusion</h2><p>Today, we talked about <code class="language-plaintext highlighter-rouge">std::chrono::steady_clock</code> which a tool that it essential for reliable time measurement. It’s main characteristic is its monotonic behaviour, meaning it never goes backwards. This makes it the perfect choice when you care about <em>how much time has passed</em>, not <em>what the current time is</em>. Such cases are benchmarking code, waiting on a timeout, or simulating delays.</p><p>Unlike <code class="language-plaintext highlighter-rouge">system_clock</code>, it doesn’t try to align with the wall clock. There’s no concept of “now” in the human sense — just a steady, ever-increasing counter of time.</p><p>In tests, this predictability opens up great opportunities. By wrapping or mocking <code class="language-plaintext highlighter-rouge">steady_clock</code>, you can advance “time” however you like, making your tests both fast and deterministic.</p><p>In short, <code class="language-plaintext highlighter-rouge">steady_clock</code> isn’t about <em>when</em> something happens — it’s about <em>how long</em> it takes.</p><p>Next week, we’ll talk about the <code class="language-plaintext highlighter-rouge">high_resolution_clock</code>. Stay tuned.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/clocks/" class="post-tag no-text-decoration" >clocks</a> <a href="/tags/time/" class="post-tag no-text-decoration" >time</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Time in C++: Understanding std::chrono::steady_clock - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Time in C++: Understanding std::chrono::steady_clock - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Time in C++: Understanding std::chrono::steady_clock - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Time in C++: Understanding std::chrono::steady_clock - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/10/clocks-part-4-high_resolution_clock"><div class="card-body"> <span class="timeago small" > Dec 10, 2025 <i class="unloaded">2025-12-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</h3><div class="text-muted small"><p> If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like m...</p></div></div></a></div><div class="card"> <a href="/blog/2025/12/24/clocks-part-5-conversions"><div class="card-body"> <span class="timeago small" > Dec 24, 2025 <i class="unloaded">2025-12-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Inter-clock Conversions, Epochs, and Durations</h3><div class="text-muted small"><p> By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today,...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/07/clocks-part-6-cpp20"><div class="card-body"> <span class="timeago small" > Jan 7 <i class="unloaded">2026-01-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Additional clocks in C++20</h3><div class="text-muted small"><p> In this series, we’ve already talked about the main pillars behind &lt;chrono&gt;, the most widely used clocks, and even inter-clock conversions. Those clocks — system_clock, steady_clock, and hig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/11/26/clocks-part-2-system_clock" class="btn btn-outline-primary" prompt="Older"><p>Time in C++: std::chrono::system_clock</p></a> <a href="/blog/2025/12/10/clocks-part-4-high_resolution_clock" class="btn btn-outline-primary" prompt="Newer"><p>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Time in C++: Understanding std::chrono::steady_clock'; this.page.url = 'https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock'; this.page.identifier = '/blog/2025/12/03/clocks-part-3-steady_clock'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
