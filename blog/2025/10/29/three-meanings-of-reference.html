<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Three Meanings of Reference" /><meta property="og:locale" content="en_US" /><meta name="description" content="Conferences are a great source of inspiration, partly trought talks and partly trough the best track, the hallway track. I already mentioned that at CppCon one of my favourite talks was the one by Steve Downey on std::optional&lt;T&amp;&gt;. He also mentioned that there are three different uses of references in C++. I was thinking whether it’s four and disucssed this the next day during the break between two talks. Let’s talk about the 3 usages and I’ll give you the extra one which is not a usage of references but what I was thinking about originally. Calling Conventions One of the most common uses of references are function parameters. We often pass arguments by reference to avoid unnecessary copies — especially when dealing with non-POD types. By default we take parameters by const T&amp; to ensure that the function cannot modify the argument whose copy we avoided with the help of using a reference. If we want to allow the function to modify its parameters, we should use a plain reference. When an argument is passed by reference, we typiically also express that a value must be present - unlike for a pointer - and that we don’t pass ownership. Local Aliases Another everyday use of references is creating local aliases. By declaring a variable as T&amp; or auto&amp; possibly with a const added, you can refer to an existing object without copying it. Just like when you do the same for a function parameter. You see this pattern all the time in range-based for loops: 1 2 3 for (auto&amp; item : container) { item.doSomething(); } Here, item is just an alias to each element of container. Without the &amp;, every iteration would copy the element, which could be both wasteful and slow. Local references are also handy for readability. Instead of repeatedly typing a long expression, you can give it a short, meaningful name: 1 2 auto&amp; settings = config.user.profile.settings; settings.enableFeatureX(); This makes it clear that you’re modifying the original settings, not a copy. Usig local aliases is, of course, not a silver bullet. Use them with moderation and you’ll make your code more readable, but if you overuse them, they can make code harder to follow make you jumping back and forth in a function to figure out the meaning of aliases. References as Members The third usage Steve referred to was the reference qualification of member variables. 1 2 3 struct Foo { int&amp; x; }; This often feels like a good idea - storing only a reference in an object instead of making a copy. And sometimes it is. But we often forget it also changes some of the fundamental characteristics of your type in subtle ways. First of all, Foo - or any struct/class with a refernce member - cannot be default-constructed. A reference always must be bound to a valid object, you cannot leave them unitialized. 1 2 3 int value = 42; Foo f{value}; // OK Foo g; // Error: no default constructor available Other default operations behave differently as well. A reference cannot be reseated, so copy and move assignments cannot rebind it. If they exist - they are not generated by the compiler by the default. A copy constructor will just copy the reference itself, leaving both the old and the new object referring to the same underlying variable. 1 2 3 4 5 6 7 8 9 10 11 int a = 10; int b = 20; Foo f1{a}; Foo f2{b}; f2 = f1; // Error: no copy or move assignments are available Foo f3{f1} std::cout &lt;&lt; f3.x &lt;&lt; &#39;\n&#39;; // prints 10 There are legitimate use cases for reference members, though. They can serve well as non-owning views into other objects or enforce that a struct must always be tied to an existing resource. You just have be thoughtful about when and how to use them. Is there a fourth one? After Steve’s talk, I started wondering if there was a fourth one — the one that appears after a member function declaration. 1 2 3 4 5 struct Foo { void bar() &amp;; // can be called only on lvalues void bar() &amp;&amp;; // can be called only on rvalues }; This trailing &amp; (and its cousin &amp;&amp;) is called a ref-qualifier. It tells the compiler which kind of object — an lvalue or an rvalue — is allowed to call the method. In other words, it controls how the function can be invoked based on the value category of the object. Ref-qualifiers are most often used in fluent APIs or move-only types, where chaining or resource ownership rules matter. For example: 1 2 3 4 5 6 7 8 9 10 struct Builder { Builder&amp;&amp; setName(std::string n) &amp;&amp; { name = std::move(n); return std::move(*this); } Builder&amp; setName(std::string n) &amp; = delete; std::string name; }; Here, setName can only be called on a temporary (Builder{}), not on an existing named object. This prevents accidental mutation of already-built instances while keeping the rvalue usage clean and expressive. Ref-qualifiers are often misunderstood because they’re rare in everyday code, but they’re a powerful tool for API design. They let you express ownership intent, control chaining, and enforce correct usage patterns at compile time — all with a tiny &amp; at the end of a function. So maybe it’s not exactly a fourth meaning, but it certainly feels like a forgotten part of the reference world. Conclusion It’s fascinating and scary how one small symbol — &amp; — can mean so many different things depending on where it appears. It can shape how we pass data into functions, how we work with objects locally, how our classes behave, and even how methods can or cannot be called. Each use carries its own rules, intentions, and traps. Sometimes it’s about efficiency, sometimes about clarity, and sometimes about enforcing invariants. Understanding these nuances helps us write APIs that communicate better, avoid surprises, and make intent explicit — both for ourselves and for others reading our code. So next time you see an &amp;, take a moment to think: is it about aliasing, ownership, construction, or invocation? It’s the same symbol, but each meaning tells a different story about how your program thinks about data and identity. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Conferences are a great source of inspiration, partly trought talks and partly trough the best track, the hallway track. I already mentioned that at CppCon one of my favourite talks was the one by Steve Downey on std::optional&lt;T&amp;&gt;. He also mentioned that there are three different uses of references in C++. I was thinking whether it’s four and disucssed this the next day during the break between two talks. Let’s talk about the 3 usages and I’ll give you the extra one which is not a usage of references but what I was thinking about originally. Calling Conventions One of the most common uses of references are function parameters. We often pass arguments by reference to avoid unnecessary copies — especially when dealing with non-POD types. By default we take parameters by const T&amp; to ensure that the function cannot modify the argument whose copy we avoided with the help of using a reference. If we want to allow the function to modify its parameters, we should use a plain reference. When an argument is passed by reference, we typiically also express that a value must be present - unlike for a pointer - and that we don’t pass ownership. Local Aliases Another everyday use of references is creating local aliases. By declaring a variable as T&amp; or auto&amp; possibly with a const added, you can refer to an existing object without copying it. Just like when you do the same for a function parameter. You see this pattern all the time in range-based for loops: 1 2 3 for (auto&amp; item : container) { item.doSomething(); } Here, item is just an alias to each element of container. Without the &amp;, every iteration would copy the element, which could be both wasteful and slow. Local references are also handy for readability. Instead of repeatedly typing a long expression, you can give it a short, meaningful name: 1 2 auto&amp; settings = config.user.profile.settings; settings.enableFeatureX(); This makes it clear that you’re modifying the original settings, not a copy. Usig local aliases is, of course, not a silver bullet. Use them with moderation and you’ll make your code more readable, but if you overuse them, they can make code harder to follow make you jumping back and forth in a function to figure out the meaning of aliases. References as Members The third usage Steve referred to was the reference qualification of member variables. 1 2 3 struct Foo { int&amp; x; }; This often feels like a good idea - storing only a reference in an object instead of making a copy. And sometimes it is. But we often forget it also changes some of the fundamental characteristics of your type in subtle ways. First of all, Foo - or any struct/class with a refernce member - cannot be default-constructed. A reference always must be bound to a valid object, you cannot leave them unitialized. 1 2 3 int value = 42; Foo f{value}; // OK Foo g; // Error: no default constructor available Other default operations behave differently as well. A reference cannot be reseated, so copy and move assignments cannot rebind it. If they exist - they are not generated by the compiler by the default. A copy constructor will just copy the reference itself, leaving both the old and the new object referring to the same underlying variable. 1 2 3 4 5 6 7 8 9 10 11 int a = 10; int b = 20; Foo f1{a}; Foo f2{b}; f2 = f1; // Error: no copy or move assignments are available Foo f3{f1} std::cout &lt;&lt; f3.x &lt;&lt; &#39;\n&#39;; // prints 10 There are legitimate use cases for reference members, though. They can serve well as non-owning views into other objects or enforce that a struct must always be tied to an existing resource. You just have be thoughtful about when and how to use them. Is there a fourth one? After Steve’s talk, I started wondering if there was a fourth one — the one that appears after a member function declaration. 1 2 3 4 5 struct Foo { void bar() &amp;; // can be called only on lvalues void bar() &amp;&amp;; // can be called only on rvalues }; This trailing &amp; (and its cousin &amp;&amp;) is called a ref-qualifier. It tells the compiler which kind of object — an lvalue or an rvalue — is allowed to call the method. In other words, it controls how the function can be invoked based on the value category of the object. Ref-qualifiers are most often used in fluent APIs or move-only types, where chaining or resource ownership rules matter. For example: 1 2 3 4 5 6 7 8 9 10 struct Builder { Builder&amp;&amp; setName(std::string n) &amp;&amp; { name = std::move(n); return std::move(*this); } Builder&amp; setName(std::string n) &amp; = delete; std::string name; }; Here, setName can only be called on a temporary (Builder{}), not on an existing named object. This prevents accidental mutation of already-built instances while keeping the rvalue usage clean and expressive. Ref-qualifiers are often misunderstood because they’re rare in everyday code, but they’re a powerful tool for API design. They let you express ownership intent, control chaining, and enforce correct usage patterns at compile time — all with a tiny &amp; at the end of a function. So maybe it’s not exactly a fourth meaning, but it certainly feels like a forgotten part of the reference world. Conclusion It’s fascinating and scary how one small symbol — &amp; — can mean so many different things depending on where it appears. It can shape how we pass data into functions, how we work with objects locally, how our classes behave, and even how methods can or cannot be called. Each use carries its own rules, intentions, and traps. Sometimes it’s about efficiency, sometimes about clarity, and sometimes about enforcing invariants. Understanding these nuances helps us write APIs that communicate better, avoid surprises, and make intent explicit — both for ourselves and for others reading our code. So next time you see an &amp;, take a moment to think: is it about aliasing, ownership, construction, or invocation? It’s the same symbol, but each meaning tells a different story about how your program thinks about data and identity. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-10-29T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Three Meanings of Reference" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-29T00:00:00+01:00","datePublished":"2025-10-29T00:00:00+01:00","description":"Conferences are a great source of inspiration, partly trought talks and partly trough the best track, the hallway track. I already mentioned that at CppCon one of my favourite talks was the one by Steve Downey on std::optional&lt;T&amp;&gt;. He also mentioned that there are three different uses of references in C++. I was thinking whether it’s four and disucssed this the next day during the break between two talks. Let’s talk about the 3 usages and I’ll give you the extra one which is not a usage of references but what I was thinking about originally. Calling Conventions One of the most common uses of references are function parameters. We often pass arguments by reference to avoid unnecessary copies — especially when dealing with non-POD types. By default we take parameters by const T&amp; to ensure that the function cannot modify the argument whose copy we avoided with the help of using a reference. If we want to allow the function to modify its parameters, we should use a plain reference. When an argument is passed by reference, we typiically also express that a value must be present - unlike for a pointer - and that we don’t pass ownership. Local Aliases Another everyday use of references is creating local aliases. By declaring a variable as T&amp; or auto&amp; possibly with a const added, you can refer to an existing object without copying it. Just like when you do the same for a function parameter. You see this pattern all the time in range-based for loops: 1 2 3 for (auto&amp; item : container) { item.doSomething(); } Here, item is just an alias to each element of container. Without the &amp;, every iteration would copy the element, which could be both wasteful and slow. Local references are also handy for readability. Instead of repeatedly typing a long expression, you can give it a short, meaningful name: 1 2 auto&amp; settings = config.user.profile.settings; settings.enableFeatureX(); This makes it clear that you’re modifying the original settings, not a copy. Usig local aliases is, of course, not a silver bullet. Use them with moderation and you’ll make your code more readable, but if you overuse them, they can make code harder to follow make you jumping back and forth in a function to figure out the meaning of aliases. References as Members The third usage Steve referred to was the reference qualification of member variables. 1 2 3 struct Foo { int&amp; x; }; This often feels like a good idea - storing only a reference in an object instead of making a copy. And sometimes it is. But we often forget it also changes some of the fundamental characteristics of your type in subtle ways. First of all, Foo - or any struct/class with a refernce member - cannot be default-constructed. A reference always must be bound to a valid object, you cannot leave them unitialized. 1 2 3 int value = 42; Foo f{value}; // OK Foo g; // Error: no default constructor available Other default operations behave differently as well. A reference cannot be reseated, so copy and move assignments cannot rebind it. If they exist - they are not generated by the compiler by the default. A copy constructor will just copy the reference itself, leaving both the old and the new object referring to the same underlying variable. 1 2 3 4 5 6 7 8 9 10 11 int a = 10; int b = 20; Foo f1{a}; Foo f2{b}; f2 = f1; // Error: no copy or move assignments are available Foo f3{f1} std::cout &lt;&lt; f3.x &lt;&lt; &#39;\\n&#39;; // prints 10 There are legitimate use cases for reference members, though. They can serve well as non-owning views into other objects or enforce that a struct must always be tied to an existing resource. You just have be thoughtful about when and how to use them. Is there a fourth one? After Steve’s talk, I started wondering if there was a fourth one — the one that appears after a member function declaration. 1 2 3 4 5 struct Foo { void bar() &amp;; // can be called only on lvalues void bar() &amp;&amp;; // can be called only on rvalues }; This trailing &amp; (and its cousin &amp;&amp;) is called a ref-qualifier. It tells the compiler which kind of object — an lvalue or an rvalue — is allowed to call the method. In other words, it controls how the function can be invoked based on the value category of the object. Ref-qualifiers are most often used in fluent APIs or move-only types, where chaining or resource ownership rules matter. For example: 1 2 3 4 5 6 7 8 9 10 struct Builder { Builder&amp;&amp; setName(std::string n) &amp;&amp; { name = std::move(n); return std::move(*this); } Builder&amp; setName(std::string n) &amp; = delete; std::string name; }; Here, setName can only be called on a temporary (Builder{}), not on an existing named object. This prevents accidental mutation of already-built instances while keeping the rvalue usage clean and expressive. Ref-qualifiers are often misunderstood because they’re rare in everyday code, but they’re a powerful tool for API design. They let you express ownership intent, control chaining, and enforce correct usage patterns at compile time — all with a tiny &amp; at the end of a function. So maybe it’s not exactly a fourth meaning, but it certainly feels like a forgotten part of the reference world. Conclusion It’s fascinating and scary how one small symbol — &amp; — can mean so many different things depending on where it appears. It can shape how we pass data into functions, how we work with objects locally, how our classes behave, and even how methods can or cannot be called. Each use carries its own rules, intentions, and traps. Sometimes it’s about efficiency, sometimes about clarity, and sometimes about enforcing invariants. Understanding these nuances helps us write APIs that communicate better, avoid surprises, and make intent explicit — both for ourselves and for others reading our code. So next time you see an &amp;, take a moment to think: is it about aliasing, ownership, construction, or invocation? It’s the same symbol, but each meaning tells a different story about how your program thinks about data and identity. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Three Meanings of Reference","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference"},"url":"https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference"}</script><title>Three Meanings of Reference | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/29"> 29 </a> </span> <span>Three Meanings of Reference</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Three Meanings of Reference</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 29, 2025, 12:00 AM +0100" prep="on" > Oct 29, 2025 <i class="unloaded">2025-10-29T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1065 words">5 min</span></div></div><div class="post-content"><p>Conferences are a great source of inspiration, partly trought talks and partly trough the best track, the hallway track. I already mentioned that at CppCon one of my favourite talks was <a href="https://www.sandordargo.com/blog/2025/09/24/trip-report-cppcon-2025#my-favourite-talks">the one by Steve Downey on <code class="language-plaintext highlighter-rouge">std::optional&lt;T&amp;&gt;</code></a>. He also mentioned that there are three different uses of references in C++. I was thinking whether it’s four and disucssed this the next day during the break between two talks.</p><p>Let’s talk about the 3 usages and I’ll give you the extra one which is not a usage of references but what I was thinking about originally.</p><h2 id="calling-conventions">Calling Conventions</h2><p>One of the most common uses of references are function parameters. We often pass arguments by reference to avoid unnecessary copies — especially when dealing with non-POD types. By default we take parameters by <code class="language-plaintext highlighter-rouge">const T&amp;</code> to ensure that the function cannot modify the argument whose copy we avoided with the help of using a reference.</p><p>If we want to allow the function to modify its parameters, we should use a plain reference.</p><p>When an argument is passed by reference, we typiically also express that a value must be present - unlike for a pointer - and that we don’t pass ownership.</p><h2 id="local-aliases">Local Aliases</h2><p>Another everyday use of references is creating local aliases. By declaring a variable as <code class="language-plaintext highlighter-rouge">T&amp;</code> or <code class="language-plaintext highlighter-rouge">auto&amp;</code> possibly with a <code class="language-plaintext highlighter-rouge">const</code> added, you can refer to an existing object without copying it. Just like when you do the same for a function parameter.</p><p>You see this pattern all the time in range-based for loops:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">item</span> <span class="o">:</span> <span class="n">container</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">item</span><span class="p">.</span><span class="n">doSomething</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Here, <code class="language-plaintext highlighter-rouge">item</code> is just an alias to each element of container. Without the<code class="language-plaintext highlighter-rouge"> &amp;,</code> every iteration would copy the element, which could be both wasteful and slow.</p><p>Local references are also handy for readability. Instead of repeatedly typing a long expression, you can give it a short, meaningful name:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">auto</span><span class="o">&amp;</span> <span class="n">settings</span> <span class="o">=</span> <span class="n">config</span><span class="p">.</span><span class="n">user</span><span class="p">.</span><span class="n">profile</span><span class="p">.</span><span class="n">settings</span><span class="p">;</span>
<span class="n">settings</span><span class="p">.</span><span class="n">enableFeatureX</span><span class="p">();</span>
</pre></table></code></div></div><p>This makes it clear that you’re modifying the original settings, not a copy.</p><p>Usig local aliases is, of course, not a silver bullet. Use them with moderation and you’ll make your code more readable, but if you overuse them, they can make code harder to follow make you jumping back and forth in a function to figure out the meaning of aliases.</p><h2 id="references-as-members">References as Members</h2><p>The third usage Steve referred to was the reference qualification of member variables.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>This often feels like a good idea - storing only a reference in an object instead of making a copy. And sometimes it is. But we often forget it also changes some of the fundamental characteristics of your type in subtle ways.</p><p>First of all, <code class="language-plaintext highlighter-rouge">Foo</code> - or any <code class="language-plaintext highlighter-rouge">struct</code>/<code class="language-plaintext highlighter-rouge">class</code> with a refernce member - cannot be default-constructed. A reference always must be bound to a valid object, you cannot leave them unitialized.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">value</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
<span class="n">Foo</span> <span class="n">f</span><span class="p">{</span><span class="n">value</span><span class="p">};</span>      <span class="c1">// OK</span>
<span class="n">Foo</span> <span class="n">g</span><span class="p">;</span>             <span class="c1">// Error: no default constructor available</span>
</pre></table></code></div></div><p>Other default operations behave differently as well. A reference cannot be reseated, so copy and move assignments cannot rebind it. If they exist - they are not generated by the compiler by the default. A copy constructor will just copy the reference itself, leaving both the old and the new object referring to the same underlying variable.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">20</span><span class="p">;</span>

<span class="n">Foo</span> <span class="n">f1</span><span class="p">{</span><span class="n">a</span><span class="p">};</span>
<span class="n">Foo</span> <span class="n">f2</span><span class="p">{</span><span class="n">b</span><span class="p">};</span>

<span class="n">f2</span> <span class="o">=</span> <span class="n">f1</span><span class="p">;</span>          <span class="c1">// Error: no copy or move assignments are available</span>

<span class="n">Foo</span> <span class="n">f3</span><span class="p">{</span><span class="n">f1</span><span class="p">}</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">f3</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>  <span class="c1">// prints 10</span>

</pre></table></code></div></div><p>There are legitimate use cases for reference members, though. They can serve well as non-owning views into other objects or enforce that a struct must always be tied to an existing resource. You just have be thoughtful about when and how to use them.</p><h2 id="is-there-a-fourth-one">Is there a fourth one?</h2><p>After Steve’s talk, I started wondering if there was a fourth one — <a href="https://www.sandordargo.com/blog/2018/11/25/override-r-and-l0-values#use--or--for-function-overloading">the one that appears after a member function declaration</a>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="o">&amp;</span><span class="p">;</span>   <span class="c1">// can be called only on lvalues</span>
    <span class="kt">void</span> <span class="n">bar</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span>  <span class="c1">// can be called only on rvalues</span>
<span class="p">};</span>

</pre></table></code></div></div><p>This trailing <code class="language-plaintext highlighter-rouge">&amp;</code> (and its cousin <code class="language-plaintext highlighter-rouge">&amp;&amp;</code>) is called a ref-qualifier. It tells the compiler which kind of object — an <code class="language-plaintext highlighter-rouge">lvalue</code> or an <code class="language-plaintext highlighter-rouge">rvalue</code> — is allowed to call the method. In other words, it controls how the function can be invoked based on the value category of the object.</p><p>Ref-qualifiers are most often used in fluent APIs or move-only types, where chaining or resource ownership rules matter.</p><p>For example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Builder</span> <span class="p">{</span>
    <span class="n">Builder</span><span class="o">&amp;&amp;</span> <span class="n">setName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">{</span>
        <span class="n">name</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">Builder</span><span class="o">&amp;</span> <span class="n">setName</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">n</span><span class="p">)</span> <span class="o">&amp;</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Here, <code class="language-plaintext highlighter-rouge">setName</code> can only be called on a temporary (<code class="language-plaintext highlighter-rouge">Builder{}</code>), not on an existing named object. This prevents accidental mutation of already-built instances while keeping the rvalue usage clean and expressive.</p><p>Ref-qualifiers are often misunderstood because they’re rare in everyday code, but they’re a powerful tool for API design. They let you express ownership intent, control chaining, and enforce correct usage patterns at compile time — all with a tiny <code class="language-plaintext highlighter-rouge">&amp;</code> at the end of a function.</p><p>So maybe it’s not exactly a fourth meaning, but it certainly feels like a forgotten part of the reference world.</p><h2 id="conclusion">Conclusion</h2><p>It’s fascinating and scary how one small symbol — <code class="language-plaintext highlighter-rouge">&amp;</code> — can mean so many different things depending on where it appears. It can shape how we pass data into functions, how we work with objects locally, how our classes behave, and even how methods can or cannot be called.</p><p>Each use carries its own rules, intentions, and traps. Sometimes it’s about efficiency, sometimes about clarity, and sometimes about enforcing invariants. Understanding these nuances helps us write APIs that communicate better, avoid surprises, and make intent explicit — both for ourselves and for others reading our code.</p><p>So next time you see an <code class="language-plaintext highlighter-rouge">&amp;</code>, take a moment to think: is it about <em>aliasing</em>, <em>ownership</em>, <em>construction</em>, or <em>invocation</em>? It’s the same symbol, but each meaning tells a different story about how your program thinks about data and identity.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/conferences/" class="post-tag no-text-decoration" >conferences</a> <a href="/tags/watercooler/" class="post-tag no-text-decoration" >watercooler</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Three Meanings of Reference - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Three Meanings of Reference - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Three Meanings of Reference - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Three Meanings of Reference - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/17/conferences-2025"><div class="card-body"> <span class="timeago small" > Dec 17, 2025 <i class="unloaded">2025-12-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>2025, A Year of Conferences</h3><div class="text-muted small"><p> This year I had the chance to attend three conferences onsite, plus one online, and even a meetup in my hometown, Budapest. Depending on who you ask, maybe it’s not a lot — I know some speakers do ...</p></div></div></a></div><div class="card"> <a href="/blog/2025/10/15/how-to-choose-good-talks-to-go-to"><div class="card-body"> <span class="timeago small" > Oct 15, 2025 <i class="unloaded">2025-10-15T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to Pick Which Conference Talks to Attend</h3><div class="text-muted small"><p> You might say that it’s already mid-October and the conference season is over. That’s far from true! Europe’s largest C++ conference is still ahead of us: Meeting C++. At CppCon, I ended up sharin...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/24/5-reasons-not-to-talk-about-politics-at-work"><div class="card-body"> <span class="timeago small" > Jul 24, 2024 <i class="unloaded">2024-07-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5 reasons why politics will ruin your career hopes</h3><div class="text-muted small"><p> I’m not apolitical, I do have my opinion and quite a strong one. Yet, I don’t let it interfere with my job. I don’t think that one should talk about his or her political agenda at work or that one ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/10/22/trip-report-budapest-cpp" class="btn btn-outline-primary" prompt="Older"><p>Trip report: Budapest C++ - Breaking & Building C++</p></a> <a href="/blog/2025/11/05/unroll-pragma" class="btn btn-outline-primary" prompt="Newer"><p>Pragma unroll</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Three Meanings of Reference'; this.page.url = 'https://www.sandordargo.com/blog/2025/10/29/three-meanings-of-reference'; this.page.identifier = '/blog/2025/10/29/three-meanings-of-reference'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
