<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Trip report: Budapest C++ - Breaking &amp; Building C++" /><meta property="og:locale" content="en_US" /><meta name="description" content="We often spend the French autumn school holidays back in our hometown, Budapest, Hungary — and this year, the timing worked out perfectly for me to attend an event of the Budapest C++ Meetup. I’d like to thank the organizers for putting together such a great evening by sharing a short report from the event. More than a hundred people registered, and the room quickly filled up with local developers eager to hear three technical talks. The atmosphere was lively and welcoming — it showed the strength of the C++ community in Budapest. In 2027, even WG21 might come to Hungary! The evening began with Jonathan Müller’s talk, Cache-Friendly C++, followed by my own session on Strongly Typed Containers. Finally, Marcell Juhász closed the event with an insightful and hands-on presentation on Hacking and Securing C++. Budapest C++ Group (photo by Balázs Bondici) Let’s dive into some more details. Cache-Friendly C++ by Jonathan Müller This was one of those deep dives that reminds you how much of software performance is bound by the physical reality of hardware. He began by walking us through the fundamentals of memory access — how the CPU’s speed advantage over main memory has made caching essential, and why understanding this hierarchy is key for writing fast code. It’s one thing to know that “cache is fast, RAM is slow”, but Jonathan illustrated this vividly: object size, access patterns, and even the order of members inside a struct can make a measurable difference. From there, he contrasted data structures that play nicely with caches against those that don’t. Linked lists, for instance, are almost a textbook example of cache-unfriendly design: every node jump likely triggers a cache miss. In contrast, std::vector shines precisely because its elements live in contiguous memory. That’s the real reason it’s so often the best choice — not just because of its API convenience, but because it aligns with how modern CPUs want to consume data. Jonathan then shifted to the philosophy of data-oriented design, where you shape your data for efficient access rather than just elegant abstraction. This often leads to transforming “arrays of structs” into “structs of arrays”, which can drastically improve cache performance in tight loops. But he was quick to temper the enthusiasm: this transformation can also harm readability and maintainability. It’s a tool for when performance really matters, not a default approach. The talk closed on a pragmatic note that summed up the spirit of his message: “But benchmark to make sure you’re actually optimizing”. Don’t end up situations where you spend a lot of time optimizing, but you don’t end up with faster, just less maintainable code. Strongly Typed Containers by Sándor Dargó I guess it’s always a special feeling to speak in your hometown. For me it was the first time, and it felt great. In my talk, we explored one of my favorite topics: how far we can take type safety in C++ before the language — or our sanity — starts to push back. Strong typing is easy to advocate for in theory: it reduces ambiguity, improves readability, and catches a whole class of bugs at compile time. But in practice, it raises important design questions — especially when our goal is to make containers not just generic, but also semantically strong. Me at Budapest C++ (photo by Balázs Bondici) I began by examining why we’d even want strongly typed containers in the first place. It’s not just about avoiding accidental mix-ups between units or IDs — it’s about making code self-documenting and harder to misuse. From there, I walked through different implementation strategies: inheritance (and the pitfalls of both public and private forms), composition as a safer and clearer alternative, and how to use C++’s type system to wrap std::vector or other STL containers without losing their familiar interface. We discussed when it’s acceptable to “bend” STL design rules, and when it’s better to keep them intact. Toward the end, I mentioned a few open source tools for implementing strong types and went into some details about one. I did, admittedly, miscalculate my timing and had to rush through the last couple of slides, but the audience in Budapest was engaged and forgiving. Presenting this talk at home made it all the more enjoyable. Sharing ideas about stronger types and safer abstractions in C++ — and seeing how others connect with those challenges — was a reminder of why I love speaking at meetups like this one. Hacking and Securing C++ by Marcell Juhász Marcell talk was one of the most vivid demonstrations of how dangerous “undefined behavior” can become when code meets hardware. He built his entire presentation around a small embedded device — simple enough to understand in detail, yet realistic enough to expose the kind of vulnerabilities that still plague production systems today. We began with the basics: memory layouts and address spaces on microcontrollers. We learned about how de/allocation happens on the stack. When a function exits, the next one might unknowingly read leftovers from its predecessor - maybe someone’s password. From there, Marcell guided us through increasingly severe exploits, showing how seemingly harmless coding oversights can leak sensitive information or even allow arbitrary code execution. The slides on the stack vulnerability were particularly striking — how an uninitialized local buffer can serve as a window into the stack, exposing old data byte by byte. Later, he shifted focus to the heap, illustrating how use-after-free and dangling pointers can emerge from innocent-looking delete operations. Once again, the lesson was clear: C and C++ give you enormous power over memory, but with that power comes the responsibility to initialize, sanitize, and properly manage every allocation. Marcell didn’t stop at the horrors. He also offered a pragmatic roadmap toward safety. Initialize local and dynamic variables. Wipe sensitive data in destructors. Prefer RAII and smart pointers to raw ownership. Use bounded containers like std::array and std::vector, and never rely on client-side validation for anything security-related. His closing slide said it all, with large C++ shield in the middle: In the end, what made this talk memorable wasn’t just the exploits — it was how Marcell connected them back to everyday C++ coding. Even if you’ll never write firmware for a microcontroller, the principles carry over: memory is fragile, trust is dangerous, and the best security often comes from disciplined simplicity and the most basic features of C++. Conclusion The Budapest C++ Meetup was a great reminder of how strong and curious our local community is. Each talk approached the language from a different angle — Jonathan Müller from the perspective of performance, mine from design and type safety, and Marcell Juhász from security — yet all shared the same core message: understand what C++ gives you and use it wisely. Whether it’s memory access patterns, type abstractions, or resource management, the difference between elegant code and fragile software often comes down to awareness and discipline. It was inspiring to see so many people gathered to learn, discuss, and share ideas about modern C++. Budapest clearly has a thriving developer scene, and I’m already looking forward my next visit to Budapest - hopefully at the same time with another meetup. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="We often spend the French autumn school holidays back in our hometown, Budapest, Hungary — and this year, the timing worked out perfectly for me to attend an event of the Budapest C++ Meetup. I’d like to thank the organizers for putting together such a great evening by sharing a short report from the event. More than a hundred people registered, and the room quickly filled up with local developers eager to hear three technical talks. The atmosphere was lively and welcoming — it showed the strength of the C++ community in Budapest. In 2027, even WG21 might come to Hungary! The evening began with Jonathan Müller’s talk, Cache-Friendly C++, followed by my own session on Strongly Typed Containers. Finally, Marcell Juhász closed the event with an insightful and hands-on presentation on Hacking and Securing C++. Budapest C++ Group (photo by Balázs Bondici) Let’s dive into some more details. Cache-Friendly C++ by Jonathan Müller This was one of those deep dives that reminds you how much of software performance is bound by the physical reality of hardware. He began by walking us through the fundamentals of memory access — how the CPU’s speed advantage over main memory has made caching essential, and why understanding this hierarchy is key for writing fast code. It’s one thing to know that “cache is fast, RAM is slow”, but Jonathan illustrated this vividly: object size, access patterns, and even the order of members inside a struct can make a measurable difference. From there, he contrasted data structures that play nicely with caches against those that don’t. Linked lists, for instance, are almost a textbook example of cache-unfriendly design: every node jump likely triggers a cache miss. In contrast, std::vector shines precisely because its elements live in contiguous memory. That’s the real reason it’s so often the best choice — not just because of its API convenience, but because it aligns with how modern CPUs want to consume data. Jonathan then shifted to the philosophy of data-oriented design, where you shape your data for efficient access rather than just elegant abstraction. This often leads to transforming “arrays of structs” into “structs of arrays”, which can drastically improve cache performance in tight loops. But he was quick to temper the enthusiasm: this transformation can also harm readability and maintainability. It’s a tool for when performance really matters, not a default approach. The talk closed on a pragmatic note that summed up the spirit of his message: “But benchmark to make sure you’re actually optimizing”. Don’t end up situations where you spend a lot of time optimizing, but you don’t end up with faster, just less maintainable code. Strongly Typed Containers by Sándor Dargó I guess it’s always a special feeling to speak in your hometown. For me it was the first time, and it felt great. In my talk, we explored one of my favorite topics: how far we can take type safety in C++ before the language — or our sanity — starts to push back. Strong typing is easy to advocate for in theory: it reduces ambiguity, improves readability, and catches a whole class of bugs at compile time. But in practice, it raises important design questions — especially when our goal is to make containers not just generic, but also semantically strong. Me at Budapest C++ (photo by Balázs Bondici) I began by examining why we’d even want strongly typed containers in the first place. It’s not just about avoiding accidental mix-ups between units or IDs — it’s about making code self-documenting and harder to misuse. From there, I walked through different implementation strategies: inheritance (and the pitfalls of both public and private forms), composition as a safer and clearer alternative, and how to use C++’s type system to wrap std::vector or other STL containers without losing their familiar interface. We discussed when it’s acceptable to “bend” STL design rules, and when it’s better to keep them intact. Toward the end, I mentioned a few open source tools for implementing strong types and went into some details about one. I did, admittedly, miscalculate my timing and had to rush through the last couple of slides, but the audience in Budapest was engaged and forgiving. Presenting this talk at home made it all the more enjoyable. Sharing ideas about stronger types and safer abstractions in C++ — and seeing how others connect with those challenges — was a reminder of why I love speaking at meetups like this one. Hacking and Securing C++ by Marcell Juhász Marcell talk was one of the most vivid demonstrations of how dangerous “undefined behavior” can become when code meets hardware. He built his entire presentation around a small embedded device — simple enough to understand in detail, yet realistic enough to expose the kind of vulnerabilities that still plague production systems today. We began with the basics: memory layouts and address spaces on microcontrollers. We learned about how de/allocation happens on the stack. When a function exits, the next one might unknowingly read leftovers from its predecessor - maybe someone’s password. From there, Marcell guided us through increasingly severe exploits, showing how seemingly harmless coding oversights can leak sensitive information or even allow arbitrary code execution. The slides on the stack vulnerability were particularly striking — how an uninitialized local buffer can serve as a window into the stack, exposing old data byte by byte. Later, he shifted focus to the heap, illustrating how use-after-free and dangling pointers can emerge from innocent-looking delete operations. Once again, the lesson was clear: C and C++ give you enormous power over memory, but with that power comes the responsibility to initialize, sanitize, and properly manage every allocation. Marcell didn’t stop at the horrors. He also offered a pragmatic roadmap toward safety. Initialize local and dynamic variables. Wipe sensitive data in destructors. Prefer RAII and smart pointers to raw ownership. Use bounded containers like std::array and std::vector, and never rely on client-side validation for anything security-related. His closing slide said it all, with large C++ shield in the middle: In the end, what made this talk memorable wasn’t just the exploits — it was how Marcell connected them back to everyday C++ coding. Even if you’ll never write firmware for a microcontroller, the principles carry over: memory is fragile, trust is dangerous, and the best security often comes from disciplined simplicity and the most basic features of C++. Conclusion The Budapest C++ Meetup was a great reminder of how strong and curious our local community is. Each talk approached the language from a different angle — Jonathan Müller from the perspective of performance, mine from design and type safety, and Marcell Juhász from security — yet all shared the same core message: understand what C++ gives you and use it wisely. Whether it’s memory access patterns, type abstractions, or resource management, the difference between elegant code and fragile software often comes down to awareness and discipline. It was inspiring to see so many people gathered to learn, discuss, and share ideas about modern C++. Budapest clearly has a thriving developer scene, and I’m already looking forward my next visit to Budapest - hopefully at the same time with another meetup. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-10-22T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Trip report: Budapest C++ - Breaking &amp; Building C++" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-10-27T18:15:07+01:00","datePublished":"2025-10-22T00:00:00+02:00","description":"We often spend the French autumn school holidays back in our hometown, Budapest, Hungary — and this year, the timing worked out perfectly for me to attend an event of the Budapest C++ Meetup. I’d like to thank the organizers for putting together such a great evening by sharing a short report from the event. More than a hundred people registered, and the room quickly filled up with local developers eager to hear three technical talks. The atmosphere was lively and welcoming — it showed the strength of the C++ community in Budapest. In 2027, even WG21 might come to Hungary! The evening began with Jonathan Müller’s talk, Cache-Friendly C++, followed by my own session on Strongly Typed Containers. Finally, Marcell Juhász closed the event with an insightful and hands-on presentation on Hacking and Securing C++. Budapest C++ Group (photo by Balázs Bondici) Let’s dive into some more details. Cache-Friendly C++ by Jonathan Müller This was one of those deep dives that reminds you how much of software performance is bound by the physical reality of hardware. He began by walking us through the fundamentals of memory access — how the CPU’s speed advantage over main memory has made caching essential, and why understanding this hierarchy is key for writing fast code. It’s one thing to know that “cache is fast, RAM is slow”, but Jonathan illustrated this vividly: object size, access patterns, and even the order of members inside a struct can make a measurable difference. From there, he contrasted data structures that play nicely with caches against those that don’t. Linked lists, for instance, are almost a textbook example of cache-unfriendly design: every node jump likely triggers a cache miss. In contrast, std::vector shines precisely because its elements live in contiguous memory. That’s the real reason it’s so often the best choice — not just because of its API convenience, but because it aligns with how modern CPUs want to consume data. Jonathan then shifted to the philosophy of data-oriented design, where you shape your data for efficient access rather than just elegant abstraction. This often leads to transforming “arrays of structs” into “structs of arrays”, which can drastically improve cache performance in tight loops. But he was quick to temper the enthusiasm: this transformation can also harm readability and maintainability. It’s a tool for when performance really matters, not a default approach. The talk closed on a pragmatic note that summed up the spirit of his message: “But benchmark to make sure you’re actually optimizing”. Don’t end up situations where you spend a lot of time optimizing, but you don’t end up with faster, just less maintainable code. Strongly Typed Containers by Sándor Dargó I guess it’s always a special feeling to speak in your hometown. For me it was the first time, and it felt great. In my talk, we explored one of my favorite topics: how far we can take type safety in C++ before the language — or our sanity — starts to push back. Strong typing is easy to advocate for in theory: it reduces ambiguity, improves readability, and catches a whole class of bugs at compile time. But in practice, it raises important design questions — especially when our goal is to make containers not just generic, but also semantically strong. Me at Budapest C++ (photo by Balázs Bondici) I began by examining why we’d even want strongly typed containers in the first place. It’s not just about avoiding accidental mix-ups between units or IDs — it’s about making code self-documenting and harder to misuse. From there, I walked through different implementation strategies: inheritance (and the pitfalls of both public and private forms), composition as a safer and clearer alternative, and how to use C++’s type system to wrap std::vector or other STL containers without losing their familiar interface. We discussed when it’s acceptable to “bend” STL design rules, and when it’s better to keep them intact. Toward the end, I mentioned a few open source tools for implementing strong types and went into some details about one. I did, admittedly, miscalculate my timing and had to rush through the last couple of slides, but the audience in Budapest was engaged and forgiving. Presenting this talk at home made it all the more enjoyable. Sharing ideas about stronger types and safer abstractions in C++ — and seeing how others connect with those challenges — was a reminder of why I love speaking at meetups like this one. Hacking and Securing C++ by Marcell Juhász Marcell talk was one of the most vivid demonstrations of how dangerous “undefined behavior” can become when code meets hardware. He built his entire presentation around a small embedded device — simple enough to understand in detail, yet realistic enough to expose the kind of vulnerabilities that still plague production systems today. We began with the basics: memory layouts and address spaces on microcontrollers. We learned about how de/allocation happens on the stack. When a function exits, the next one might unknowingly read leftovers from its predecessor - maybe someone’s password. From there, Marcell guided us through increasingly severe exploits, showing how seemingly harmless coding oversights can leak sensitive information or even allow arbitrary code execution. The slides on the stack vulnerability were particularly striking — how an uninitialized local buffer can serve as a window into the stack, exposing old data byte by byte. Later, he shifted focus to the heap, illustrating how use-after-free and dangling pointers can emerge from innocent-looking delete operations. Once again, the lesson was clear: C and C++ give you enormous power over memory, but with that power comes the responsibility to initialize, sanitize, and properly manage every allocation. Marcell didn’t stop at the horrors. He also offered a pragmatic roadmap toward safety. Initialize local and dynamic variables. Wipe sensitive data in destructors. Prefer RAII and smart pointers to raw ownership. Use bounded containers like std::array and std::vector, and never rely on client-side validation for anything security-related. His closing slide said it all, with large C++ shield in the middle: In the end, what made this talk memorable wasn’t just the exploits — it was how Marcell connected them back to everyday C++ coding. Even if you’ll never write firmware for a microcontroller, the principles carry over: memory is fragile, trust is dangerous, and the best security often comes from disciplined simplicity and the most basic features of C++. Conclusion The Budapest C++ Meetup was a great reminder of how strong and curious our local community is. Each talk approached the language from a different angle — Jonathan Müller from the perspective of performance, mine from design and type safety, and Marcell Juhász from security — yet all shared the same core message: understand what C++ gives you and use it wisely. Whether it’s memory access patterns, type abstractions, or resource management, the difference between elegant code and fragile software often comes down to awareness and discipline. It was inspiring to see so many people gathered to learn, discuss, and share ideas about modern C++. Budapest clearly has a thriving developer scene, and I’m already looking forward my next visit to Budapest - hopefully at the same time with another meetup. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Trip report: Budapest C++ - Breaking &amp; Building C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp"},"url":"https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp"}</script><title>Trip report: Budapest C++ - Breaking & Building C++ | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/22"> 22 </a> </span> <span>Trip report: Budapest C++ - Breaking & Building C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Trip report: Budapest C++ - Breaking & Building C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 22, 2025, 12:00 AM +0200" prep="on" > Oct 22 <i class="unloaded">2025-10-22T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Mon, Oct 27, 2025, 6:15 PM +0100" prefix="Updated " > Oct 27 <i class="unloaded">2025-10-27T18:15:07+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1220 words">6 min</span></div></div><div class="post-content"><p>We often spend the French autumn school holidays back in our hometown, Budapest, Hungary — and this year, the timing worked out perfectly for me to attend an event of the Budapest C++ Meetup. I’d like to thank the organizers for putting together such a great evening by sharing a short report from the event.</p><p>More than a hundred people registered, and the room quickly filled up with local developers eager to hear three technical talks. The atmosphere was lively and welcoming — it showed the strength of the C++ community in Budapest. <strong>In 2027, <a href="https://isocpp.org/std/meetings-and-participation/upcoming-meetings">even WG21 might come to Hungary</a>!</strong></p><p>The evening began with Jonathan Müller’s talk, <strong>Cache-Friendly C++</strong>, followed by my own session on <strong>Strongly Typed Containers</strong>. Finally, Marcell Juhász closed the event with an insightful and hands-on presentation on <strong>Hacking and Securing C++</strong>.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/c++meetup_1022.jpeg" alt="Budapest C++ Group (photo by Balázs Bondici)" /> <em>Budapest C++ Group (photo by Balázs Bondici)</em></p><p>Let’s dive into some more details.</p><h2 id="cache-friendly-c-by-jonathan-müller">Cache-Friendly C++ by Jonathan Müller</h2><p>This was one of those deep dives that reminds you how much of software performance is bound by the physical reality of hardware. He began by walking us through the fundamentals of memory access — how the CPU’s speed advantage over main memory has made caching essential, and why understanding this hierarchy is key for writing fast code. It’s one thing to know that “cache is fast, RAM is slow”, but Jonathan illustrated this vividly: object size, access patterns, and even the order of members inside a struct can make a measurable difference.</p><p>From there, he contrasted data structures that play nicely with caches against those that don’t. Linked lists, for instance, are almost a textbook example of cache-unfriendly design: every node jump likely triggers a cache miss. In contrast, <code class="language-plaintext highlighter-rouge">std::vector</code> shines precisely because its elements live in contiguous memory. That’s the real reason it’s so often the best choice — not just because of its API convenience, but because it aligns with how modern CPUs want to consume data.</p><p>Jonathan then shifted to the philosophy of data-oriented design, where you shape your data for efficient access rather than just elegant abstraction. This often leads to transforming <em>“arrays of structs”</em> into <em>“structs of arrays”</em>, which can drastically improve cache performance in tight loops. But he was quick to temper the enthusiasm: this transformation can also harm readability and maintainability. It’s a tool for when performance really matters, not a default approach.</p><p>The talk closed on a pragmatic note that summed up the spirit of his message: “<em>But benchmark to make sure you’re actually optimizing”</em>. Don’t end up situations where you spend a lot of time optimizing, but you don’t end up with faster, just less maintainable code.</p><h2 id="strongly-typed-containers-by-sándor-dargó">Strongly Typed Containers by Sándor Dargó</h2><p>I guess it’s always a special feeling to speak in your hometown. For me it was the first time, and it felt great. In my talk, we explored one of my favorite topics: how far we can take type safety in C++ before the language — or our sanity — starts to push back. Strong typing is easy to advocate for in theory: it reduces ambiguity, improves readability, and catches a whole class of bugs at compile time. But in practice, it raises important design questions — especially when our goal is to make containers not just generic, but also semantically strong.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/me-at-budapest-cpp-2025.jpg" alt="Me at Budapest C++ (photo by Balázs Bondici)" /> <em>Me at Budapest C++ (photo by Balázs Bondici)</em></p><p>I began by examining why we’d even want strongly typed containers in the first place. It’s not just about avoiding accidental mix-ups between units or IDs — it’s about making code self-documenting and harder to misuse. From there, I walked through different implementation strategies: inheritance (and the pitfalls of both <code class="language-plaintext highlighter-rouge">public</code> and <code class="language-plaintext highlighter-rouge">private</code> forms), composition as a safer and clearer alternative, and how to use C++’s type system to wrap <code class="language-plaintext highlighter-rouge">std::vector</code> or other STL containers without losing their familiar interface. We discussed when it’s acceptable to <em>“bend”</em> STL design rules, and when it’s better to keep them intact.</p><p>Toward the end, I mentioned a few open source tools for implementing strong types and went into some details about one. I did, admittedly, miscalculate my timing and had to rush through the last couple of slides, but the audience in Budapest was engaged and forgiving.</p><p>Presenting this talk at home made it all the more enjoyable. Sharing ideas about stronger types and safer abstractions in C++ — and seeing how others connect with those challenges — was a reminder of why I love speaking at meetups like this one.</p><h2 id="hacking-and-securing-c-by-marcell-juhász">Hacking and Securing C++ by Marcell Juhász</h2><p>Marcell talk was one of the most vivid demonstrations of how dangerous <em>“undefined behavior”</em> can become when code meets hardware. He built his entire presentation around a small embedded device — simple enough to understand in detail, yet realistic enough to expose the kind of vulnerabilities that still plague production systems today. We began with the basics: memory layouts and address spaces on microcontrollers. We learned about how de/allocation happens on the stack. When a function exits, the next one might unknowingly read leftovers from its predecessor - maybe someone’s password.</p><p>From there, Marcell guided us through increasingly severe exploits, showing how seemingly harmless coding oversights can leak sensitive information or even allow arbitrary code execution. The slides on the stack vulnerability were particularly striking — how an uninitialized local buffer can serve as a window into the stack, exposing old data byte by byte. Later, he shifted focus to the heap, illustrating how use-after-free and dangling pointers can emerge from innocent-looking delete operations. Once again, the lesson was clear: C and C++ give you enormous power over memory, but with that power comes the responsibility to initialize, sanitize, and properly manage every allocation.</p><p>Marcell didn’t stop at the horrors. He also offered a pragmatic roadmap toward safety. Initialize local and dynamic variables. Wipe sensitive data in destructors. Prefer RAII and smart pointers to raw ownership. Use bounded containers like <code class="language-plaintext highlighter-rouge">std::array</code> and <code class="language-plaintext highlighter-rouge">std::vector</code>, and never rely on client-side validation for anything security-related. His closing slide said it all, with large C++ shield in the middle:</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/use-modern-cpp.png" alt="Use modern C++" /></p><p>In the end, what made this talk memorable wasn’t just the exploits — it was how Marcell connected them back to everyday C++ coding. Even if you’ll never write firmware for a microcontroller, the principles carry over: memory is fragile, trust is dangerous, and the best security often comes from disciplined simplicity and the most basic features of C++.</p><h2 id="conclusion">Conclusion</h2><p>The Budapest C++ Meetup was a great reminder of how strong and curious our local community is. Each talk approached the language from a different angle — Jonathan Müller from the perspective of performance, mine from design and type safety, and Marcell Juhász from security — yet all shared the same core message: understand what C++ gives you and use it wisely. Whether it’s memory access patterns, type abstractions, or resource management, the difference between elegant code and fragile software often comes down to awareness and discipline.</p><p>It was inspiring to see so many people gathered to learn, discuss, and share ideas about modern C++. Budapest clearly has a thriving developer scene, and I’m already looking forward my next visit to Budapest - hopefully at the same time with another meetup.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/conference/" class="post-tag no-text-decoration" >conference</a> <a href="/tags/budapestcpp/" class="post-tag no-text-decoration" >budapestcpp</a> <a href="/tags/tripreport/" class="post-tag no-text-decoration" >tripreport</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Trip report: Budapest C++ - Breaking & Building C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Trip report: Budapest C++ - Breaking & Building C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Trip report: Budapest C++ - Breaking & Building C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Trip report: Budapest C++ - Breaking & Building C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2019/06/26/travel-report-cppp"><div class="card-body"> <span class="timeago small" > Jun 26, 2019 <i class="unloaded">2019-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Travel report: CPPP 2019</h3><div class="text-muted small"><p> Right after I was returning from a three and a half weeks long road trip with destinations in 5 countries, then attending an advanced presentation skills workshop, I was finally heading to the airp...</p></div></div></a></div><div class="card"> <a href="/blog/2020/07/29/cpponsea2020-trip-report"><div class="card-body"> <span class="timeago small" > Jul 29, 2020 <i class="unloaded">2020-07-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtual Trip Report: C++ On Sea 2020</h3><div class="text-muted small"><p> Last week, I “went” to the C++ On Sea 2020, which was my second C++ conference, after CPPP 2019. I put went between quotes because as you might have guessed due to the Coronavirus, the organizers h...</p></div></div></a></div><div class="card"> <a href="/blog/2021/11/17/trip-rerport-meetingcpp-2021"><div class="card-body"> <span class="timeago small" > Nov 17, 2021 <i class="unloaded">2021-11-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip Report: Meeting C++ 2021</h3><div class="text-muted small"><p> I feel very lucky that I could attend so many C++ conferences during the last 2 years. It feels a bit strange, but without Covid, this would not have been possible. My last conference was Meeting ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/10/15/how-to-choose-good-talks-to-go-to" class="btn btn-outline-primary" prompt="Older"><p>How to Pick Which Conference Talks to Attend</p></a> <a href="/blog/2025/10/29/three-meanings-of-reference" class="btn btn-outline-primary" prompt="Newer"><p>Three Meanings of Reference</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Trip report: Budapest C++ - Breaking & Building C++'; this.page.url = 'https://www.sandordargo.com/blog/2025/10/22/trip-report-budapest-cpp'; this.page.identifier = '/blog/2025/10/22/trip-report-budapest-cpp'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
