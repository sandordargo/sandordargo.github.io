<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Once more about dynamic_cast, a real use case" /><meta property="og:locale" content="en_US" /><meta name="description" content="I wrote a couple of times about dynamic_cast and I discouraged you from using it. In general, it makes code worse in terms of readability. When you get rid of dynamic_cast, either via self-discipline or by turning RTTI off, you’ll have to rely on dynamic dispatching and better abstractions. But there might be cases, when it’s not possible or at least it’s not meaningful to remove dynamic_cast, here is one, sent by one of you. Versioning with the help of dynamic_cast They have an SDK that anyone can implement. As there are new features added every now and then, the API keeps changing. Not surprisingly, the owners of the SDK want to prevent their users’ code from breaking. They achieve this by having different “versioned” interfaces for the same service where a new version inherits from the previous one. Let’s see a simplified example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InterfaceForSomeService_v1 { public: virtual void featureA() = 0; virtual void featureB() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { public: virtual void featureD() = 0; }; So far so good, now the question is what it’s the best way to choose between the interfaces, and how to know during runtime which are the interfaces that are implemented. By “best” we mean the most readable way that doesn’t leak any implementation details. Their solution is that they get the instance of the DLL and they always retrieve a void* (or something similarly basic type) pointer to stay compatible, but then they try to cast the object to all the different interfaces to know which are really implemented. If the cast is successful, they know they have found the right version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // https://godbolt.org/z/TK9WM65n1 #include &lt;iostream&gt; #include &lt;memory&gt; // sdk class InterfaceForSomeServiceBase{ public: virtual ~InterfaceForSomeServiceBase() = default; }; class InterfaceForSomeService_v1: public InterfaceForSomeServiceBase { public: virtual void featureA() = 0; virtual void featureB() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { public: virtual void featureD() = 0; }; class Server { public: void handle(std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation) { if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v3*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); p-&gt;featureC(); p-&gt;featureD(); } else if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v2*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); p-&gt;featureC(); } else if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v1*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); } else { std::cout &lt;&lt; &quot;unhandled version\n&quot;; } } }; // client class ClientServiceImplementation : public InterfaceForSomeService_v2 { public: void featureA() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureA\n&quot;; } void featureB() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureB\n&quot;; } void featureC() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureC\n&quot;; } }; // server std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; LoadFromDLL() { return std::make_unique&lt;ClientServiceImplementation&gt;(); } int main() { std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation = LoadFromDLL(); Server s; s.handle(std::move(clientImplementation)); } In this solution, it’s important to start casting from the newest version and go towards the oldest one. If in the previous listing, we change Server::handle and accidentally try to cast to InterfaceForSomeService_v1* before InterfaceForSomeService_v2* then we end up in a different branch and miss calling p-&gt;featureC() which is not part of the v1 API. As long as the API versioning is straightforward, it’s relatively easy to pay attention to this rule. Is there another solution? There is always another solution! Is it better? In this case, I’m not sure though. Remember, the goal is to avoid dynamic_cast so that we don’t depend on RTTI and our code becomes cleaner as well. Sadly (?), we cannot simply use different overloads to handle where there is an overload for each interface version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Server { public: /* ...*/ void handle(InterfaceForSomeService_v1* p) { // ... } void handle(InterfaceForSomeService_v2* p) { // ... } void handle(InterfaceForSomeService_v3* p) { // ... } int main() { std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation = LoadFromDLL(); Server s; s.handle(clientImplementation.get()); } /* &lt;source&gt;:120:7: error: no matching member function for call to &#39;handle&#39; 120 | s.handle(clientImplementation.get()); | ~~^~~~~~ &lt;source&gt;:69:11: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v1 *&#39; for 1st argument 69 | void handle(InterfaceForSomeService_v1* p) { | ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;source&gt;:75:10: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v2 *&#39; for 1st argument 75 | void handle(InterfaceForSomeService_v2* p) { | ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;source&gt;:82:11: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v3 *&#39; for 1st argument 82 | void handle(InterfaceForSomeService_v3* p) { */ This is probably evident for many of you, but I thought it’s still worth mentioning. We cannot get away from this problem that simply. Let’s introduce a ServiceVersion tag The way out of this situation is paved with a ServiceVersion tag. Let’s add an abstract method called getVersion to the InterfaceForSomeServiceBase class that has to be defined by each interface version. Then by querying that method, the server knows exactly which version it’s dealing with and therefore it can static_cast the base class pointer to the right derived class pointer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 enum class ServiceVersion { V1, V2, V3 }; class InterfaceForSomeServiceBase { public: virtual ~InterfaceForSomeServiceBase() = default; virtual ServiceVersion getVersion() const = 0; }; class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { public: ServiceVersion getVersion() const override { return ServiceVersion::V1; } // ... }; // ... class Server { public: void handle(std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation) { switch(clientImplementation-&gt;getVersion()) { case ServiceVersion::V1: handle_v1(static_cast&lt;InterfaceForSomeService_v1*&gt;(clientImplementation.get())); return; case ServiceVersion::V2: handle_v2(static_cast&lt;InterfaceForSomeService_v2*&gt;(clientImplementation.get())); return; case ServiceVersion::V3: handle_v3(static_cast&lt;InterfaceForSomeService_v3*&gt;(clientImplementation.get())); return; } } // ... }; This works well in a clean laboratory environment. The problem is that each derived class can override getVersion and a malicious or ignorant client might do this: 1 2 3 4 5 6 7 8 class ClientServiceImplementation : public InterfaceForSomeService_v2 { public: ServiceVersion getVersion() const override { return ServiceVersion::V3; // Oh, oh! } // ... }; And now due to the static_cast and the version mismatch, we’re going to have a segmentation fault! We cannot afford that. (Here is the whole example.) Ideally, we should ban the ClientServiceImplementation from overriding getVersion(). That’s what final is for, right? Making getVersion() final in InterfaceForSomeService_v2 would solve the problem, right? Not exactly. Remember that in the original example (and that’s a hard requirement in our scenario today), each new version inherits from the previous one: 1 2 3 class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { /* ... */ }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { /* ... */ }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { /* ... */ }; If we add the final qualifier to InterfaceForSomeService_v2::getVersion() then InterfaceForSomeService_v3 has no means to override it. Hiding details from the clients As I shared my concerns with the engineer who shared this example, he came up with a better solution. He would even hide the ServiceVersion enum. In this solution, the getInteraceServiceVersion() method returns a new type InterfaceForSomeServiceVersion which is only forward declared and its definition is not distributed to the clients. This type effectively wraps ServiceVersion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // sdk.h // Client cannot see the implementation of this class class InterfaceForSomeServiceVersion; class InterfaceForSomeServiceBase { public: virtual ~InterfaceForSomeServiceBase() = default; virtual InterfaceForSomeServiceVersion getInteraceServiceVersion() const = 0; }; class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { public: virtual void featureA() = 0; virtual void featureB() = 0; InterfaceForSomeServiceVersion getInteraceServiceVersion() const override; }; // and below would come the rest of the different versions The definition of ServiceVersion and InterfaceForSomeServiceVersion is part of an internal header that is not distributed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // This file is not distributed enum class ServiceVersion { V1, V2, V3 }; class InterfaceForSomeServiceVersion { public: constexpr InterfaceForSomeServiceVersion(ServiceVersion version) : version(version) {} constexpr ServiceVersion getVersion() const { return version; } private: ServiceVersion version; }; The implementation of the public sdk.h header would also not be distributed and it contains the definitions of getInteraceServiceVersion() for the different interface versions, such as this one: 1 2 3 4 InterfaceForSomeServiceVersion InterfaceForSomeService_v1::getInteraceServiceVersion() const { return { ServiceVersion::V1 }; } On the server side, the same handling goes on as in the previous version, each call can be dispatched to the right version with the help of static_cast, given that we know exactly which type we are dealing with. You can check out the full solution here. In this solution, the ServiceVersion is completely hidden from the client and if they want to try something malicious, they would have to define their own version of InterfaceForSomeServiceVersion which would violate the One Definition Rule and still likely make the server crash. Move forward with double inheritance I took a slightly different approach and ended up with code that is sadly less readable. My goal was to restrict client implementations from overriding getVersion while new interface versions can still do it. In order to do that, I expanded the inheritance tree. In order to define new interface versions, let’s use classes whose definitions are not available for clients. I mark them by appending Private to their names: 1 2 3 class InterfaceForSomeService_v1Private : public InterfaceForSomeServiceBase { /* ... */ }; class InterfaceForSomeService_v2Private : public InterfaceForSomeService_v1Private { /* ... */ }; class InterfaceForSomeService_v3Private : public InterfaceForSomeService_v2Private { /* ... */ }; These classes don’t make the getVersion() method final. On the other hand, for each version, there is a non-private counterpart and they do make the getVersion method final so that client implementations cannot override the version values. Here is one pair of classes: 1 2 3 4 5 6 7 8 9 10 class InterfaceForSomeService_v2Private : public InterfaceForSomeService_v1Private { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v2Private { ServiceVersion getVersion() const final override { return ServiceVersion::V2; } }; Now it’s impossible for the client implementation (inhering from a non-“private” class) to override getVersion() so as far as I can tell, our solution is safe. You can have a look at the full code here. Now you might tell me that this solution is not more readable than the original one based on RTTI and dynamic_casts. And you are perfectly right about that. Maybe we have found a case where using dynamic_cast gives probably the better solution. At the same time, it’s also worth remembering that RTTI incurs a bigger binary size and if that is something you cannot afford, you might have to deal with such occasional increased complexities. Conclusion Over the last years, I claimed a couple of times that if you give up RTTI and you restrict yourself from using dynamic_cast you’ll have not only smaller but also more readable code. I still think that it’s true in general, but we have been shown e a case where dynamic_cast makes things easier and probably even safer. Yet, if you cannot use RTTI, we saw some alternative solutions. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I wrote a couple of times about dynamic_cast and I discouraged you from using it. In general, it makes code worse in terms of readability. When you get rid of dynamic_cast, either via self-discipline or by turning RTTI off, you’ll have to rely on dynamic dispatching and better abstractions. But there might be cases, when it’s not possible or at least it’s not meaningful to remove dynamic_cast, here is one, sent by one of you. Versioning with the help of dynamic_cast They have an SDK that anyone can implement. As there are new features added every now and then, the API keeps changing. Not surprisingly, the owners of the SDK want to prevent their users’ code from breaking. They achieve this by having different “versioned” interfaces for the same service where a new version inherits from the previous one. Let’s see a simplified example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InterfaceForSomeService_v1 { public: virtual void featureA() = 0; virtual void featureB() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { public: virtual void featureD() = 0; }; So far so good, now the question is what it’s the best way to choose between the interfaces, and how to know during runtime which are the interfaces that are implemented. By “best” we mean the most readable way that doesn’t leak any implementation details. Their solution is that they get the instance of the DLL and they always retrieve a void* (or something similarly basic type) pointer to stay compatible, but then they try to cast the object to all the different interfaces to know which are really implemented. If the cast is successful, they know they have found the right version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // https://godbolt.org/z/TK9WM65n1 #include &lt;iostream&gt; #include &lt;memory&gt; // sdk class InterfaceForSomeServiceBase{ public: virtual ~InterfaceForSomeServiceBase() = default; }; class InterfaceForSomeService_v1: public InterfaceForSomeServiceBase { public: virtual void featureA() = 0; virtual void featureB() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { public: virtual void featureD() = 0; }; class Server { public: void handle(std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation) { if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v3*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); p-&gt;featureC(); p-&gt;featureD(); } else if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v2*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); p-&gt;featureC(); } else if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v1*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); } else { std::cout &lt;&lt; &quot;unhandled version\n&quot;; } } }; // client class ClientServiceImplementation : public InterfaceForSomeService_v2 { public: void featureA() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureA\n&quot;; } void featureB() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureB\n&quot;; } void featureC() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureC\n&quot;; } }; // server std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; LoadFromDLL() { return std::make_unique&lt;ClientServiceImplementation&gt;(); } int main() { std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation = LoadFromDLL(); Server s; s.handle(std::move(clientImplementation)); } In this solution, it’s important to start casting from the newest version and go towards the oldest one. If in the previous listing, we change Server::handle and accidentally try to cast to InterfaceForSomeService_v1* before InterfaceForSomeService_v2* then we end up in a different branch and miss calling p-&gt;featureC() which is not part of the v1 API. As long as the API versioning is straightforward, it’s relatively easy to pay attention to this rule. Is there another solution? There is always another solution! Is it better? In this case, I’m not sure though. Remember, the goal is to avoid dynamic_cast so that we don’t depend on RTTI and our code becomes cleaner as well. Sadly (?), we cannot simply use different overloads to handle where there is an overload for each interface version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Server { public: /* ...*/ void handle(InterfaceForSomeService_v1* p) { // ... } void handle(InterfaceForSomeService_v2* p) { // ... } void handle(InterfaceForSomeService_v3* p) { // ... } int main() { std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation = LoadFromDLL(); Server s; s.handle(clientImplementation.get()); } /* &lt;source&gt;:120:7: error: no matching member function for call to &#39;handle&#39; 120 | s.handle(clientImplementation.get()); | ~~^~~~~~ &lt;source&gt;:69:11: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v1 *&#39; for 1st argument 69 | void handle(InterfaceForSomeService_v1* p) { | ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;source&gt;:75:10: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v2 *&#39; for 1st argument 75 | void handle(InterfaceForSomeService_v2* p) { | ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;source&gt;:82:11: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v3 *&#39; for 1st argument 82 | void handle(InterfaceForSomeService_v3* p) { */ This is probably evident for many of you, but I thought it’s still worth mentioning. We cannot get away from this problem that simply. Let’s introduce a ServiceVersion tag The way out of this situation is paved with a ServiceVersion tag. Let’s add an abstract method called getVersion to the InterfaceForSomeServiceBase class that has to be defined by each interface version. Then by querying that method, the server knows exactly which version it’s dealing with and therefore it can static_cast the base class pointer to the right derived class pointer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 enum class ServiceVersion { V1, V2, V3 }; class InterfaceForSomeServiceBase { public: virtual ~InterfaceForSomeServiceBase() = default; virtual ServiceVersion getVersion() const = 0; }; class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { public: ServiceVersion getVersion() const override { return ServiceVersion::V1; } // ... }; // ... class Server { public: void handle(std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation) { switch(clientImplementation-&gt;getVersion()) { case ServiceVersion::V1: handle_v1(static_cast&lt;InterfaceForSomeService_v1*&gt;(clientImplementation.get())); return; case ServiceVersion::V2: handle_v2(static_cast&lt;InterfaceForSomeService_v2*&gt;(clientImplementation.get())); return; case ServiceVersion::V3: handle_v3(static_cast&lt;InterfaceForSomeService_v3*&gt;(clientImplementation.get())); return; } } // ... }; This works well in a clean laboratory environment. The problem is that each derived class can override getVersion and a malicious or ignorant client might do this: 1 2 3 4 5 6 7 8 class ClientServiceImplementation : public InterfaceForSomeService_v2 { public: ServiceVersion getVersion() const override { return ServiceVersion::V3; // Oh, oh! } // ... }; And now due to the static_cast and the version mismatch, we’re going to have a segmentation fault! We cannot afford that. (Here is the whole example.) Ideally, we should ban the ClientServiceImplementation from overriding getVersion(). That’s what final is for, right? Making getVersion() final in InterfaceForSomeService_v2 would solve the problem, right? Not exactly. Remember that in the original example (and that’s a hard requirement in our scenario today), each new version inherits from the previous one: 1 2 3 class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { /* ... */ }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { /* ... */ }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { /* ... */ }; If we add the final qualifier to InterfaceForSomeService_v2::getVersion() then InterfaceForSomeService_v3 has no means to override it. Hiding details from the clients As I shared my concerns with the engineer who shared this example, he came up with a better solution. He would even hide the ServiceVersion enum. In this solution, the getInteraceServiceVersion() method returns a new type InterfaceForSomeServiceVersion which is only forward declared and its definition is not distributed to the clients. This type effectively wraps ServiceVersion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // sdk.h // Client cannot see the implementation of this class class InterfaceForSomeServiceVersion; class InterfaceForSomeServiceBase { public: virtual ~InterfaceForSomeServiceBase() = default; virtual InterfaceForSomeServiceVersion getInteraceServiceVersion() const = 0; }; class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { public: virtual void featureA() = 0; virtual void featureB() = 0; InterfaceForSomeServiceVersion getInteraceServiceVersion() const override; }; // and below would come the rest of the different versions The definition of ServiceVersion and InterfaceForSomeServiceVersion is part of an internal header that is not distributed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // This file is not distributed enum class ServiceVersion { V1, V2, V3 }; class InterfaceForSomeServiceVersion { public: constexpr InterfaceForSomeServiceVersion(ServiceVersion version) : version(version) {} constexpr ServiceVersion getVersion() const { return version; } private: ServiceVersion version; }; The implementation of the public sdk.h header would also not be distributed and it contains the definitions of getInteraceServiceVersion() for the different interface versions, such as this one: 1 2 3 4 InterfaceForSomeServiceVersion InterfaceForSomeService_v1::getInteraceServiceVersion() const { return { ServiceVersion::V1 }; } On the server side, the same handling goes on as in the previous version, each call can be dispatched to the right version with the help of static_cast, given that we know exactly which type we are dealing with. You can check out the full solution here. In this solution, the ServiceVersion is completely hidden from the client and if they want to try something malicious, they would have to define their own version of InterfaceForSomeServiceVersion which would violate the One Definition Rule and still likely make the server crash. Move forward with double inheritance I took a slightly different approach and ended up with code that is sadly less readable. My goal was to restrict client implementations from overriding getVersion while new interface versions can still do it. In order to do that, I expanded the inheritance tree. In order to define new interface versions, let’s use classes whose definitions are not available for clients. I mark them by appending Private to their names: 1 2 3 class InterfaceForSomeService_v1Private : public InterfaceForSomeServiceBase { /* ... */ }; class InterfaceForSomeService_v2Private : public InterfaceForSomeService_v1Private { /* ... */ }; class InterfaceForSomeService_v3Private : public InterfaceForSomeService_v2Private { /* ... */ }; These classes don’t make the getVersion() method final. On the other hand, for each version, there is a non-private counterpart and they do make the getVersion method final so that client implementations cannot override the version values. Here is one pair of classes: 1 2 3 4 5 6 7 8 9 10 class InterfaceForSomeService_v2Private : public InterfaceForSomeService_v1Private { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v2Private { ServiceVersion getVersion() const final override { return ServiceVersion::V2; } }; Now it’s impossible for the client implementation (inhering from a non-“private” class) to override getVersion() so as far as I can tell, our solution is safe. You can have a look at the full code here. Now you might tell me that this solution is not more readable than the original one based on RTTI and dynamic_casts. And you are perfectly right about that. Maybe we have found a case where using dynamic_cast gives probably the better solution. At the same time, it’s also worth remembering that RTTI incurs a bigger binary size and if that is something you cannot afford, you might have to deal with such occasional increased complexities. Conclusion Over the last years, I claimed a couple of times that if you give up RTTI and you restrict yourself from using dynamic_cast you’ll have not only smaller but also more readable code. I still think that it’s true in general, but we have been shown e a case where dynamic_cast makes things easier and probably even safer. Yet, if you cannot use RTTI, we saw some alternative solutions. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts" /><meta property="og:url" content="https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2025-06-25T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Once more about dynamic_cast, a real use case" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-25T00:00:00+02:00","datePublished":"2025-06-25T00:00:00+02:00","description":"I wrote a couple of times about dynamic_cast and I discouraged you from using it. In general, it makes code worse in terms of readability. When you get rid of dynamic_cast, either via self-discipline or by turning RTTI off, you’ll have to rely on dynamic dispatching and better abstractions. But there might be cases, when it’s not possible or at least it’s not meaningful to remove dynamic_cast, here is one, sent by one of you. Versioning with the help of dynamic_cast They have an SDK that anyone can implement. As there are new features added every now and then, the API keeps changing. Not surprisingly, the owners of the SDK want to prevent their users’ code from breaking. They achieve this by having different “versioned” interfaces for the same service where a new version inherits from the previous one. Let’s see a simplified example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class InterfaceForSomeService_v1 { public: virtual void featureA() = 0; virtual void featureB() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { public: virtual void featureD() = 0; }; So far so good, now the question is what it’s the best way to choose between the interfaces, and how to know during runtime which are the interfaces that are implemented. By “best” we mean the most readable way that doesn’t leak any implementation details. Their solution is that they get the instance of the DLL and they always retrieve a void* (or something similarly basic type) pointer to stay compatible, but then they try to cast the object to all the different interfaces to know which are really implemented. If the cast is successful, they know they have found the right version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 // https://godbolt.org/z/TK9WM65n1 #include &lt;iostream&gt; #include &lt;memory&gt; // sdk class InterfaceForSomeServiceBase{ public: virtual ~InterfaceForSomeServiceBase() = default; }; class InterfaceForSomeService_v1: public InterfaceForSomeServiceBase { public: virtual void featureA() = 0; virtual void featureB() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { public: virtual void featureD() = 0; }; class Server { public: void handle(std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation) { if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v3*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); p-&gt;featureC(); p-&gt;featureD(); } else if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v2*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); p-&gt;featureC(); } else if (auto* p = dynamic_cast&lt;InterfaceForSomeService_v1*&gt;(clientImplementation.get()); p) { p-&gt;featureA(); p-&gt;featureB(); } else { std::cout &lt;&lt; &quot;unhandled version\\n&quot;; } } }; // client class ClientServiceImplementation : public InterfaceForSomeService_v2 { public: void featureA() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureA\\n&quot;; } void featureB() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureB\\n&quot;; } void featureC() override { std::cout &lt;&lt; &quot;ClientServiceImplementation(InterfaceForSomeService_v2)::featureC\\n&quot;; } }; // server std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; LoadFromDLL() { return std::make_unique&lt;ClientServiceImplementation&gt;(); } int main() { std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation = LoadFromDLL(); Server s; s.handle(std::move(clientImplementation)); } In this solution, it’s important to start casting from the newest version and go towards the oldest one. If in the previous listing, we change Server::handle and accidentally try to cast to InterfaceForSomeService_v1* before InterfaceForSomeService_v2* then we end up in a different branch and miss calling p-&gt;featureC() which is not part of the v1 API. As long as the API versioning is straightforward, it’s relatively easy to pay attention to this rule. Is there another solution? There is always another solution! Is it better? In this case, I’m not sure though. Remember, the goal is to avoid dynamic_cast so that we don’t depend on RTTI and our code becomes cleaner as well. Sadly (?), we cannot simply use different overloads to handle where there is an overload for each interface version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 class Server { public: /* ...*/ void handle(InterfaceForSomeService_v1* p) { // ... } void handle(InterfaceForSomeService_v2* p) { // ... } void handle(InterfaceForSomeService_v3* p) { // ... } int main() { std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation = LoadFromDLL(); Server s; s.handle(clientImplementation.get()); } /* &lt;source&gt;:120:7: error: no matching member function for call to &#39;handle&#39; 120 | s.handle(clientImplementation.get()); | ~~^~~~~~ &lt;source&gt;:69:11: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v1 *&#39; for 1st argument 69 | void handle(InterfaceForSomeService_v1* p) { | ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;source&gt;:75:10: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v2 *&#39; for 1st argument 75 | void handle(InterfaceForSomeService_v2* p) { | ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ &lt;source&gt;:82:11: note: candidate function not viable: cannot convert from base class pointer &#39;pointer&#39; (aka &#39;InterfaceForSomeServiceBase *&#39;) to derived class pointer &#39;InterfaceForSomeService_v3 *&#39; for 1st argument 82 | void handle(InterfaceForSomeService_v3* p) { */ This is probably evident for many of you, but I thought it’s still worth mentioning. We cannot get away from this problem that simply. Let’s introduce a ServiceVersion tag The way out of this situation is paved with a ServiceVersion tag. Let’s add an abstract method called getVersion to the InterfaceForSomeServiceBase class that has to be defined by each interface version. Then by querying that method, the server knows exactly which version it’s dealing with and therefore it can static_cast the base class pointer to the right derived class pointer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 enum class ServiceVersion { V1, V2, V3 }; class InterfaceForSomeServiceBase { public: virtual ~InterfaceForSomeServiceBase() = default; virtual ServiceVersion getVersion() const = 0; }; class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { public: ServiceVersion getVersion() const override { return ServiceVersion::V1; } // ... }; // ... class Server { public: void handle(std::unique_ptr&lt;InterfaceForSomeServiceBase&gt; clientImplementation) { switch(clientImplementation-&gt;getVersion()) { case ServiceVersion::V1: handle_v1(static_cast&lt;InterfaceForSomeService_v1*&gt;(clientImplementation.get())); return; case ServiceVersion::V2: handle_v2(static_cast&lt;InterfaceForSomeService_v2*&gt;(clientImplementation.get())); return; case ServiceVersion::V3: handle_v3(static_cast&lt;InterfaceForSomeService_v3*&gt;(clientImplementation.get())); return; } } // ... }; This works well in a clean laboratory environment. The problem is that each derived class can override getVersion and a malicious or ignorant client might do this: 1 2 3 4 5 6 7 8 class ClientServiceImplementation : public InterfaceForSomeService_v2 { public: ServiceVersion getVersion() const override { return ServiceVersion::V3; // Oh, oh! } // ... }; And now due to the static_cast and the version mismatch, we’re going to have a segmentation fault! We cannot afford that. (Here is the whole example.) Ideally, we should ban the ClientServiceImplementation from overriding getVersion(). That’s what final is for, right? Making getVersion() final in InterfaceForSomeService_v2 would solve the problem, right? Not exactly. Remember that in the original example (and that’s a hard requirement in our scenario today), each new version inherits from the previous one: 1 2 3 class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { /* ... */ }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v1 { /* ... */ }; class InterfaceForSomeService_v3 : public InterfaceForSomeService_v2 { /* ... */ }; If we add the final qualifier to InterfaceForSomeService_v2::getVersion() then InterfaceForSomeService_v3 has no means to override it. Hiding details from the clients As I shared my concerns with the engineer who shared this example, he came up with a better solution. He would even hide the ServiceVersion enum. In this solution, the getInteraceServiceVersion() method returns a new type InterfaceForSomeServiceVersion which is only forward declared and its definition is not distributed to the clients. This type effectively wraps ServiceVersion. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // sdk.h // Client cannot see the implementation of this class class InterfaceForSomeServiceVersion; class InterfaceForSomeServiceBase { public: virtual ~InterfaceForSomeServiceBase() = default; virtual InterfaceForSomeServiceVersion getInteraceServiceVersion() const = 0; }; class InterfaceForSomeService_v1 : public InterfaceForSomeServiceBase { public: virtual void featureA() = 0; virtual void featureB() = 0; InterfaceForSomeServiceVersion getInteraceServiceVersion() const override; }; // and below would come the rest of the different versions The definition of ServiceVersion and InterfaceForSomeServiceVersion is part of an internal header that is not distributed: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // This file is not distributed enum class ServiceVersion { V1, V2, V3 }; class InterfaceForSomeServiceVersion { public: constexpr InterfaceForSomeServiceVersion(ServiceVersion version) : version(version) {} constexpr ServiceVersion getVersion() const { return version; } private: ServiceVersion version; }; The implementation of the public sdk.h header would also not be distributed and it contains the definitions of getInteraceServiceVersion() for the different interface versions, such as this one: 1 2 3 4 InterfaceForSomeServiceVersion InterfaceForSomeService_v1::getInteraceServiceVersion() const { return { ServiceVersion::V1 }; } On the server side, the same handling goes on as in the previous version, each call can be dispatched to the right version with the help of static_cast, given that we know exactly which type we are dealing with. You can check out the full solution here. In this solution, the ServiceVersion is completely hidden from the client and if they want to try something malicious, they would have to define their own version of InterfaceForSomeServiceVersion which would violate the One Definition Rule and still likely make the server crash. Move forward with double inheritance I took a slightly different approach and ended up with code that is sadly less readable. My goal was to restrict client implementations from overriding getVersion while new interface versions can still do it. In order to do that, I expanded the inheritance tree. In order to define new interface versions, let’s use classes whose definitions are not available for clients. I mark them by appending Private to their names: 1 2 3 class InterfaceForSomeService_v1Private : public InterfaceForSomeServiceBase { /* ... */ }; class InterfaceForSomeService_v2Private : public InterfaceForSomeService_v1Private { /* ... */ }; class InterfaceForSomeService_v3Private : public InterfaceForSomeService_v2Private { /* ... */ }; These classes don’t make the getVersion() method final. On the other hand, for each version, there is a non-private counterpart and they do make the getVersion method final so that client implementations cannot override the version values. Here is one pair of classes: 1 2 3 4 5 6 7 8 9 10 class InterfaceForSomeService_v2Private : public InterfaceForSomeService_v1Private { public: virtual void featureC() = 0; }; class InterfaceForSomeService_v2 : public InterfaceForSomeService_v2Private { ServiceVersion getVersion() const final override { return ServiceVersion::V2; } }; Now it’s impossible for the client implementation (inhering from a non-“private” class) to override getVersion() so as far as I can tell, our solution is safe. You can have a look at the full code here. Now you might tell me that this solution is not more readable than the original one based on RTTI and dynamic_casts. And you are perfectly right about that. Maybe we have found a case where using dynamic_cast gives probably the better solution. At the same time, it’s also worth remembering that RTTI incurs a bigger binary size and if that is something you cannot afford, you might have to deal with such occasional increased complexities. Conclusion Over the last years, I claimed a couple of times that if you give up RTTI and you restrict yourself from using dynamic_cast you’ll have not only smaller but also more readable code. I still think that it’s true in general, but we have been shown e a case where dynamic_cast makes things easier and probably even safer. Yet, if you cannot use RTTI, we saw some alternative solutions. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Once more about dynamic_cast, a real use case","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts"},"url":"https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts"}</script><title>Once more about dynamic_cast, a real use case | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2025"> 2025 </a> </span> <span> <a href="/06"> 06 </a> </span> <span> <a href="/25"> 25 </a> </span> <span>Once more about dynamic_cast, a real use case</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Once more about dynamic_cast, a real use case</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jun 25, 2025, 12:00 AM +0200" prep="on" > Jun 25 <i class="unloaded">2025-06-25T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1980 words">11 min</span></div></div><div class="post-content"><p>I wrote a couple of times about <code class="language-plaintext highlighter-rouge">dynamic_cast</code> and I discouraged you from using it. In general, <a href="https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner">it makes code worse in terms of readability</a>. When you get rid of <code class="language-plaintext highlighter-rouge">dynamic_cast</code>, either via self-discipline or by <a href="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti">turning RTTI off</a>, you’ll have to rely on dynamic dispatching and better abstractions.</p><p>But there might be cases, when it’s not possible or at least it’s not meaningful to remove <code class="language-plaintext highlighter-rouge">dynamic_cast</code>, here is one, sent by one of you.</p><h2 id="versioning-with-the-help-of-dynamic_cast">Versioning with the help of <code class="language-plaintext highlighter-rouge">dynamic_cast</code></h2><p>They have an SDK that anyone can implement. As there are new features added every now and then, the API keeps changing. Not surprisingly, the owners of the SDK want to prevent their users’ code from breaking. They achieve this by having different “versioned” interfaces for the same service where a new version inherits from the previous one.</p><p>Let’s see a simplified example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">InterfaceForSomeService_v1</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureA</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureB</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v1</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureC</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureD</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>So far so good, now the question is what it’s the best way to choose between the interfaces, and how to know during runtime which are the interfaces that are implemented. By “best” we mean the most readable way that doesn’t leak any implementation details.</p><p>Their solution is that they get the instance of the DLL and they always retrieve a <code class="language-plaintext highlighter-rouge">void*</code> (or something similarly basic type) pointer to stay compatible, but then they try to cast the object to all the different interfaces to know which are really implemented. If the cast is successful, they know they have found the right version.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/TK9WM65n1</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span>
<span class="c1">// sdk</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeServiceBase</span><span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">InterfaceForSomeServiceBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v1</span><span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeServiceBase</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureA</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureB</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v1</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureC</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureD</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Server</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">InterfaceForSomeServiceBase</span><span class="o">&gt;</span> <span class="n">clientImplementation</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">InterfaceForSomeService_v3</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureA</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureB</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureC</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureD</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">InterfaceForSomeService_v2</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureA</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureB</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureC</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">auto</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">InterfaceForSomeService_v1</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureA</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">featureB</span><span class="p">();</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unhandled version</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">};</span>


<span class="c1">// client</span>

<span class="k">class</span> <span class="nc">ClientServiceImplementation</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="kt">void</span> <span class="n">featureA</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ClientServiceImplementation(InterfaceForSomeService_v2)::featureA</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
	<span class="kt">void</span> <span class="n">featureB</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ClientServiceImplementation(InterfaceForSomeService_v2)::featureB</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">void</span> <span class="n">featureC</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"ClientServiceImplementation(InterfaceForSomeService_v2)::featureC</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// server</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">InterfaceForSomeServiceBase</span><span class="o">&gt;</span> <span class="n">LoadFromDLL</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">ClientServiceImplementation</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">InterfaceForSomeServiceBase</span><span class="o">&gt;</span> <span class="n">clientImplementation</span> <span class="o">=</span> <span class="n">LoadFromDLL</span><span class="p">();</span>

    <span class="n">Server</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In this solution, it’s important to start casting from the newest version and go towards the oldest one. If in the previous listing, we change <code class="language-plaintext highlighter-rouge">Server::handle</code> and accidentally try to cast to <code class="language-plaintext highlighter-rouge">InterfaceForSomeService_v1*</code> before <code class="language-plaintext highlighter-rouge">InterfaceForSomeService_v2*</code> then we end up in a different branch and miss calling <code class="language-plaintext highlighter-rouge">p-&gt;featureC()</code> which is not part of the <em>v1</em> API. As long as the API versioning is straightforward, it’s relatively easy to pay attention to this rule.</p><h2 id="is-there-another-solution">Is there another solution?</h2><p>There is always another solution! Is it better? In this case, I’m not sure though. Remember, the goal is to avoid <code class="language-plaintext highlighter-rouge">dynamic_cast</code> so that we don’t depend on RTTI and our code becomes cleaner as well.</p><p>Sadly (?), we cannot simply use different overloads to handle where there is an overload for each interface version.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Server</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="cm">/* ...*/</span>

    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">InterfaceForSomeService_v1</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">handle</span><span class="p">(</span><span class="n">InterfaceForSomeService_v2</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
    	<span class="c1">// ...</span>
    <span class="p">}</span>

     <span class="kt">void</span> <span class="nf">handle</span><span class="p">(</span><span class="n">InterfaceForSomeService_v3</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span>
     	<span class="c1">// ...</span>
    <span class="p">}</span>

   <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">InterfaceForSomeServiceBase</span><span class="o">&gt;</span> <span class="n">clientImplementation</span> <span class="o">=</span> <span class="n">LoadFromDLL</span><span class="p">();</span>

    <span class="n">Server</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">handle</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
<span class="p">}</span>

<span class="cm">/*
&lt;source&gt;:120:7: error: no matching member function for call to 'handle'
  120 |     s.handle(clientImplementation.get());
      |     ~~^~~~~~
&lt;source&gt;:69:11: note: candidate function not viable: cannot convert from base class pointer 'pointer' (aka 'InterfaceForSomeServiceBase *') to derived class pointer 'InterfaceForSomeService_v1 *' for 1st argument
   69 |      void handle(InterfaceForSomeService_v1* p) {
      |           ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;source&gt;:75:10: note: candidate function not viable: cannot convert from base class pointer 'pointer' (aka 'InterfaceForSomeServiceBase *') to derived class pointer 'InterfaceForSomeService_v2 *' for 1st argument
   75 |     void handle(InterfaceForSomeService_v2* p) {
      |          ^      ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
&lt;source&gt;:82:11: note: candidate function not viable: cannot convert from base class pointer 'pointer' (aka 'InterfaceForSomeServiceBase *') to derived class pointer 'InterfaceForSomeService_v3 *' for 1st argument
   82 |      void handle(InterfaceForSomeService_v3* p) {
*/</span>
</pre></table></code></div></div><p>This is probably evident for many of you, but I thought it’s still worth mentioning. We cannot get away from this problem that simply.</p><h3 id="lets-introduce-a-serviceversion-tag">Let’s introduce a <code class="language-plaintext highlighter-rouge">ServiceVersion</code> tag</h3><p>The way out of this situation is paved with a <code class="language-plaintext highlighter-rouge">ServiceVersion</code> tag. Let’s add an abstract method called <code class="language-plaintext highlighter-rouge">getVersion</code> to the <code class="language-plaintext highlighter-rouge">InterfaceForSomeServiceBase</code> class that has to be defined by each interface version.</p><p>Then by querying that method, the server knows exactly which version it’s dealing with and therefore it can <code class="language-plaintext highlighter-rouge">static_cast</code> the base class pointer to the right derived class pointer.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">ServiceVersion</span> <span class="p">{</span>
    <span class="n">V1</span><span class="p">,</span>
    <span class="n">V2</span><span class="p">,</span>
    <span class="n">V3</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeServiceBase</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">InterfaceForSomeServiceBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">ServiceVersion</span> <span class="n">getVersion</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeServiceBase</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ServiceVersion</span> <span class="n">getVersion</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V1</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="k">class</span> <span class="nc">Server</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">handle</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">InterfaceForSomeServiceBase</span><span class="o">&gt;</span> <span class="n">clientImplementation</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">switch</span><span class="p">(</span><span class="n">clientImplementation</span><span class="o">-&gt;</span><span class="n">getVersion</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">case</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V1</span><span class="p">:</span> 
                <span class="n">handle_v1</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">InterfaceForSomeService_v1</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V2</span><span class="p">:</span>
                <span class="n">handle_v2</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">InterfaceForSomeService_v2</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="k">case</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V3</span><span class="p">:</span>
                <span class="n">handle_v3</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">InterfaceForSomeService_v3</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">clientImplementation</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
                <span class="k">return</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>This works well in a clean laboratory environment. The problem is that each derived class can override <code class="language-plaintext highlighter-rouge">getVersion</code> and a malicious or ignorant client might do this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ClientServiceImplementation</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ServiceVersion</span> <span class="n">getVersion</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V3</span><span class="p">;</span> <span class="c1">// Oh, oh!</span>
    <span class="p">}</span>
    
    <span class="c1">// ...</span>
<span class="p">};</span>
</pre></table></code></div></div><p>And now due to the <code class="language-plaintext highlighter-rouge">static_cast</code> and the version mismatch, we’re going to have a segmentation fault! We cannot afford that. (<a href="https://godbolt.org/z/3sdbcjGhf">Here is the whole example.</a>)</p><p>Ideally, we should ban the <code class="language-plaintext highlighter-rouge">ClientServiceImplementation</code> from overriding <code class="language-plaintext highlighter-rouge">getVersion()</code>. That’s what <code class="language-plaintext highlighter-rouge">final</code> is for, right? Making <code class="language-plaintext highlighter-rouge">getVersion()</code> <code class="language-plaintext highlighter-rouge">final</code> in <code class="language-plaintext highlighter-rouge">InterfaceForSomeService_v2</code> would solve the problem, right? Not exactly. Remember that in the original example (and that’s a hard requirement in our scenario today), each new version inherits from the previous one:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">InterfaceForSomeService_v1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeServiceBase</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">InterfaceForSomeService_v2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v1</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">InterfaceForSomeService_v3</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</pre></table></code></div></div><p>If we add the <code class="language-plaintext highlighter-rouge">final</code> qualifier to <code class="language-plaintext highlighter-rouge">InterfaceForSomeService_v2::getVersion()</code> then <code class="language-plaintext highlighter-rouge">InterfaceForSomeService_v3</code> has no means to override it.</p><h3 id="hiding-details-from-the-clients">Hiding details from the clients</h3><p>As I shared my concerns with the engineer who shared this example, he came up with a better solution. He would even hide the <code class="language-plaintext highlighter-rouge">ServiceVersion</code> <code class="language-plaintext highlighter-rouge">enum</code>. In this solution, the <code class="language-plaintext highlighter-rouge">getInteraceServiceVersion()</code> method returns a new type <code class="language-plaintext highlighter-rouge">InterfaceForSomeServiceVersion</code> which is only forward declared and its definition is not distributed to the clients. This type effectively wraps <code class="language-plaintext highlighter-rouge">ServiceVersion</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="c1">// sdk.h</span>

<span class="c1">// Client cannot see the implementation of this class</span>
<span class="k">class</span> <span class="nc">InterfaceForSomeServiceVersion</span><span class="p">;</span>


<span class="k">class</span> <span class="nc">InterfaceForSomeServiceBase</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">InterfaceForSomeServiceBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">InterfaceForSomeServiceVersion</span> <span class="n">getInteraceServiceVersion</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeServiceBase</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureA</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureB</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="n">InterfaceForSomeServiceVersion</span> <span class="n">getInteraceServiceVersion</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>
<span class="c1">// and below would come the rest of the different versions</span>
</pre></table></code></div></div><p>The definition of <code class="language-plaintext highlighter-rouge">ServiceVersion</code> and <code class="language-plaintext highlighter-rouge">InterfaceForSomeServiceVersion</code> is part of an internal header that is not distributed:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// This file is not distributed</span>

<span class="k">enum</span> <span class="k">class</span> <span class="nc">ServiceVersion</span> <span class="p">{</span>
    <span class="n">V1</span><span class="p">,</span>
    <span class="n">V2</span><span class="p">,</span>
    <span class="n">V3</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeServiceVersion</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">constexpr</span> <span class="n">InterfaceForSomeServiceVersion</span><span class="p">(</span><span class="n">ServiceVersion</span> <span class="n">version</span><span class="p">)</span> <span class="o">:</span> <span class="n">version</span><span class="p">(</span><span class="n">version</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">constexpr</span> <span class="n">ServiceVersion</span> <span class="n">getVersion</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">version</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="n">ServiceVersion</span> <span class="n">version</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The implementation of the public <code class="language-plaintext highlighter-rouge">sdk.h</code> header would also not be distributed and it contains the definitions of <code class="language-plaintext highlighter-rouge">getInteraceServiceVersion()</code> for the different interface versions, such as this one:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">InterfaceForSomeServiceVersion</span> <span class="n">InterfaceForSomeService_v1</span><span class="o">::</span><span class="n">getInteraceServiceVersion</span><span class="p">()</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V1</span> <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>On the server side, the same handling goes on as in the previous version, each call can be dispatched to the right version with the help of <code class="language-plaintext highlighter-rouge">static_cast</code>, given that we know exactly which type we are dealing with. You can <a href="https://godbolt.org/z/WGq7o96a5">check out the full solution here</a>.</p><p>In this solution, the <code class="language-plaintext highlighter-rouge">ServiceVersion</code> is completely hidden from the client and if they want to try something malicious, they would have to define their own version of <code class="language-plaintext highlighter-rouge">InterfaceForSomeServiceVersion</code> which would violate the <a href="https://en.wikipedia.org/wiki/One_Definition_Rule">One Definition Rule</a> and still likely make the server crash.</p><h3 id="move-forward-with-double-inheritance">Move forward with double inheritance</h3><p>I took a slightly different approach and ended up with code that is sadly less readable. My goal was to restrict client implementations from overriding <code class="language-plaintext highlighter-rouge">getVersion</code> while new interface versions can still do it. In order to do that, I expanded the inheritance tree.</p><p>In order to define new interface versions, let’s use classes whose definitions are not available for clients. I mark them by appending <em>Private</em> to their names:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">InterfaceForSomeService_v1Private</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeServiceBase</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">InterfaceForSomeService_v2Private</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v1Private</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
<span class="k">class</span> <span class="nc">InterfaceForSomeService_v3Private</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2Private</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</pre></table></code></div></div><p>These classes don’t make the <code class="language-plaintext highlighter-rouge">getVersion()</code> method final.</p><p>On the other hand, for each version, there is a non-private counterpart and they do make the <code class="language-plaintext highlighter-rouge">getVersion</code> method <code class="language-plaintext highlighter-rouge">final</code> so that client implementations cannot override the version values.</p><p>Here is one pair of classes:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">InterfaceForSomeService_v2Private</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v1Private</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">featureC</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">InterfaceForSomeService_v2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InterfaceForSomeService_v2Private</span> <span class="p">{</span>
    <span class="n">ServiceVersion</span> <span class="n">getVersion</span><span class="p">()</span> <span class="k">const</span> <span class="k">final</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">ServiceVersion</span><span class="o">::</span><span class="n">V2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Now it’s impossible for the client implementation (inhering from a non-“private” class) to override <code class="language-plaintext highlighter-rouge">getVersion()</code> so as far as I can tell, our solution is safe. <a href="https://godbolt.org/z/oPW8YEnvq">You can have a look at the full code here</a>.</p><p>Now you might tell me that this solution is not more readable than the original one based on RTTI and <code class="language-plaintext highlighter-rouge">dynamic_cast</code>s. And you are perfectly right about that. Maybe we have found a case where using <code class="language-plaintext highlighter-rouge">dynamic_cast</code> gives probably the better solution.</p><p>At the same time, it’s also worth remembering that RTTI incurs a bigger binary size and if that is something you cannot afford, you might have to deal with such occasional increased complexities.</p><h2 id="conclusion">Conclusion</h2><p>Over the last years, I claimed a couple of times that if you give up RTTI and you restrict yourself from using <code class="language-plaintext highlighter-rouge">dynamic_cast</code> you’ll have not only smaller but also more readable code. I still think that it’s true in general, but we have been shown e a case where <code class="language-plaintext highlighter-rouge">dynamic_cast</code> makes things easier and probably even safer. Yet, if you cannot use RTTI, we saw some alternative solutions.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/bug/" class="post-tag no-text-decoration" >bug</a> <a href="/tags/undefinedbehaviour/" class="post-tag no-text-decoration" >undefinedbehaviour</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Once more about dynamic_cast, a real use case - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Once more about dynamic_cast, a real use case - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Once more about dynamic_cast, a real use case - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Once more about dynamic_cast, a real use case - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/04/20/range-base-p2012"><div class="card-body"> <span class="timeago small" > Apr 20, 2022 <i class="unloaded">2022-04-20T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The infamous bug of range-based for loops</h3><div class="text-muted small"><p> Imagine that you used a feature of your favourite language without fear. Imagine that you used that feature endlessly, without having a second thought. You even promoted it in conversations, in cod...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2025/06/18/variadic-inheritance" class="btn btn-outline-primary" prompt="Older"><p>Variadic class template arguments</p></a> <a href="/blog/2025/07/02/cpponsea-trip-report" class="btn btn-outline-primary" prompt="Newer"><p>Trip report: C++ On Sea 2025</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Once more about dynamic_cast, a real use case'; this.page.url = 'https://www.sandordargo.com/blog/2025/06/25/once-more-about-dynamic-casts'; this.page.identifier = '/blog/2025/06/25/once-more-about-dynamic-casts'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
