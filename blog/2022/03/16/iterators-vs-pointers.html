<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++ basics: Pointers vs iterators" /><meta property="og:locale" content="en_US" /><meta name="description" content="Do you sometimes feel that you cannot explain the most basic things of a language you work with? You’re asked a simple question and suddenly you can only say “eeeeeeeh, I have to check, sorry.” Don’t worry. Often we take things for granted, and until a less experienced person asks such a question, we don’t even think about them. But sometimes it’s worth going back to the basics and deepening or simply refreshing our knowledge." /><meta property="og:description" content="Do you sometimes feel that you cannot explain the most basic things of a language you work with? You’re asked a simple question and suddenly you can only say “eeeeeeeh, I have to check, sorry.” Don’t worry. Often we take things for granted, and until a less experienced person asks such a question, we don’t even think about them. But sometimes it’s worth going back to the basics and deepening or simply refreshing our knowledge." /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-03-16T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++ basics: Pointers vs iterators" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-03-16T00:00:00+01:00","datePublished":"2022-03-16T00:00:00+01:00","description":"Do you sometimes feel that you cannot explain the most basic things of a language you work with? You’re asked a simple question and suddenly you can only say “eeeeeeeh, I have to check, sorry.” Don’t worry. Often we take things for granted, and until a less experienced person asks such a question, we don’t even think about them. But sometimes it’s worth going back to the basics and deepening or simply refreshing our knowledge.","headline":"C++ basics: Pointers vs iterators","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers"},"url":"https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers"}</script><title>C++ basics: Pointers vs iterators | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/16"> 16 </a> </span> <span>C++ basics: Pointers vs iterators</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++ basics: Pointers vs iterators</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 16, 2022, 12:00 AM +0100" prep="on" > Mar 16, 2022 <i class="unloaded">2022-03-16T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2606 words">14 min</span></div></div><div class="post-content"><p>Do you sometimes feel that you cannot explain the most basic things of a language you work with? You’re asked a simple question and suddenly you can only say <em>“eeeeeeeh, I have to check, sorry.</em>”</p><p>Don’t worry. Often we take things for granted, and until a less experienced person asks such a question, we don’t even think about them. But sometimes it’s worth going back to the basics and deepening or simply refreshing our knowledge.</p><p>Today, let’s discuss pointers and iterators.</p><h2 id="pointers">Pointers</h2><p>Let’s start with the dreaded pointers which can make C and C++ difficult to learn compared to other languages.</p><h3 id="what-is-a-pointer">What is a pointer?</h3><p>First of all, a pointer is a type of variable that is meant to store a memory address.</p><p>I say meant to, because if it’s correctly initialized it either stores <code class="language-plaintext highlighter-rouge">nullptr</code> or the address of another variable - it can even store the address of another pointer -, but if it’s not correctly initialized, it will contain random data which is quite dangerous, it can lead to undefined behaviour.</p><h3 id="how-can-you-initialize-a-pointer">How can you initialize a pointer?</h3><p>You have three different ways!</p><ul><li>Take the address of another variable:</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="n">v</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><ul><li>Point it to a variable on the heap ```cpp #include <iostream></iostream></ul><p>int main(){ int* p = new int {42}; }</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>
- Or just take the value of another pointer
```cpp
#include &lt;iostream&gt;

int main(){
  int* p = new int {42};
  int* p2 = p;
}
</pre></table></code></div></div><h3 id="pointer-values-and-pointed-values">Pointer values and pointed values</h3><p>In any case, if you print the value of a pointer, it will be a memory address. If you want to get the pointed value, you have to dereference the pointer with <code class="language-plaintext highlighter-rouge">operator*</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">&amp;</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
0x215dc20 42
0x215dc20 42
0x7fff77592cb0 0x7fff77592cb8
*/</span>
</pre></table></code></div></div><p>In this example, we can see that both <code class="language-plaintext highlighter-rouge">p</code> and <code class="language-plaintext highlighter-rouge">p2</code> stores the same memory address and therefore they locate the same value too. At the same time, the addresses of the pointers themselves are different - taken by <code class="language-plaintext highlighter-rouge">operator&amp;</code>.</p><h3 id="memory-deallocation">Memory deallocation</h3><p>If an allocation happens with the <code class="language-plaintext highlighter-rouge">new</code> operator, in other words, if an allocation is on the heap, someone has to deallocate the allocated memory which happens with <code class="language-plaintext highlighter-rouge">delete</code>. Should you forget to do it when the pointer goes out of scope and you will have a memory leak.</p><p>You’ll have no more access to that place of memory and as it’s not deallocated nobody else can use it. Should your code run long enough and create enough memory leaks, it might crash as it won’t have access to enough memory anymore. So make sure you deallocate all allocated memory.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>If you try to access the pointer after the deletion, or if you try to delete it a second time, that’s undefined behaviour and you’ll most probably face a core dump.</p><p>Such errors often happen in legacy code, for example in such scenarios:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  
  <span class="kt">bool</span> <span class="n">error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> 
  <span class="p">}</span>
  
  <span class="c1">// ...</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> 
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">error</code> obviously is assigned from a more complex computation and usually, the 2 deletions are not added to the code at the same time.</p><p>The poor man’s defence technique is to assign <code class="language-plaintext highlighter-rouge">nullptr</code> to <code class="language-plaintext highlighter-rouge">p</code> after deletion. If you try to delete the pointer again, it won’t have any effect as deleting a <code class="language-plaintext highlighter-rouge">nullptr</code> is a no-op.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  
  <span class="kt">bool</span> <span class="n">error</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="c1">// ...</span>
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> 
  <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The other thing to do is to always check for ptr validity before you access one. But even if we ignore the problems of thread safety, we cannot feel safe. What if a pointer was deleted already and not set to <code class="language-plaintext highlighter-rouge">nullptr</code>? Undefined behaviour, potentially a crash. Or even worse…</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// we forget to set it to nullptr</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// we pass the condition</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
0x22f3c20 42
0x22f3c20 0
*/</span>
</pre></table></code></div></div><p>Or what if you made a copy of the pointer? You delete one pointer and set it to <code class="language-plaintext highlighter-rouge">nullptr</code>. The copied sibling will not know that the other was deleted:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">42</span><span class="p">};</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="c1">// we forget to set it to nullptr</span>
  <span class="n">p</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// p is nullptr, we skip this block</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  
  
  <span class="k">if</span> <span class="p">(</span><span class="n">p2</span> <span class="o">!=</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// we pass the condition and anything can happen</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
0x1133c20 42
0x1133c20 0
*/</span>
</pre></table></code></div></div><p>This case can easily happen when you have classes managing resources via raw pointers and their copy/move operations are not correctly implemented.</p><h3 id="iterate-over-arrays">Iterate over arrays</h3><p>One more thing to mention about pointers is the operations you can perform on them. We often refer to them as pointer arithmetics. Meaning that you can increment or decrement them (perform addition and subtraction). But in fact, you can add or subtract any integer… Using the increment/decrement feature, pointers can be used to iterate over arrays or to access any element of them.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="kt">int</span> <span class="n">numbers</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">numbers</span><span class="p">;</span>
  
  <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="o">++</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*--</span><span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="p">(</span><span class="n">p</span><span class="o">+</span><span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
1
2
3
4
5
5
4
3
2
1

4
*/</span>
</pre></table></code></div></div><p>Nice, but in 2022 should we use pointers to iterate over arrays?</p><p>The answer is clearly no. It’s not safe, a pointer can just point anywhere and it doesn’t work with all the container types.</p><p>You might have noticed in the previous example that in the first loop we use post-fix increment and in the second loop a pre-fix decrement. After counting up, the pointer already points to an invalid location, so we have to decrement it before dereferencing, otherwise, we risk undefined behaviour.</p><h3 id="do-not-use-raw-pointers">Do not use raw pointers</h3><p>In fact, nowadays there is not much reason to use raw pointers at all. Especially not raw pointers that are allocated with new, raw pointers that are owning their resources. Passing around resources via a raw pointer is still okay, but owning those resources or using pointers as iterators or expressing that a value might or might not be there is something you shouldn’t tolerate in your codebase anymore.</p><p>We have different better options.</p><p>First of all, we can use smart pointers to replace owning raw pointers.</p><p>When we use non-owning pointers, we might use references if something cannot be <code class="language-plaintext highlighter-rouge">nullptr</code> or if we want to express that something might or might not be present, we could try <code class="language-plaintext highlighter-rouge">std::optional</code>. But more on this another day.</p><p>Let’s focus on iterating over an array now and let’s see some other options, what can we do with iterators?</p><h2 id="what-is-an-iterator">What is an iterator?</h2><p>Iterators are an essential part of the Standard Template Library. The STL has 4 main building blocks:</p><ul><li><a href="https://www.sandordargo.com/blog/2019/01/30/stl-algos-intro">algorithms</a> (<code class="language-plaintext highlighter-rouge">std::rotate</code>, <code class="language-plaintext highlighter-rouge">std::find_if</code>, etc.)<li>containers (<code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">std::list&lt;T&gt;</code>, etc.)<li>function objects (<code class="language-plaintext highlighter-rouge">std::greater&lt;T&gt;</code>, <code class="language-plaintext highlighter-rouge">std::logical_and&lt;T&gt;</code>, etc.)<li>iterators (<code class="language-plaintext highlighter-rouge">std::iterator</code>, <code class="language-plaintext highlighter-rouge">std::back_inserter</code>, etc.)</ul><p>Iterators are the result of the generalization of the concept of a pointer. They can be used to iterate over the elements of an STL container and provide access to the individual elements.</p><p>The mention of the STL containers also means that they cannot be used with C-style arrays. It’s fine, we should not use C-style arrays at all in 2021.</p><h3 id="the-5-categories-of-iterators">The 5 categories of iterators</h3><p>There are essentially 5 categories of iterators:</p><ul><li>input iterators<li>output iterators<li>forward iterators<li>bidirectional iterators<li>random access iterators</ul><p><em>Input iterators</em> are the simplest form of iterators. They are supporting read-operations and can only move forward. You can use input iterators for (in)equality comparisons and they can be incremented. An example would be the iterator of a <code class="language-plaintext highlighter-rouge">std::list</code>.</p><p><em>Output iterators</em> are also forward iterators, but they are used to assign values in a container, they are write-only iterators. You cannot use them to read values. Such an iterator is the <code class="language-plaintext highlighter-rouge">std::back_inserter</code> iterator.</p><p><em>Forward iterators</em> are the combination of input and output iterators. They let us both access and modify values. <code class="language-plaintext highlighter-rouge">std::replace</code> uses forward iterators for example. Forward iterators are default constructible and they can access/dereference the same positions multiple times.</p><p><em>Bidirectional iterators</em> are like forward iterators, but they can be also decremented, so they can move both forward and backward. <code class="language-plaintext highlighter-rouge">std::reverse_copy</code> uses such iterators as it both has to reverse values of a container (decrement) and put results in a new container one after the other (increment).</p><p><em>Random access iterators</em> are capable of anything that bidirectional iterators can do. In addition, they cannot only be incremented or decremented but their position can be modified by any value. In other words, they support <code class="language-plaintext highlighter-rouge">operator+</code> and <code class="language-plaintext highlighter-rouge">operator-</code>. Different random access iterators can also be compared with the different comparison operators (not just with equality/inequality). Random access means that containers accepting random-access iterators can be simply accessed with the offset operator. An algorithm that needs random-access iterators is <code class="language-plaintext highlighter-rouge">std::random_shuffle()</code>.</p><h3 id="usage-of-iterators">Usage of iterators</h3><p>Iterators can be obtained from containers essentially two different ways:</p><ul><li>through member functions such as <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;::begin()</code> or <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;::end()</code><li>or via free functions such as <code class="language-plaintext highlighter-rouge">std::begin()</code> or <code class="language-plaintext highlighter-rouge">std::end()</code></ul><p>There are different variations of iterators, from a practical point of view, they can be <code class="language-plaintext highlighter-rouge">const</code> or reversed direction as well.</p><p>Just like pointers, iterators can be incremented or decremented which makes them suitable for loops. Though before C++11 they were a bit verbose to use:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="o">=</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With C++11 and the introduction of the keyword <code class="language-plaintext highlighter-rouge">auto</code>, the usage of iterators was simplified quite a bit.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(){</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span><span class="o">=</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Of course, you might argue that <a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for loops</a> are easier to use, and you are right. It’s worth mentioning though that range-based for loops are also implemented with the help of iterators.</p><h2 id="how-an-iterator-differs-from-a-pointer">How an iterator differs from a pointer</h2><p>Now that we discussed both pointers and iterators separately, let’s collect the differences between the two categories.</p><p>While we are using pointers to hold a memory address, whatever memory address, an iterator is always used with containers. An iterator is used to go through the elements of a container and the items of the container don’t need to be stored on a contagious memory area. Even if the items are scattered in the memory, such as for a linked list, an iterator would still work.</p><p>Given that the pointer is always storing a memory address, it can be always be converted to an integer (which is the address). Most iterators cannot be converted into integers.</p><p>As we saw there are 5 different categories of iterators and not all of them support all the different pointer arithmetic operations. At the same time, pointers don’t have any such distinction. A pointer is a pointer and you can do all the operations with them - which is often quite dangerous.</p><p>If you declare a pointer to a type, it can point to any object of the same type. Luckily, iterators are more restricted and they work only inside a certain type of container.</p><p>If you ever used raw pointers, you know that they can be deleted, moreover, the owning ones must be deleted in order to avoid memory leaks. Iterators on the other hand cannot be, should not be deleted. An iterator is not responsible for memory management, its sole responsibility is to provide a handle to the elements in the container.</p><h2 id="when-to-use-one-and-when-the-other">When to use one and when the other?</h2><p>Whenever you need to iterate over a standard container, use an iterator over a pointer. As it was designed exactly for that, it’s safer and that’s what you’d get anyway if you’d call <code class="language-plaintext highlighter-rouge">begin()</code> or <code class="language-plaintext highlighter-rouge">end()</code> on the container. Moreover, it’s iterators that STL algorithms are taking as inputs, not pointers and also that’s what they often return.</p><p>There are two reasons not to use iterators:</p><ul><li>using a <a href="https://en.cppreference.com/w/cpp/language/range-for">range-based for loop</a> that you should indeed prefer, but under the hood, in most cases, they use iterators anyway<li>using a C-style array. But in 2021, don’t use a C-style array, you can use <code class="language-plaintext highlighter-rouge">std::array</code> or another STL container.</ul><p>Don’t use pointers for iterations. Use pointers only when you need to pass the address of a variable to another function and when it might be null so you cannot use a reference instead.</p><p>Pointers also come in handy when you have to deal with polymorphism and you need dynamic dispatching, you need to determine which version of a <code class="language-plaintext highlighter-rouge">virtual</code> function should be called only during runtime.</p><p>For memory handling, don’t use (raw) pointers. If you need to use dynamic memory allocations, if you need the heap, use a smart pointer instead of a raw pointer so that you can avoid memory leaks or double frees.</p><h2 id="conclusion">Conclusion</h2><p>I wish I understood the basics of C++ at the beginning of my developer career.</p><p>I wish I understood them today.</p><p>With this piece, I’m a bit closer to understanding the basics of pointers and iterators, I hope you do too.</p><h2 id="references">References</h2><ul><li><a href="https://stdcxx.apache.org/doc/stdlibug/2-2.html">Apache C++ Standard Library User’s Guide: Varieties of Iterators</a><li><a href="https://www.cs.helsinki.fi/u/tpkarkka/alglib/k06/lectures/iterators.html">University of Helsinki: STL Iterators</a><li><a href="https://www.geeksforgeeks.org/difference-between-iterators-and-pointers-in-c-c-with-examples/">GeeksForGeeks: Difference between Iterators and Pointers in C/C++ with Examples</a><li><a href="https://docs.microsoft.com/en-us/cpp/cpp/raw-pointers?view=msvc-160">Microsoft: Raw pointers (C++)</a><li><a href="https://stackoverflow.com/questions/22146094/why-should-i-use-a-pointer-rather-than-the-object-itself">Stackoverflow: Why should I use a pointer rather than the object itself?</a></ul><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/tutorial/" class="post-tag no-text-decoration" >tutorial</a> <a href="/tags/iterators/" class="post-tag no-text-decoration" >iterators</a> <a href="/tags/pointers/" class="post-tag no-text-decoration" >pointers</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++ basics: Pointers vs iterators - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++ basics: Pointers vs iterators - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++ basics: Pointers vs iterators - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++ basics: Pointers vs iterators - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/03/30/vector-of-references-of-pointers"><div class="card-body"> <span class="timeago small" > Mar 30, 2022 <i class="unloaded">2022-03-30T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Storing references of pointers in containers in C++</h3><div class="text-muted small"><p> This article is about the problem of storing vectors in a container and a bug I faced recently. Many would quickly find the conclusion that you should not store raw pointers, but you should work ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div><div class="card"> <a href="/blog/2018/07/05/cpp-override"><div class="card-body"> <span class="timeago small" > Jul 5, 2018 <i class="unloaded">2018-07-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Why to use the override specifier in C++ 11?</h3><div class="text-muted small"><p> The override specifier was introduced to the language with C++11 and it is one of the easiest tool to significantly improve the maintainability of our codebases. override tells both the reader an...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/03/09/mocking-non-virtual-and-free-functions" class="btn btn-outline-primary" prompt="Older"><p>Mocking non-virtual and free functions with gMock</p></a> <a href="/blog/2022/03/23/employee-company-triangle" class="btn btn-outline-primary" prompt="Newer"><p>The Employee-Company triangle</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++ basics: Pointers vs iterators'; this.page.url = 'https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers'; this.page.identifier = '/blog/2022/03/16/iterators-vs-pointers'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
