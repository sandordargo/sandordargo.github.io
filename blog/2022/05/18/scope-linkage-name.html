<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++ basics: scopes, linkage, names" /><meta property="og:locale" content="en_US" /><meta name="description" content="First, I learnt C++ at university, but I better not count it. Then I first started to work with it 9 years ago. My employer booked a 5-day-training only for me. Those were good, generous times. But I think that the training was not that much of a success for several reasons. I understood years later when I started to review our C++ training offerings that the instructor was below average. Just like my English and programming knowledge. Despite the fact that I had been using English for a long time - even for work - following a 5-day-long technical training delivered by a non-native instructor was a bit too difficult for me. But I learned on the go. More or less. I still realize that sometimes I lack the correct understanding of some basic concepts. Whenever I have the realization, I consider writing an article on the topic. And I’ve been posting every week for the last 5 years. Lately, I had a similar realization while I was reading Beautiful C++. I’d still run into some issues if I had to explain what linkage is. So let’s discuss now a couple of things that the book brought up; the differences between name, linkage and scope. What is a name? That seems a simple question, especially if you consider this piece of code. 1 2 3 4 5 6 7 struct S { int m_num = 0; }; int main() { [[maybe_unused]] S s{42}; } What is a name? That’s s, right? It’s a name! Well. Right. But what is the difference between a name and an object? That’s probably still an easy one. What’s the difference between your name and you? Your name denotes you, but it’s not you, it’s not your physically existing body. A name is just a handle, a reference to an object. This might seem philosophical. Still, it’s important to make the distinction. Not only because the C++ standard does it, but because names and objects have different attributes. Names have a scope and objects have storage durations. Besides, not every object has a name, and not every name refers to an object. The latter one is obvious. For example functions and classes also have names but they are not objects. Objects might not have names. Like temporaries. Look at this example. 1 2 3 4 5 6 7 void foo(std::string s) { // ... } int main() { foo(std::string{&quot;bar&quot;}); } std::string{&quot;bar&quot;} creates an object, but it doesn’t have a name. But let’s get back to the question of scopes and store durations. We start with the latter. Storage duration All objects have a storage duration. The storage duration of an object determines what rules to apply for its creation and destruction. Often, people find it difficult to make a distinction between storage duration and lifetime. Lifetime is about the time when objects are usable and it’s a runtime property of an object. The storage duration determines the minimum potential lifetime of the storage containing an object. This is determined by the construct that is used to create the object. An object will always have one of the 4 following storage durations: automatic static dynamic thread Automatic storage duration means that all the storage necessary for non-static, non-extern, non-thread-local local objects in a code block are allocated at the beginning of the block and deallocated at the end. This also shows how the storage duration can start earlier than the lifetime of an object. The storage is usually allocated sooner than the object is constructed. In the case of static storage duration, the storage is allocated when the program begins and deallocated when the program ends. Variables with static storage duration have only one instance. Which objects have static storage duration? All that were declared with the static keyword! Besides, all of the objects that were declared at a namespace level or declared with the extern keyword. Dynamic storage duration probably raises the least number of questions. Storage for such objects is allocated and deallocated upon request. Think about the dreaded new/delete pairs. Objects that use them have a dynamic storage duration. Last but not least, we have to speak about thread local storage duration. The storage for such variables is allocated when the thread begins and deallocated when the thread ends. There is a different instance of the object in each thread. Only objects declared with the thread_local specifier have this kind of storage duration. thead_local can be combined with the static or extern keywords. Linkage Now that we talked about names and storage durations, we can finally talk about linkage. You declare a name in a scope. But what happens if you declare another entity with the same name in another scope? Or in several other scopes? It depends on the (lack of) linkage that how many instances will be generated. Till C++20, there were 3 different linkages, the fourth is a new one. no linkage internal linkage external linkage module linkage (introduced in C++20) A translation unit is the basic unit of compilation in C++. It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements. A single translation unit can be compiled into an object file, library, or executable program. With no linkage, a name can be referred to only from the scope where it was created. Think about simple local variables declared in a block of code. They have no linkage, you cannot refer to them from an outer scope. When a name has internal linkage, that name can be referred to from all scopes in the current translation unit. Static functions, variables, and their templated version, they all have internal linkage. Also, any names declared in an unnamed namespace have this level of linkage. When a name has external linkage, it can be referred to from the scopes of another translation unit. This can go as far as using variables and functions from translation units that were written in another language. Enumerations, class names and their member functions and static data members, non-static templates and class templates, etc. Module linkage was introduced in C++20. When a name has module linkage, it can only be referred to from the same module unit. This might mean another translation unit. Note that this section aimed to show what kind of different linkages exist in C++. If you want to verify the full specs of what kind of names have what kind of linkage, please read this page. Scope Last but not least, let’s talk about scopes. Scopes are collections of names referring to abstractions. Scopes are where a name is visible with an unqualified name lookup. This implies two things: names might be looked up in non-unqualified ways even outside of their scope the lifetime of an object might not end where the scope of its name ends There are 6 different scopes we can talk about: block scope function parameter scope namespace scope class scope enumeration scope template parameter scope A block scope is the most usual one. It starts with an opening brace and ends with a closing one. It’s worth noting that they can be discontinuous when we use nested blocks. 1 2 3 4 5 6 7 8 9 10 11 if (x.isValid) { // opens scope 1 auto r = 42; auto z = Foo{}; { // opens scope 2! auto r = z.something(); // this is a different r } // ends scope 2! // it&#39;s scope 1 again std::cout &lt;&lt; r &lt;&lt; &#39;\n&#39;; // r is 42 once again } // ends scope 1 It’s worth noting that in the nested block you can declare names that are used within the outer scope and as such, those become inaccessible (like r), but once the nested scope is closed we can refer to them again. Function parameter scope is very similar to block scope. In terms of scopes, the function is the combination of the block and the function header. A function-try-block is similar, the end of the scope is the end of the last catch block. By the way, have you ever seen a function-try-block? The following piece of code is a valid function: 1 2 3 4 5 6 7 float divide(float a, float b) try { std::cout &lt;&lt; &quot;Dividing\n&quot;; return a / b; } catch (...) { std::cout &lt;&lt; &quot;Dividing failed, was the denominator zero?\n&quot;; } The namespace scope starts where the namespace is declared and includes the rest of the namespace and all other namespace declarations with the same name. The top-level scope of a translation unit is also a namespace scope, that’s the global namespace scope. The class scope starts when a class starts being declared but does not end where the class declaration ends. It just pauses. You can resume it any time to define the declared elements. After resuming the scope, you can access entities of the class with different syntaxes (., -&gt;, ::). The enumeration scope depends on the type of the enumeration. In any case, the scope starts at the beginning of the enumeration declaration. The scope of a scoped enum ends at the end of the declaration. But the scope of an unscoped enum ends at the end of the enclosing scope. Last but not least, let’s not forget about the template parameter scope. The scope of a template parameter name begins at the point of declaration and ends at the end of the smallest template declaration in which it was introduced. Such parameters can be used in subsequent template parameter declarations and also in the base class specifications. Conclusion In this article, we discussed a couple of ideas that are often used when people talk about C++ or programming in general. Words that we might not dare to use in everyday conversations because we are not sure if we understand them well. Names, scopes, linkage and even translation units! Today we came a few steps closer to having a better view of them. I highly recommended you read through the linked materials to have a deeper understanding! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="First, I learnt C++ at university, but I better not count it. Then I first started to work with it 9 years ago. My employer booked a 5-day-training only for me. Those were good, generous times. But I think that the training was not that much of a success for several reasons. I understood years later when I started to review our C++ training offerings that the instructor was below average. Just like my English and programming knowledge. Despite the fact that I had been using English for a long time - even for work - following a 5-day-long technical training delivered by a non-native instructor was a bit too difficult for me. But I learned on the go. More or less. I still realize that sometimes I lack the correct understanding of some basic concepts. Whenever I have the realization, I consider writing an article on the topic. And I’ve been posting every week for the last 5 years. Lately, I had a similar realization while I was reading Beautiful C++. I’d still run into some issues if I had to explain what linkage is. So let’s discuss now a couple of things that the book brought up; the differences between name, linkage and scope. What is a name? That seems a simple question, especially if you consider this piece of code. 1 2 3 4 5 6 7 struct S { int m_num = 0; }; int main() { [[maybe_unused]] S s{42}; } What is a name? That’s s, right? It’s a name! Well. Right. But what is the difference between a name and an object? That’s probably still an easy one. What’s the difference between your name and you? Your name denotes you, but it’s not you, it’s not your physically existing body. A name is just a handle, a reference to an object. This might seem philosophical. Still, it’s important to make the distinction. Not only because the C++ standard does it, but because names and objects have different attributes. Names have a scope and objects have storage durations. Besides, not every object has a name, and not every name refers to an object. The latter one is obvious. For example functions and classes also have names but they are not objects. Objects might not have names. Like temporaries. Look at this example. 1 2 3 4 5 6 7 void foo(std::string s) { // ... } int main() { foo(std::string{&quot;bar&quot;}); } std::string{&quot;bar&quot;} creates an object, but it doesn’t have a name. But let’s get back to the question of scopes and store durations. We start with the latter. Storage duration All objects have a storage duration. The storage duration of an object determines what rules to apply for its creation and destruction. Often, people find it difficult to make a distinction between storage duration and lifetime. Lifetime is about the time when objects are usable and it’s a runtime property of an object. The storage duration determines the minimum potential lifetime of the storage containing an object. This is determined by the construct that is used to create the object. An object will always have one of the 4 following storage durations: automatic static dynamic thread Automatic storage duration means that all the storage necessary for non-static, non-extern, non-thread-local local objects in a code block are allocated at the beginning of the block and deallocated at the end. This also shows how the storage duration can start earlier than the lifetime of an object. The storage is usually allocated sooner than the object is constructed. In the case of static storage duration, the storage is allocated when the program begins and deallocated when the program ends. Variables with static storage duration have only one instance. Which objects have static storage duration? All that were declared with the static keyword! Besides, all of the objects that were declared at a namespace level or declared with the extern keyword. Dynamic storage duration probably raises the least number of questions. Storage for such objects is allocated and deallocated upon request. Think about the dreaded new/delete pairs. Objects that use them have a dynamic storage duration. Last but not least, we have to speak about thread local storage duration. The storage for such variables is allocated when the thread begins and deallocated when the thread ends. There is a different instance of the object in each thread. Only objects declared with the thread_local specifier have this kind of storage duration. thead_local can be combined with the static or extern keywords. Linkage Now that we talked about names and storage durations, we can finally talk about linkage. You declare a name in a scope. But what happens if you declare another entity with the same name in another scope? Or in several other scopes? It depends on the (lack of) linkage that how many instances will be generated. Till C++20, there were 3 different linkages, the fourth is a new one. no linkage internal linkage external linkage module linkage (introduced in C++20) A translation unit is the basic unit of compilation in C++. It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements. A single translation unit can be compiled into an object file, library, or executable program. With no linkage, a name can be referred to only from the scope where it was created. Think about simple local variables declared in a block of code. They have no linkage, you cannot refer to them from an outer scope. When a name has internal linkage, that name can be referred to from all scopes in the current translation unit. Static functions, variables, and their templated version, they all have internal linkage. Also, any names declared in an unnamed namespace have this level of linkage. When a name has external linkage, it can be referred to from the scopes of another translation unit. This can go as far as using variables and functions from translation units that were written in another language. Enumerations, class names and their member functions and static data members, non-static templates and class templates, etc. Module linkage was introduced in C++20. When a name has module linkage, it can only be referred to from the same module unit. This might mean another translation unit. Note that this section aimed to show what kind of different linkages exist in C++. If you want to verify the full specs of what kind of names have what kind of linkage, please read this page. Scope Last but not least, let’s talk about scopes. Scopes are collections of names referring to abstractions. Scopes are where a name is visible with an unqualified name lookup. This implies two things: names might be looked up in non-unqualified ways even outside of their scope the lifetime of an object might not end where the scope of its name ends There are 6 different scopes we can talk about: block scope function parameter scope namespace scope class scope enumeration scope template parameter scope A block scope is the most usual one. It starts with an opening brace and ends with a closing one. It’s worth noting that they can be discontinuous when we use nested blocks. 1 2 3 4 5 6 7 8 9 10 11 if (x.isValid) { // opens scope 1 auto r = 42; auto z = Foo{}; { // opens scope 2! auto r = z.something(); // this is a different r } // ends scope 2! // it&#39;s scope 1 again std::cout &lt;&lt; r &lt;&lt; &#39;\n&#39;; // r is 42 once again } // ends scope 1 It’s worth noting that in the nested block you can declare names that are used within the outer scope and as such, those become inaccessible (like r), but once the nested scope is closed we can refer to them again. Function parameter scope is very similar to block scope. In terms of scopes, the function is the combination of the block and the function header. A function-try-block is similar, the end of the scope is the end of the last catch block. By the way, have you ever seen a function-try-block? The following piece of code is a valid function: 1 2 3 4 5 6 7 float divide(float a, float b) try { std::cout &lt;&lt; &quot;Dividing\n&quot;; return a / b; } catch (...) { std::cout &lt;&lt; &quot;Dividing failed, was the denominator zero?\n&quot;; } The namespace scope starts where the namespace is declared and includes the rest of the namespace and all other namespace declarations with the same name. The top-level scope of a translation unit is also a namespace scope, that’s the global namespace scope. The class scope starts when a class starts being declared but does not end where the class declaration ends. It just pauses. You can resume it any time to define the declared elements. After resuming the scope, you can access entities of the class with different syntaxes (., -&gt;, ::). The enumeration scope depends on the type of the enumeration. In any case, the scope starts at the beginning of the enumeration declaration. The scope of a scoped enum ends at the end of the declaration. But the scope of an unscoped enum ends at the end of the enclosing scope. Last but not least, let’s not forget about the template parameter scope. The scope of a template parameter name begins at the point of declaration and ends at the end of the smallest template declaration in which it was introduced. Such parameters can be used in subsequent template parameter declarations and also in the base class specifications. Conclusion In this article, we discussed a couple of ideas that are often used when people talk about C++ or programming in general. Words that we might not dare to use in everyday conversations because we are not sure if we understand them well. Names, scopes, linkage and even translation units! Today we came a few steps closer to having a better view of them. I highly recommended you read through the linked materials to have a deeper understanding! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-18T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++ basics: scopes, linkage, names" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-18T00:00:00+02:00","datePublished":"2022-05-18T00:00:00+02:00","description":"First, I learnt C++ at university, but I better not count it. Then I first started to work with it 9 years ago. My employer booked a 5-day-training only for me. Those were good, generous times. But I think that the training was not that much of a success for several reasons. I understood years later when I started to review our C++ training offerings that the instructor was below average. Just like my English and programming knowledge. Despite the fact that I had been using English for a long time - even for work - following a 5-day-long technical training delivered by a non-native instructor was a bit too difficult for me. But I learned on the go. More or less. I still realize that sometimes I lack the correct understanding of some basic concepts. Whenever I have the realization, I consider writing an article on the topic. And I’ve been posting every week for the last 5 years. Lately, I had a similar realization while I was reading Beautiful C++. I’d still run into some issues if I had to explain what linkage is. So let’s discuss now a couple of things that the book brought up; the differences between name, linkage and scope. What is a name? That seems a simple question, especially if you consider this piece of code. 1 2 3 4 5 6 7 struct S { int m_num = 0; }; int main() { [[maybe_unused]] S s{42}; } What is a name? That’s s, right? It’s a name! Well. Right. But what is the difference between a name and an object? That’s probably still an easy one. What’s the difference between your name and you? Your name denotes you, but it’s not you, it’s not your physically existing body. A name is just a handle, a reference to an object. This might seem philosophical. Still, it’s important to make the distinction. Not only because the C++ standard does it, but because names and objects have different attributes. Names have a scope and objects have storage durations. Besides, not every object has a name, and not every name refers to an object. The latter one is obvious. For example functions and classes also have names but they are not objects. Objects might not have names. Like temporaries. Look at this example. 1 2 3 4 5 6 7 void foo(std::string s) { // ... } int main() { foo(std::string{&quot;bar&quot;}); } std::string{&quot;bar&quot;} creates an object, but it doesn’t have a name. But let’s get back to the question of scopes and store durations. We start with the latter. Storage duration All objects have a storage duration. The storage duration of an object determines what rules to apply for its creation and destruction. Often, people find it difficult to make a distinction between storage duration and lifetime. Lifetime is about the time when objects are usable and it’s a runtime property of an object. The storage duration determines the minimum potential lifetime of the storage containing an object. This is determined by the construct that is used to create the object. An object will always have one of the 4 following storage durations: automatic static dynamic thread Automatic storage duration means that all the storage necessary for non-static, non-extern, non-thread-local local objects in a code block are allocated at the beginning of the block and deallocated at the end. This also shows how the storage duration can start earlier than the lifetime of an object. The storage is usually allocated sooner than the object is constructed. In the case of static storage duration, the storage is allocated when the program begins and deallocated when the program ends. Variables with static storage duration have only one instance. Which objects have static storage duration? All that were declared with the static keyword! Besides, all of the objects that were declared at a namespace level or declared with the extern keyword. Dynamic storage duration probably raises the least number of questions. Storage for such objects is allocated and deallocated upon request. Think about the dreaded new/delete pairs. Objects that use them have a dynamic storage duration. Last but not least, we have to speak about thread local storage duration. The storage for such variables is allocated when the thread begins and deallocated when the thread ends. There is a different instance of the object in each thread. Only objects declared with the thread_local specifier have this kind of storage duration. thead_local can be combined with the static or extern keywords. Linkage Now that we talked about names and storage durations, we can finally talk about linkage. You declare a name in a scope. But what happens if you declare another entity with the same name in another scope? Or in several other scopes? It depends on the (lack of) linkage that how many instances will be generated. Till C++20, there were 3 different linkages, the fourth is a new one. no linkage internal linkage external linkage module linkage (introduced in C++20) A translation unit is the basic unit of compilation in C++. It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements. A single translation unit can be compiled into an object file, library, or executable program. With no linkage, a name can be referred to only from the scope where it was created. Think about simple local variables declared in a block of code. They have no linkage, you cannot refer to them from an outer scope. When a name has internal linkage, that name can be referred to from all scopes in the current translation unit. Static functions, variables, and their templated version, they all have internal linkage. Also, any names declared in an unnamed namespace have this level of linkage. When a name has external linkage, it can be referred to from the scopes of another translation unit. This can go as far as using variables and functions from translation units that were written in another language. Enumerations, class names and their member functions and static data members, non-static templates and class templates, etc. Module linkage was introduced in C++20. When a name has module linkage, it can only be referred to from the same module unit. This might mean another translation unit. Note that this section aimed to show what kind of different linkages exist in C++. If you want to verify the full specs of what kind of names have what kind of linkage, please read this page. Scope Last but not least, let’s talk about scopes. Scopes are collections of names referring to abstractions. Scopes are where a name is visible with an unqualified name lookup. This implies two things: names might be looked up in non-unqualified ways even outside of their scope the lifetime of an object might not end where the scope of its name ends There are 6 different scopes we can talk about: block scope function parameter scope namespace scope class scope enumeration scope template parameter scope A block scope is the most usual one. It starts with an opening brace and ends with a closing one. It’s worth noting that they can be discontinuous when we use nested blocks. 1 2 3 4 5 6 7 8 9 10 11 if (x.isValid) { // opens scope 1 auto r = 42; auto z = Foo{}; { // opens scope 2! auto r = z.something(); // this is a different r } // ends scope 2! // it&#39;s scope 1 again std::cout &lt;&lt; r &lt;&lt; &#39;\\n&#39;; // r is 42 once again } // ends scope 1 It’s worth noting that in the nested block you can declare names that are used within the outer scope and as such, those become inaccessible (like r), but once the nested scope is closed we can refer to them again. Function parameter scope is very similar to block scope. In terms of scopes, the function is the combination of the block and the function header. A function-try-block is similar, the end of the scope is the end of the last catch block. By the way, have you ever seen a function-try-block? The following piece of code is a valid function: 1 2 3 4 5 6 7 float divide(float a, float b) try { std::cout &lt;&lt; &quot;Dividing\\n&quot;; return a / b; } catch (...) { std::cout &lt;&lt; &quot;Dividing failed, was the denominator zero?\\n&quot;; } The namespace scope starts where the namespace is declared and includes the rest of the namespace and all other namespace declarations with the same name. The top-level scope of a translation unit is also a namespace scope, that’s the global namespace scope. The class scope starts when a class starts being declared but does not end where the class declaration ends. It just pauses. You can resume it any time to define the declared elements. After resuming the scope, you can access entities of the class with different syntaxes (., -&gt;, ::). The enumeration scope depends on the type of the enumeration. In any case, the scope starts at the beginning of the enumeration declaration. The scope of a scoped enum ends at the end of the declaration. But the scope of an unscoped enum ends at the end of the enclosing scope. Last but not least, let’s not forget about the template parameter scope. The scope of a template parameter name begins at the point of declaration and ends at the end of the smallest template declaration in which it was introduced. Such parameters can be used in subsequent template parameter declarations and also in the base class specifications. Conclusion In this article, we discussed a couple of ideas that are often used when people talk about C++ or programming in general. Words that we might not dare to use in everyday conversations because we are not sure if we understand them well. Names, scopes, linkage and even translation units! Today we came a few steps closer to having a better view of them. I highly recommended you read through the linked materials to have a deeper understanding! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++ basics: scopes, linkage, names","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name"},"url":"https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name"}</script><title>C++ basics: scopes, linkage, names | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/18"> 18 </a> </span> <span>C++ basics: scopes, linkage, names</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++ basics: scopes, linkage, names</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 18, 2022, 12:00 AM +0200" prep="on" > May 18, 2022 <i class="unloaded">2022-05-18T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1716 words">9 min</span></div></div><div class="post-content"><p>First, I learnt C++ at university, but I better not count it. Then I first started to work with it 9 years ago. My employer booked a 5-day-training only for me. Those were good, generous times. But I think that the training was not that much of a success for several reasons.</p><p>I understood years later when I started to review our C++ training offerings that the instructor was below average. Just like my English and programming knowledge. Despite the fact that I had been using English for a long time - even for work - following a 5-day-long technical training delivered by a non-native instructor was a bit too difficult for me.</p><p>But I learned on the go.</p><p>More or less.</p><p>I still realize that sometimes I lack the correct understanding of some basic concepts. Whenever I have the realization, I consider writing an article on the topic. And I’ve been posting every week for the last 5 years.</p><p>Lately, I had a similar realization while I was reading <a href="https://devreads.sandordargo.com/beautiful-cpp-by-kate-gregory-and-guy-davidson/">Beautiful C++</a>. I’d still run into some issues if I had to explain what linkage is.</p><p>So let’s discuss now a couple of things that the book brought up; the differences between name, linkage and scope.</p><h2 id="what-is-a-name">What is a name?</h2><p>That seems a simple question, especially if you consider this piece of code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">m_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="n">S</span> <span class="n">s</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What is a name? That’s <code class="language-plaintext highlighter-rouge">s</code>, right? It’s a name! Well. Right. But what is the difference between a name and an object?</p><p>That’s probably still an easy one. What’s the difference between your name and you?</p><p>Your name denotes you, but it’s not you, it’s not your physically existing body.</p><p>A name is just a handle, a reference to an object.</p><p>This might seem philosophical. Still, it’s important to make the distinction. Not only because the C++ standard does it, but because names and objects have different attributes.</p><p>Names have a scope and objects have storage durations.</p><p>Besides, not every object has a name, and not every name refers to an object. The latter one is obvious. For example functions and classes also have names but they are not objects.</p><p>Objects might not have names. Like temporaries. Look at this example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">{</span><span class="s">"bar"</span><span class="p">});</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">std::string{"bar"}</code> creates an object, but it doesn’t have a name.</p><p>But let’s get back to the question of scopes and store durations. We start with the latter.</p><h2 id="storage-duration">Storage duration</h2><p>All objects have a <a href="https://en.cppreference.com/w/cpp/language/storage_duration">storage duration</a>. The storage duration of an object determines what rules to apply for its creation and destruction.</p><p>Often, people find it difficult to make a distinction between <em>storage duration</em> and <em>lifetime</em>. Lifetime is about the time when objects are usable and it’s a runtime property of an object. The storage duration determines the minimum potential lifetime of the storage containing an object. This is determined by the construct that is used to create the object.</p><p>An object will always have one of the 4 following storage durations:</p><ul><li>automatic<li>static<li>dynamic<li>thread</ul><p><em>Automatic</em> storage duration means that all the storage necessary for non-<code class="language-plaintext highlighter-rouge">static</code>, non-<code class="language-plaintext highlighter-rouge">extern</code>, non-thread-local local objects in a code block are allocated at the beginning of the block and deallocated at the end. This also shows how the storage duration can start earlier than the lifetime of an object. The storage is usually allocated sooner than the object is constructed.</p><p>In the case of <em>static</em> storage duration, the storage is allocated when the program begins and deallocated when the program ends. Variables with <em>static</em> storage duration have only one instance. Which objects have <em>static</em> storage duration? All that were declared with the <code class="language-plaintext highlighter-rouge">static</code> keyword! Besides, all of the objects that were declared at a namespace level or declared with the <code class="language-plaintext highlighter-rouge">extern</code> keyword.</p><p><em>Dynamic</em> storage duration probably raises the least number of questions. Storage for such objects is allocated and deallocated upon request. Think about the dreaded <code class="language-plaintext highlighter-rouge">new</code>/<code class="language-plaintext highlighter-rouge">delete</code> pairs. Objects that use them have a <em>dynamic</em> storage duration.</p><p>Last but not least, we have to speak about <em>thread local</em> storage duration. The storage for such variables is allocated when the thread begins and deallocated when the thread ends. There is a different instance of the object in each thread. Only objects declared with the <code class="language-plaintext highlighter-rouge">thread_local</code> specifier have this kind of storage duration. <code class="language-plaintext highlighter-rouge">thead_local</code> can be combined with the <code class="language-plaintext highlighter-rouge">static</code> or <code class="language-plaintext highlighter-rouge">extern</code> keywords.</p><h2 id="linkage">Linkage</h2><p>Now that we talked about names and storage durations, we can finally talk about linkage. You declare a name in a scope. But what happens if you declare another entity with the same name in another scope? Or in several other scopes? It depends on the (lack of) linkage that how many instances will be generated.</p><p>Till C++20, there were 3 different linkages, the fourth is a new one.</p><ul><li>no linkage<li>internal linkage<li>external linkage<li>module linkage (introduced in C++20)</ul><blockquote><p><em>A translation unit is the basic unit of compilation in C++. It consists of the contents of a single source file, plus the contents of any header files directly or indirectly included by it, minus those lines that were ignored using conditional preprocessing statements.</em></p><p><em>A single translation unit can be compiled into an object file, library, or executable program.</em></p></blockquote><p>With <em>no linkage</em>, a name can be referred to only from the scope where it was created. Think about simple local variables declared in a block of code. They have no linkage, you cannot refer to them from an outer scope.</p><p>When a name has <em>internal linkage</em>, that name can be referred to from all scopes in the current translation unit. Static functions, variables, and their templated version, they all have internal linkage. Also, any names declared in an unnamed namespace have this level of linkage.</p><p>When a name has <em>external linkage</em>, it can be referred to from the scopes of another translation unit. This can go as far as using variables and functions from translation units that were written in another language. Enumerations, class names and their member functions and static data members, non-static templates and class templates, etc.</p><p><em>Module linkage</em> was introduced in C++20. When a name has <em>module linkage</em>, it can only be referred to from the same module unit. This might mean another translation unit.</p><p>Note that this section aimed to show what kind of different linkages exist in C++. If you want to verify the full specs of what kind of names have what kind of linkage, <a href="https://en.cppreference.com/w/cpp/language/storage_duration#Linkage">please read this page</a>.</p><h2 id="scope">Scope</h2><p>Last but not least, let’s talk about scopes. Scopes are collections of names referring to abstractions. Scopes are where a name is visible with an unqualified name lookup. This implies two things:</p><ul><li>names might be looked up in non-unqualified ways even outside of their scope<li>the lifetime of an object might not end where the scope of its name ends</ul><p>There are 6 different scopes we can talk about:</p><ul><li>block scope<li>function parameter scope<li>namespace scope<li>class scope<li>enumeration scope<li>template parameter scope</ul><p>A <em>block scope</em> is the most usual one. It starts with an opening brace and ends with a closing one. It’s worth noting that they can be discontinuous when we use nested blocks.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">isValid</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// opens scope 1</span>
  <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">auto</span> <span class="n">z</span> <span class="o">=</span> <span class="n">Foo</span><span class="p">{};</span>
  <span class="p">{</span> <span class="c1">// opens scope 2!</span>

    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">z</span><span class="p">.</span><span class="n">something</span><span class="p">();</span> <span class="c1">// this is a different r</span>

  <span class="p">}</span> <span class="c1">// ends scope 2!</span>
  <span class="c1">// it's scope 1 again</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// r is 42 once again</span>
<span class="p">}</span> <span class="c1">// ends scope 1</span>
</pre></table></code></div></div><p>It’s worth noting that in the nested block you can declare names that are used within the outer scope and as such, those become inaccessible (like <code class="language-plaintext highlighter-rouge">r</code>), but once the nested scope is closed we can refer to them again.</p><p><em>Function parameter scope</em> is very similar to <em>block scope</em>. In terms of scopes, the function is the combination of the block and the function header. A <em>function-try-block</em> is similar, the end of the scope is the end of the last <code class="language-plaintext highlighter-rouge">catch</code> block. By the way, have you ever seen a <em>function-try-block</em>? The following piece of code is a valid function:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">float</span> <span class="n">divide</span><span class="p">(</span><span class="kt">float</span> <span class="n">a</span><span class="p">,</span> <span class="kt">float</span> <span class="n">b</span><span class="p">)</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dividing</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">a</span> <span class="o">/</span> <span class="n">b</span><span class="p">;</span>
<span class="p">}</span> <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Dividing failed, was the denominator zero?</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The <em>namespace scope</em> starts where the namespace is declared and includes the rest of the namespace and all other namespace declarations with the same name. The top-level scope of a translation unit is also a <em>namespace scope</em>, that’s the <em>global namespace scope</em>.</p><p>The <em>class scope</em> starts when a class starts being declared but does not end where the class declaration ends. It just pauses. You can resume it any time to define the declared elements. After resuming the scope, you can access entities of the class with different syntaxes (<code class="language-plaintext highlighter-rouge">.</code>, <code class="language-plaintext highlighter-rouge">-&gt;</code>, <code class="language-plaintext highlighter-rouge">::</code>).</p><p>The <em>enumeration scope</em> depends on the type of the enumeration. In any case, the scope starts at the beginning of the enumeration declaration. The scope of a scoped <code class="language-plaintext highlighter-rouge">enum</code> ends at the end of the declaration. But the scope of an unscoped <code class="language-plaintext highlighter-rouge">enum</code> ends at the end of the enclosing scope.</p><p>Last but not least, let’s not forget about the <em>template parameter scope</em>. The scope of a template parameter name begins at the point of declaration and ends at the end of the smallest template declaration in which it was introduced. Such parameters can be used in subsequent template parameter declarations and also in the base class specifications.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we discussed a couple of ideas that are often used when people talk about C++ or programming in general. Words that we might not dare to use in everyday conversations because we are not sure if we understand them well. Names, scopes, linkage and even translation units! Today we came a few steps closer to having a better view of them.</p><p>I highly recommended you read through the linked materials to have a deeper understanding!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/beginners/" class="post-tag no-text-decoration" >beginners</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++ basics: scopes, linkage, names - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++ basics: scopes, linkage, names - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++ basics: scopes, linkage, names - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++ basics: scopes, linkage, names - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2021/12/22/most-vexing-parse"><div class="card-body"> <span class="timeago small" > Dec 22, 2021 <i class="unloaded">2021-12-22T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What is the most vexing parse?</h3><div class="text-muted small"><p> The most vexing parse is a specific form of syntactic ambiguity resolution in the C++ programming language. The term was used by Scott Meyers in Effective STL. It is formally defined in section 8.2...</p></div></div></a></div><div class="card"> <a href="/blog/2024/01/03/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Jan 3, 2024 <i class="unloaded">2024-01-03T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/01/10/cpp23-and-allocators"><div class="card-body"> <span class="timeago small" > Jan 10, 2024 <i class="unloaded">2024-01-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: Allocator related changes</h3><div class="text-muted small"><p> In this post, we are going to review two changes related to allocators in C++. One is about providing size information about the allocated memory and the other is about how CTAD should happen for c...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/05/09/tipi-build-review" class="btn btn-outline-primary" prompt="Older"><p>Tipi, a new solution to build C++ projects easier</p></a> <a href="/blog/2022/05/21/the-tech-resume-by-gergely-orosz" class="btn btn-outline-primary" prompt="Newer"><p>The Tech Resume Inside Out by Gergely Orosz</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++ basics: scopes, linkage, names'; this.page.url = 'https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name'; this.page.identifier = '/blog/2022/05/18/scope-linkage-name'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
