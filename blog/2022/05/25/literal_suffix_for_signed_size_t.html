<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: Literal suffix for (signed) size_t" /><meta property="og:locale" content="en_US" /><meta name="description" content="Let’s continue our exploration of C++23 features! This week we discuss the extended language support for literal suffixes. What is a literal suffix? Literals can have an optional suffix which indicates the type of the literal. As such, one doesn’t have to store the value in a variable of the desired type but can use the literal directly. For example, if you need a long value and you don’t want to rely on implicit conversions, you can pass 42L instead of passing 42. While we can define our own user-defined literals, for integers, C++ provides quite a few literal suffixes: none means that the literal is an int U makes an integer unsigned L makes integers long LL males them long long ULL (or LLU) turns ints into unsigned long long ints And C++23 is going to add one, or if combined with U then 2 elements to this list: Z turns an int into the signed version of std::size_t UZ turns an int into std::size_t But why do we need this new Z literal suffix? If you’re an Almost Always Auto person, you probably shook your head quite often when you wanted to write a good old for loop. But even if you just had a look into legacy code’s for loops, you probably saw too many messed up situations with loop indexes. Let’s have a look at a simple situation: 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0; i &lt; v.size(); ++i) { /* use both i and v[i] */ } } We try to use auto for the loop index, but we got a compiler warning! std::vector&lt;T&gt;::size() returns a std::vector&lt;T&gt;::size_type, usually std::size_t that is an unsigned type. At the same time, 0 is deduced as a signed integer. Comparing a signed with an unsigned type leads to a compiler warning. Hopefully, you don’t tolerate compiler warnings in your project, so we consider that the above example does not compile. In case, you want to store the size of the vector for optimization reasons, you even get a hard error, reminding you that the auto education for i and s was not consistent! 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } What if 0u is used for initializing i? It depends on whether you have a helper variable to store the size and on your system. The worst case is that i will be truncated on a 64-bit system as 0u is deduced as an unsinged int, while s is a long unsigned int. In a better situation, you get a compilation error because of this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0u, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } /* main.cpp: In function &#39;int main()&#39;: main.cpp:5:10: error: inconsistent deduction for &#39;auto&#39;: &#39;unsigned int&#39; and then &#39;long unsigned int&#39; 5 | for (auto i = 0u, s = v.size(); i &lt; s; ++i) { | */ These were the simple examples borrowed from the accepted proposal, but you can find there many more. In general, with an existing set of literal suffixes, you can run into situations when you want the compiler to deduce the type for you for an integer literal because comparing signed with unsigned elements is unsafe and you cannot replace std::size_t with ul (unsigned long) because you can run into narrowing/truncating situations when switching between 32-bit and 64-bit systems To avoid the problems, you either have to use some verbose casts (mostly static_cast) or introduce a helper variable without relying on auto type deduction. As mentioned in the beginning, [P0330R8] finally solves this problem by introducing Z and UZ. Z introduces the signed version of std::size_t and UZ the unsigned version. With that, our previous examples should compile without any problem and unpleasant surprises as such: 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0UZ, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } Just make sure that you compile with the option -std=c++2b. Conclusion In this article, we saw why it’s difficult to use literal suffixes and auto type deduction for good old loops and how P0330R8 solves this situation by introducing Z/UZ in C++23 to denote std::size_t. Where do you think the signed version of size_t comes in handy? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Let’s continue our exploration of C++23 features! This week we discuss the extended language support for literal suffixes. What is a literal suffix? Literals can have an optional suffix which indicates the type of the literal. As such, one doesn’t have to store the value in a variable of the desired type but can use the literal directly. For example, if you need a long value and you don’t want to rely on implicit conversions, you can pass 42L instead of passing 42. While we can define our own user-defined literals, for integers, C++ provides quite a few literal suffixes: none means that the literal is an int U makes an integer unsigned L makes integers long LL males them long long ULL (or LLU) turns ints into unsigned long long ints And C++23 is going to add one, or if combined with U then 2 elements to this list: Z turns an int into the signed version of std::size_t UZ turns an int into std::size_t But why do we need this new Z literal suffix? If you’re an Almost Always Auto person, you probably shook your head quite often when you wanted to write a good old for loop. But even if you just had a look into legacy code’s for loops, you probably saw too many messed up situations with loop indexes. Let’s have a look at a simple situation: 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0; i &lt; v.size(); ++i) { /* use both i and v[i] */ } } We try to use auto for the loop index, but we got a compiler warning! std::vector&lt;T&gt;::size() returns a std::vector&lt;T&gt;::size_type, usually std::size_t that is an unsigned type. At the same time, 0 is deduced as a signed integer. Comparing a signed with an unsigned type leads to a compiler warning. Hopefully, you don’t tolerate compiler warnings in your project, so we consider that the above example does not compile. In case, you want to store the size of the vector for optimization reasons, you even get a hard error, reminding you that the auto education for i and s was not consistent! 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } What if 0u is used for initializing i? It depends on whether you have a helper variable to store the size and on your system. The worst case is that i will be truncated on a 64-bit system as 0u is deduced as an unsinged int, while s is a long unsigned int. In a better situation, you get a compilation error because of this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0u, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } /* main.cpp: In function &#39;int main()&#39;: main.cpp:5:10: error: inconsistent deduction for &#39;auto&#39;: &#39;unsigned int&#39; and then &#39;long unsigned int&#39; 5 | for (auto i = 0u, s = v.size(); i &lt; s; ++i) { | */ These were the simple examples borrowed from the accepted proposal, but you can find there many more. In general, with an existing set of literal suffixes, you can run into situations when you want the compiler to deduce the type for you for an integer literal because comparing signed with unsigned elements is unsafe and you cannot replace std::size_t with ul (unsigned long) because you can run into narrowing/truncating situations when switching between 32-bit and 64-bit systems To avoid the problems, you either have to use some verbose casts (mostly static_cast) or introduce a helper variable without relying on auto type deduction. As mentioned in the beginning, [P0330R8] finally solves this problem by introducing Z and UZ. Z introduces the signed version of std::size_t and UZ the unsigned version. With that, our previous examples should compile without any problem and unpleasant surprises as such: 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0UZ, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } Just make sure that you compile with the option -std=c++2b. Conclusion In this article, we saw why it’s difficult to use literal suffixes and auto type deduction for good old loops and how P0330R8 solves this situation by introducing Z/UZ in C++23 to denote std::size_t. Where do you think the signed version of size_t comes in handy? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-05-25T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: Literal suffix for (signed) size_t" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-05-25T20:02:52+02:00","datePublished":"2022-05-25T00:00:00+02:00","description":"Let’s continue our exploration of C++23 features! This week we discuss the extended language support for literal suffixes. What is a literal suffix? Literals can have an optional suffix which indicates the type of the literal. As such, one doesn’t have to store the value in a variable of the desired type but can use the literal directly. For example, if you need a long value and you don’t want to rely on implicit conversions, you can pass 42L instead of passing 42. While we can define our own user-defined literals, for integers, C++ provides quite a few literal suffixes: none means that the literal is an int U makes an integer unsigned L makes integers long LL males them long long ULL (or LLU) turns ints into unsigned long long ints And C++23 is going to add one, or if combined with U then 2 elements to this list: Z turns an int into the signed version of std::size_t UZ turns an int into std::size_t But why do we need this new Z literal suffix? If you’re an Almost Always Auto person, you probably shook your head quite often when you wanted to write a good old for loop. But even if you just had a look into legacy code’s for loops, you probably saw too many messed up situations with loop indexes. Let’s have a look at a simple situation: 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0; i &lt; v.size(); ++i) { /* use both i and v[i] */ } } We try to use auto for the loop index, but we got a compiler warning! std::vector&lt;T&gt;::size() returns a std::vector&lt;T&gt;::size_type, usually std::size_t that is an unsigned type. At the same time, 0 is deduced as a signed integer. Comparing a signed with an unsigned type leads to a compiler warning. Hopefully, you don’t tolerate compiler warnings in your project, so we consider that the above example does not compile. In case, you want to store the size of the vector for optimization reasons, you even get a hard error, reminding you that the auto education for i and s was not consistent! 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } What if 0u is used for initializing i? It depends on whether you have a helper variable to store the size and on your system. The worst case is that i will be truncated on a 64-bit system as 0u is deduced as an unsinged int, while s is a long unsigned int. In a better situation, you get a compilation error because of this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0u, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } /* main.cpp: In function &#39;int main()&#39;: main.cpp:5:10: error: inconsistent deduction for &#39;auto&#39;: &#39;unsigned int&#39; and then &#39;long unsigned int&#39; 5 | for (auto i = 0u, s = v.size(); i &lt; s; ++i) { | */ These were the simple examples borrowed from the accepted proposal, but you can find there many more. In general, with an existing set of literal suffixes, you can run into situations when you want the compiler to deduce the type for you for an integer literal because comparing signed with unsigned elements is unsafe and you cannot replace std::size_t with ul (unsigned long) because you can run into narrowing/truncating situations when switching between 32-bit and 64-bit systems To avoid the problems, you either have to use some verbose casts (mostly static_cast) or introduce a helper variable without relying on auto type deduction. As mentioned in the beginning, [P0330R8] finally solves this problem by introducing Z and UZ. Z introduces the signed version of std::size_t and UZ the unsigned version. With that, our previous examples should compile without any problem and unpleasant surprises as such: 1 2 3 4 5 6 7 8 #include &lt;vector&gt; int main() { std::vector&lt;int&gt; v{0, 1, 2, 3}; for (auto i = 0UZ, s = v.size(); i &lt; s; ++i) { /* use both i and v[i] */ } } Just make sure that you compile with the option -std=c++2b. Conclusion In this article, we saw why it’s difficult to use literal suffixes and auto type deduction for good old loops and how P0330R8 solves this situation by introducing Z/UZ in C++23 to denote std::size_t. Where do you think the signed version of size_t comes in handy? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: Literal suffix for (signed) size_t","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t"},"url":"https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t"}</script><title>C++23: Literal suffix for (signed) size_t | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/25"> 25 </a> </span> <span>C++23: Literal suffix for (signed) size_t</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: Literal suffix for (signed) size_t</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 25, 2022, 12:00 AM +0200" prep="on" > May 25, 2022 <i class="unloaded">2022-05-25T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, May 25, 2022, 8:02 PM +0200" prefix="Updated " > May 25, 2022 <i class="unloaded">2022-05-25T20:02:52+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="820 words">4 min</span></div></div><div class="post-content"><p>Let’s continue our exploration of C++23 features! This week we discuss <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0330r8.html">the extended language support for literal suffixes</a>.</p><h2 id="what-is-a-literal-suffix">What is a literal suffix?</h2><p>Literals can have an optional suffix which indicates the type of the literal. As such, one doesn’t have to store the value in a variable of the desired type but can use the literal directly.</p><p>For example, if you need a <code class="language-plaintext highlighter-rouge">long</code> value and you don’t want to rely on implicit conversions, you can pass <code class="language-plaintext highlighter-rouge">42L</code> instead of passing <code class="language-plaintext highlighter-rouge">42</code>.</p><p>While <a href="https://www.sandordargo.com/blog/2020/10/21/user-defined-literals">we can define our own user-defined literals</a>, for integers, C++ provides quite a few literal suffixes:</p><ul><li>none means that the literal is an <code class="language-plaintext highlighter-rouge">int</code><li><code class="language-plaintext highlighter-rouge">U</code> makes an integer <code class="language-plaintext highlighter-rouge">unsigned</code><li><code class="language-plaintext highlighter-rouge">L</code> makes integers <code class="language-plaintext highlighter-rouge">long</code><li><code class="language-plaintext highlighter-rouge">LL</code> males them <code class="language-plaintext highlighter-rouge">long long</code><li><code class="language-plaintext highlighter-rouge">ULL</code> (or <code class="language-plaintext highlighter-rouge">LLU</code>) turns <code class="language-plaintext highlighter-rouge">int</code>s into <code class="language-plaintext highlighter-rouge">unsigned long long int</code>s</ul><p>And C++23 is going to add one, or if combined with <code class="language-plaintext highlighter-rouge">U</code> then 2 elements to this list:</p><ul><li><code class="language-plaintext highlighter-rouge">Z</code> turns an <code class="language-plaintext highlighter-rouge">int</code> into the signed version of <code class="language-plaintext highlighter-rouge">std::size_t</code><li><code class="language-plaintext highlighter-rouge">UZ</code> turns an <code class="language-plaintext highlighter-rouge">int</code> into <code class="language-plaintext highlighter-rouge">std::size_t</code></ul><h2 id="but-why-do-we-need-this-new-z-literal-suffix">But why do we need this new <code class="language-plaintext highlighter-rouge">Z</code> literal suffix?</h2><p>If you’re an <a href="https://herbsutter.com/2013/08/12/gotw-94-solution-aaa-style-almost-always-auto/">Almost Always Auto</a> person, you probably shook your head quite often when you wanted to write a good old <code class="language-plaintext highlighter-rouge">for</code> loop. But even if you just had a look into legacy code’s <code class="language-plaintext highlighter-rouge">for</code> loops, you probably saw too many messed up situations with loop indexes.</p><p>Let’s have a look at a simple situation:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* use both i and v[i] */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We try to use <code class="language-plaintext highlighter-rouge">auto</code> for the loop index, but we got a compiler warning! <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;::size()</code> returns a <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;::size_type</code>, usually <code class="language-plaintext highlighter-rouge">std::size_t</code> that is an unsigned type. At the same time, <code class="language-plaintext highlighter-rouge">0</code> is deduced as a signed integer. Comparing a signed with an unsigned type leads to a compiler warning. Hopefully, you don’t tolerate compiler warnings in your project, so we consider that the above example does not compile.</p><p>In case, you want to store the size of the vector for optimization reasons, you even get a hard error, reminding you that the <code class="language-plaintext highlighter-rouge">auto</code> education for <code class="language-plaintext highlighter-rouge">i</code> and <code class="language-plaintext highlighter-rouge">s</code> was not consistent!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* use both i and v[i] */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What if <code class="language-plaintext highlighter-rouge">0u</code> is used for initializing <code class="language-plaintext highlighter-rouge">i</code>? It depends on whether you have a helper variable to store the size and on your system.</p><p>The worst case is that <code class="language-plaintext highlighter-rouge">i</code> will be truncated on a 64-bit system as <code class="language-plaintext highlighter-rouge">0u</code> is deduced as an <code class="language-plaintext highlighter-rouge">unsinged int</code>, while <code class="language-plaintext highlighter-rouge">s</code> is a <code class="language-plaintext highlighter-rouge">long unsigned int</code>. In a better situation, you get a compilation error because of this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0u</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* use both i and v[i] */</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
main.cpp: In function 'int main()':
main.cpp:5:10: error: inconsistent deduction for 'auto': 'unsigned int' and then 'long unsigned int'
    5 |     for (auto i = 0u, s = v.size(); i &lt; s; ++i) {
      |   
*/</span>
</pre></table></code></div></div><p>These were the simple examples borrowed from the accepted proposal, but you can find there many more. In general, with an existing set of literal suffixes, you can run into situations when you want the compiler to deduce the type for you for an integer literal because</p><ul><li>comparing signed with unsigned elements is unsafe<li>and you cannot replace <code class="language-plaintext highlighter-rouge">std::size_t</code> with <code class="language-plaintext highlighter-rouge">ul</code> (<code class="language-plaintext highlighter-rouge">unsigned long</code>) because you can run into narrowing/truncating situations when switching between 32-bit and 64-bit systems</ul><p>To avoid the problems, you either have to use some verbose casts (mostly <code class="language-plaintext highlighter-rouge">static_cast</code>) or introduce a helper variable without relying on <code class="language-plaintext highlighter-rouge">auto</code> type deduction.</p><p>As mentioned in the beginning, [P0330R8] finally solves this problem by introducing <code class="language-plaintext highlighter-rouge">Z</code> and <code class="language-plaintext highlighter-rouge">UZ</code>. <code class="language-plaintext highlighter-rouge">Z</code> introduces the signed version of <code class="language-plaintext highlighter-rouge">std::size_t</code> and <code class="language-plaintext highlighter-rouge">UZ</code> the unsigned version.</p><p>With that, our previous examples should compile without any problem and unpleasant surprises as such:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0U</span><span class="n">Z</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">s</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="cm">/* use both i and v[i] */</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Just make sure that you compile with the option <code class="language-plaintext highlighter-rouge">-std=c++2b</code>.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we saw why it’s difficult to use literal suffixes and <code class="language-plaintext highlighter-rouge">auto</code> type deduction for good old loops and how <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0330r8.html">P0330R8</a> solves this situation by introducing <code class="language-plaintext highlighter-rouge">Z</code>/<code class="language-plaintext highlighter-rouge">UZ</code> in C++23 to denote <code class="language-plaintext highlighter-rouge">std::size_t</code>.</p><p>Where do you think the signed version of <code class="language-plaintext highlighter-rouge">size_t</code> comes in handy?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/literals/" class="post-tag no-text-decoration" >literals</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: Literal suffix for (signed) size_t - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: Literal suffix for (signed) size_t - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: Literal suffix for (signed) size_t - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: Literal suffix for (signed) size_t - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/05/21/the-tech-resume-by-gergely-orosz" class="btn btn-outline-primary" prompt="Older"><p>The Tech Resume Inside Out by Gergely Orosz</p></a> <a href="/blog/2022/06/01/cpp23-if-consteval" class="btn btn-outline-primary" prompt="Newer"><p>C++23: Consteval if to make compile time programming easier</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: Literal suffix for (signed) size_t'; this.page.url = 'https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t'; this.page.identifier = '/blog/2022/05/25/literal_suffix_for_signed_size_t'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
