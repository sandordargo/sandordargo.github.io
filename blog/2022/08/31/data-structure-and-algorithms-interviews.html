<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Should you really memorize algorithm complexities?" /><meta property="og:locale" content="en_US" /><meta name="description" content="A few years ago I read one of Yegor Bugayenko’s articles about his feelings about applying to a BigTech company. He wrote something like he would never be accepted and could never pass such interviews because he is not prepared for such nonsense and would not waste his time doing so. I felt the same. I thought I was already a good programmer and I wouldn’t need those. In any case, who wouldn’t want to hire me? (Hint: in fact, many, way too many…) I was partly wrong. I realized that when I started to go through some interview processes with different companies. It turned out quite fast that what I want from a job are things that many others want too. It must be remote, it must be a senior/senior+ position and it must pay a hefty salary. Companies receive lots of applications for such positions and they must be able to select somehow. The competition is strong. They must be able to assess your skills. One relatively fast way of doing that is asking some questions about data structures and algorithms in an interview. Let’s see how I approached the first interviews and how my views changed. Algorithms By the time I went to my first interviews, I could figure out many solutions to easy and medium LeetCode problems on my own without using hints. I could analyze the space and time complexity of the solutions, although not in a very sophisticated manner. More on that just in a minute. My experience is that many problems can be solved in C++ as a combination of standard algorithms. There are more than 100 of them, combining them is very powerful. Although C++ Reference lists the complexity of each algorithm, I didn’t always know them. You can imagine how it impacted my complexity analysis performance. So how did I change my approach? I still think that being able to implement the different sorts on a whiteboard is superfluous. You’ll almost never need them. In most positions, using what the standard library of your language provides is a way better choice than implementing whatever sorting algorithm. And if one day you have to implement it, it’s not a big deal to look up the algorithm in a book. No sane interviewer should ask for it. On the other hand, it is extremely useful to know the complexity of the different algorithms and their requirements. For example, if you want to decide in C++ whether a value is in a container or not, you might use binary_search or find. While std::binary_search is faster (O(logN) vs O(N)), it requires that you have a sorted container. As sorting a container has the complexity of O(N*logN), it’s also obvious that it’s not worth sorting a container just so that you can binary search it. Knowing the standard functions, their requirements and their complexities lets us decide which path to take in different situations. You don’t have to be able to implement them on the spot. (Even though implementing a simplified version of find with O(N) is really not complex) Data structures The case for data structures though is a bit different. When it comes to algorithms, they are quite specific and you don’t have plenty of different functions to achieve the same thing. With data structures, it’s different. In the C++ STL you have quite a few: array vector list, forward_list deque, stack, queue, priority_queue set, multiset map, multimap unordered_set, unordered_multiset unordered_map, unordered_multimap span Some of them are just adapters, but still. They are all there to store data. This list has 20 elements, while there are more than a hundred algorithms. I’d advise that you learn them well. Understand how they are implemented. No, you don’t have to be able to implement them with all their special cases, but know that a list is a doubly linked list, and know that vectors are dynamic size arrays with contiguous element storage. Know that a map is implemented as a tree, while an unordered_map is a hashmap. Also focus a bit on learning how complex it is to access, insert or delete an element from these data structures. When you know the underlying data structure, most of these questions become quite easy given that you learnt about the structures once. If not, it’s high time to do so. I find this important because when you implement an algorithm on your own, it becomes way easier to analyze its complexity. You’ll understand easily that finding an item in a map is O(logn), while doing the same in a hashmap is constant on average. Once you understand these complexities it also becomes simpler to understand when and why to use each of these data structures. To learn all these, you don’t need any fancy tool or platform. Browsing C++ Reference and taking some notes of the complexities are more than enough. Conclusion In this article, I shared with you how unimportant I found knowing details about algorithms and data structures before I started interviewing companies after working for 9 years at the same corporation. I was pretty much wrong. I still think that knowing how to implement all the algorithms would be an overkill and I would not focus on that while preparing, but knowing the complexities of some algorithms of your standard library is essential. What I found even more important is that you understand deeply the data structures offered by the standard library of your chosen language. Understand what kind of data structures are used for their implementations and the complexities of their operations. Invest a few hours doing so and you’ll significantly improve your chances to make good decisions to choose a data structure and nailing the complexity analysis at an interview. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="A few years ago I read one of Yegor Bugayenko’s articles about his feelings about applying to a BigTech company. He wrote something like he would never be accepted and could never pass such interviews because he is not prepared for such nonsense and would not waste his time doing so. I felt the same. I thought I was already a good programmer and I wouldn’t need those. In any case, who wouldn’t want to hire me? (Hint: in fact, many, way too many…) I was partly wrong. I realized that when I started to go through some interview processes with different companies. It turned out quite fast that what I want from a job are things that many others want too. It must be remote, it must be a senior/senior+ position and it must pay a hefty salary. Companies receive lots of applications for such positions and they must be able to select somehow. The competition is strong. They must be able to assess your skills. One relatively fast way of doing that is asking some questions about data structures and algorithms in an interview. Let’s see how I approached the first interviews and how my views changed. Algorithms By the time I went to my first interviews, I could figure out many solutions to easy and medium LeetCode problems on my own without using hints. I could analyze the space and time complexity of the solutions, although not in a very sophisticated manner. More on that just in a minute. My experience is that many problems can be solved in C++ as a combination of standard algorithms. There are more than 100 of them, combining them is very powerful. Although C++ Reference lists the complexity of each algorithm, I didn’t always know them. You can imagine how it impacted my complexity analysis performance. So how did I change my approach? I still think that being able to implement the different sorts on a whiteboard is superfluous. You’ll almost never need them. In most positions, using what the standard library of your language provides is a way better choice than implementing whatever sorting algorithm. And if one day you have to implement it, it’s not a big deal to look up the algorithm in a book. No sane interviewer should ask for it. On the other hand, it is extremely useful to know the complexity of the different algorithms and their requirements. For example, if you want to decide in C++ whether a value is in a container or not, you might use binary_search or find. While std::binary_search is faster (O(logN) vs O(N)), it requires that you have a sorted container. As sorting a container has the complexity of O(N*logN), it’s also obvious that it’s not worth sorting a container just so that you can binary search it. Knowing the standard functions, their requirements and their complexities lets us decide which path to take in different situations. You don’t have to be able to implement them on the spot. (Even though implementing a simplified version of find with O(N) is really not complex) Data structures The case for data structures though is a bit different. When it comes to algorithms, they are quite specific and you don’t have plenty of different functions to achieve the same thing. With data structures, it’s different. In the C++ STL you have quite a few: array vector list, forward_list deque, stack, queue, priority_queue set, multiset map, multimap unordered_set, unordered_multiset unordered_map, unordered_multimap span Some of them are just adapters, but still. They are all there to store data. This list has 20 elements, while there are more than a hundred algorithms. I’d advise that you learn them well. Understand how they are implemented. No, you don’t have to be able to implement them with all their special cases, but know that a list is a doubly linked list, and know that vectors are dynamic size arrays with contiguous element storage. Know that a map is implemented as a tree, while an unordered_map is a hashmap. Also focus a bit on learning how complex it is to access, insert or delete an element from these data structures. When you know the underlying data structure, most of these questions become quite easy given that you learnt about the structures once. If not, it’s high time to do so. I find this important because when you implement an algorithm on your own, it becomes way easier to analyze its complexity. You’ll understand easily that finding an item in a map is O(logn), while doing the same in a hashmap is constant on average. Once you understand these complexities it also becomes simpler to understand when and why to use each of these data structures. To learn all these, you don’t need any fancy tool or platform. Browsing C++ Reference and taking some notes of the complexities are more than enough. Conclusion In this article, I shared with you how unimportant I found knowing details about algorithms and data structures before I started interviewing companies after working for 9 years at the same corporation. I was pretty much wrong. I still think that knowing how to implement all the algorithms would be an overkill and I would not focus on that while preparing, but knowing the complexities of some algorithms of your standard library is essential. What I found even more important is that you understand deeply the data structures offered by the standard library of your chosen language. Understand what kind of data structures are used for their implementations and the complexities of their operations. Invest a few hours doing so and you’ll significantly improve your chances to make good decisions to choose a data structure and nailing the complexity analysis at an interview. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-08-31T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Should you really memorize algorithm complexities?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-08-31T00:00:00+02:00","datePublished":"2022-08-31T00:00:00+02:00","description":"A few years ago I read one of Yegor Bugayenko’s articles about his feelings about applying to a BigTech company. He wrote something like he would never be accepted and could never pass such interviews because he is not prepared for such nonsense and would not waste his time doing so. I felt the same. I thought I was already a good programmer and I wouldn’t need those. In any case, who wouldn’t want to hire me? (Hint: in fact, many, way too many…) I was partly wrong. I realized that when I started to go through some interview processes with different companies. It turned out quite fast that what I want from a job are things that many others want too. It must be remote, it must be a senior/senior+ position and it must pay a hefty salary. Companies receive lots of applications for such positions and they must be able to select somehow. The competition is strong. They must be able to assess your skills. One relatively fast way of doing that is asking some questions about data structures and algorithms in an interview. Let’s see how I approached the first interviews and how my views changed. Algorithms By the time I went to my first interviews, I could figure out many solutions to easy and medium LeetCode problems on my own without using hints. I could analyze the space and time complexity of the solutions, although not in a very sophisticated manner. More on that just in a minute. My experience is that many problems can be solved in C++ as a combination of standard algorithms. There are more than 100 of them, combining them is very powerful. Although C++ Reference lists the complexity of each algorithm, I didn’t always know them. You can imagine how it impacted my complexity analysis performance. So how did I change my approach? I still think that being able to implement the different sorts on a whiteboard is superfluous. You’ll almost never need them. In most positions, using what the standard library of your language provides is a way better choice than implementing whatever sorting algorithm. And if one day you have to implement it, it’s not a big deal to look up the algorithm in a book. No sane interviewer should ask for it. On the other hand, it is extremely useful to know the complexity of the different algorithms and their requirements. For example, if you want to decide in C++ whether a value is in a container or not, you might use binary_search or find. While std::binary_search is faster (O(logN) vs O(N)), it requires that you have a sorted container. As sorting a container has the complexity of O(N*logN), it’s also obvious that it’s not worth sorting a container just so that you can binary search it. Knowing the standard functions, their requirements and their complexities lets us decide which path to take in different situations. You don’t have to be able to implement them on the spot. (Even though implementing a simplified version of find with O(N) is really not complex) Data structures The case for data structures though is a bit different. When it comes to algorithms, they are quite specific and you don’t have plenty of different functions to achieve the same thing. With data structures, it’s different. In the C++ STL you have quite a few: array vector list, forward_list deque, stack, queue, priority_queue set, multiset map, multimap unordered_set, unordered_multiset unordered_map, unordered_multimap span Some of them are just adapters, but still. They are all there to store data. This list has 20 elements, while there are more than a hundred algorithms. I’d advise that you learn them well. Understand how they are implemented. No, you don’t have to be able to implement them with all their special cases, but know that a list is a doubly linked list, and know that vectors are dynamic size arrays with contiguous element storage. Know that a map is implemented as a tree, while an unordered_map is a hashmap. Also focus a bit on learning how complex it is to access, insert or delete an element from these data structures. When you know the underlying data structure, most of these questions become quite easy given that you learnt about the structures once. If not, it’s high time to do so. I find this important because when you implement an algorithm on your own, it becomes way easier to analyze its complexity. You’ll understand easily that finding an item in a map is O(logn), while doing the same in a hashmap is constant on average. Once you understand these complexities it also becomes simpler to understand when and why to use each of these data structures. To learn all these, you don’t need any fancy tool or platform. Browsing C++ Reference and taking some notes of the complexities are more than enough. Conclusion In this article, I shared with you how unimportant I found knowing details about algorithms and data structures before I started interviewing companies after working for 9 years at the same corporation. I was pretty much wrong. I still think that knowing how to implement all the algorithms would be an overkill and I would not focus on that while preparing, but knowing the complexities of some algorithms of your standard library is essential. What I found even more important is that you understand deeply the data structures offered by the standard library of your chosen language. Understand what kind of data structures are used for their implementations and the complexities of their operations. Invest a few hours doing so and you’ll significantly improve your chances to make good decisions to choose a data structure and nailing the complexity analysis at an interview. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Should you really memorize algorithm complexities?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews"},"url":"https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews"}</script><title>Should you really memorize algorithm complexities? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/08"> 08 </a> </span> <span> <a href="/31"> 31 </a> </span> <span>Should you really memorize algorithm complexities?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Should you really memorize algorithm complexities?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 31, 2022, 12:00 AM +0200" prep="on" > Aug 31, 2022 <i class="unloaded">2022-08-31T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="979 words">5 min</span></div></div><div class="post-content"><p>A few years ago I read one of Yegor Bugayenko’s articles about his feelings about applying to a BigTech company. He wrote something like he would never be accepted and could never pass such interviews because he is not prepared for such nonsense and would not waste his time doing so.</p><p>I felt the same. I thought I was already a good programmer and I wouldn’t need those. In any case, who wouldn’t want to hire me? (Hint: in fact, many, way too many…)</p><p>I was partly wrong.</p><p>I realized that when I started to go through some interview processes with different companies.</p><p>It turned out quite fast that what I want from a job are things that many others want too. It must be remote, it must be a senior/senior+ position and it must pay a hefty salary.</p><p>Companies receive lots of applications for such positions and they must be able to select somehow. The competition is strong. They must be able to assess your skills. One relatively fast way of doing that is asking some questions about data structures and algorithms in an interview.</p><p>Let’s see how I approached the first interviews and how my views changed.</p><h2 id="algorithms">Algorithms</h2><p>By the time I went to my first interviews, I could figure out many solutions to easy and medium <a href="https://leetcode.com/problem-list/top-interview-questions/">LeetCode problems</a> on my own without using hints. I could analyze the space and time complexity of the solutions, although not in a very sophisticated manner. More on that just in a minute.</p><p>My experience is that many problems can be solved in C++ as a combination of standard algorithms. There are more than 100 of them, combining them is very powerful. Although <a href="https://en.cppreference.com/w/cpp/algorithm/binary_search">C++ Reference lists</a> the <em>complexity</em> of each algorithm, I didn’t always know them. You can imagine how it impacted my complexity analysis performance.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/binary_search-complexity.png" alt="Binary search complexity" /></p><p>So how did I change my approach?</p><p>I still think that being able to implement the different sorts on a whiteboard is superfluous. You’ll almost never need them. In most positions, using what the standard library of your language provides is a way better choice than implementing whatever sorting algorithm. And if one day you have to implement it, it’s not a big deal to look up the algorithm in a book.</p><p>No sane interviewer should ask for it.</p><p>On the other hand, it is extremely useful to know the complexity of the different algorithms and their requirements. For example, if you want to decide in C++ whether a value is in a container or not, you might use <code class="language-plaintext highlighter-rouge">binary_search</code> or <code class="language-plaintext highlighter-rouge">find</code>. While <code class="language-plaintext highlighter-rouge">std::binary_search</code> is faster (<em>O(logN)</em> vs <em>O(N)</em>), it requires that you have a sorted container.</p><p>As sorting a container has the complexity of <em>O(N*logN)</em>, it’s also obvious that it’s not worth sorting a container just so that you can binary search it.</p><p>Knowing the standard functions, their requirements and their complexities lets us decide which path to take in different situations. You don’t have to be able to implement them on the spot. <a href="https://github.com/llvm-mirror/libcxx/blob/master/include/algorithm#L912-L922">(Even though implementing a simplified version of <code class="language-plaintext highlighter-rouge">find</code> with <em>O(N)</em> is really not complex)</a></p><h2 id="data-structures">Data structures</h2><p>The case for data structures though is a bit different. When it comes to algorithms, they are quite specific and you don’t have plenty of different functions to achieve the same thing. With data structures, it’s different. In the C++ STL you have quite a few:</p><ul><li>array<li>vector<li>list, forward_list<li>deque, stack, queue, priority_queue<li>set, multiset<li>map, multimap<li>unordered_set, unordered_multiset<li>unordered_map, unordered_multimap<li>span</ul><p>Some of them are just adapters, but still. They are all there to store data. This list has 20 elements, while there are more than a hundred algorithms. I’d advise that you learn them well.</p><p>Understand how they are implemented. No, you don’t have to be able to implement them with all their special cases, but know that a <code class="language-plaintext highlighter-rouge">list</code> is a doubly linked list, and know that <code class="language-plaintext highlighter-rouge">vector</code>s are dynamic size arrays with contiguous element storage. Know that a <code class="language-plaintext highlighter-rouge">map</code> is implemented as a tree, while an <code class="language-plaintext highlighter-rouge">unordered_map</code> is a hashmap.</p><p>Also focus a bit on learning how complex it is to access, insert or delete an element from these data structures. When you know the underlying data structure, most of these questions become quite easy given that you learnt about the structures once. If not, it’s high time to do so.</p><p>I find this important because when you implement an algorithm on your own, it becomes way easier to analyze its complexity. You’ll understand easily that finding an item in a map is <em>O(logn)</em>, while doing the same in a hashmap is constant on average.</p><p>Once you understand these complexities it also becomes simpler to understand when and why to use each of these data structures.</p><p>To learn all these, you don’t need any fancy tool or platform. Browsing <a href="https://en.cppreference.com/w/cpp/container">C++ Reference</a> and taking some notes of the complexities are more than enough.</p><h2 id="conclusion">Conclusion</h2><p>In this article, I shared with you how unimportant I found knowing details about algorithms and data structures before I started interviewing companies after working for 9 years at the same corporation. I was pretty much wrong. I still think that knowing how to implement all the algorithms would be an overkill and I would not focus on that while preparing, but knowing the complexities of some algorithms of your standard library is essential.</p><p>What I found even more important is that you understand deeply the data structures offered by the standard library of your chosen language. Understand what kind of data structures are used for their implementations and the complexities of their operations.</p><p>Invest a few hours doing so and you’ll significantly improve your chances to make good decisions to choose a data structure and nailing the complexity analysis at an interview.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/career/" class="post-tag no-text-decoration" >career</a> <a href="/tags/watercooler/" class="post-tag no-text-decoration" >watercooler</a> <a href="/tags/interview/" class="post-tag no-text-decoration" >interview</a> <a href="/tags/learning/" class="post-tag no-text-decoration" >learning</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Should you really memorize algorithm complexities? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Should you really memorize algorithm complexities? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Should you really memorize algorithm complexities? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Should you really memorize algorithm complexities? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/09/14/dont-feel-bad-just-learn"><div class="card-body"> <span class="timeago small" > Sep 14, 2022 <i class="unloaded">2022-09-14T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Don't feel bad because of failed interviews, just keep learning!</h3><div class="text-muted small"><p> I was thinking about switching jobs since about the beginning of the year. But as we had our dream vacation planned for 3 weeks in April, I didn’t really want to look for a new job before coming ba...</p></div></div></a></div><div class="card"> <a href="/blog/2022/09/28/5-tips-to-find-your-next-job"><div class="card-body"> <span class="timeago small" > Sep 28, 2022 <i class="unloaded">2022-09-28T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5 tips to find your next job</h3><div class="text-muted small"><p> A few months ago, I decided that it was time for me to look for a new job. I must tell you, it’s a very competitive and requiring process. I’ve already written about it here and here focusing on di...</p></div></div></a></div><div class="card"> <a href="/blog/2024/02/17/the-software-engineers-guidebook-by-orosz-gergely"><div class="card-body"> <span class="timeago small" > Feb 17, 2024 <i class="unloaded">2024-02-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The Software Engineer's Guidebook by Orosz Gergely</h3><div class="text-muted small"><p> This is not the first book of Gergely Orosz, author of The Pragmatic Engineer newsletter, but this is the most general one so far. Before this one, he wrote books that targeted much narrower topics...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/08/24/tmp-and-nvi" class="btn btn-outline-primary" prompt="Older"><p>The Template Method Pattern and the Non-Virtual Idiom</p></a> <a href="/blog/2022/09/03/thinking-fast-and-slow-by-daniel-kahneman" class="btn btn-outline-primary" prompt="Newer"><p>Thinking, Fast and Slow by Daniel Kahneman</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Should you really memorize algorithm complexities?'; this.page.url = 'https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews'; this.page.identifier = '/blog/2022/08/31/data-structure-and-algorithms-interviews'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
