<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++: standardized" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this article, let’s step back from coding a little bit. We are going to discuss how C++ was born and how it’s been evolving ever since. We’ll only have a brief overview of what happened in the last 40 years, then we will focus on how the C++ programming language is evolving, and where the decisions are taken. Non-standard C++ The language started out as an extension of the C programming language which itself was an improved version of B. In 1979, the Danish computer scientist, Bjarne Stroustrup started to work on an extension that was called “C with classes”. Yet, we cannot tell that C++, or at the moment “C with classes” is simply based on C. While Stroustrup was working on his PhD thesis, among other languages he learnt Simula. Simula is considered the first object-oriented programming language. One could create classes and organize them into hierarchical models. Bjarne loved its expressiveness. If you think about the history of innovation, great things are rarely born out of the blue. Great things are born when ideas have sex with each other. Stroustrup wanted to combine the humanly understandable relationships introduced by Simula with the sheer power of a low-level language, such as C. That’s how the idea of “C with classes” was born. It was delivered as a preprocessor of the C compiler, called Cpre. It already included classes and inheritance, public and private access levels, friends, constructors and destructors, assignment operator overloading, inlining and default arguments. In 1982, Stroustrup started to develop a new language based on his “C with classes” which he named C++, referring to the increment operator (++) in C. Additional new features were added such as virtual functions, function and operator overloading, references, consts, the dreaded new and delete keywords for memory allocations, etc. It was not a preprocessor for the C compiler anymore, but the features were implemented as part of a standalone compiler called Cfront. Bjarne Stroustrup continued to work on the language and 7 months after I was born, in 1985 he released the first edition of his book called The C++ Programming Language. At that point, C++ was not a standardized language. This book was the de-facto reference to the language. A new version, C++ 2.0 came out 4 years later in 1989. in the same year when the Iron Curtain fell. Yes, C++ is that old. The language was finally standardized Sixteen years after the initial release and nine years after the second version, in 1998, the language was finally standardized based on C++ 2.0 and it was released as C++98. Five years later C++03 was released, but it was mostly about bug fixes. C++ was evolving really slowly. No new version was released for 8 years, until 2011. Let’s stop for a second. What does it even mean to standardize a language? And how is C++ different from Java or Python in that sense? The International Standardization Organization (ISO) has a subcommittee responsible for “Programming languages, their environments and system software interfaces”, it’s the ISO/IEC JTC 1/SC 22 subcommittee. This committee has several different workgroups, WG21 is the one responsible for standardizing C++. On the internet language, people working on the C++ standardization usually refer to it simply as WG21. In contrast, Java is owned by the tech giant Oracle. Therefore Java is not standardized. One can consider Oracle’s official implementation as the standard, but it doesn’t correspond to any formal standardization. Python is managed by the Python Software Foundation. Its mission is “to promote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmers”. The benefits of standardizing a language are you know the language won’t randomly change if you want to write your own compiler/interpreter for the language, you have a very clear document defining how a language should behave in almost all circumstances. Standards - just like legal texts - are difficult to read and are lengthy in order to cover all the details. But does the C++ standard define exactly how the language should behave in all the circumstances? Actually, it doesn’t. About 2000 pages are not enough for that! While reading the standard, we will encounter 3 different categories where we won’t know how our software would behave. Unspecified behaviour Implementation-defined behaviour Undefined behaviour Unspecified behaviour leaves to the compiler implementers to define the behaviour without the obligation of documenting it. E.g. the outcome of comparing the addresses of local variables is unspecified behaviour. Implementation-defined behaviour is very similar to unspecified, but in this case, the implementers must document their decision. Think about the number of bits in a byte or default integer types, those are implementation-defined. Undefined behaviour is the worst. It means that rules are broken, and the compiler is entitled to do anything without guaranteeing us anything. If we are lucky our code would crash, but maybe it will produce logically non-sense, even non-deterministic results. For example, accessing uninitialized variables is undefined behaviour. How does the committee work? It would be too simple for us to stop at the level of WG21. Let’s jump into the details. The WG21 is organized into a pipeline of three stages. In the first stage, you find study groups (SG). Since the beginning of the C++ standardization, there have been 24 study groups and 19 are still active. These groups are working on proposals for their own areas of expertise. For example, SG9 is responsible for ranges evolution, SG7 for reflection and SG1 for concurrency. Once a study group considers a proposal ready for the next stage, the proposal goes to one of the two groups of stage 2: Core Language Evolution (EWG) Library Evolution (LEWG) Once the proposal is approved at stage 2, it advances to stage 3 where the Core Language Wording Group (CWG) or the Library Wording Group (LWG) makes sure that the new changes will be consistently and properly worded. Once a proposal went through all these stages, it can be accepted or actually declined by the full plenary C++ Committee, by WG21. A recent such proposal is P0847R7, which is going to be part of C++23 and it’s usually just referred to as deducing this. With this new language feature, we get “a way to tell from within a member function whether the expression it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the expression’s type”. If you are interested in further details, follow this link. A proposal might be sent back to previous stages several times or can be rejected completely. For example, P2012R0 is having a hard time. Their authors want to address a long-known and quite serious issue with range-based for loops (check the details here) and while they had quite some support, in the end, the EWG rejected it still hoping for a future “perfect” solution… But who can vote and who can work on these standards and proposals? Let’s answer the easier question. Anyone who is willing to work on the evolution of C++ is welcome to do so. Anyone can write, submit and present a proposal. At the same time, not everyone who goes to a meeting can actually vote. The committee is built up by the national bodies. In other words, each country’s own standardization organization delegates some people to the international group. At the international meetings, each country has one vote to determine the ISO decision. For example, my employer, Amadeus is part of the French national body through AFNOR, the French standardization organization. We have a representative at the meetings of the AFNOR, but Amadeus doesn’t have its own delegate at the ISO meetings. The members of the French national body, including Amadeus, choose who can vote at the international meeting representing the French opinion. It’s worth emphasizing the fact that while voting is possible only for the national bodies, anyone can participate at the meetings. They are open and everyone can go and discuss/defend their proposals. Most of the important work is done through these open discussions. The meetings used to be face-to-face full weeks sessions, but with the COVID they became virtual. You can find more information about the meetings and participation here. Standards are released on a schedule Since the release of C++11, the committee is dedicated to following a predictable train-like model. The analogy is - luckily - not about SAFe. It refers to the timetable of trains. Every three years there is a new version to be released. It does not matter how much a fix or a new feature is expected. If it’s not ready when the next train departs, the feature will not be on that train. The train doesn’t wait. The feature missing its train will wait for the next one. It’ll come in 3 years. The original idea was to have every second version packed with new features and the others to include mostly minor additions and bug fixes. The reality hasn’t met this expectation yet as after C+11 the next “major” release was C++20. It’s still to see if C++26 can be a major release. Nevertheless, the train-like model is respected, we have a new release every 3 years. C++11, C++14, C++17, C++20… Setting a predictable schedule of release dates into stone is useful to avoid special treatment for certain features that are either highly waited for or that are supported by people with bigger authority over the committee. Besides, the schedule also ensures a high level of predictability of the language evolution. While nobody can know what exactly will be included in the next release, we pretty much know when it will be published. If you think about those who are working on compilers and on different toolings, you understand why this matters so much. It further increases the needed predictability that developers working with compilers are widely represented among the committee members. At the same time, people might feel that there are too many versions and it’s difficult to keep up to date. This criticism is valid on a certain level. Still, in comparison to Java or Python, it still gives plenty of leeways for us to keep ourselves up to date. Conclusion In this post, we discussed how the C++ programming language was born around 40 years ago. We saw how after the initial agility it lost a bit the momentum - at least in terms of evolution. C++ is a complex and widely used language and as such it’s governed by a multi-level organization. We saw how that organization is built-up and how the release pipeline is composed. Since the release of C++11, the C++ Committee is committed to following a predictable schedule. There are new features and bug fixes released every three years. Thanks to those, C++ is evolving, it is now considered a modern programming language and it’s getting simpler to write correct code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this article, let’s step back from coding a little bit. We are going to discuss how C++ was born and how it’s been evolving ever since. We’ll only have a brief overview of what happened in the last 40 years, then we will focus on how the C++ programming language is evolving, and where the decisions are taken. Non-standard C++ The language started out as an extension of the C programming language which itself was an improved version of B. In 1979, the Danish computer scientist, Bjarne Stroustrup started to work on an extension that was called “C with classes”. Yet, we cannot tell that C++, or at the moment “C with classes” is simply based on C. While Stroustrup was working on his PhD thesis, among other languages he learnt Simula. Simula is considered the first object-oriented programming language. One could create classes and organize them into hierarchical models. Bjarne loved its expressiveness. If you think about the history of innovation, great things are rarely born out of the blue. Great things are born when ideas have sex with each other. Stroustrup wanted to combine the humanly understandable relationships introduced by Simula with the sheer power of a low-level language, such as C. That’s how the idea of “C with classes” was born. It was delivered as a preprocessor of the C compiler, called Cpre. It already included classes and inheritance, public and private access levels, friends, constructors and destructors, assignment operator overloading, inlining and default arguments. In 1982, Stroustrup started to develop a new language based on his “C with classes” which he named C++, referring to the increment operator (++) in C. Additional new features were added such as virtual functions, function and operator overloading, references, consts, the dreaded new and delete keywords for memory allocations, etc. It was not a preprocessor for the C compiler anymore, but the features were implemented as part of a standalone compiler called Cfront. Bjarne Stroustrup continued to work on the language and 7 months after I was born, in 1985 he released the first edition of his book called The C++ Programming Language. At that point, C++ was not a standardized language. This book was the de-facto reference to the language. A new version, C++ 2.0 came out 4 years later in 1989. in the same year when the Iron Curtain fell. Yes, C++ is that old. The language was finally standardized Sixteen years after the initial release and nine years after the second version, in 1998, the language was finally standardized based on C++ 2.0 and it was released as C++98. Five years later C++03 was released, but it was mostly about bug fixes. C++ was evolving really slowly. No new version was released for 8 years, until 2011. Let’s stop for a second. What does it even mean to standardize a language? And how is C++ different from Java or Python in that sense? The International Standardization Organization (ISO) has a subcommittee responsible for “Programming languages, their environments and system software interfaces”, it’s the ISO/IEC JTC 1/SC 22 subcommittee. This committee has several different workgroups, WG21 is the one responsible for standardizing C++. On the internet language, people working on the C++ standardization usually refer to it simply as WG21. In contrast, Java is owned by the tech giant Oracle. Therefore Java is not standardized. One can consider Oracle’s official implementation as the standard, but it doesn’t correspond to any formal standardization. Python is managed by the Python Software Foundation. Its mission is “to promote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmers”. The benefits of standardizing a language are you know the language won’t randomly change if you want to write your own compiler/interpreter for the language, you have a very clear document defining how a language should behave in almost all circumstances. Standards - just like legal texts - are difficult to read and are lengthy in order to cover all the details. But does the C++ standard define exactly how the language should behave in all the circumstances? Actually, it doesn’t. About 2000 pages are not enough for that! While reading the standard, we will encounter 3 different categories where we won’t know how our software would behave. Unspecified behaviour Implementation-defined behaviour Undefined behaviour Unspecified behaviour leaves to the compiler implementers to define the behaviour without the obligation of documenting it. E.g. the outcome of comparing the addresses of local variables is unspecified behaviour. Implementation-defined behaviour is very similar to unspecified, but in this case, the implementers must document their decision. Think about the number of bits in a byte or default integer types, those are implementation-defined. Undefined behaviour is the worst. It means that rules are broken, and the compiler is entitled to do anything without guaranteeing us anything. If we are lucky our code would crash, but maybe it will produce logically non-sense, even non-deterministic results. For example, accessing uninitialized variables is undefined behaviour. How does the committee work? It would be too simple for us to stop at the level of WG21. Let’s jump into the details. The WG21 is organized into a pipeline of three stages. In the first stage, you find study groups (SG). Since the beginning of the C++ standardization, there have been 24 study groups and 19 are still active. These groups are working on proposals for their own areas of expertise. For example, SG9 is responsible for ranges evolution, SG7 for reflection and SG1 for concurrency. Once a study group considers a proposal ready for the next stage, the proposal goes to one of the two groups of stage 2: Core Language Evolution (EWG) Library Evolution (LEWG) Once the proposal is approved at stage 2, it advances to stage 3 where the Core Language Wording Group (CWG) or the Library Wording Group (LWG) makes sure that the new changes will be consistently and properly worded. Once a proposal went through all these stages, it can be accepted or actually declined by the full plenary C++ Committee, by WG21. A recent such proposal is P0847R7, which is going to be part of C++23 and it’s usually just referred to as deducing this. With this new language feature, we get “a way to tell from within a member function whether the expression it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the expression’s type”. If you are interested in further details, follow this link. A proposal might be sent back to previous stages several times or can be rejected completely. For example, P2012R0 is having a hard time. Their authors want to address a long-known and quite serious issue with range-based for loops (check the details here) and while they had quite some support, in the end, the EWG rejected it still hoping for a future “perfect” solution… But who can vote and who can work on these standards and proposals? Let’s answer the easier question. Anyone who is willing to work on the evolution of C++ is welcome to do so. Anyone can write, submit and present a proposal. At the same time, not everyone who goes to a meeting can actually vote. The committee is built up by the national bodies. In other words, each country’s own standardization organization delegates some people to the international group. At the international meetings, each country has one vote to determine the ISO decision. For example, my employer, Amadeus is part of the French national body through AFNOR, the French standardization organization. We have a representative at the meetings of the AFNOR, but Amadeus doesn’t have its own delegate at the ISO meetings. The members of the French national body, including Amadeus, choose who can vote at the international meeting representing the French opinion. It’s worth emphasizing the fact that while voting is possible only for the national bodies, anyone can participate at the meetings. They are open and everyone can go and discuss/defend their proposals. Most of the important work is done through these open discussions. The meetings used to be face-to-face full weeks sessions, but with the COVID they became virtual. You can find more information about the meetings and participation here. Standards are released on a schedule Since the release of C++11, the committee is dedicated to following a predictable train-like model. The analogy is - luckily - not about SAFe. It refers to the timetable of trains. Every three years there is a new version to be released. It does not matter how much a fix or a new feature is expected. If it’s not ready when the next train departs, the feature will not be on that train. The train doesn’t wait. The feature missing its train will wait for the next one. It’ll come in 3 years. The original idea was to have every second version packed with new features and the others to include mostly minor additions and bug fixes. The reality hasn’t met this expectation yet as after C+11 the next “major” release was C++20. It’s still to see if C++26 can be a major release. Nevertheless, the train-like model is respected, we have a new release every 3 years. C++11, C++14, C++17, C++20… Setting a predictable schedule of release dates into stone is useful to avoid special treatment for certain features that are either highly waited for or that are supported by people with bigger authority over the committee. Besides, the schedule also ensures a high level of predictability of the language evolution. While nobody can know what exactly will be included in the next release, we pretty much know when it will be published. If you think about those who are working on compilers and on different toolings, you understand why this matters so much. It further increases the needed predictability that developers working with compilers are widely represented among the committee members. At the same time, people might feel that there are too many versions and it’s difficult to keep up to date. This criticism is valid on a certain level. Still, in comparison to Java or Python, it still gives plenty of leeways for us to keep ourselves up to date. Conclusion In this post, we discussed how the C++ programming language was born around 40 years ago. We saw how after the initial agility it lost a bit the momentum - at least in terms of evolution. C++ is a complex and widely used language and as such it’s governed by a multi-level organization. We saw how that organization is built-up and how the release pipeline is composed. Since the release of C++11, the C++ Committee is committed to following a predictable schedule. There are new features and bug fixes released every three years. Thanks to those, C++ is evolving, it is now considered a modern programming language and it’s getting simpler to write correct code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/06/29/cpp-standardized" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/06/29/cpp-standardized" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-29T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++: standardized" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-22T20:07:51+02:00","datePublished":"2022-06-29T00:00:00+02:00","description":"In this article, let’s step back from coding a little bit. We are going to discuss how C++ was born and how it’s been evolving ever since. We’ll only have a brief overview of what happened in the last 40 years, then we will focus on how the C++ programming language is evolving, and where the decisions are taken. Non-standard C++ The language started out as an extension of the C programming language which itself was an improved version of B. In 1979, the Danish computer scientist, Bjarne Stroustrup started to work on an extension that was called “C with classes”. Yet, we cannot tell that C++, or at the moment “C with classes” is simply based on C. While Stroustrup was working on his PhD thesis, among other languages he learnt Simula. Simula is considered the first object-oriented programming language. One could create classes and organize them into hierarchical models. Bjarne loved its expressiveness. If you think about the history of innovation, great things are rarely born out of the blue. Great things are born when ideas have sex with each other. Stroustrup wanted to combine the humanly understandable relationships introduced by Simula with the sheer power of a low-level language, such as C. That’s how the idea of “C with classes” was born. It was delivered as a preprocessor of the C compiler, called Cpre. It already included classes and inheritance, public and private access levels, friends, constructors and destructors, assignment operator overloading, inlining and default arguments. In 1982, Stroustrup started to develop a new language based on his “C with classes” which he named C++, referring to the increment operator (++) in C. Additional new features were added such as virtual functions, function and operator overloading, references, consts, the dreaded new and delete keywords for memory allocations, etc. It was not a preprocessor for the C compiler anymore, but the features were implemented as part of a standalone compiler called Cfront. Bjarne Stroustrup continued to work on the language and 7 months after I was born, in 1985 he released the first edition of his book called The C++ Programming Language. At that point, C++ was not a standardized language. This book was the de-facto reference to the language. A new version, C++ 2.0 came out 4 years later in 1989. in the same year when the Iron Curtain fell. Yes, C++ is that old. The language was finally standardized Sixteen years after the initial release and nine years after the second version, in 1998, the language was finally standardized based on C++ 2.0 and it was released as C++98. Five years later C++03 was released, but it was mostly about bug fixes. C++ was evolving really slowly. No new version was released for 8 years, until 2011. Let’s stop for a second. What does it even mean to standardize a language? And how is C++ different from Java or Python in that sense? The International Standardization Organization (ISO) has a subcommittee responsible for “Programming languages, their environments and system software interfaces”, it’s the ISO/IEC JTC 1/SC 22 subcommittee. This committee has several different workgroups, WG21 is the one responsible for standardizing C++. On the internet language, people working on the C++ standardization usually refer to it simply as WG21. In contrast, Java is owned by the tech giant Oracle. Therefore Java is not standardized. One can consider Oracle’s official implementation as the standard, but it doesn’t correspond to any formal standardization. Python is managed by the Python Software Foundation. Its mission is “to promote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmers”. The benefits of standardizing a language are you know the language won’t randomly change if you want to write your own compiler/interpreter for the language, you have a very clear document defining how a language should behave in almost all circumstances. Standards - just like legal texts - are difficult to read and are lengthy in order to cover all the details. But does the C++ standard define exactly how the language should behave in all the circumstances? Actually, it doesn’t. About 2000 pages are not enough for that! While reading the standard, we will encounter 3 different categories where we won’t know how our software would behave. Unspecified behaviour Implementation-defined behaviour Undefined behaviour Unspecified behaviour leaves to the compiler implementers to define the behaviour without the obligation of documenting it. E.g. the outcome of comparing the addresses of local variables is unspecified behaviour. Implementation-defined behaviour is very similar to unspecified, but in this case, the implementers must document their decision. Think about the number of bits in a byte or default integer types, those are implementation-defined. Undefined behaviour is the worst. It means that rules are broken, and the compiler is entitled to do anything without guaranteeing us anything. If we are lucky our code would crash, but maybe it will produce logically non-sense, even non-deterministic results. For example, accessing uninitialized variables is undefined behaviour. How does the committee work? It would be too simple for us to stop at the level of WG21. Let’s jump into the details. The WG21 is organized into a pipeline of three stages. In the first stage, you find study groups (SG). Since the beginning of the C++ standardization, there have been 24 study groups and 19 are still active. These groups are working on proposals for their own areas of expertise. For example, SG9 is responsible for ranges evolution, SG7 for reflection and SG1 for concurrency. Once a study group considers a proposal ready for the next stage, the proposal goes to one of the two groups of stage 2: Core Language Evolution (EWG) Library Evolution (LEWG) Once the proposal is approved at stage 2, it advances to stage 3 where the Core Language Wording Group (CWG) or the Library Wording Group (LWG) makes sure that the new changes will be consistently and properly worded. Once a proposal went through all these stages, it can be accepted or actually declined by the full plenary C++ Committee, by WG21. A recent such proposal is P0847R7, which is going to be part of C++23 and it’s usually just referred to as deducing this. With this new language feature, we get “a way to tell from within a member function whether the expression it’s invoked on is an lvalue or an rvalue; whether it is const or volatile; and the expression’s type”. If you are interested in further details, follow this link. A proposal might be sent back to previous stages several times or can be rejected completely. For example, P2012R0 is having a hard time. Their authors want to address a long-known and quite serious issue with range-based for loops (check the details here) and while they had quite some support, in the end, the EWG rejected it still hoping for a future “perfect” solution… But who can vote and who can work on these standards and proposals? Let’s answer the easier question. Anyone who is willing to work on the evolution of C++ is welcome to do so. Anyone can write, submit and present a proposal. At the same time, not everyone who goes to a meeting can actually vote. The committee is built up by the national bodies. In other words, each country’s own standardization organization delegates some people to the international group. At the international meetings, each country has one vote to determine the ISO decision. For example, my employer, Amadeus is part of the French national body through AFNOR, the French standardization organization. We have a representative at the meetings of the AFNOR, but Amadeus doesn’t have its own delegate at the ISO meetings. The members of the French national body, including Amadeus, choose who can vote at the international meeting representing the French opinion. It’s worth emphasizing the fact that while voting is possible only for the national bodies, anyone can participate at the meetings. They are open and everyone can go and discuss/defend their proposals. Most of the important work is done through these open discussions. The meetings used to be face-to-face full weeks sessions, but with the COVID they became virtual. You can find more information about the meetings and participation here. Standards are released on a schedule Since the release of C++11, the committee is dedicated to following a predictable train-like model. The analogy is - luckily - not about SAFe. It refers to the timetable of trains. Every three years there is a new version to be released. It does not matter how much a fix or a new feature is expected. If it’s not ready when the next train departs, the feature will not be on that train. The train doesn’t wait. The feature missing its train will wait for the next one. It’ll come in 3 years. The original idea was to have every second version packed with new features and the others to include mostly minor additions and bug fixes. The reality hasn’t met this expectation yet as after C+11 the next “major” release was C++20. It’s still to see if C++26 can be a major release. Nevertheless, the train-like model is respected, we have a new release every 3 years. C++11, C++14, C++17, C++20… Setting a predictable schedule of release dates into stone is useful to avoid special treatment for certain features that are either highly waited for or that are supported by people with bigger authority over the committee. Besides, the schedule also ensures a high level of predictability of the language evolution. While nobody can know what exactly will be included in the next release, we pretty much know when it will be published. If you think about those who are working on compilers and on different toolings, you understand why this matters so much. It further increases the needed predictability that developers working with compilers are widely represented among the committee members. At the same time, people might feel that there are too many versions and it’s difficult to keep up to date. This criticism is valid on a certain level. Still, in comparison to Java or Python, it still gives plenty of leeways for us to keep ourselves up to date. Conclusion In this post, we discussed how the C++ programming language was born around 40 years ago. We saw how after the initial agility it lost a bit the momentum - at least in terms of evolution. C++ is a complex and widely used language and as such it’s governed by a multi-level organization. We saw how that organization is built-up and how the release pipeline is composed. Since the release of C++11, the C++ Committee is committed to following a predictable schedule. There are new features and bug fixes released every three years. Thanks to those, C++ is evolving, it is now considered a modern programming language and it’s getting simpler to write correct code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++: standardized","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/06/29/cpp-standardized"},"url":"https://www.sandordargo.com/blog/2022/06/29/cpp-standardized"}</script><title>C++: standardized | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/06"> 06 </a> </span> <span> <a href="/29"> 29 </a> </span> <span>C++: standardized</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++: standardized</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jun 29, 2022, 12:00 AM +0200" prep="on" > Jun 29, 2022 <i class="unloaded">2022-06-29T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Jul 22, 2022, 8:07 PM +0200" prefix="Updated " > Jul 22, 2022 <i class="unloaded">2022-07-22T20:07:51+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1843 words">10 min</span></div></div><div class="post-content"><p>In this article, let’s step back from coding a little bit. We are going to discuss how C++ was born and how it’s been evolving ever since. We’ll only have a brief overview of what happened in the last 40 years, then we will focus on how the C++ programming language is evolving, and where the decisions are taken.</p><h2 id="non-standard-c">Non-standard C++</h2><p>The language started out as an extension of the C programming language which itself was an improved version of <a href="https://en.wikipedia.org/wiki/B_(programming_language)">B</a>. In 1979, the Danish computer scientist, <a href="https://www.stroustrup.com/">Bjarne Stroustrup</a> started to work on an extension that was called <em>“C with classes”</em>.</p><p>Yet, we cannot tell that C++, or at the moment <em>“C with classes”</em> is simply based on C. While Stroustrup was working on his PhD thesis, among other languages he learnt Simula. Simula is considered the first object-oriented programming language. One could create classes and organize them into hierarchical models.</p><p>Bjarne loved its expressiveness.</p><p>If you think about the history of innovation, great things are rarely born out of the blue. Great things are born when ideas have sex with each other. Stroustrup wanted to combine the humanly understandable relationships introduced by Simula with the sheer power of a low-level language, such as C. That’s how the idea of <em>“C with classes”</em> was born.</p><p>It was delivered as a preprocessor of the C compiler, called <em>Cpre</em>. It already included classes and inheritance, public and private access levels, friends, constructors and destructors, assignment operator overloading, inlining and default arguments.</p><p>In 1982, Stroustrup started to develop a new language based on his <em>“C with classes”</em> which he named C++, referring to the increment operator (<code class="language-plaintext highlighter-rouge">++</code>) in C. Additional new features were added such as <code class="language-plaintext highlighter-rouge">virtual</code> functions, function and operator overloading, references, <code class="language-plaintext highlighter-rouge">const</code>s, the dreaded <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code> keywords for memory allocations, etc.</p><p>It was not a preprocessor for the C compiler anymore, but the features were implemented as part of a standalone compiler called <a href="https://en.wikipedia.org/wiki/Cfront">Cfront</a>.</p><p>Bjarne Stroustrup continued to work on the language and 7 months after I was born, in 1985 he released the first edition of his book called <a href="https://www.amazon.com/C-Programming-Language-4th/dp/0321563840?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=e2dad849d02505b124c6a2048aac0620&amp;camp=1789&amp;creative=9325">The C++ Programming Language</a>. At that point, C++ was not a standardized language. This book was the <em>de-facto</em> reference to the language.</p><p>A new version, C++ 2.0 came out 4 years later in 1989. in the same year when the Iron Curtain fell. Yes, C++ is that old.</p><h2 id="the-language-was-finally-standardized">The language was finally standardized</h2><p>Sixteen years after the initial release and nine years after the second version, in 1998, the language was finally standardized based on C++ 2.0 and it was released as <a href="https://en.wikipedia.org/wiki/C%2B%2B#Standardization">C++98</a>. Five years later <a href="https://en.wikipedia.org/wiki/C%2B%2B03">C++03</a> was released, but it was mostly about bug fixes.</p><p>C++ was evolving really slowly. No new version was released for 8 years, until 2011.</p><p>Let’s stop for a second.</p><p>What does it even mean to standardize a language? And how is C++ different from Java or Python in that sense?</p><p>The International Standardization Organization (ISO) has a subcommittee responsible for “Programming languages, their environments and system software interfaces”, it’s the <a href="http://www.open-std.org/jtc1/sc22/">ISO/IEC JTC 1/SC 22 subcommittee</a>. This committee has several different workgroups, <a href="http://www.open-std.org/JTC1/SC22/WG21/">WG21</a> is the one responsible for standardizing C++.</p><p>On the internet language, people working on the C++ standardization usually refer to it simply as <em>WG21</em>.</p><p>In contrast, Java is owned by the tech giant <a href="https://www.oracle.com/id/index.html">Oracle</a>. Therefore Java is not standardized. One can consider Oracle’s official implementation as the standard, but it doesn’t correspond to any formal standardization.</p><p>Python is managed by the <a href="https://www.python.org/psf">Python Software Foundation</a>. <a href="https://www.python.org/psf/mission/">Its mission is</a> <em>“to promote, protect, and advance the Python programming language, and to support and facilitate the growth of a diverse and international community of Python programmers”.</em></p><p>The benefits of standardizing a language are</p><ul><li>you know the language won’t randomly change<li>if you want to write your own compiler/interpreter for the language, you have a very clear document defining how a language should behave in almost all circumstances.</ul><blockquote><p>Standards - just like legal texts - are difficult to read and are lengthy in order to cover all the details. But does the C++ standard define exactly how the language should behave in all the circumstances?</p><p>Actually, it doesn’t. About 2000 pages are not enough for that! While reading the standard, we will encounter 3 different categories where we won’t know how our software would behave.</p><ul><li>Unspecified behaviour<li>Implementation-defined behaviour<li>Undefined behaviour</ul><p>Unspecified behaviour leaves to the compiler implementers to define the behaviour without the obligation of documenting it. E.g. the outcome of comparing the addresses of local variables is unspecified behaviour.</p><p>Implementation-defined behaviour is very similar to unspecified, but in this case, the implementers must document their decision. Think about the number of bits in a byte or default integer types, those are implementation-defined.</p><p>Undefined behaviour is the worst. It means that rules are broken, and the compiler is entitled to do anything without guaranteeing us anything. If we are lucky our code would crash, but maybe it will produce logically non-sense, even non-deterministic results. For example, accessing uninitialized variables is undefined behaviour.</p></blockquote><h2 id="how-does-the-committee-work">How does the committee work?</h2><p>It would be too simple for us to stop at the level of <em>WG21</em>.</p><p>Let’s jump into the details.</p><p>The WG21 is organized into a pipeline of three stages.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/wg21-structure-2021-06.png" alt="WG21 organization" /></p><p>In the first stage, you find study groups (SG). Since the beginning of the C++ standardization, there have been 24 study groups and 19 are still active. These groups are working on proposals for their own areas of expertise. For example, SG9 is responsible for <a href="https://github.com/cplusplus/SG9/blob/main/2022-Telecons.md">ranges</a> evolution, SG7 for reflection and SG1 for concurrency.</p><p>Once a study group considers a proposal ready for the next stage, the proposal goes to one of the two groups of stage 2:</p><ul><li>Core Language Evolution (<em>EWG</em>)<li>Library Evolution (<em>LEWG</em>)</ul><p>Once the proposal is approved at stage 2, it advances to stage 3 where the Core Language Wording Group (<em>CWG</em>) or the Library Wording Group (<em>LWG</em>) makes sure that the new changes will be consistently and properly worded.</p><p>Once a proposal went through all these stages, it can be accepted or actually declined by the full plenary C++ Committee, by <em>WG21</em>. A recent such proposal is <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0847r7.html">P0847R7</a>, which is going to be part of C++23 and it’s usually just referred to as <a href="https://www.sandordargo.com/blog/2022/02/16/deducing-this-cpp23">deducing this</a>. With this new language feature, we get <em>“a way to tell from within a member function whether the expression it’s invoked on is an lvalue or an rvalue; whether it is <code class="language-plaintext highlighter-rouge">const</code> or <code class="language-plaintext highlighter-rouge">volatile</code>; and the expression’s type”</em>. If you are interested in further details, <a href="https://www.sandordargo.com/blog/2022/02/16/deducing-this-cpp23">follow this link</a>.</p><p>A proposal might be sent back to previous stages several times or can be rejected completely. For example, <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2012r0.pdf">P2012R0</a> is having a hard time. Their authors want to address a long-known and quite serious issue with range-based <code class="language-plaintext highlighter-rouge">for</code> loops (<a href="https://www.sandordargo.com/blog/2022/04/20/range-base-p2012">check the details here</a>) and while they had quite some support, in the end, the <em>EWG</em> rejected it still hoping for a future <em>“perfect”</em> solution…</p><p>But who can vote and who can work on these standards and proposals?</p><p>Let’s answer the easier question. Anyone who is willing to work on the evolution of C++ is welcome to do so. Anyone can write, submit and present a proposal.</p><p>At the same time, not everyone who goes to a meeting can actually vote. The committee is built up by the national bodies. In other words, each country’s own standardization organization delegates some people to the international group. At the international meetings, each country has one vote to determine the ISO decision.</p><p>For example, my employer, <a href="https://amadeus.com/en">Amadeus</a> is part of the French national body through <a href="https://www.afnor.org/en/">AFNOR</a>, the French standardization organization. We have a representative at the meetings of the AFNOR, but Amadeus doesn’t have its own delegate at the ISO meetings. The members of the French national body, including Amadeus, choose who can vote at the international meeting representing the French opinion.</p><p>It’s worth emphasizing the fact that while voting is possible only for the national bodies, anyone can participate at the meetings. They are open and everyone can go and discuss/defend their proposals. Most of the important work is done through these open discussions. The meetings used to be face-to-face full weeks sessions, but with the COVID they became virtual. You can find more information <a href="https://isocpp.org/std/meetings-and-participation">about the meetings and participation here</a>.</p><h2 id="standards-are-released-on-a-schedule">Standards are released on a schedule</h2><p>Since the release of C++11, the committee is dedicated to following a predictable train-like model. The analogy is - luckily - not about <a href="https://www.scaledagileframework.com/">SAFe</a>. It refers to the timetable of trains. Every three years there is a new version to be released. It does not matter how much a fix or a new feature is expected. If it’s not ready when the next train departs, the feature will not be on that train. The train doesn’t wait. The feature missing its train will wait for the next one. It’ll come in 3 years. The original idea was to have every second version packed with new features and the others to include mostly minor additions and bug fixes. The reality hasn’t met this expectation yet as after C+11 the next “major” release was C++20. It’s still to see if C++26 can be a major release. Nevertheless, the train-like model is respected, we have a new release every 3 years. C++11, C++14, C++17, C++20…</p><p>Setting a predictable schedule of release dates into stone is useful to avoid special treatment for certain features that are either highly waited for or that are supported by people with bigger authority over the committee.</p><p>Besides, the schedule also ensures a high level of predictability of the language evolution. While nobody can know what exactly will be included in the next release, we pretty much know when it will be published. If you think about those who are working on compilers and on different toolings, you understand why this matters so much. It further increases the needed predictability that developers working with compilers are widely represented among the committee members.</p><p>At the same time, people might feel that there are too many versions and it’s difficult to keep up to date. This criticism is valid on a certain level. Still, in comparison to Java or Python, it still gives plenty of leeways for us to keep ourselves up to date.</p><h2 id="conclusion">Conclusion</h2><p>In this post, we discussed how the C++ programming language was born around 40 years ago. We saw how after the initial agility it lost a bit the momentum - at least in terms of evolution. C++ is a complex and widely used language and as such it’s governed by a multi-level organization. We saw how that organization is built-up and how the release pipeline is composed.</p><p>Since the release of C++11, the C++ Committee is committed to following a predictable schedule. There are new features and bug fixes released every three years. Thanks to those, C++ is evolving, it is now considered a modern programming language and it’s getting simpler to write correct code.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/standardization/" class="post-tag no-text-decoration" >standardization</a> <a href="/tags/community/" class="post-tag no-text-decoration" >community</a> <a href="/tags/watercooler/" class="post-tag no-text-decoration" >watercooler</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++: standardized - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/06/29/cpp-standardized" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++: standardized - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/06/29/cpp-standardized" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++: standardized - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/06/29/cpp-standardized" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++: standardized - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/06/29/cpp-standardized" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/07/24/5-reasons-not-to-talk-about-politics-at-work"><div class="card-body"> <span class="timeago small" > Jul 24, 2024 <i class="unloaded">2024-07-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5 reasons why politics will ruin your career hopes</h3><div class="text-muted small"><p> I’m not apolitical, I do have my opinion and quite a strong one. Yet, I don’t let it interfere with my job. I don’t think that one should talk about his or her political agenda at work or that one ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/14/learn-cpp-by-frances-buontempo"><div class="card-body"> <span class="timeago small" > Aug 14, 2024 <i class="unloaded">2024-08-14T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Learn C++ by Example by Frances Buontempo</h3><div class="text-muted small"><p> I know Fran from C++ On Sea where she hosted lightning talk nights for the last two years. She recently asked me if I would be interested in reading her book, Learn C++ by Example. It was on my rad...</p></div></div></a></div><div class="card"> <a href="/blog/2024/10/16/cpp-brain-teasers"><div class="card-body"> <span class="timeago small" > Oct 16, 2024 <i class="unloaded">2024-10-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ Brain Teasers by Anders Schau Knatten</h3><div class="text-muted small"><p> I bought C++ Brain Teasers at C++ On Sea where the author also gave a presentation and made a few references to his book. I couldn’t wait to read it. Now that I finally did it, I’d like to share my...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/06/22/bitwise-enums" class="btn btn-outline-primary" prompt="Older"><p>Bitwise enumerations</p></a> <a href="/blog/2022/07/06/lifetime-extension-bughunt" class="btn btn-outline-primary" prompt="Newer"><p>Won't extend it more than once!</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++: standardized'; this.page.url = 'https://www.sandordargo.com/blog/2022/06/29/cpp-standardized'; this.page.identifier = '/blog/2022/06/29/cpp-standardized'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
