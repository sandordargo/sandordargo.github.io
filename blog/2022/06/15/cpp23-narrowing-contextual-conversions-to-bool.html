<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: Narrowing contextual conversions to bool" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the previous article discussing new language features of C++23, we discussed if consteval. Today, we’ll slightly discuss if constexpr and also static_assert. Andrzej Krzemieński proposed a paper to make life a bit easier by allowing a bit more implicit conversions. Allowing a bit more narrowing in some special contexts. A quick recap For someone less experienced with C++, let’s start with recapitulating what the most important concepts of this paper represent. static_assert Something I just learned is that static_assert was introduced by C++11. I personally thought that it was a much older feature. It serves for performing compile-time assertions. It takes two parameters a boolean constant expression a message to be printed by the compiler in case of the boolean expression is false. C++17 made this message optional. With static_assert we can assert the characteristics of types at compiler time (or anything else that is available knowledge at compile time. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;type_traits&gt; class A { public: // uncomment the following line to break the first assertion // virtual ~A() = default; }; int main() { static_assert(std::is_trivial_v&lt;A&gt;, &quot;A is not a trivial type&quot;); static_assert(1 + 1 == 2); } constexpr if if constexpr is a feature introduced in C++17. Based on a constant expression condition, with constexpr if we can select and discard which branch to compile. Take the following example from C++ Reference: 1 2 3 4 5 6 7 8 template&lt;typename T&gt; auto get_value(T t) { if constexpr (std::is_pointer_v&lt;T&gt;) return *t; // deduces return type to int for T = int* else return t; // deduces return type to int for T = int } If T is a pointer, then the template will be instantiated with the first branch and the else part be ignored. In case, it’s a value, the if part will be ignored and the else is kept. if constexpr has been a great addition that helps us simplify SFINAE and whatever code that is using std::enable_if. Narrowing Narrowing is a type of conversion. When that happens the converted value is losing from its precision. Most often it’s something to avoid, just like the Core Guidelienes says in ES.46. Converting a double to an int, a long to an int, etc., are all narrowing conversions where you (potentially) lose data. In the first case, you lose the fractions and in the second, you might already store a number that is bigger than the target type can store. Why would anyone want that implicitly? But converting an int to a bool is also narrowing and that can be useful. When that happens 0 is converted to false, and anything else (including negative numbers) will result in true. Let’s see how the paper wants to change the status quo. What is the paper proposing In fact, the proposal of Andrzej might or might not change anything for you depending on your compiler and its version. On the other hand, it definitely makes the standard compiler compliant. Wait, what? Let’s take the following piece of code. 1 2 3 4 5 6 7 8 template &lt;std::size_t N&gt; class Array { static_assert(N, &quot;no 0-size Arrays&quot;); // ... }; Array&lt;16&gt; a; According to - the pre-paper-acceptance version of - the standard, it should fail to compile because N which is 16 shouldn’t be narrowed to bool. Still, if you compile the code with the major implementations, it will compile without any issue. The paper updates the standard so that it matches this behaviour. The other context where the paper changes the standard is if constexpr. Converting contextually a type to bool is especially useful with enums used as flags. Let’s have a look at the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 enum Flags { Write = 1, Read = 2, Exec = 4 }; template &lt;Flags flags&gt; int f() { if constexpr (flags &amp; Flags::Exec) // should fail to compile due to narrowing return 0; else return 1; } int main() { return f&lt;Flags::Exec&gt;(); // when instantiated like this } As the output of flags &amp; Flags::Exec is an int, according to the standard it shouldn’t be narrowed down to a bool, while the intentions of the coder are evident. Earlier versions of Clang failed to compile this piece of code, you had to cast the condition to bool explicitly. Yet, later versions and all the other major compilers compiled the successfully. There are 2 other cases where the standard speaks about “contextually converted constant expression of type bool“, but the paper doesn’t change the situation for those. For more details on that, check out the paper! Conclusion P1401R5 will not change how we code, it will not or just slightly change how compilers work. But it makes the major compilers compliant with the standard. It aligns the standard with the implemented behaviour and will officially let the compilers perform a narrowing conversion to bool in the contexts of a static_assert or if constexpr. Now we can avoid explicitly casting expressions to bool in these contexts without guilt. Thank you, Andrzej! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In the previous article discussing new language features of C++23, we discussed if consteval. Today, we’ll slightly discuss if constexpr and also static_assert. Andrzej Krzemieński proposed a paper to make life a bit easier by allowing a bit more implicit conversions. Allowing a bit more narrowing in some special contexts. A quick recap For someone less experienced with C++, let’s start with recapitulating what the most important concepts of this paper represent. static_assert Something I just learned is that static_assert was introduced by C++11. I personally thought that it was a much older feature. It serves for performing compile-time assertions. It takes two parameters a boolean constant expression a message to be printed by the compiler in case of the boolean expression is false. C++17 made this message optional. With static_assert we can assert the characteristics of types at compiler time (or anything else that is available knowledge at compile time. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;type_traits&gt; class A { public: // uncomment the following line to break the first assertion // virtual ~A() = default; }; int main() { static_assert(std::is_trivial_v&lt;A&gt;, &quot;A is not a trivial type&quot;); static_assert(1 + 1 == 2); } constexpr if if constexpr is a feature introduced in C++17. Based on a constant expression condition, with constexpr if we can select and discard which branch to compile. Take the following example from C++ Reference: 1 2 3 4 5 6 7 8 template&lt;typename T&gt; auto get_value(T t) { if constexpr (std::is_pointer_v&lt;T&gt;) return *t; // deduces return type to int for T = int* else return t; // deduces return type to int for T = int } If T is a pointer, then the template will be instantiated with the first branch and the else part be ignored. In case, it’s a value, the if part will be ignored and the else is kept. if constexpr has been a great addition that helps us simplify SFINAE and whatever code that is using std::enable_if. Narrowing Narrowing is a type of conversion. When that happens the converted value is losing from its precision. Most often it’s something to avoid, just like the Core Guidelienes says in ES.46. Converting a double to an int, a long to an int, etc., are all narrowing conversions where you (potentially) lose data. In the first case, you lose the fractions and in the second, you might already store a number that is bigger than the target type can store. Why would anyone want that implicitly? But converting an int to a bool is also narrowing and that can be useful. When that happens 0 is converted to false, and anything else (including negative numbers) will result in true. Let’s see how the paper wants to change the status quo. What is the paper proposing In fact, the proposal of Andrzej might or might not change anything for you depending on your compiler and its version. On the other hand, it definitely makes the standard compiler compliant. Wait, what? Let’s take the following piece of code. 1 2 3 4 5 6 7 8 template &lt;std::size_t N&gt; class Array { static_assert(N, &quot;no 0-size Arrays&quot;); // ... }; Array&lt;16&gt; a; According to - the pre-paper-acceptance version of - the standard, it should fail to compile because N which is 16 shouldn’t be narrowed to bool. Still, if you compile the code with the major implementations, it will compile without any issue. The paper updates the standard so that it matches this behaviour. The other context where the paper changes the standard is if constexpr. Converting contextually a type to bool is especially useful with enums used as flags. Let’s have a look at the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 enum Flags { Write = 1, Read = 2, Exec = 4 }; template &lt;Flags flags&gt; int f() { if constexpr (flags &amp; Flags::Exec) // should fail to compile due to narrowing return 0; else return 1; } int main() { return f&lt;Flags::Exec&gt;(); // when instantiated like this } As the output of flags &amp; Flags::Exec is an int, according to the standard it shouldn’t be narrowed down to a bool, while the intentions of the coder are evident. Earlier versions of Clang failed to compile this piece of code, you had to cast the condition to bool explicitly. Yet, later versions and all the other major compilers compiled the successfully. There are 2 other cases where the standard speaks about “contextually converted constant expression of type bool“, but the paper doesn’t change the situation for those. For more details on that, check out the paper! Conclusion P1401R5 will not change how we code, it will not or just slightly change how compilers work. But it makes the major compilers compliant with the standard. It aligns the standard with the implemented behaviour and will officially let the compilers perform a narrowing conversion to bool in the contexts of a static_assert or if constexpr. Now we can avoid explicitly casting expressions to bool in these contexts without guilt. Thank you, Andrzej! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-06-15T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: Narrowing contextual conversions to bool" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-06-15T00:00:00+02:00","datePublished":"2022-06-15T00:00:00+02:00","description":"In the previous article discussing new language features of C++23, we discussed if consteval. Today, we’ll slightly discuss if constexpr and also static_assert. Andrzej Krzemieński proposed a paper to make life a bit easier by allowing a bit more implicit conversions. Allowing a bit more narrowing in some special contexts. A quick recap For someone less experienced with C++, let’s start with recapitulating what the most important concepts of this paper represent. static_assert Something I just learned is that static_assert was introduced by C++11. I personally thought that it was a much older feature. It serves for performing compile-time assertions. It takes two parameters a boolean constant expression a message to be printed by the compiler in case of the boolean expression is false. C++17 made this message optional. With static_assert we can assert the characteristics of types at compiler time (or anything else that is available knowledge at compile time. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;type_traits&gt; class A { public: // uncomment the following line to break the first assertion // virtual ~A() = default; }; int main() { static_assert(std::is_trivial_v&lt;A&gt;, &quot;A is not a trivial type&quot;); static_assert(1 + 1 == 2); } constexpr if if constexpr is a feature introduced in C++17. Based on a constant expression condition, with constexpr if we can select and discard which branch to compile. Take the following example from C++ Reference: 1 2 3 4 5 6 7 8 template&lt;typename T&gt; auto get_value(T t) { if constexpr (std::is_pointer_v&lt;T&gt;) return *t; // deduces return type to int for T = int* else return t; // deduces return type to int for T = int } If T is a pointer, then the template will be instantiated with the first branch and the else part be ignored. In case, it’s a value, the if part will be ignored and the else is kept. if constexpr has been a great addition that helps us simplify SFINAE and whatever code that is using std::enable_if. Narrowing Narrowing is a type of conversion. When that happens the converted value is losing from its precision. Most often it’s something to avoid, just like the Core Guidelienes says in ES.46. Converting a double to an int, a long to an int, etc., are all narrowing conversions where you (potentially) lose data. In the first case, you lose the fractions and in the second, you might already store a number that is bigger than the target type can store. Why would anyone want that implicitly? But converting an int to a bool is also narrowing and that can be useful. When that happens 0 is converted to false, and anything else (including negative numbers) will result in true. Let’s see how the paper wants to change the status quo. What is the paper proposing In fact, the proposal of Andrzej might or might not change anything for you depending on your compiler and its version. On the other hand, it definitely makes the standard compiler compliant. Wait, what? Let’s take the following piece of code. 1 2 3 4 5 6 7 8 template &lt;std::size_t N&gt; class Array { static_assert(N, &quot;no 0-size Arrays&quot;); // ... }; Array&lt;16&gt; a; According to - the pre-paper-acceptance version of - the standard, it should fail to compile because N which is 16 shouldn’t be narrowed to bool. Still, if you compile the code with the major implementations, it will compile without any issue. The paper updates the standard so that it matches this behaviour. The other context where the paper changes the standard is if constexpr. Converting contextually a type to bool is especially useful with enums used as flags. Let’s have a look at the following example: 1 2 3 4 5 6 7 8 9 10 11 12 13 enum Flags { Write = 1, Read = 2, Exec = 4 }; template &lt;Flags flags&gt; int f() { if constexpr (flags &amp; Flags::Exec) // should fail to compile due to narrowing return 0; else return 1; } int main() { return f&lt;Flags::Exec&gt;(); // when instantiated like this } As the output of flags &amp; Flags::Exec is an int, according to the standard it shouldn’t be narrowed down to a bool, while the intentions of the coder are evident. Earlier versions of Clang failed to compile this piece of code, you had to cast the condition to bool explicitly. Yet, later versions and all the other major compilers compiled the successfully. There are 2 other cases where the standard speaks about “contextually converted constant expression of type bool“, but the paper doesn’t change the situation for those. For more details on that, check out the paper! Conclusion P1401R5 will not change how we code, it will not or just slightly change how compilers work. But it makes the major compilers compliant with the standard. It aligns the standard with the implemented behaviour and will officially let the compilers perform a narrowing conversion to bool in the contexts of a static_assert or if constexpr. Now we can avoid explicitly casting expressions to bool in these contexts without guilt. Thank you, Andrzej! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: Narrowing contextual conversions to bool","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool"},"url":"https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool"}</script><title>C++23: Narrowing contextual conversions to bool | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/06"> 06 </a> </span> <span> <a href="/15"> 15 </a> </span> <span>C++23: Narrowing contextual conversions to bool</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: Narrowing contextual conversions to bool</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jun 15, 2022, 12:00 AM +0200" prep="on" > Jun 15, 2022 <i class="unloaded">2022-06-15T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="875 words">4 min</span></div></div><div class="post-content"><p>In the previous article discussing new language features of C++23, <a href="https://www.sandordargo.com/blog/2022/06/01/cpp23-if-consteval">we discussed <code class="language-plaintext highlighter-rouge">if consteval</code></a>. Today, we’ll slightly discuss <code class="language-plaintext highlighter-rouge">if constexpr</code> and also <code class="language-plaintext highlighter-rouge">static_assert</code>. Andrzej Krzemieński proposed a paper to make life a bit easier by allowing a bit more implicit conversions. Allowing a bit more narrowing in some special contexts.</p><h2 id="a-quick-recap">A quick recap</h2><p>For someone less experienced with C++, let’s start with recapitulating what the most important concepts of this paper represent.</p><h3 id="static_assert"><code class="language-plaintext highlighter-rouge">static_assert</code></h3><p>Something I just learned is that <code class="language-plaintext highlighter-rouge">static_assert</code> was introduced by C++11. I personally thought that it was a much older feature. It serves for performing compile-time assertions. It takes two parameters</p><ul><li>a boolean constant expression<li>a message to be printed by the compiler in case of the boolean expression is <code class="language-plaintext highlighter-rouge">false</code>. C++17 made this message optional.</ul><p>With <code class="language-plaintext highlighter-rouge">static_assert</code> we can assert the characteristics of types at compiler time (or anything else that is available knowledge at compile time.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
<span class="c1">// uncomment the following line to break the first assertion</span>
<span class="c1">// virtual ~A() = default;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivial_v</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">,</span> <span class="s">"A is not a trivial type"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span> <span class="o">==</span> <span class="mi">2</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="constexpr-if">constexpr if</h3><p><code class="language-plaintext highlighter-rouge">if constexpr</code> is a feature introduced in C++17. Based on a constant expression condition, with <em>constexpr if</em> we can select and discard which branch to compile.</p><p>Take the following example from <a href="https://en.cppreference.com/w/cpp/language/if">C++ Reference</a>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">get_value</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_pointer_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">*</span><span class="n">t</span><span class="p">;</span> <span class="c1">// deduces return type to int for T = int*</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">;</span>  <span class="c1">// deduces return type to int for T = int</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If <code class="language-plaintext highlighter-rouge">T</code> is a pointer, then the <code class="language-plaintext highlighter-rouge">template</code> will be instantiated with the first branch and the <code class="language-plaintext highlighter-rouge">else</code> part be ignored. In case, it’s a value, the <code class="language-plaintext highlighter-rouge">if</code> part will be ignored and the <code class="language-plaintext highlighter-rouge">else</code> is kept. <code class="language-plaintext highlighter-rouge">if constexpr</code> has been a great addition that helps us simplify SFINAE and whatever code that is using <code class="language-plaintext highlighter-rouge">std::enable_if</code>.</p><h3 id="narrowing">Narrowing</h3><p>Narrowing is a type of conversion. When that happens the converted value is losing from its precision. Most often it’s something to avoid, just like <a href="http://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Res-narrowing">the Core Guidelienes says in ES.46</a>.</p><p>Converting a <code class="language-plaintext highlighter-rouge">double</code> to an <code class="language-plaintext highlighter-rouge">int</code>, a <code class="language-plaintext highlighter-rouge">long</code> to an <code class="language-plaintext highlighter-rouge">int</code>, etc., are all narrowing conversions where you (potentially) lose data. In the first case, you lose the fractions and in the second, you might already store a number that is bigger than the target type can store.</p><p>Why would anyone want that implicitly?</p><p>But converting an <code class="language-plaintext highlighter-rouge">int</code> to a <code class="language-plaintext highlighter-rouge">bool</code> is also narrowing and that can be useful. When that happens <code class="language-plaintext highlighter-rouge">0</code> is converted to <code class="language-plaintext highlighter-rouge">false</code>, and anything else (including negative numbers) will result in <code class="language-plaintext highlighter-rouge">true</code>.</p><p>Let’s see how <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1401r5.html">the paper</a> wants to change the status quo.</p><h2 id="what-is-the-paper-proposing">What is the paper proposing</h2><p>In fact, the proposal of Andrzej might or might not change anything for you depending on your compiler and its version. On the other hand, it definitely makes the standard compiler compliant.</p><p>Wait, what?</p><p>Let’s take the following piece of code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">N</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Array</span>
<span class="p">{</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">N</span><span class="p">,</span> <span class="s">"no 0-size Arrays"</span><span class="p">);</span>
  <span class="c1">// ...</span>
<span class="p">};</span>

<span class="n">Array</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>
</pre></table></code></div></div><p>According to - the pre-paper-acceptance version of - the standard, it should fail to compile because <code class="language-plaintext highlighter-rouge">N</code> which is 16 shouldn’t be narrowed to <code class="language-plaintext highlighter-rouge">bool</code>. Still, if you compile the code with the major implementations, it will compile without any issue.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1401r5.html">The paper</a> updates the standard so that it matches this behaviour.</p><p>The other context where the paper changes the standard is <code class="language-plaintext highlighter-rouge">if constexpr</code>. Converting contextually a type to bool is especially useful with enums used as flags. Let’s have a look at the following example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Flags</span> <span class="p">{</span> <span class="n">Write</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Read</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">Exec</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">Flags</span> <span class="n">flags</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">flags</span> <span class="o">&amp;</span> <span class="n">Flags</span><span class="o">::</span><span class="n">Exec</span><span class="p">)</span> <span class="c1">// should fail to compile due to narrowing</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">f</span><span class="o">&lt;</span><span class="n">Flags</span><span class="o">::</span><span class="n">Exec</span><span class="o">&gt;</span><span class="p">();</span> <span class="c1">// when instantiated like this</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As the output of <code class="language-plaintext highlighter-rouge">flags &amp; Flags::Exec</code> is an <code class="language-plaintext highlighter-rouge">int</code>, according to the standard it shouldn’t be narrowed down to a <code class="language-plaintext highlighter-rouge">bool</code>, while the intentions of the coder are evident.</p><p>Earlier versions of Clang failed to compile this piece of code, you had to cast the condition to bool explicitly. Yet, later versions and all the other major compilers compiled the successfully.</p><p>There are 2 other cases where the standard speaks about <em>“contextually converted constant expression of type <code class="language-plaintext highlighter-rouge">bool</code>“</em>, but the paper doesn’t change the situation for those. For more details on that, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1401r5.html">check out the paper</a>!</p><h2 id="conclusion">Conclusion</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1401r5.html">P1401R5</a> will not change how we code, it will not or just slightly change how compilers work. But it makes the major compilers compliant with the standard. It aligns the standard with the implemented behaviour and will officially let the compilers perform a narrowing conversion to <code class="language-plaintext highlighter-rouge">bool</code> in the contexts of a <code class="language-plaintext highlighter-rouge">static_assert</code> or <code class="language-plaintext highlighter-rouge">if constexpr</code>. Now we can avoid explicitly casting expressions to bool in these contexts without guilt. Thank you, Andrzej!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/conversions/" class="post-tag no-text-decoration" >conversions</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: Narrowing contextual conversions to bool - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: Narrowing contextual conversions to bool - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: Narrowing contextual conversions to bool - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: Narrowing contextual conversions to bool - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/06/11/evolution-of-cooperation" class="btn btn-outline-primary" prompt="Older"><p>The Evolution of Cooperation by Robert Axelrod</p></a> <a href="/blog/2022/06/22/bitwise-enums" class="btn btn-outline-primary" prompt="Newer"><p>Bitwise enumerations</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: Narrowing contextual conversions to bool'; this.page.url = 'https://www.sandordargo.com/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool'; this.page.identifier = '/blog/2022/06/15/cpp23-narrowing-contextual-conversions-to-bool'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
