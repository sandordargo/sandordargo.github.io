<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Class templates versus constructor templates" /><meta property="og:locale" content="en_US" /><meta name="description" content="I realized that this simple but important difference should be covered twice during the last year. Once when I wrote about how shared and unique pointers take their deleters, and once when I read Template Metaprogramming with C++ by Marius Bancila. Class templates A class template serves as a blueprint for creating a class. The relationship is similar to that of a class and an instance. You (optionally) pass in a certain number of parameters to create an instance of a class. In the case of a class template, you pass in a certain amount of types to create a class. Defining a class template is straightforward. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; template &lt;typename T&gt; class ClassTemplateWithRegularConstructor { public: ClassTemplateWithRegularConstructor(T data); T getData() const; private: T m_data; }; template&lt;typename T&gt; ClassTemplateWithRegularConstructor&lt;T&gt;::ClassTemplateWithRegularConstructor(T data) : m_data(data) {} template&lt;typename T&gt; T ClassTemplateWithRegularConstructor&lt;T&gt;::getData() const { return m_data; } int main() { ClassTemplateWithRegularConstructor&lt;int&gt; a{42}; std::cout &lt;&lt; a.getData() &lt;&lt; &#39;\n&#39;; } We define the template parameter on a class level and then we can use it throughout the class. Unless it can be deduced, you have to define it at instantiation time. What is also important to note is that for each function definition that takes place outside of the class, you must type template &lt;typename T&gt; and you have to list the template parameters after the class name. Constructor templates Just as it’s possible to write class templates, we can write function templates. But what about the special functions? Is it possible to templatize them? It’s not possible to templatize the destructor as it doesn’t take any parameter and there can be only one destructor in a class - unless you use concepts to constrain them. But it’s totally possible to have a constructor template - even without having a class template. The syntax is simple. Instead of using the usual template syntax on the class, you apply it to the constructor. 1 2 3 4 5 6 7 8 class RegularClassWithConstructorTemplate { public: template&lt;typename T&gt; RegularClassWithConstructorTemplate(T data) { std::cout &lt;&lt; &quot;RegularClassWithConstructorTemplate called with &quot; &lt;&lt; data &lt;&lt; &#39;\n&#39;; } private: }; The important difference to keep in mind is that the template type T cannot be used outside the constructor. So how to use it then? Convert types with a constructor template You might want to convert some value of any type to a certain type that you store then. To have it more effective, you might want to even constrain the accepted types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;concepts&gt; #include &lt;string&gt; template&lt;typename T&gt; concept HasToString = requires (T t) { { t.to_string() } -&gt; std::same_as&lt;std::string&gt;; }; template &lt;typename T&gt; concept ConvertableToString = std::constructible_from&lt;std::string, T&gt;; class RegularClassWithConstructorTemplate { public: template&lt;std::integral T&gt; RegularClassWithConstructorTemplate(T number) : m_text(std::to_string(number)) {} template&lt;HasToString T&gt; RegularClassWithConstructorTemplate(T input) : m_text(input.to_string()) {} template&lt;ConvertableToString T&gt; RegularClassWithConstructorTemplate(T input) : m_text(std::string(input)) {} private: std::string m_text; }; class Wrapper { public: Wrapper(int data) : m_data(data) {} std::string to_string() const { return std::to_string(m_data); } private: int m_data; }; int main() { RegularClassWithConstructorTemplate ct1{Wrapper{42}}; RegularClassWithConstructorTemplate ct2{&quot;c-string&quot;}; RegularClassWithConstructorTemplate ct3{41}; } In the above example, we provided 3 different constrained constructors to take care of the conversion of the input parameter. We could simplify these constructors, using the abbrevieated function template syntax, completely removing the template keywords. No matter the syntax, the constructors would still remain templated ones. 1 2 3 4 5 RegularClassWithConstructorTemplate(std::integral number) : m_text(std::to_string(number)) {} RegularClassWithConstructorTemplate(HasToString input) : m_text(input.to_string()) {} RegularClassWithConstructorTemplate(ConvertableToString input) : m_text(std::string(input)) {} Use a constructor template with a nested class template Another occasion to use a constructor template without a class template is when you need to use the type parameter with an internal class template that inherits from a non-template class. With the help of the non-template base type, you can store a reference or pointer of the templatized child without relying on the type parameter. I know this might be a bit overwhelming. In other words, you have to use such a constructor template in the type erasure design patterns. Let’s see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;memory&gt; #include &lt;vector&gt; struct Shape { template &lt;typename T&gt; Shape(T&amp;&amp; obj) : m_shape(std::make_shared&lt;ShapeModel&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj))) {} void rotate() { m_shape-&gt;rotate(); } struct ShapeConcept { virtual void rotate() = 0; virtual ~ShapeConcept() = default; }; template &lt;typename T&gt; struct ShapeModel : public ShapeConcept { ShapeModel(T&amp; shape) : t(shape) {} void rotate() override { t.rotate(); } private: T&amp; t; }; private: std::shared_ptr&lt;ShapeConcept&gt; m_shape; }; void rotate(std::vector&lt;Shape&gt;&amp; shapes) { for (auto&amp; shape : shapes) { shape.rotate(); } } int main() {} There can be different implementations of the type erasure design pattern, I borrowed this one from Template Metaprogramming with C++ by Marius Bancila. Another day, we’ll dig deeper in the topic. So in this example, we can see how the template constructor’s template parameter is used to instantiate the internal class template ShapeModel which inherits from the non-class template ShapeConcept. As ShapeConcept is not templatized, we can (only) store a non-template pointer to ShapeConcept, pointing to a ShapeModel&lt;T&gt;. Conclusion In this article, we saw that we cannot only write class templates, but we can also write classes which are not templatized, yet their constructors are templates. We saw that we can use a constructor template to provide different conversions for inputs and that it’s also useful if we have a nested class template that inherits from a non-template base. How and why do you use constructor templates? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I realized that this simple but important difference should be covered twice during the last year. Once when I wrote about how shared and unique pointers take their deleters, and once when I read Template Metaprogramming with C++ by Marius Bancila. Class templates A class template serves as a blueprint for creating a class. The relationship is similar to that of a class and an instance. You (optionally) pass in a certain number of parameters to create an instance of a class. In the case of a class template, you pass in a certain amount of types to create a class. Defining a class template is straightforward. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; template &lt;typename T&gt; class ClassTemplateWithRegularConstructor { public: ClassTemplateWithRegularConstructor(T data); T getData() const; private: T m_data; }; template&lt;typename T&gt; ClassTemplateWithRegularConstructor&lt;T&gt;::ClassTemplateWithRegularConstructor(T data) : m_data(data) {} template&lt;typename T&gt; T ClassTemplateWithRegularConstructor&lt;T&gt;::getData() const { return m_data; } int main() { ClassTemplateWithRegularConstructor&lt;int&gt; a{42}; std::cout &lt;&lt; a.getData() &lt;&lt; &#39;\n&#39;; } We define the template parameter on a class level and then we can use it throughout the class. Unless it can be deduced, you have to define it at instantiation time. What is also important to note is that for each function definition that takes place outside of the class, you must type template &lt;typename T&gt; and you have to list the template parameters after the class name. Constructor templates Just as it’s possible to write class templates, we can write function templates. But what about the special functions? Is it possible to templatize them? It’s not possible to templatize the destructor as it doesn’t take any parameter and there can be only one destructor in a class - unless you use concepts to constrain them. But it’s totally possible to have a constructor template - even without having a class template. The syntax is simple. Instead of using the usual template syntax on the class, you apply it to the constructor. 1 2 3 4 5 6 7 8 class RegularClassWithConstructorTemplate { public: template&lt;typename T&gt; RegularClassWithConstructorTemplate(T data) { std::cout &lt;&lt; &quot;RegularClassWithConstructorTemplate called with &quot; &lt;&lt; data &lt;&lt; &#39;\n&#39;; } private: }; The important difference to keep in mind is that the template type T cannot be used outside the constructor. So how to use it then? Convert types with a constructor template You might want to convert some value of any type to a certain type that you store then. To have it more effective, you might want to even constrain the accepted types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;concepts&gt; #include &lt;string&gt; template&lt;typename T&gt; concept HasToString = requires (T t) { { t.to_string() } -&gt; std::same_as&lt;std::string&gt;; }; template &lt;typename T&gt; concept ConvertableToString = std::constructible_from&lt;std::string, T&gt;; class RegularClassWithConstructorTemplate { public: template&lt;std::integral T&gt; RegularClassWithConstructorTemplate(T number) : m_text(std::to_string(number)) {} template&lt;HasToString T&gt; RegularClassWithConstructorTemplate(T input) : m_text(input.to_string()) {} template&lt;ConvertableToString T&gt; RegularClassWithConstructorTemplate(T input) : m_text(std::string(input)) {} private: std::string m_text; }; class Wrapper { public: Wrapper(int data) : m_data(data) {} std::string to_string() const { return std::to_string(m_data); } private: int m_data; }; int main() { RegularClassWithConstructorTemplate ct1{Wrapper{42}}; RegularClassWithConstructorTemplate ct2{&quot;c-string&quot;}; RegularClassWithConstructorTemplate ct3{41}; } In the above example, we provided 3 different constrained constructors to take care of the conversion of the input parameter. We could simplify these constructors, using the abbrevieated function template syntax, completely removing the template keywords. No matter the syntax, the constructors would still remain templated ones. 1 2 3 4 5 RegularClassWithConstructorTemplate(std::integral number) : m_text(std::to_string(number)) {} RegularClassWithConstructorTemplate(HasToString input) : m_text(input.to_string()) {} RegularClassWithConstructorTemplate(ConvertableToString input) : m_text(std::string(input)) {} Use a constructor template with a nested class template Another occasion to use a constructor template without a class template is when you need to use the type parameter with an internal class template that inherits from a non-template class. With the help of the non-template base type, you can store a reference or pointer of the templatized child without relying on the type parameter. I know this might be a bit overwhelming. In other words, you have to use such a constructor template in the type erasure design patterns. Let’s see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;memory&gt; #include &lt;vector&gt; struct Shape { template &lt;typename T&gt; Shape(T&amp;&amp; obj) : m_shape(std::make_shared&lt;ShapeModel&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj))) {} void rotate() { m_shape-&gt;rotate(); } struct ShapeConcept { virtual void rotate() = 0; virtual ~ShapeConcept() = default; }; template &lt;typename T&gt; struct ShapeModel : public ShapeConcept { ShapeModel(T&amp; shape) : t(shape) {} void rotate() override { t.rotate(); } private: T&amp; t; }; private: std::shared_ptr&lt;ShapeConcept&gt; m_shape; }; void rotate(std::vector&lt;Shape&gt;&amp; shapes) { for (auto&amp; shape : shapes) { shape.rotate(); } } int main() {} There can be different implementations of the type erasure design pattern, I borrowed this one from Template Metaprogramming with C++ by Marius Bancila. Another day, we’ll dig deeper in the topic. So in this example, we can see how the template constructor’s template parameter is used to instantiate the internal class template ShapeModel which inherits from the non-class template ShapeConcept. As ShapeConcept is not templatized, we can (only) store a non-template pointer to ShapeConcept, pointing to a ShapeModel&lt;T&gt;. Conclusion In this article, we saw that we cannot only write class templates, but we can also write classes which are not templatized, yet their constructors are templates. We saw that we can use a constructor template to provide different conversions for inputs and that it’s also useful if we have a nested class template that inherits from a non-template base. How and why do you use constructor templates? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-12-21T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Class templates versus constructor templates" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-19T06:34:24+01:00","datePublished":"2022-12-21T00:00:00+01:00","description":"I realized that this simple but important difference should be covered twice during the last year. Once when I wrote about how shared and unique pointers take their deleters, and once when I read Template Metaprogramming with C++ by Marius Bancila. Class templates A class template serves as a blueprint for creating a class. The relationship is similar to that of a class and an instance. You (optionally) pass in a certain number of parameters to create an instance of a class. In the case of a class template, you pass in a certain amount of types to create a class. Defining a class template is straightforward. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; template &lt;typename T&gt; class ClassTemplateWithRegularConstructor { public: ClassTemplateWithRegularConstructor(T data); T getData() const; private: T m_data; }; template&lt;typename T&gt; ClassTemplateWithRegularConstructor&lt;T&gt;::ClassTemplateWithRegularConstructor(T data) : m_data(data) {} template&lt;typename T&gt; T ClassTemplateWithRegularConstructor&lt;T&gt;::getData() const { return m_data; } int main() { ClassTemplateWithRegularConstructor&lt;int&gt; a{42}; std::cout &lt;&lt; a.getData() &lt;&lt; &#39;\\n&#39;; } We define the template parameter on a class level and then we can use it throughout the class. Unless it can be deduced, you have to define it at instantiation time. What is also important to note is that for each function definition that takes place outside of the class, you must type template &lt;typename T&gt; and you have to list the template parameters after the class name. Constructor templates Just as it’s possible to write class templates, we can write function templates. But what about the special functions? Is it possible to templatize them? It’s not possible to templatize the destructor as it doesn’t take any parameter and there can be only one destructor in a class - unless you use concepts to constrain them. But it’s totally possible to have a constructor template - even without having a class template. The syntax is simple. Instead of using the usual template syntax on the class, you apply it to the constructor. 1 2 3 4 5 6 7 8 class RegularClassWithConstructorTemplate { public: template&lt;typename T&gt; RegularClassWithConstructorTemplate(T data) { std::cout &lt;&lt; &quot;RegularClassWithConstructorTemplate called with &quot; &lt;&lt; data &lt;&lt; &#39;\\n&#39;; } private: }; The important difference to keep in mind is that the template type T cannot be used outside the constructor. So how to use it then? Convert types with a constructor template You might want to convert some value of any type to a certain type that you store then. To have it more effective, you might want to even constrain the accepted types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 #include &lt;concepts&gt; #include &lt;string&gt; template&lt;typename T&gt; concept HasToString = requires (T t) { { t.to_string() } -&gt; std::same_as&lt;std::string&gt;; }; template &lt;typename T&gt; concept ConvertableToString = std::constructible_from&lt;std::string, T&gt;; class RegularClassWithConstructorTemplate { public: template&lt;std::integral T&gt; RegularClassWithConstructorTemplate(T number) : m_text(std::to_string(number)) {} template&lt;HasToString T&gt; RegularClassWithConstructorTemplate(T input) : m_text(input.to_string()) {} template&lt;ConvertableToString T&gt; RegularClassWithConstructorTemplate(T input) : m_text(std::string(input)) {} private: std::string m_text; }; class Wrapper { public: Wrapper(int data) : m_data(data) {} std::string to_string() const { return std::to_string(m_data); } private: int m_data; }; int main() { RegularClassWithConstructorTemplate ct1{Wrapper{42}}; RegularClassWithConstructorTemplate ct2{&quot;c-string&quot;}; RegularClassWithConstructorTemplate ct3{41}; } In the above example, we provided 3 different constrained constructors to take care of the conversion of the input parameter. We could simplify these constructors, using the abbrevieated function template syntax, completely removing the template keywords. No matter the syntax, the constructors would still remain templated ones. 1 2 3 4 5 RegularClassWithConstructorTemplate(std::integral number) : m_text(std::to_string(number)) {} RegularClassWithConstructorTemplate(HasToString input) : m_text(input.to_string()) {} RegularClassWithConstructorTemplate(ConvertableToString input) : m_text(std::string(input)) {} Use a constructor template with a nested class template Another occasion to use a constructor template without a class template is when you need to use the type parameter with an internal class template that inherits from a non-template class. With the help of the non-template base type, you can store a reference or pointer of the templatized child without relying on the type parameter. I know this might be a bit overwhelming. In other words, you have to use such a constructor template in the type erasure design patterns. Let’s see an example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;memory&gt; #include &lt;vector&gt; struct Shape { template &lt;typename T&gt; Shape(T&amp;&amp; obj) : m_shape(std::make_shared&lt;ShapeModel&lt;T&gt;&gt;(std::forward&lt;T&gt;(obj))) {} void rotate() { m_shape-&gt;rotate(); } struct ShapeConcept { virtual void rotate() = 0; virtual ~ShapeConcept() = default; }; template &lt;typename T&gt; struct ShapeModel : public ShapeConcept { ShapeModel(T&amp; shape) : t(shape) {} void rotate() override { t.rotate(); } private: T&amp; t; }; private: std::shared_ptr&lt;ShapeConcept&gt; m_shape; }; void rotate(std::vector&lt;Shape&gt;&amp; shapes) { for (auto&amp; shape : shapes) { shape.rotate(); } } int main() {} There can be different implementations of the type erasure design pattern, I borrowed this one from Template Metaprogramming with C++ by Marius Bancila. Another day, we’ll dig deeper in the topic. So in this example, we can see how the template constructor’s template parameter is used to instantiate the internal class template ShapeModel which inherits from the non-class template ShapeConcept. As ShapeConcept is not templatized, we can (only) store a non-template pointer to ShapeConcept, pointing to a ShapeModel&lt;T&gt;. Conclusion In this article, we saw that we cannot only write class templates, but we can also write classes which are not templatized, yet their constructors are templates. We saw that we can use a constructor template to provide different conversions for inputs and that it’s also useful if we have a nested class template that inherits from a non-template base. How and why do you use constructor templates? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Class templates versus constructor templates","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template"},"url":"https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template"}</script><title>Class templates versus constructor templates | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/21"> 21 </a> </span> <span>Class templates versus constructor templates</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Class templates versus constructor templates</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 21, 2022, 12:00 AM +0100" prep="on" > Dec 21, 2022 <i class="unloaded">2022-12-21T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 19, 2024, 6:34 AM +0100" prefix="Updated " > Dec 19, 2024 <i class="unloaded">2024-12-19T06:34:24+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1004 words">5 min</span></div></div><div class="post-content"><p>I realized that this simple but important difference should be covered twice during the last year. Once when I wrote about <a href="https://www.sandordargo.com/blog/2022/06/08/smart-pointers-and-deleters">how shared and unique pointers take their deleters</a>, and once when I read <a href="https://www.sandordargo.com/blog/2022/10/28/template-metaprogramming-with-cpp-by-marius-bancila">Template Metaprogramming with C++ by Marius Bancila</a>.</p><h2 id="class-templates">Class templates</h2><p>A class template serves as a blueprint for creating a class. The relationship is similar to that of a class and an instance. You (optionally) pass in a certain number of parameters to create an instance of a class. In the case of a class template, you pass in a certain amount of types to create a class.</p><p>Defining a class template is straightforward.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">ClassTemplateWithRegularConstructor</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">ClassTemplateWithRegularConstructor</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">);</span>
  
  <span class="n">T</span> <span class="n">getData</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="nl">private:</span>
  <span class="n">T</span> <span class="n">m_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">ClassTemplateWithRegularConstructor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">ClassTemplateWithRegularConstructor</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="n">T</span> <span class="n">ClassTemplateWithRegularConstructor</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">getData</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_data</span><span class="p">;</span> <span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">ClassTemplateWithRegularConstructor</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">getData</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We define the template parameter on a class level and then we can use it throughout the class. Unless it can be deduced, you have to define it at instantiation time. What is also important to note is that for each function definition that takes place outside of the class, you must type <code class="language-plaintext highlighter-rouge">template &lt;typename T&gt;</code> and you have to list the template parameters after the class name.</p><h2 id="constructor-templates">Constructor templates</h2><p>Just as it’s possible to write class templates, we can write function templates.</p><p>But what about the special functions? Is it possible to templatize them?</p><p>It’s not possible to templatize the destructor as it doesn’t take any parameter and there can be only one destructor in a class - <a href="https://www.sandordargo.com/blog/2021/06/16/multiple-destructors-with-cpp-concepts">unless you use concepts to constrain them</a>. But it’s totally possible to have a constructor template - even without having a class template.</p><p>The syntax is simple. Instead of using the usual template syntax on the class, you apply it to the constructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">RegularClassWithConstructorTemplate</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
  <span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">T</span> <span class="n">data</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"RegularClassWithConstructorTemplate called with "</span> <span class="o">&lt;&lt;</span> <span class="n">data</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The important difference to keep in mind is that the template type <code class="language-plaintext highlighter-rouge">T</code> cannot be used outside the constructor.</p><p>So how to use it then?</p><h2 id="convert-types-with-a-constructor-template">Convert types with a constructor template</h2><p>You might want to convert some value of any type to a certain type that you store then. To have it more effective, you might want to even constrain the accepted types.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> 
<span class="k">concept</span> <span class="n">HasToString</span> <span class="o">=</span> <span class="k">requires</span> <span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">to_string</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">ConvertableToString</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">constructible_from</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">RegularClassWithConstructorTemplate</span> <span class="p">{</span>
<span class="nl">public:</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span> <span class="n">T</span><span class="p">&gt;</span>
  <span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">T</span> <span class="n">number</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">number</span><span class="p">))</span> <span class="p">{}</span>

  <span class="k">template</span><span class="o">&lt;</span><span class="n">HasToString</span> <span class="n">T</span><span class="p">&gt;</span>
  <span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">T</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_text</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span> <span class="p">{}</span>
  
  
  <span class="k">template</span><span class="o">&lt;</span><span class="n">ConvertableToString</span> <span class="n">T</span><span class="p">&gt;</span>
  <span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">T</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">input</span><span class="p">))</span> <span class="p">{}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Wrapper</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Wrapper</span><span class="p">(</span><span class="kt">int</span> <span class="n">data</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_data</span><span class="p">(</span><span class="n">data</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">to_string</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">m_data</span><span class="p">);</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="kt">int</span> <span class="n">m_data</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">RegularClassWithConstructorTemplate</span> <span class="n">ct1</span><span class="p">{</span><span class="n">Wrapper</span><span class="p">{</span><span class="mi">42</span><span class="p">}};</span>
    <span class="n">RegularClassWithConstructorTemplate</span> <span class="n">ct2</span><span class="p">{</span><span class="s">"c-string"</span><span class="p">};</span>
    <span class="n">RegularClassWithConstructorTemplate</span> <span class="n">ct3</span><span class="p">{</span><span class="mi">41</span><span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the above example, we provided 3 different constrained constructors to take care of the conversion of the input parameter.</p><p>We could simplify these constructors, using the <a href="https://www.sandordargo.com/blog/2021/02/17/cpp-concepts-4-ways-to-use-them">abbrevieated function template syntax</a>, completely removing the <code class="language-plaintext highlighter-rouge">template</code> keywords. No matter the syntax, the constructors would still remain templated ones.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">integral</span> <span class="n">number</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">number</span><span class="p">))</span> <span class="p">{}</span>

<span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">HasToString</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_text</span><span class="p">(</span><span class="n">input</span><span class="p">.</span><span class="n">to_string</span><span class="p">())</span> <span class="p">{}</span>
  
<span class="n">RegularClassWithConstructorTemplate</span><span class="p">(</span><span class="n">ConvertableToString</span> <span class="n">input</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_text</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="n">input</span><span class="p">))</span> <span class="p">{}</span>
</pre></table></code></div></div><h2 id="use-a-constructor-template-with-a-nested-class-template">Use a constructor template with a nested class template</h2><p>Another occasion to use a constructor template without a class template is when you need to use the type parameter with an internal class template that inherits from a non-template class. With the help of the non-template base type, you can store a reference or pointer of the templatized child without relying on the type parameter.</p><p>I know this might be a bit overwhelming.</p><p>In other words, you have to use such a constructor template in the type erasure design patterns.</p><p>Let’s see an example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Shape</span> <span class="p">{</span>
   <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
   <span class="n">Shape</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">obj</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">m_shape</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">ShapeModel</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">obj</span><span class="p">)))</span> <span class="p">{}</span>
   
   <span class="kt">void</span> <span class="nf">rotate</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">m_shape</span><span class="o">-&gt;</span><span class="n">rotate</span><span class="p">();</span>
   <span class="p">}</span>
   
   <span class="k">struct</span> <span class="nc">ShapeConcept</span> <span class="p">{</span>
      <span class="k">virtual</span> <span class="kt">void</span> <span class="n">rotate</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">ShapeConcept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
   <span class="k">struct</span> <span class="nc">ShapeModel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ShapeConcept</span> <span class="p">{</span>
      <span class="n">ShapeModel</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">shape</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span><span class="p">(</span><span class="n">shape</span><span class="p">)</span> <span class="p">{}</span>
      
      <span class="kt">void</span> <span class="nf">rotate</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="n">t</span><span class="p">.</span><span class="n">rotate</span><span class="p">();</span> <span class="p">}</span>
     <span class="k">private</span><span class="o">:</span>
      <span class="n">T</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">};</span>
<span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">ShapeConcept</span><span class="o">&gt;</span> <span class="n">m_shape</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Shape</span><span class="o">&gt;&amp;</span> <span class="n">shapes</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">shape</span> <span class="o">:</span> <span class="n">shapes</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">shape</span><span class="p">.</span><span class="n">rotate</span><span class="p">();</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>There can be different implementations of the type erasure design pattern, I borrowed this one from <a href="https://www.sandordargo.com/blog/2022/10/28/template-metaprogramming-with-cpp-by-marius-bancila">Template Metaprogramming with C++ by Marius Bancila</a>. Another day, we’ll dig deeper in the topic.</p><p>So in this example, we can see how the template constructor’s template parameter is used to instantiate the internal class template <code class="language-plaintext highlighter-rouge">ShapeModel</code> which inherits from the non-class template <code class="language-plaintext highlighter-rouge">ShapeConcept</code>. As <code class="language-plaintext highlighter-rouge">ShapeConcept</code> is not templatized, we can (only) store a non-template pointer to <code class="language-plaintext highlighter-rouge">ShapeConcept</code>, pointing to a <code class="language-plaintext highlighter-rouge">ShapeModel&lt;T&gt;</code>.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we saw that we cannot only write class templates, but we can also write classes which are not templatized, yet their constructors are templates. We saw that we can use a constructor template to provide different conversions for inputs and that it’s also useful if we have a nested class template that inherits from a non-template base.</p><p>How and why do you use constructor templates?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/templates/" class="post-tag no-text-decoration" >templates</a> <a href="/tags/tmp/" class="post-tag no-text-decoration" >tmp</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Class templates versus constructor templates - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Class templates versus constructor templates - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Class templates versus constructor templates - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Class templates versus constructor templates - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/05/03/variadic-functions-vs-variadic-templates"><div class="card-body"> <span class="timeago small" > May 3, 2023 <i class="unloaded">2023-05-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Variadic functions vs variadic templates</h3><div class="text-muted small"><p> A few months ago, I wrote a review on Template Metaprogramming with C++ by Marius Bancila where I mentioned not only that it’s a great book, but also that there are some topics which I’ll cover mo...</p></div></div></a></div><div class="card"> <a href="/blog/2021/04/07/what-are-type-traits"><div class="card-body"> <span class="timeago small" > Apr 7, 2021 <i class="unloaded">2021-04-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What are type traits?</h3><div class="text-muted small"><p> Let’s start with a more generic question, what is a trait? What does the word trait mean? According to the Cambridge Dictionary, a trait is “a particular characteristic that can produce a particu...</p></div></div></a></div><div class="card"> <a href="/blog/2021/06/02/different-ways-to-achieve-SFINAE"><div class="card-body"> <span class="timeago small" > Jun 2, 2021 <i class="unloaded">2021-06-02T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Different ways to achieve SFINAE</h3><div class="text-muted small"><p> Life is a chain of opportunities. Each task you take on will lead you to more doors hiding other opportunities. Some are worth opening, some are not. Proofreading C++20: Get the Details by Rainer...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/12/17/cpp-software-design-by-klaus-iglberger" class="btn btn-outline-primary" prompt="Older"><p>C++ Software Design by Klaus Iglberger</p></a> <a href="/blog/2022/12/28/2022-on-the-balance" class="btn btn-outline-primary" prompt="Newer"><p>2022: Another great year!</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Class templates versus constructor templates'; this.page.url = 'https://www.sandordargo.com/blog/2022/12/21/class-template-vs-class-with-ctor-template'; this.page.identifier = '/blog/2022/12/21/class-template-vs-class-with-ctor-template'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
