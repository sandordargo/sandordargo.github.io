<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: attributes" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++11 introduced attributes. Even though the language itself only came with two ([[noreturn]] and [[carries_dependency]]), it also provided the unified standard syntax for *implementation-defined language extensions/. Ever since that version, each new release brought us some new standard attributes or changes in the ways we can use them. The list of changes continues with C++23. Three papers affect attributes. Duplications will not be punished anymore, their usage with lambdas evolves and there is also a new standard attribute [[assume]]. Let’s have a deeper look. DR: Allow Duplicate Attributes So far the standard didn’t allow that an attribute such as [[nodiscard]] appear more than once in an attribute list. Wait? Isn’t that a good thing? You might ask these questions, and that’s exactly what I asked myself when I saw this DR proposal. When you see DR in a proposal title, it means that it’s a remediation for a “defect report” that was filed against the standard. Defining the same attribute more than once is not a good practice. It’s something you shouldn’t do as a developer. But according to the paper P2156R1, it can happen that a macro-based solution generates the same attribute more than once. Specifying that attributes shouldn’t appear more than once is a constraint for such a solution. At the same time, it doesn’t make standardization easier. On the contrary, removing this constraint, makes the standard easier! So far, it was specified for each standard attribute that “it shall appear at most once in each attribute list”. From now on, they can and that constraint is removed from the text. Attributes on lambdas After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types. The attributes sequence belongs to the type of the corresponding function call operator. The paper P2173R1 argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator. After all, why couldn’t the operator and with that almost always the lambda be [[nodiscard]], [[noreturn]] or [[deprecated]]? According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause. The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a [[nodiscard]] attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones. With this change, the following piece of code becomes valid, where the function call of the operator is [[nodiscard]]: 1 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; Meaning that this would emit a warning: 1 2 3 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; // ... lm(); // warning: ignoring return value of &#39;main()::&lt;lambda()&gt;&#39;, declared with attribute &#39;nodiscard&#39; [-Wunused-result] Please note that GCC and Clang already implemented this behaviour, GCC already in version 9! Attribute [[assume]] The new attribute [[assume]] is the standardized version of some already existing compiler-specific attributes, such as __assume() (MSVC, ICC) and __builtin_assume() (Clang). With their help, the programmer can signal to the compiler that an expression will be true without the compiler having to evaluate it. On gcc, an alternative was not available, so probably that’s why they are the first, who implemented the standardized [[assume]] in version 13. If you want to emulate the same functionality before you have to use if(expr) {} else {__builtin_unreachable();}. As such, the compiler can generate more efficient, faster code. This can bring significant benefits in some high-performance, low-latency explications. It’s syntax is [[assume(expr)]]. It’s worth noting that the expression is not evaluated. Which is a change compared to the gcc simulation, but is the same as how clang and msvc already worked. The accepted paper brings us quite a few examples when and how to use [[assume]]. The first one is an example from audio processing, and it uses information that is commonly known by the developers, but it’s not represented in the code: 1 2 3 4 5 6 7 8 9 void limiter(float* data, size_t size) { [[assume(size &gt; 0)]]; [[assume(size % 32 == 0)]]; for (size_t i = 0; i &lt; size; ++i) { [[assume(std::isfinite(data[i])]]; data[i] = std::clamp(data[i], -1.0f, 1.0f); } } I first overlooked the first assumption, but Thief in the comments and Julien in an e-mail gently pointed out my mistake. The first assumption is that the parameter size will never be zero, but it will always be a positive number! The second example hints to the compiler that the passed in size will always be the multiple of 32 and with the last assumption, we even tell that the data is not NaN or infinity. In another example, the copy constructor of a reference counting shared pointer got the assumption, that the refcount is already at least one. Makes sense, it’s a copy constructor. This could also help the compiler to ignore some increments and decrements and avoid destroying the owned resource when the passed in smart pointer’s lifecycle ends. Interestingly, it didn’t lead to great optimizations on some of the compilers. So I’d say, measure, measure and measure before you assume some gains. On most compilers, this leads to a significant performance increase (for the details, please check paper P1774R8. But what if an assumption does not hold true? It’s important to emphasize that assumptions are not evaluated! They are not checked! Instead, the compiler assumes that the expression would evaluate to true and optimize accordingly. If the assumption does not hold, so if the assumption returns false, throws an exception or if it’s UB, the behaviour will be undefined. Use it with care. Conclusion C++23 brings 3 changes to attributes. The restriction that an attribute cannot be duplicated is removed now. Attributes can be used with lambdas in a way that it belongs to the function call operator from now on, not to the lambda itself. Last but least, we get a new standard attribute [[assume]] to ease compiler optimizations. Do you often use attributes? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="C++11 introduced attributes. Even though the language itself only came with two ([[noreturn]] and [[carries_dependency]]), it also provided the unified standard syntax for *implementation-defined language extensions/. Ever since that version, each new release brought us some new standard attributes or changes in the ways we can use them. The list of changes continues with C++23. Three papers affect attributes. Duplications will not be punished anymore, their usage with lambdas evolves and there is also a new standard attribute [[assume]]. Let’s have a deeper look. DR: Allow Duplicate Attributes So far the standard didn’t allow that an attribute such as [[nodiscard]] appear more than once in an attribute list. Wait? Isn’t that a good thing? You might ask these questions, and that’s exactly what I asked myself when I saw this DR proposal. When you see DR in a proposal title, it means that it’s a remediation for a “defect report” that was filed against the standard. Defining the same attribute more than once is not a good practice. It’s something you shouldn’t do as a developer. But according to the paper P2156R1, it can happen that a macro-based solution generates the same attribute more than once. Specifying that attributes shouldn’t appear more than once is a constraint for such a solution. At the same time, it doesn’t make standardization easier. On the contrary, removing this constraint, makes the standard easier! So far, it was specified for each standard attribute that “it shall appear at most once in each attribute list”. From now on, they can and that constraint is removed from the text. Attributes on lambdas After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types. The attributes sequence belongs to the type of the corresponding function call operator. The paper P2173R1 argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator. After all, why couldn’t the operator and with that almost always the lambda be [[nodiscard]], [[noreturn]] or [[deprecated]]? According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause. The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a [[nodiscard]] attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones. With this change, the following piece of code becomes valid, where the function call of the operator is [[nodiscard]]: 1 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; Meaning that this would emit a warning: 1 2 3 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; // ... lm(); // warning: ignoring return value of &#39;main()::&lt;lambda()&gt;&#39;, declared with attribute &#39;nodiscard&#39; [-Wunused-result] Please note that GCC and Clang already implemented this behaviour, GCC already in version 9! Attribute [[assume]] The new attribute [[assume]] is the standardized version of some already existing compiler-specific attributes, such as __assume() (MSVC, ICC) and __builtin_assume() (Clang). With their help, the programmer can signal to the compiler that an expression will be true without the compiler having to evaluate it. On gcc, an alternative was not available, so probably that’s why they are the first, who implemented the standardized [[assume]] in version 13. If you want to emulate the same functionality before you have to use if(expr) {} else {__builtin_unreachable();}. As such, the compiler can generate more efficient, faster code. This can bring significant benefits in some high-performance, low-latency explications. It’s syntax is [[assume(expr)]]. It’s worth noting that the expression is not evaluated. Which is a change compared to the gcc simulation, but is the same as how clang and msvc already worked. The accepted paper brings us quite a few examples when and how to use [[assume]]. The first one is an example from audio processing, and it uses information that is commonly known by the developers, but it’s not represented in the code: 1 2 3 4 5 6 7 8 9 void limiter(float* data, size_t size) { [[assume(size &gt; 0)]]; [[assume(size % 32 == 0)]]; for (size_t i = 0; i &lt; size; ++i) { [[assume(std::isfinite(data[i])]]; data[i] = std::clamp(data[i], -1.0f, 1.0f); } } I first overlooked the first assumption, but Thief in the comments and Julien in an e-mail gently pointed out my mistake. The first assumption is that the parameter size will never be zero, but it will always be a positive number! The second example hints to the compiler that the passed in size will always be the multiple of 32 and with the last assumption, we even tell that the data is not NaN or infinity. In another example, the copy constructor of a reference counting shared pointer got the assumption, that the refcount is already at least one. Makes sense, it’s a copy constructor. This could also help the compiler to ignore some increments and decrements and avoid destroying the owned resource when the passed in smart pointer’s lifecycle ends. Interestingly, it didn’t lead to great optimizations on some of the compilers. So I’d say, measure, measure and measure before you assume some gains. On most compilers, this leads to a significant performance increase (for the details, please check paper P1774R8. But what if an assumption does not hold true? It’s important to emphasize that assumptions are not evaluated! They are not checked! Instead, the compiler assumes that the expression would evaluate to true and optimize accordingly. If the assumption does not hold, so if the assumption returns false, throws an exception or if it’s UB, the behaviour will be undefined. Use it with care. Conclusion C++23 brings 3 changes to attributes. The restriction that an attribute cannot be duplicated is removed now. Attributes can be used with lambdas in a way that it belongs to the function call operator from now on, not to the lambda itself. Last but least, we get a new standard attribute [[assume]] to ease compiler optimizations. Do you often use attributes? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-12-14T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: attributes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-12-14T19:56:19+01:00","datePublished":"2022-12-14T00:00:00+01:00","description":"C++11 introduced attributes. Even though the language itself only came with two ([[noreturn]] and [[carries_dependency]]), it also provided the unified standard syntax for *implementation-defined language extensions/. Ever since that version, each new release brought us some new standard attributes or changes in the ways we can use them. The list of changes continues with C++23. Three papers affect attributes. Duplications will not be punished anymore, their usage with lambdas evolves and there is also a new standard attribute [[assume]]. Let’s have a deeper look. DR: Allow Duplicate Attributes So far the standard didn’t allow that an attribute such as [[nodiscard]] appear more than once in an attribute list. Wait? Isn’t that a good thing? You might ask these questions, and that’s exactly what I asked myself when I saw this DR proposal. When you see DR in a proposal title, it means that it’s a remediation for a “defect report” that was filed against the standard. Defining the same attribute more than once is not a good practice. It’s something you shouldn’t do as a developer. But according to the paper P2156R1, it can happen that a macro-based solution generates the same attribute more than once. Specifying that attributes shouldn’t appear more than once is a constraint for such a solution. At the same time, it doesn’t make standardization easier. On the contrary, removing this constraint, makes the standard easier! So far, it was specified for each standard attribute that “it shall appear at most once in each attribute list”. From now on, they can and that constraint is removed from the text. Attributes on lambdas After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types. The attributes sequence belongs to the type of the corresponding function call operator. The paper P2173R1 argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator. After all, why couldn’t the operator and with that almost always the lambda be [[nodiscard]], [[noreturn]] or [[deprecated]]? According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause. The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a [[nodiscard]] attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones. With this change, the following piece of code becomes valid, where the function call of the operator is [[nodiscard]]: 1 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; Meaning that this would emit a warning: 1 2 3 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; // ... lm(); // warning: ignoring return value of &#39;main()::&lt;lambda()&gt;&#39;, declared with attribute &#39;nodiscard&#39; [-Wunused-result] Please note that GCC and Clang already implemented this behaviour, GCC already in version 9! Attribute [[assume]] The new attribute [[assume]] is the standardized version of some already existing compiler-specific attributes, such as __assume() (MSVC, ICC) and __builtin_assume() (Clang). With their help, the programmer can signal to the compiler that an expression will be true without the compiler having to evaluate it. On gcc, an alternative was not available, so probably that’s why they are the first, who implemented the standardized [[assume]] in version 13. If you want to emulate the same functionality before you have to use if(expr) {} else {__builtin_unreachable();}. As such, the compiler can generate more efficient, faster code. This can bring significant benefits in some high-performance, low-latency explications. It’s syntax is [[assume(expr)]]. It’s worth noting that the expression is not evaluated. Which is a change compared to the gcc simulation, but is the same as how clang and msvc already worked. The accepted paper brings us quite a few examples when and how to use [[assume]]. The first one is an example from audio processing, and it uses information that is commonly known by the developers, but it’s not represented in the code: 1 2 3 4 5 6 7 8 9 void limiter(float* data, size_t size) { [[assume(size &gt; 0)]]; [[assume(size % 32 == 0)]]; for (size_t i = 0; i &lt; size; ++i) { [[assume(std::isfinite(data[i])]]; data[i] = std::clamp(data[i], -1.0f, 1.0f); } } I first overlooked the first assumption, but Thief in the comments and Julien in an e-mail gently pointed out my mistake. The first assumption is that the parameter size will never be zero, but it will always be a positive number! The second example hints to the compiler that the passed in size will always be the multiple of 32 and with the last assumption, we even tell that the data is not NaN or infinity. In another example, the copy constructor of a reference counting shared pointer got the assumption, that the refcount is already at least one. Makes sense, it’s a copy constructor. This could also help the compiler to ignore some increments and decrements and avoid destroying the owned resource when the passed in smart pointer’s lifecycle ends. Interestingly, it didn’t lead to great optimizations on some of the compilers. So I’d say, measure, measure and measure before you assume some gains. On most compilers, this leads to a significant performance increase (for the details, please check paper P1774R8. But what if an assumption does not hold true? It’s important to emphasize that assumptions are not evaluated! They are not checked! Instead, the compiler assumes that the expression would evaluate to true and optimize accordingly. If the assumption does not hold, so if the assumption returns false, throws an exception or if it’s UB, the behaviour will be undefined. Use it with care. Conclusion C++23 brings 3 changes to attributes. The restriction that an attribute cannot be duplicated is removed now. Attributes can be used with lambdas in a way that it belongs to the function call operator from now on, not to the lambda itself. Last but least, we get a new standard attribute [[assume]] to ease compiler optimizations. Do you often use attributes? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: attributes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes"},"url":"https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes"}</script><title>C++23: attributes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/14"> 14 </a> </span> <span>C++23: attributes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: attributes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 14, 2022, 12:00 AM +0100" prep="on" > Dec 14, 2022 <i class="unloaded">2022-12-14T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 14, 2022, 7:56 PM +0100" prefix="Updated " > Dec 14, 2022 <i class="unloaded">2022-12-14T19:56:19+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1117 words">6 min</span></div></div><div class="post-content"><p>C++11 introduced attributes. Even though the language itself only came with two (<code class="language-plaintext highlighter-rouge">[[noreturn]]</code> and <code class="language-plaintext highlighter-rouge">[[carries_dependency]]</code>), it also provided the unified standard syntax for *implementation-defined language extensions/. Ever since that version, each new release brought us some new standard attributes or changes in the ways we can use them.</p><p>The list of changes continues with C++23. Three papers affect attributes. Duplications will not be punished anymore, their usage with lambdas evolves and there is also a new standard attribute <code class="language-plaintext highlighter-rouge">[[assume]]</code>. Let’s have a deeper look.</p><h2 id="dr-allow-duplicate-attributes">DR: Allow Duplicate Attributes</h2><p>So far the standard didn’t allow that an attribute such as <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code> appear more than once in an attribute list.</p><p>Wait? Isn’t that a good thing? You might ask these questions, and that’s exactly what I asked myself when I saw this DR proposal.</p><blockquote><p>When you see <code class="language-plaintext highlighter-rouge">DR</code> in a proposal title, it means that it’s a remediation for a <em>“defect report”</em> that was filed against the standard.</p></blockquote><p>Defining the same attribute more than once is not a good practice. It’s something you shouldn’t do as a developer. But according to the paper <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2156r1.pdf">P2156R1</a>, it can happen that a macro-based solution generates the same attribute more than once.</p><p>Specifying that attributes shouldn’t appear more than once is a constraint for such a solution. At the same time, it doesn’t make standardization easier. On the contrary, removing this constraint, makes the standard easier! So far, it was specified for each standard attribute that <em>“it shall appear at most once in each attribute list”</em>. From now on, they can and that constraint is removed from the text.</p><h2 id="attributes-on-lambdas">Attributes on lambdas</h2><p>After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types.</p><p>The attributes sequence belongs to the <strong>type</strong> of the corresponding function call operator. The paper <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2173r1.pdf">P2173R1</a> argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator.</p><p>After all, why couldn’t the operator and with that almost always the lambda be <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>, <code class="language-plaintext highlighter-rouge">[[noreturn]]</code> or <code class="language-plaintext highlighter-rouge">[[deprecated]]</code>?</p><p>According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause.</p><p>The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code> attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones.</p><p>With <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2173r1.pdf">this change</a>, the following piece of code becomes valid, where the function call of the operator is <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">lm</span> <span class="o">=</span> <span class="p">[][[</span><span class="n">nodiscard</span><span class="p">]]()</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
</pre></table></code></div></div><p>Meaning that this would emit a warning:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">lm</span> <span class="o">=</span> <span class="p">[][[</span><span class="n">nodiscard</span><span class="p">]]()</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
<span class="c1">// ...</span>
<span class="n">lm</span><span class="p">();</span> <span class="c1">// warning: ignoring return value of 'main()::&lt;lambda()&gt;', declared with attribute 'nodiscard' [-Wunused-result]</span>
</pre></table></code></div></div><p>Please note that GCC and Clang already implemented this behaviour, GCC already in version 9!</p><h2 id="attribute-assume">Attribute <code class="language-plaintext highlighter-rouge">[[assume]]</code></h2><p>The new attribute <code class="language-plaintext highlighter-rouge">[[assume]]</code> is the standardized version of some already existing compiler-specific attributes, such as <code class="language-plaintext highlighter-rouge">__assume()</code> (MSVC, ICC) and <code class="language-plaintext highlighter-rouge">__builtin_assume()</code> (Clang). With their help, the programmer can signal to the compiler that an expression will be true without the compiler having to evaluate it.</p><blockquote><p>On gcc, an alternative was not available, so probably that’s why they are the first, who implemented the standardized <code class="language-plaintext highlighter-rouge">[[assume]]</code> in version 13. If you want to emulate the same functionality before you have to use <code class="language-plaintext highlighter-rouge">if(expr) {} else {__builtin_unreachable();}</code>.</p></blockquote><p>As such, the compiler can generate more efficient, faster code. This can bring significant benefits in some high-performance, low-latency explications.</p><p>It’s syntax is <code class="language-plaintext highlighter-rouge">[[assume(expr)]]</code>. It’s worth noting that the expression is not evaluated. Which is a change compared to the gcc simulation, but is the same as how clang and msvc already worked.</p><p>The <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1774r8.pdf">accepted paper</a> brings us quite a few examples when and how to use <code class="language-plaintext highlighter-rouge">[[assume]]</code>. The first one is an example from audio processing, and it uses information that is commonly known by the developers, but it’s not represented in the code:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">limiter</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">data</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">[[</span><span class="n">assume</span><span class="p">(</span><span class="n">size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)]];</span>
    <span class="p">[[</span><span class="n">assume</span><span class="p">(</span><span class="n">size</span> <span class="o">%</span> <span class="mi">32</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)]];</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">[[</span><span class="n">assume</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isfinite</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">])]];</span>
        <span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">clamp</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="o">-</span><span class="mf">1.0f</span><span class="p">,</span> <span class="mf">1.0f</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>I first overlooked the first assumption, but Thief in the comments and Julien in an e-mail gently pointed out my mistake. The first assumption is that the parameter <code class="language-plaintext highlighter-rouge">size</code> will never be zero, but it will always be a positive number!</p><p>The second example hints to the compiler that the passed in size will always be the multiple of 32 and with the last assumption, we even tell that the data is not <em>NaN</em> or <em>infinity</em>.</p><p>In another example, the copy constructor of a reference counting shared pointer got the assumption, that the refcount is already at least one. Makes sense, it’s a copy constructor. This could also help the compiler to ignore some increments and decrements and avoid destroying the owned resource when the passed in smart pointer’s lifecycle ends. Interestingly, it didn’t lead to great optimizations on some of the compilers.</p><p>So I’d say, measure, measure and measure before you assume some gains.</p><p>On most compilers, this leads to a significant performance increase (for the details, please check paper <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1774r8.pdf">P1774R8</a>.</p><p>But what if an assumption does not hold true?</p><p>It’s important to emphasize that assumptions are not evaluated! They are not checked! Instead, the compiler assumes that the expression <strong>would</strong> evaluate to true and optimize accordingly. If the assumption does not hold, so if the assumption returns false, throws an exception or if it’s UB, the behaviour will be undefined. Use it with care.</p><h2 id="conclusion">Conclusion</h2><p>C++23 brings 3 changes to attributes. The restriction that an attribute cannot be duplicated is removed now. Attributes can be used with lambdas in a way that it belongs to the function call operator from now on, not to the lambda itself. Last but least, we get a new standard attribute <code class="language-plaintext highlighter-rouge">[[assume]]</code> to ease compiler optimizations.</p><p>Do you often use attributes?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/attributes/" class="post-tag no-text-decoration" >attributes</a> <a href="/tags/lambdas/" class="post-tag no-text-decoration" >lambdas</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: attributes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: attributes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: attributes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: attributes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/05/29/cpp23-chrono"><div class="card-body"> <span class="timeago small" > May 29, 2024 <i class="unloaded">2024-05-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: chrono related changes</h3><div class="text-muted small"><p> Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/05/the-limits-of-maybe-unused"><div class="card-body"> <span class="timeago small" > Jun 5, 2024 <i class="unloaded">2024-06-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The limits of `[[maybe_unused]]`</h3><div class="text-muted small"><p> The codebase I work with defines a utility macro called UNUSED. Its implementation is straightforward, it takes a variable (let’s call it x) as a parameter and expands it as ((void)x). The reason w...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr" class="btn btn-outline-primary" prompt="Older"><p>C++23: std::out_ptr and std::inout_ptr</p></a> <a href="/blog/2022/12/17/cpp-software-design-by-klaus-iglberger" class="btn btn-outline-primary" prompt="Newer"><p>C++ Software Design by Klaus Iglberger</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: attributes'; this.page.url = 'https://www.sandordargo.com/blog/2022/12/14/cpp23-attributes'; this.page.identifier = '/blog/2022/12/14/cpp23-attributes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
