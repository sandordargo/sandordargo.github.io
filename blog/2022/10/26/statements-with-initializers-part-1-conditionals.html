<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The evolution of statements with initializers in C++" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the coming two articles, we’ll see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code. In the first - shorter - part, we are going to cover some basics and conditionals and in the second, we’ll discuss loops. But first of all, what’s a statement? According to Wikipedia, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements. Initialization cannot only happen in simple statements, like in an assignment, but also in compound ones. That’s probably not relevant news, but it’s also worth seeing that more and more compound statements offer options to initialize variables. Let’s see their evolution, but let’s have a glimpse of variable initialization first. Declaring a variable and initializing it at the same time The first time I started to learn programming was in elementary school. I was around 9-10 years old. The language we used was Pascal. I don’t remember much of it, but I do remember that we had to declare all the variables on the top of a function. In many cases, you don’t know what value a variable should hold, with what value a variable should be initialized… so you have to modify those variables later on. While sometimes it was possible to initialize the variable, often you could not. Therefore when we take it for granted that we can declare and initialize a variable at the same time, let’s step a bit back and remember that was not always the case. In the past, we didn’t have the possibility of declaring and initializing a variable anywhere in a function (or in a class). I won’t bore you with a so dull example. The good thing about being able to declare and initialize a variable just anywhere is that we can keep scopes smaller, lifetimes shorter - yes, in programming it’s a good thing. Conditionals with initializers Keeping the lifetimes the shortest that is still meaningful is not always evident. C++17 offers a new way both for if-else and switch statements. If statement with initializer If you need a variable that is available only during the scope of a conditional statement, you didn’t have too many choices. If you didn’t want to use it in the condition within, you could obviously create it within the block of the if. But if you needed the same value in the else branch too, you needed to declare it there too. That’s obviously code duplication and our program might have to perform some expensive computations for the initialization. Besides, if the computation has side effects, you might run into extra problems. 1 2 3 4 5 6 7 if (condition) { MyType aVarWithShortScope; //... } else { MyType aVarWithShortScope; //... } So the best thing you can do is to declare the variable right before the if-else block. This will also work if you want to use the value of the variable in the condition. 1 2 3 4 5 6 7 MyType aVarWithShortScope; // now only once if (condition &amp;&amp; aVarWithShortScope.isValid()) { //... } else { //... } With C++17, we can declare new variables between the if keyword and the subsequent code block, between the usual parenthesis, and right before the conditional expression. The new variable does not have to be used within the conditional expression and it is available in all branches of the if-else. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; int getValue() { return 21; // put here random } int main () { if (int val = getValue(); val&lt;10) { std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &#39;\n&#39;; } else if (val &lt; 5) { std::cout &lt;&lt; &quot;val smaller than 5: &quot; &lt;&lt; val &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; &quot;val is bigger than 10: &quot; &lt;&lt; val &lt;&lt; &#39;\n&#39;; } } You are free to declare new variables in any of the else if branches, but they will be accessible only in the following branches, not in the previous ones! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; int getValue() { return 21; } int main () { if (int val = getValue(); val&lt;10) { std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; } else if (int val2 = getValue(); val &lt; 5) { std::cout &lt;&lt; &quot;val smaller than 5: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; &quot;val is bigger than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; } } /* &lt;source&gt;:9:63: error: use of undeclared identifier &#39;val2&#39;; did you mean &#39;val&#39;? std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; ^~~~ val */ This might be completely a no-brainer, but I still found it worth mentioning as the compiler can rearrange the different branches for optimization purposes. Rearrangements do not affect the scope of the variables introduced in else if statements. switch statement with initializer It’s not only ifs that can benefit from initializer statements, but also switch statements. C++17 gave us the possibility to include variable declaration and initializations right before the condition, just like for ifs. It’s a neat way to limit the scope of a variable that we use for the selection. When the role of a variable is only to provide the value for the selection, it’s useful to “officially” limit its scope accordingly. So instead of having: 1 2 3 4 5 6 7 8 9 10 11 12 Foo foo; switch (foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } Now you can write: 1 2 3 4 5 6 7 8 9 10 11 switch (Foo foo; foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } By this time you might get the idea that we could have limited the scope differently by enclosing the declaration and the statement in a code block: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { Foo foo; switch (foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } } Still, it’s obvious that the new way requires less discipline, it’s shorter and it reads better. Conclusion In this article, we saw how C++ evolved in terms of providing conditional statements with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, and make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated. Do you use if/switch statements with initializers? What do you do when you need them but you are stuck on an earlier version? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In the coming two articles, we’ll see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code. In the first - shorter - part, we are going to cover some basics and conditionals and in the second, we’ll discuss loops. But first of all, what’s a statement? According to Wikipedia, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements. Initialization cannot only happen in simple statements, like in an assignment, but also in compound ones. That’s probably not relevant news, but it’s also worth seeing that more and more compound statements offer options to initialize variables. Let’s see their evolution, but let’s have a glimpse of variable initialization first. Declaring a variable and initializing it at the same time The first time I started to learn programming was in elementary school. I was around 9-10 years old. The language we used was Pascal. I don’t remember much of it, but I do remember that we had to declare all the variables on the top of a function. In many cases, you don’t know what value a variable should hold, with what value a variable should be initialized… so you have to modify those variables later on. While sometimes it was possible to initialize the variable, often you could not. Therefore when we take it for granted that we can declare and initialize a variable at the same time, let’s step a bit back and remember that was not always the case. In the past, we didn’t have the possibility of declaring and initializing a variable anywhere in a function (or in a class). I won’t bore you with a so dull example. The good thing about being able to declare and initialize a variable just anywhere is that we can keep scopes smaller, lifetimes shorter - yes, in programming it’s a good thing. Conditionals with initializers Keeping the lifetimes the shortest that is still meaningful is not always evident. C++17 offers a new way both for if-else and switch statements. If statement with initializer If you need a variable that is available only during the scope of a conditional statement, you didn’t have too many choices. If you didn’t want to use it in the condition within, you could obviously create it within the block of the if. But if you needed the same value in the else branch too, you needed to declare it there too. That’s obviously code duplication and our program might have to perform some expensive computations for the initialization. Besides, if the computation has side effects, you might run into extra problems. 1 2 3 4 5 6 7 if (condition) { MyType aVarWithShortScope; //... } else { MyType aVarWithShortScope; //... } So the best thing you can do is to declare the variable right before the if-else block. This will also work if you want to use the value of the variable in the condition. 1 2 3 4 5 6 7 MyType aVarWithShortScope; // now only once if (condition &amp;&amp; aVarWithShortScope.isValid()) { //... } else { //... } With C++17, we can declare new variables between the if keyword and the subsequent code block, between the usual parenthesis, and right before the conditional expression. The new variable does not have to be used within the conditional expression and it is available in all branches of the if-else. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; int getValue() { return 21; // put here random } int main () { if (int val = getValue(); val&lt;10) { std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &#39;\n&#39;; } else if (val &lt; 5) { std::cout &lt;&lt; &quot;val smaller than 5: &quot; &lt;&lt; val &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; &quot;val is bigger than 10: &quot; &lt;&lt; val &lt;&lt; &#39;\n&#39;; } } You are free to declare new variables in any of the else if branches, but they will be accessible only in the following branches, not in the previous ones! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; int getValue() { return 21; } int main () { if (int val = getValue(); val&lt;10) { std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; } else if (int val2 = getValue(); val &lt; 5) { std::cout &lt;&lt; &quot;val smaller than 5: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; &quot;val is bigger than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; } } /* &lt;source&gt;:9:63: error: use of undeclared identifier &#39;val2&#39;; did you mean &#39;val&#39;? std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\n&#39;; ^~~~ val */ This might be completely a no-brainer, but I still found it worth mentioning as the compiler can rearrange the different branches for optimization purposes. Rearrangements do not affect the scope of the variables introduced in else if statements. switch statement with initializer It’s not only ifs that can benefit from initializer statements, but also switch statements. C++17 gave us the possibility to include variable declaration and initializations right before the condition, just like for ifs. It’s a neat way to limit the scope of a variable that we use for the selection. When the role of a variable is only to provide the value for the selection, it’s useful to “officially” limit its scope accordingly. So instead of having: 1 2 3 4 5 6 7 8 9 10 11 12 Foo foo; switch (foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } Now you can write: 1 2 3 4 5 6 7 8 9 10 11 switch (Foo foo; foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } By this time you might get the idea that we could have limited the scope differently by enclosing the declaration and the statement in a code block: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { Foo foo; switch (foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } } Still, it’s obvious that the new way requires less discipline, it’s shorter and it reads better. Conclusion In this article, we saw how C++ evolved in terms of providing conditional statements with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, and make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated. Do you use if/switch statements with initializers? What do you do when you need them but you are stuck on an earlier version? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-10-26T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The evolution of statements with initializers in C++" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-26T00:00:00+02:00","datePublished":"2022-10-26T00:00:00+02:00","description":"In the coming two articles, we’ll see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code. In the first - shorter - part, we are going to cover some basics and conditionals and in the second, we’ll discuss loops. But first of all, what’s a statement? According to Wikipedia, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements. Initialization cannot only happen in simple statements, like in an assignment, but also in compound ones. That’s probably not relevant news, but it’s also worth seeing that more and more compound statements offer options to initialize variables. Let’s see their evolution, but let’s have a glimpse of variable initialization first. Declaring a variable and initializing it at the same time The first time I started to learn programming was in elementary school. I was around 9-10 years old. The language we used was Pascal. I don’t remember much of it, but I do remember that we had to declare all the variables on the top of a function. In many cases, you don’t know what value a variable should hold, with what value a variable should be initialized… so you have to modify those variables later on. While sometimes it was possible to initialize the variable, often you could not. Therefore when we take it for granted that we can declare and initialize a variable at the same time, let’s step a bit back and remember that was not always the case. In the past, we didn’t have the possibility of declaring and initializing a variable anywhere in a function (or in a class). I won’t bore you with a so dull example. The good thing about being able to declare and initialize a variable just anywhere is that we can keep scopes smaller, lifetimes shorter - yes, in programming it’s a good thing. Conditionals with initializers Keeping the lifetimes the shortest that is still meaningful is not always evident. C++17 offers a new way both for if-else and switch statements. If statement with initializer If you need a variable that is available only during the scope of a conditional statement, you didn’t have too many choices. If you didn’t want to use it in the condition within, you could obviously create it within the block of the if. But if you needed the same value in the else branch too, you needed to declare it there too. That’s obviously code duplication and our program might have to perform some expensive computations for the initialization. Besides, if the computation has side effects, you might run into extra problems. 1 2 3 4 5 6 7 if (condition) { MyType aVarWithShortScope; //... } else { MyType aVarWithShortScope; //... } So the best thing you can do is to declare the variable right before the if-else block. This will also work if you want to use the value of the variable in the condition. 1 2 3 4 5 6 7 MyType aVarWithShortScope; // now only once if (condition &amp;&amp; aVarWithShortScope.isValid()) { //... } else { //... } With C++17, we can declare new variables between the if keyword and the subsequent code block, between the usual parenthesis, and right before the conditional expression. The new variable does not have to be used within the conditional expression and it is available in all branches of the if-else. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; int getValue() { return 21; // put here random } int main () { if (int val = getValue(); val&lt;10) { std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &#39;\\n&#39;; } else if (val &lt; 5) { std::cout &lt;&lt; &quot;val smaller than 5: &quot; &lt;&lt; val &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; &quot;val is bigger than 10: &quot; &lt;&lt; val &lt;&lt; &#39;\\n&#39;; } } You are free to declare new variables in any of the else if branches, but they will be accessible only in the following branches, not in the previous ones! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; int getValue() { return 21; } int main () { if (int val = getValue(); val&lt;10) { std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\\n&#39;; } else if (int val2 = getValue(); val &lt; 5) { std::cout &lt;&lt; &quot;val smaller than 5: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; &quot;val is bigger than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\\n&#39;; } } /* &lt;source&gt;:9:63: error: use of undeclared identifier &#39;val2&#39;; did you mean &#39;val&#39;? std::cout &lt;&lt; &quot;val smaller than 10: &quot; &lt;&lt; val &lt;&lt; &quot; &quot; &lt;&lt; val2 &lt;&lt; &#39;\\n&#39;; ^~~~ val */ This might be completely a no-brainer, but I still found it worth mentioning as the compiler can rearrange the different branches for optimization purposes. Rearrangements do not affect the scope of the variables introduced in else if statements. switch statement with initializer It’s not only ifs that can benefit from initializer statements, but also switch statements. C++17 gave us the possibility to include variable declaration and initializations right before the condition, just like for ifs. It’s a neat way to limit the scope of a variable that we use for the selection. When the role of a variable is only to provide the value for the selection, it’s useful to “officially” limit its scope accordingly. So instead of having: 1 2 3 4 5 6 7 8 9 10 11 12 Foo foo; switch (foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } Now you can write: 1 2 3 4 5 6 7 8 9 10 11 switch (Foo foo; foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } By this time you might get the idea that we could have limited the scope differently by enclosing the declaration and the statement in a code block: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 { Foo foo; switch (foo.getValue()) { case 1: //... break; case 2: //... break; case 3: //... break; default: //... break; } } Still, it’s obvious that the new way requires less discipline, it’s shorter and it reads better. Conclusion In this article, we saw how C++ evolved in terms of providing conditional statements with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, and make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated. Do you use if/switch statements with initializers? What do you do when you need them but you are stuck on an earlier version? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The evolution of statements with initializers in C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals"},"url":"https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals"}</script><title>The evolution of statements with initializers in C++ | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/26"> 26 </a> </span> <span>The evolution of statements with initializers in C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The evolution of statements with initializers in C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 26, 2022, 12:00 AM +0200" prep="on" > Oct 26, 2022 <i class="unloaded">2022-10-26T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1246 words">6 min</span></div></div><div class="post-content"><p>In the coming two articles, we’ll see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code.</p><p>In the first - shorter - part, we are going to cover some basics and conditionals and in the second, we’ll discuss loops.</p><p>But first of all, what’s a statement?</p><p><a href="https://en.wikipedia.org/wiki/Statement_(computer_science)">According to Wikipedia</a>, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements.</p><p>Initialization cannot only happen in simple statements, like in an assignment, but also in compound ones. That’s probably not relevant news, but it’s also worth seeing that more and more compound statements offer options to initialize variables.</p><p>Let’s see their evolution, but let’s have a glimpse of variable initialization first.</p><h2 id="declaring-a-variable-and-initializing-it-at-the-same-time">Declaring a variable and initializing it at the same time</h2><p>The first time I started to learn programming was in elementary school. I was around 9-10 years old. The language we used was Pascal. I don’t remember much of it, but I do remember that we had to declare all the variables on the top of a function. In many cases, you don’t know what value a variable should hold, with what value a variable should be initialized… so you have to modify those variables later on.</p><p>While sometimes it was possible to initialize the variable, often you could not.</p><p>Therefore when we take it for granted that we can declare and initialize a variable at the same time, let’s step a bit back and remember that was not always the case. In the past, we didn’t have the possibility of declaring and initializing a variable anywhere in a function (or in a class). I won’t bore you with a so dull example.</p><p>The good thing about being able to declare and initialize a variable just anywhere is that we can keep scopes smaller, lifetimes shorter - yes, in programming it’s a good thing.</p><h2 id="conditionals-with-initializers">Conditionals with initializers</h2><p>Keeping the lifetimes the shortest that is still meaningful is not always evident. C++17 offers a new way both for <code class="language-plaintext highlighter-rouge">if-else</code> and <code class="language-plaintext highlighter-rouge">switch</code> statements.</p><h3 id="if-statement-with-initializer">If statement with initializer</h3><p>If you need a variable that is available only during the scope of a conditional statement, you didn’t have too many choices. If you didn’t want to use it in the condition within, you could obviously create it within the block of the <code class="language-plaintext highlighter-rouge">if</code>. But if you needed the same value in the <code class="language-plaintext highlighter-rouge">else</code> branch too, you needed to declare it there too. That’s obviously code duplication and our program might have to perform some expensive computations for the initialization. Besides, if the computation has side effects, you might run into extra problems.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">condition</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MyType</span> <span class="n">aVarWithShortScope</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">MyType</span> <span class="n">aVarWithShortScope</span><span class="p">;</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>So the best thing you can do is to declare the variable right before the <code class="language-plaintext highlighter-rouge">if-else</code> block. This will also work if you want to use the value of the variable in the condition.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">MyType</span> <span class="n">aVarWithShortScope</span><span class="p">;</span> <span class="c1">// now only once</span>
<span class="k">if</span> <span class="p">(</span><span class="n">condition</span> <span class="o">&amp;&amp;</span> <span class="n">aVarWithShortScope</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
    
    <span class="c1">//...</span>
<span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">//...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With C++17, we can declare new variables between the <code class="language-plaintext highlighter-rouge">if</code> keyword and the subsequent code block, between the usual parenthesis, and right before the conditional expression. The new variable does not have to be used within the conditional expression and it is available in all branches of the <code class="language-plaintext highlighter-rouge">if-else</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">getValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">21</span><span class="p">;</span> <span class="c1">// put here random</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">();</span> <span class="n">val</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val smaller than 10: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">val</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val smaller than 5: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val is bigger than 10: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
</pre></table></code></div></div><p>You are free to declare new variables in any of the <code class="language-plaintext highlighter-rouge">else if</code> branches, but they will be accessible only in the following branches, not in the previous ones!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">getValue</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">21</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">();</span> <span class="n">val</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val smaller than 10: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="kt">int</span> <span class="n">val2</span> <span class="o">=</span> <span class="n">getValue</span><span class="p">();</span> <span class="n">val</span> <span class="o">&lt;</span> <span class="mi">5</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val smaller than 5: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"val is bigger than 10: "</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">val2</span> <span class="o">&lt;&lt;</span>  <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span> 
<span class="p">}</span>
<span class="cm">/*
&lt;source&gt;:9:63: error: use of undeclared identifier 'val2'; did you mean 'val'?
        std::cout &lt;&lt; "val smaller than 10: " &lt;&lt; val &lt;&lt; " " &lt;&lt; val2 &lt;&lt; '\n';
                                                              ^~~~
                                                              val
*/</span>
</pre></table></code></div></div><p>This might be completely a no-brainer, but I still found it worth mentioning as the compiler can rearrange the different branches for optimization purposes. Rearrangements do not affect the scope of the variables introduced in <code class="language-plaintext highlighter-rouge">else if</code> statements.</p><h3 id="switch-statement-with-initializer"><code class="language-plaintext highlighter-rouge">switch</code> statement with initializer</h3><p>It’s not only <code class="language-plaintext highlighter-rouge">if</code>s that can benefit from initializer statements, but also <code class="language-plaintext highlighter-rouge">switch</code> statements. C++17 gave us the possibility to include variable declaration and initializations right before the condition, just like for <code class="language-plaintext highlighter-rouge">if</code>s. It’s a neat way to limit the scope of a variable that we use for the selection. When the role of a variable is only to provide the value for the selection, it’s useful to “officially” limit its scope accordingly.</p><p>So instead of having:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">getValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
            <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now you can write:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">switch</span> <span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span> <span class="n">foo</span><span class="p">.</span><span class="n">getValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="nl">default:</span>
            <span class="c1">//...</span>
            <span class="k">break</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>By this time you might get the idea that we could have limited the scope differently by enclosing the declaration and the statement in a code block:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="p">{</span>
    <span class="n">Foo</span> <span class="n">foo</span><span class="p">;</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">foo</span><span class="p">.</span><span class="n">getValue</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">case</span> <span class="mi">1</span><span class="p">:</span> <span class="c1">//...</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">2</span><span class="p">:</span> <span class="c1">//...</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="mi">3</span><span class="p">:</span> <span class="c1">//...</span>
                <span class="k">break</span><span class="p">;</span>
        <span class="nl">default:</span>
                <span class="c1">//...</span>
                <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Still, it’s obvious that the new way requires less discipline, it’s shorter and it reads better.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we saw how C++ evolved in terms of providing conditional statements with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, and make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated.</p><p>Do you use <code class="language-plaintext highlighter-rouge">if</code>/<code class="language-plaintext highlighter-rouge">switch</code> statements with initializers? What do you do when you need them but you are stuck on an earlier version?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/if/" class="post-tag no-text-decoration" >if</a> <a href="/tags/switch/" class="post-tag no-text-decoration" >switch</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The evolution of statements with initializers in C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The evolution of statements with initializers in C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The evolution of statements with initializers in C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The evolution of statements with initializers in C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/10/initializations-part-1"><div class="card-body"> <span class="timeago small" > Apr 10, 2024 <i class="unloaded">2024-04-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 1</h3><div class="text-muted small"><p> Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/10/19/last-days-at-amadeus-after-nine-years" class="btn btn-outline-primary" prompt="Older"><p>I'm leaving Amadeus after 9 years</p></a> <a href="/blog/2022/10/28/template-metaprogramming-with-cpp-by-marius-bancila" class="btn btn-outline-primary" prompt="Newer"><p>Template Metaprogramming with C++ by Marius Bancila</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The evolution of statements with initializers in C++'; this.page.url = 'https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals'; this.page.identifier = '/blog/2022/10/26/statements-with-initializers-part-1-conditionals'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
