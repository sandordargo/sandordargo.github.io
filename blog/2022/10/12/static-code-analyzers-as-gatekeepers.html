<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Should you use static code analyzers as gatekeepers?" /><meta property="og:locale" content="en_US" /><meta name="description" content="With the Code Insights plugin of Bitbucket, we have the possibility to make static code analyzers (from on SCAs) a gatekeeper for pull requests. Meaning that if a code analyzer reports certain kinds of issues, it can block pull requests from getting merged. While first, it sounds like a helpful idea, let’s see whether it’s realistic and whether it helps improve quality or prevents improvements. The motivation behind High-quality code is still not the norm among coders and it’s especially not recognized among stakeholders as a necessity for delivering durable software. Even though defining quality, in particular software quality, is a difficult task and many disagree on whether clean code should be considered part of software quality, I strongly believe it should. The definition of CISQ enumerates 4 elements that are part of structural software quality: security reliability maintainability performance efficiency Clean code is not part of the four points, but it clearly helps achieve maintainability and reliability. Even those who are not in favour of clean code would agree that it results in code that is easier to read. Something that is easier to read and easier to understand is simply more maintainable. If you combine clean code with Test-Driven Development, you’ll end up with fewer bugs that further increases the maintainability and also the reliability of software. Static code analysers with their recommendations on removing bugs, code smells and vulnerability issues are useful tools to deliver more correct, more clean and more maintainable code. Sadly, code quality is often sacrificed by both developers and management in order to move forward faster. Even when a static code analyzer is turned on and the scan results are pushed to the pull requests, developers often ignore fixing the reported issues. It’s slightly better when at least they comment on them and write why they don’t fix them. Considering that, making fixing the issues mandatory is an understandable approach to avoid the negligence of developers and therefore increase code quality. Potential issues Delivering code that is as clean and as free of bugs and code smells as possible is of course desirable. Making an SCA a gatekeeper still raises some questions. Let’s enumerate the potential issues introduced by an SCA as a gatekeeper. Rules or recommendations? Most SCAs clearly call their policies rules, not guidelines or recommendations. As the set of enforced rules is configurable, it makes sense. You either adhere to some rules or not. It’s your choice. At the same time, having rules does not mean that they are always applicable. Static code analysis is not an easy and straightforward task and the rules are not complete or perfect. There are cases where rules are useful in a given context, but in another, they might even go against best practices. For example, having a default case in a switch statement might be enforced by an SCA rule and it probably makes sense when you switch over an integer value. On the other hand, when the switch is combined with an enum, deliberately deleting the default and introducing instead a runtime exception as Matt Godbolt suggested and treating warnings as errors is part of compile-time enforcement of dealing with all the different enum values. Having informally discussed this with some engineers working on an SCA product, they are also aware of some inconsistencies, they are actually trying to make switch related rules better and they’d advise using rules as guidelines On the very same rules, other senior engineers said that they met cases when they explicitly didn’t want to break the compilation when a new value is given to an enum, even if that new value is not handled everywhere. Obviously, this was only one example, we can easily find others. In some cases, even an SCA asks the developer to “verify” whether a reported issue is a real issue or not. Sometimes it’s just a potential problem, but not necessarily a real one. Blocking based on such is clearly not acceptable. Blocking incremental improvements Having a clean SCA report is obviously something we prefer, but it’s not always realistic. Such an expectation makes gradual improvements too difficult. Imagine the following use case. Bob sees a badly named variable. Maybe the variable name is simply not meaningful enough, or maybe it’s using a pattern that makes an SCA cry. Bob updates the name and creates a pull request. Imagine that the mentioned variable was a non-private class member. For example, Sonar will raise an issue mentioning that. What should we do? Should we silence that error? Definitely not. That’s something we want to fix but it might require more time and effort. Should we make Bob run errands to report somehow that this is an old issue and should be ignored? Maybe. But does anyone think that Bob will raise any other improvement if reporting on something takes more time than the improvement he made? Should we keep updating the pull request until all the old issues related to the improvements are fixed? That’s probably fine for devs, but it’s hard to imagine any sane product owner supporting this idea… Blocking meaningful organization of changes When teams take time for housekeeping and dedicate some time to clean up the codebase from SCA issues they have many different ways to get organized - if they get organized at all. One meaningful way is that everyone gets a module or a repository to work on and a given rule. It can be for example that someone has to use in-class member initialization when possible. If the member declaration has other issues, such as using a reserved name, shadowing another one or if it’s just not private, the developer with the best intentions in mind cannot merge a code quality improvement without additional efforts. Blocking delivery of new versions It can easily happen that a new feature or a bugfix will require touching a line which has some rule violations. Or maybe the line violated no rules in the past, but new rules have been added and it’s not clear anymore. It might be something easy to fix and in such cases, an immediate fix is usually preferable, sometimes it’s not possible. Either not possible at all due to some strange 3rd party APIs, or it’s not possible easily. In the former case, it makes sense to mark it as an exception and it should be rare, but in the latter case, the developer is just being blocked to deliver without additional hassle even when the delivered code is not responsible for any new SCA issues. Lack of trust Using a static code analyzer with a complex set of rules as a gatekeeper also shows a lack of trust toward developers. “We, project managers, don’t trust you guys on the line that you can deliver high-quality code, we don’t trust that you can make a good judgement based on the analysis you’re given. We don’t trust that code reviewers will do a thorough job and block any PR with any meaningful outstanding static code analyzer warnings.” I see the following vital counterarguments. A failing unit/integration test can also block a pull request and we accept such “tooling”. While it’s completely true, a failing test indicates a functional failure was directly introduced by developers and they can delete or fix it in case it’s considered a faulty test. There are cases when the development teams don’t consider such warnings and they deliver low-quality code. That’s true. Developers rarely enjoy such situations and they do deliver low-quality code because they are either pushed to deliver too much by their management or because their level of experience is not adequate and the ratio of junior/senior developers is unhealthy. Neither of those reasons will be fixed by tooling, it’ll only add additional frustration both for the developers and the management. Developers will see that meeting the unrealistic expectations becomes even more difficult and management will see a further decreased output. Software engineers disapprove this solution I discussed this topic with several engineers who are dedicated to high code quality, and I found nobody who liked the idea of introducing SCAs as gatekeepers. I talked to 3 groups of developers Senior engineers who are responsible for setting the company-wide C++ Coding Guidelines Mostly senior engineers at an C++ On Sea Engineers from a company delivering static code analyzers While I found literally no one thinking that using an SCA as a gatekeeper is a good idea, many despised the idea of using one in the first place. They were not against higher quality though! They preferred turning on more and more compiler warnings and using sanitizers coming with major compilers, such as the address sanitizer, the undefined behaviour sanitizer and the memory sanitizer. I was a bit surprised but also reassured that even engineers working on SCAs don’t think it’s a good idea to use their products as gatekeepers. After all, it makes sense, they have a better view of the above troubles. Conclusion Static code analyzers are useful tools to spot certain code smells or even bugs with its own limitations. Rules might not be complete or might not be applicable in several circumstances. While the idea behind using SCA reports as gatekeeper is benign, the road to hell is paved with good intentions. Using a tool as a gatekeeper degrading developer judgement (or making its expression way too cumbersome) will reduce incremental improvements to the codebase which is exactly the opposite of the original intentions. At the same time, it will make it more difficult to integrate new features on time. While it will presumably drive down the introduction of new issues in unhealthy teams, it will increase frustration and distrust everywhere. SCA reports should be kept what they are. An input for engineers to make educated decisions. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter! Special thanks to my Patreon Supporter: Piotr Fusik." /><meta property="og:description" content="With the Code Insights plugin of Bitbucket, we have the possibility to make static code analyzers (from on SCAs) a gatekeeper for pull requests. Meaning that if a code analyzer reports certain kinds of issues, it can block pull requests from getting merged. While first, it sounds like a helpful idea, let’s see whether it’s realistic and whether it helps improve quality or prevents improvements. The motivation behind High-quality code is still not the norm among coders and it’s especially not recognized among stakeholders as a necessity for delivering durable software. Even though defining quality, in particular software quality, is a difficult task and many disagree on whether clean code should be considered part of software quality, I strongly believe it should. The definition of CISQ enumerates 4 elements that are part of structural software quality: security reliability maintainability performance efficiency Clean code is not part of the four points, but it clearly helps achieve maintainability and reliability. Even those who are not in favour of clean code would agree that it results in code that is easier to read. Something that is easier to read and easier to understand is simply more maintainable. If you combine clean code with Test-Driven Development, you’ll end up with fewer bugs that further increases the maintainability and also the reliability of software. Static code analysers with their recommendations on removing bugs, code smells and vulnerability issues are useful tools to deliver more correct, more clean and more maintainable code. Sadly, code quality is often sacrificed by both developers and management in order to move forward faster. Even when a static code analyzer is turned on and the scan results are pushed to the pull requests, developers often ignore fixing the reported issues. It’s slightly better when at least they comment on them and write why they don’t fix them. Considering that, making fixing the issues mandatory is an understandable approach to avoid the negligence of developers and therefore increase code quality. Potential issues Delivering code that is as clean and as free of bugs and code smells as possible is of course desirable. Making an SCA a gatekeeper still raises some questions. Let’s enumerate the potential issues introduced by an SCA as a gatekeeper. Rules or recommendations? Most SCAs clearly call their policies rules, not guidelines or recommendations. As the set of enforced rules is configurable, it makes sense. You either adhere to some rules or not. It’s your choice. At the same time, having rules does not mean that they are always applicable. Static code analysis is not an easy and straightforward task and the rules are not complete or perfect. There are cases where rules are useful in a given context, but in another, they might even go against best practices. For example, having a default case in a switch statement might be enforced by an SCA rule and it probably makes sense when you switch over an integer value. On the other hand, when the switch is combined with an enum, deliberately deleting the default and introducing instead a runtime exception as Matt Godbolt suggested and treating warnings as errors is part of compile-time enforcement of dealing with all the different enum values. Having informally discussed this with some engineers working on an SCA product, they are also aware of some inconsistencies, they are actually trying to make switch related rules better and they’d advise using rules as guidelines On the very same rules, other senior engineers said that they met cases when they explicitly didn’t want to break the compilation when a new value is given to an enum, even if that new value is not handled everywhere. Obviously, this was only one example, we can easily find others. In some cases, even an SCA asks the developer to “verify” whether a reported issue is a real issue or not. Sometimes it’s just a potential problem, but not necessarily a real one. Blocking based on such is clearly not acceptable. Blocking incremental improvements Having a clean SCA report is obviously something we prefer, but it’s not always realistic. Such an expectation makes gradual improvements too difficult. Imagine the following use case. Bob sees a badly named variable. Maybe the variable name is simply not meaningful enough, or maybe it’s using a pattern that makes an SCA cry. Bob updates the name and creates a pull request. Imagine that the mentioned variable was a non-private class member. For example, Sonar will raise an issue mentioning that. What should we do? Should we silence that error? Definitely not. That’s something we want to fix but it might require more time and effort. Should we make Bob run errands to report somehow that this is an old issue and should be ignored? Maybe. But does anyone think that Bob will raise any other improvement if reporting on something takes more time than the improvement he made? Should we keep updating the pull request until all the old issues related to the improvements are fixed? That’s probably fine for devs, but it’s hard to imagine any sane product owner supporting this idea… Blocking meaningful organization of changes When teams take time for housekeeping and dedicate some time to clean up the codebase from SCA issues they have many different ways to get organized - if they get organized at all. One meaningful way is that everyone gets a module or a repository to work on and a given rule. It can be for example that someone has to use in-class member initialization when possible. If the member declaration has other issues, such as using a reserved name, shadowing another one or if it’s just not private, the developer with the best intentions in mind cannot merge a code quality improvement without additional efforts. Blocking delivery of new versions It can easily happen that a new feature or a bugfix will require touching a line which has some rule violations. Or maybe the line violated no rules in the past, but new rules have been added and it’s not clear anymore. It might be something easy to fix and in such cases, an immediate fix is usually preferable, sometimes it’s not possible. Either not possible at all due to some strange 3rd party APIs, or it’s not possible easily. In the former case, it makes sense to mark it as an exception and it should be rare, but in the latter case, the developer is just being blocked to deliver without additional hassle even when the delivered code is not responsible for any new SCA issues. Lack of trust Using a static code analyzer with a complex set of rules as a gatekeeper also shows a lack of trust toward developers. “We, project managers, don’t trust you guys on the line that you can deliver high-quality code, we don’t trust that you can make a good judgement based on the analysis you’re given. We don’t trust that code reviewers will do a thorough job and block any PR with any meaningful outstanding static code analyzer warnings.” I see the following vital counterarguments. A failing unit/integration test can also block a pull request and we accept such “tooling”. While it’s completely true, a failing test indicates a functional failure was directly introduced by developers and they can delete or fix it in case it’s considered a faulty test. There are cases when the development teams don’t consider such warnings and they deliver low-quality code. That’s true. Developers rarely enjoy such situations and they do deliver low-quality code because they are either pushed to deliver too much by their management or because their level of experience is not adequate and the ratio of junior/senior developers is unhealthy. Neither of those reasons will be fixed by tooling, it’ll only add additional frustration both for the developers and the management. Developers will see that meeting the unrealistic expectations becomes even more difficult and management will see a further decreased output. Software engineers disapprove this solution I discussed this topic with several engineers who are dedicated to high code quality, and I found nobody who liked the idea of introducing SCAs as gatekeepers. I talked to 3 groups of developers Senior engineers who are responsible for setting the company-wide C++ Coding Guidelines Mostly senior engineers at an C++ On Sea Engineers from a company delivering static code analyzers While I found literally no one thinking that using an SCA as a gatekeeper is a good idea, many despised the idea of using one in the first place. They were not against higher quality though! They preferred turning on more and more compiler warnings and using sanitizers coming with major compilers, such as the address sanitizer, the undefined behaviour sanitizer and the memory sanitizer. I was a bit surprised but also reassured that even engineers working on SCAs don’t think it’s a good idea to use their products as gatekeepers. After all, it makes sense, they have a better view of the above troubles. Conclusion Static code analyzers are useful tools to spot certain code smells or even bugs with its own limitations. Rules might not be complete or might not be applicable in several circumstances. While the idea behind using SCA reports as gatekeeper is benign, the road to hell is paved with good intentions. Using a tool as a gatekeeper degrading developer judgement (or making its expression way too cumbersome) will reduce incremental improvements to the codebase which is exactly the opposite of the original intentions. At the same time, it will make it more difficult to integrate new features on time. While it will presumably drive down the introduction of new issues in unhealthy teams, it will increase frustration and distrust everywhere. SCA reports should be kept what they are. An input for engineers to make educated decisions. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter! Special thanks to my Patreon Supporter: Piotr Fusik." /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-10-12T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Should you use static code analyzers as gatekeepers?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-10-12T00:00:00+02:00","datePublished":"2022-10-12T00:00:00+02:00","description":"With the Code Insights plugin of Bitbucket, we have the possibility to make static code analyzers (from on SCAs) a gatekeeper for pull requests. Meaning that if a code analyzer reports certain kinds of issues, it can block pull requests from getting merged. While first, it sounds like a helpful idea, let’s see whether it’s realistic and whether it helps improve quality or prevents improvements. The motivation behind High-quality code is still not the norm among coders and it’s especially not recognized among stakeholders as a necessity for delivering durable software. Even though defining quality, in particular software quality, is a difficult task and many disagree on whether clean code should be considered part of software quality, I strongly believe it should. The definition of CISQ enumerates 4 elements that are part of structural software quality: security reliability maintainability performance efficiency Clean code is not part of the four points, but it clearly helps achieve maintainability and reliability. Even those who are not in favour of clean code would agree that it results in code that is easier to read. Something that is easier to read and easier to understand is simply more maintainable. If you combine clean code with Test-Driven Development, you’ll end up with fewer bugs that further increases the maintainability and also the reliability of software. Static code analysers with their recommendations on removing bugs, code smells and vulnerability issues are useful tools to deliver more correct, more clean and more maintainable code. Sadly, code quality is often sacrificed by both developers and management in order to move forward faster. Even when a static code analyzer is turned on and the scan results are pushed to the pull requests, developers often ignore fixing the reported issues. It’s slightly better when at least they comment on them and write why they don’t fix them. Considering that, making fixing the issues mandatory is an understandable approach to avoid the negligence of developers and therefore increase code quality. Potential issues Delivering code that is as clean and as free of bugs and code smells as possible is of course desirable. Making an SCA a gatekeeper still raises some questions. Let’s enumerate the potential issues introduced by an SCA as a gatekeeper. Rules or recommendations? Most SCAs clearly call their policies rules, not guidelines or recommendations. As the set of enforced rules is configurable, it makes sense. You either adhere to some rules or not. It’s your choice. At the same time, having rules does not mean that they are always applicable. Static code analysis is not an easy and straightforward task and the rules are not complete or perfect. There are cases where rules are useful in a given context, but in another, they might even go against best practices. For example, having a default case in a switch statement might be enforced by an SCA rule and it probably makes sense when you switch over an integer value. On the other hand, when the switch is combined with an enum, deliberately deleting the default and introducing instead a runtime exception as Matt Godbolt suggested and treating warnings as errors is part of compile-time enforcement of dealing with all the different enum values. Having informally discussed this with some engineers working on an SCA product, they are also aware of some inconsistencies, they are actually trying to make switch related rules better and they’d advise using rules as guidelines On the very same rules, other senior engineers said that they met cases when they explicitly didn’t want to break the compilation when a new value is given to an enum, even if that new value is not handled everywhere. Obviously, this was only one example, we can easily find others. In some cases, even an SCA asks the developer to “verify” whether a reported issue is a real issue or not. Sometimes it’s just a potential problem, but not necessarily a real one. Blocking based on such is clearly not acceptable. Blocking incremental improvements Having a clean SCA report is obviously something we prefer, but it’s not always realistic. Such an expectation makes gradual improvements too difficult. Imagine the following use case. Bob sees a badly named variable. Maybe the variable name is simply not meaningful enough, or maybe it’s using a pattern that makes an SCA cry. Bob updates the name and creates a pull request. Imagine that the mentioned variable was a non-private class member. For example, Sonar will raise an issue mentioning that. What should we do? Should we silence that error? Definitely not. That’s something we want to fix but it might require more time and effort. Should we make Bob run errands to report somehow that this is an old issue and should be ignored? Maybe. But does anyone think that Bob will raise any other improvement if reporting on something takes more time than the improvement he made? Should we keep updating the pull request until all the old issues related to the improvements are fixed? That’s probably fine for devs, but it’s hard to imagine any sane product owner supporting this idea… Blocking meaningful organization of changes When teams take time for housekeeping and dedicate some time to clean up the codebase from SCA issues they have many different ways to get organized - if they get organized at all. One meaningful way is that everyone gets a module or a repository to work on and a given rule. It can be for example that someone has to use in-class member initialization when possible. If the member declaration has other issues, such as using a reserved name, shadowing another one or if it’s just not private, the developer with the best intentions in mind cannot merge a code quality improvement without additional efforts. Blocking delivery of new versions It can easily happen that a new feature or a bugfix will require touching a line which has some rule violations. Or maybe the line violated no rules in the past, but new rules have been added and it’s not clear anymore. It might be something easy to fix and in such cases, an immediate fix is usually preferable, sometimes it’s not possible. Either not possible at all due to some strange 3rd party APIs, or it’s not possible easily. In the former case, it makes sense to mark it as an exception and it should be rare, but in the latter case, the developer is just being blocked to deliver without additional hassle even when the delivered code is not responsible for any new SCA issues. Lack of trust Using a static code analyzer with a complex set of rules as a gatekeeper also shows a lack of trust toward developers. “We, project managers, don’t trust you guys on the line that you can deliver high-quality code, we don’t trust that you can make a good judgement based on the analysis you’re given. We don’t trust that code reviewers will do a thorough job and block any PR with any meaningful outstanding static code analyzer warnings.” I see the following vital counterarguments. A failing unit/integration test can also block a pull request and we accept such “tooling”. While it’s completely true, a failing test indicates a functional failure was directly introduced by developers and they can delete or fix it in case it’s considered a faulty test. There are cases when the development teams don’t consider such warnings and they deliver low-quality code. That’s true. Developers rarely enjoy such situations and they do deliver low-quality code because they are either pushed to deliver too much by their management or because their level of experience is not adequate and the ratio of junior/senior developers is unhealthy. Neither of those reasons will be fixed by tooling, it’ll only add additional frustration both for the developers and the management. Developers will see that meeting the unrealistic expectations becomes even more difficult and management will see a further decreased output. Software engineers disapprove this solution I discussed this topic with several engineers who are dedicated to high code quality, and I found nobody who liked the idea of introducing SCAs as gatekeepers. I talked to 3 groups of developers Senior engineers who are responsible for setting the company-wide C++ Coding Guidelines Mostly senior engineers at an C++ On Sea Engineers from a company delivering static code analyzers While I found literally no one thinking that using an SCA as a gatekeeper is a good idea, many despised the idea of using one in the first place. They were not against higher quality though! They preferred turning on more and more compiler warnings and using sanitizers coming with major compilers, such as the address sanitizer, the undefined behaviour sanitizer and the memory sanitizer. I was a bit surprised but also reassured that even engineers working on SCAs don’t think it’s a good idea to use their products as gatekeepers. After all, it makes sense, they have a better view of the above troubles. Conclusion Static code analyzers are useful tools to spot certain code smells or even bugs with its own limitations. Rules might not be complete or might not be applicable in several circumstances. While the idea behind using SCA reports as gatekeeper is benign, the road to hell is paved with good intentions. Using a tool as a gatekeeper degrading developer judgement (or making its expression way too cumbersome) will reduce incremental improvements to the codebase which is exactly the opposite of the original intentions. At the same time, it will make it more difficult to integrate new features on time. While it will presumably drive down the introduction of new issues in unhealthy teams, it will increase frustration and distrust everywhere. SCA reports should be kept what they are. An input for engineers to make educated decisions. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter! Special thanks to my Patreon Supporter: Piotr Fusik.","headline":"Should you use static code analyzers as gatekeepers?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers"},"url":"https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers"}</script><title>Should you use static code analyzers as gatekeepers? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/12"> 12 </a> </span> <span>Should you use static code analyzers as gatekeepers?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Should you use static code analyzers as gatekeepers?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 12, 2022, 12:00 AM +0200" prep="on" > Oct 12, 2022 <i class="unloaded">2022-10-12T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1661 words">9 min</span></div></div><div class="post-content"><p>With the <a href="https://support.atlassian.com/bitbucket-cloud/docs/code-insights/">Code Insights plugin of Bitbucket</a>, we have the possibility to make static code analyzers (from on <em>SCA</em>s) a gatekeeper for pull requests. Meaning that if a code analyzer reports certain kinds of issues, it can block pull requests from getting merged.</p><p>While first, it sounds like a helpful idea, let’s see whether it’s realistic and whether it helps improve quality or prevents improvements.</p><h2 id="the-motivation-behind">The motivation behind</h2><p><a href="https://www.sandordargo.com/blog/2019/08/28/why-clean-code-is-not-norm">High-quality code is still not the norm among coders</a> and it’s especially not recognized among stakeholders as a necessity for delivering durable software. Even though defining quality, in particular software quality, is a difficult task and many disagree on whether clean code should be considered part of software quality, I strongly believe it should. <a href="https://www.it-cisq.org/standards/">The definition of CISQ</a> enumerates 4 elements that are part of structural software quality:</p><ul><li>security<li>reliability<li>maintainability<li>performance efficiency</ul><p>Clean code is not part of the four points, but it clearly helps achieve maintainability and reliability. Even those who are not in favour of clean code would agree that it results in code that is easier to read. Something that is easier to read and easier to understand is simply more maintainable. If you combine clean code with Test-Driven Development, you’ll end up with fewer bugs that further increases the maintainability and also the reliability of software.</p><p>Static code analysers with their recommendations on removing bugs, code smells and vulnerability issues are useful tools to deliver more correct, more clean and more maintainable code.</p><p>Sadly, code quality is often sacrificed by both developers and management in order to move forward faster. Even when a static code analyzer is turned on and the scan results are pushed to the pull requests, developers often ignore fixing the reported issues. It’s slightly better when at least they comment on them and write why they don’t fix them.</p><p>Considering that, making fixing the issues mandatory is an understandable approach to avoid the negligence of developers and therefore increase code quality.</p><h2 id="potential-issues">Potential issues</h2><p>Delivering code that is as clean and as free of bugs and code smells as possible is of course desirable. Making an <em>SCA</em> a gatekeeper still raises some questions. Let’s enumerate the potential issues introduced by an <em>SCA</em> as a gatekeeper.</p><h3 id="rules-or-recommendations">Rules or recommendations?</h3><p>Most <em>SCA</em>s clearly call their policies <em>rules</em>, not guidelines or recommendations. As the set of enforced rules is configurable, it makes sense. You either adhere to some rules or not. It’s your choice. At the same time, having rules does not mean that they are always applicable.</p><p>Static code analysis is not an easy and straightforward task and the rules are not complete or perfect. There are cases where rules are useful in a given context, but in another, they might even go against best practices. For example, having a <code class="language-plaintext highlighter-rouge">default</code> case in a <code class="language-plaintext highlighter-rouge">switch</code> statement might be enforced by an <em>SCA</em> rule and it probably makes sense when you <code class="language-plaintext highlighter-rouge">switch</code> over an integer value.</p><p>On the other hand, when the <code class="language-plaintext highlighter-rouge">switch</code> is combined with an <code class="language-plaintext highlighter-rouge">enum,</code> <a href="https://youtu.be/nLSm3Haxz0I?t=1534">deliberately deleting the <code class="language-plaintext highlighter-rouge">default</code> and introducing instead a runtime exception as Matt Godbolt suggested</a> and treating warnings as errors is part of compile-time enforcement of dealing with all the different <code class="language-plaintext highlighter-rouge">enum</code> values. Having informally discussed this with some engineers working on an <em>SCA</em> product, they are also aware of some inconsistencies, they are actually trying to make <code class="language-plaintext highlighter-rouge">switch</code> related rules better and they’d advise using rules as guidelines</p><p>On the very same rules, other senior engineers said that they met cases when they explicitly didn’t want to break the compilation when a new value is given to an <code class="language-plaintext highlighter-rouge">enum</code>, even if that new value is not handled everywhere. Obviously, this was only one example, we can easily find others.</p><p>In some cases, even an <em>SCA</em> asks the developer to “verify” whether a reported issue is a real issue or not. Sometimes it’s just a potential problem, but not necessarily a real one. Blocking based on such is clearly not acceptable.</p><h3 id="blocking-incremental-improvements">Blocking incremental improvements</h3><p>Having a clean <em>SCA</em> report is obviously something we prefer, but it’s not always realistic. Such an expectation makes gradual improvements too difficult. Imagine the following use case. Bob sees a badly named variable. Maybe the variable name is simply not meaningful enough, or maybe it’s using <a href="https://rules.sonarsource.com/cpp/RSPEC-978">a pattern that makes an <em>SCA</em> cry</a>. Bob updates the name and creates a pull request. Imagine that the mentioned variable was a non-private class member. For example, Sonar will raise an issue mentioning that.</p><p>What should we do?</p><p>Should we silence that error? Definitely not. That’s something we want to fix but it might require more time and effort.</p><p>Should we make Bob run errands to report somehow that this is an old issue and should be ignored? Maybe. But does anyone think that Bob will raise any other improvement if reporting on something takes more time than the improvement he made?</p><p>Should we keep updating the pull request until all the old issues related to the improvements are fixed? That’s probably fine for devs, but it’s hard to imagine any sane product owner supporting this idea…</p><h3 id="blocking-meaningful-organization-of-changes">Blocking meaningful organization of changes</h3><p>When teams take time for housekeeping and dedicate some time to clean up the codebase from SCA issues they have many different ways to get organized - if they get organized at all. One meaningful way is that everyone gets a module or a repository to work on and a given rule. It can be for example that someone has to <a href="https://rules.sonarsource.com/cpp/RSPEC-3230">use in-class member initialization when possible</a>. If the member declaration has other issues, such as using a reserved name, shadowing another one or if it’s just not private, the developer with the best intentions in mind cannot merge a code quality improvement without additional efforts.</p><h3 id="blocking-delivery-of-new-versions">Blocking delivery of new versions</h3><p>It can easily happen that a new feature or a bugfix will require touching a line which has some rule violations. Or maybe the line violated no rules in the past, but new rules have been added and it’s not <em>clear</em> anymore. It might be something easy to fix and in such cases, an immediate fix is usually preferable, sometimes it’s not possible. Either not possible at all due to some strange 3rd party APIs, or it’s not possible easily. In the former case, it makes sense to mark it as an exception and it should be rare, but in the latter case, the developer is just being blocked to deliver without additional hassle even when the delivered code is not responsible for any new SCA issues.</p><h3 id="lack-of-trust">Lack of trust</h3><p>Using a static code analyzer with a complex set of rules as a gatekeeper also shows a lack of trust toward developers. <em>“We, project managers, don’t trust you guys on the line that you can deliver high-quality code, we don’t trust that you can make a good judgement based on the analysis you’re given. We don’t trust that code reviewers will do a thorough job and block any PR with any meaningful outstanding static code analyzer warnings.”</em></p><p>I see the following vital counterarguments.</p><p>A failing unit/integration test can also block a pull request and we accept such “tooling”. While it’s completely true, a failing test</p><ul><li>indicates a functional failure<li>was directly introduced by developers and they can delete or fix it in case it’s considered a faulty test.</ul><p>There are cases when the development teams don’t consider such warnings and they deliver low-quality code. That’s true. Developers rarely enjoy such situations and they do deliver low-quality code because they are either pushed to deliver too much by their management or because their level of experience is not adequate and the ratio of junior/senior developers is unhealthy. Neither of those reasons will be fixed by tooling, it’ll only add additional frustration both for the developers and the management. Developers will see that meeting the unrealistic expectations becomes even more difficult and management will see a further decreased output.</p><h2 id="software-engineers-disapprove-this-solution">Software engineers disapprove this solution</h2><p>I discussed this topic with several engineers who are dedicated to high code quality, and I found nobody who liked the idea of introducing <em>SCA</em>s as gatekeepers. I talked to 3 groups of developers</p><ul><li>Senior engineers who are responsible for setting the company-wide C++ Coding Guidelines<li>Mostly senior engineers at an <a href="https://www.sandordargo.com/blog/2022/07/27/cpp-on-sea-trip-report">C++ On Sea</a><li>Engineers from a company delivering static code analyzers</ul><p>While I found literally no one thinking that using an <em>SCA</em> as a gatekeeper is a good idea, many despised the idea of using one in the first place. They were not against higher quality though! They preferred turning on more and more compiler warnings and using sanitizers coming with major compilers, such as the <a href="https://clang.llvm.org/docs/AddressSanitizer.html">address sanitizer</a>, the <a href="https://clang.llvm.org/docs/UndefinedBehaviorSanitizer.html">undefined behaviour sanitizer</a> and the <a href="https://clang.llvm.org/docs/MemorySanitizer.html">memory sanitizer</a>.</p><p>I was a bit surprised but also reassured that even engineers working on <em>SCA</em>s don’t think it’s a good idea to use their products as gatekeepers. After all, it makes sense, they have a better view of the above troubles.</p><h2 id="conclusion">Conclusion</h2><p>Static code analyzers are useful tools to spot certain code smells or even bugs with its own limitations. Rules might not be complete or might not be applicable in several circumstances. While the idea behind using <em>SCA</em> reports as gatekeeper is benign, the road to hell is paved with good intentions. Using a tool as a gatekeeper degrading developer judgement (or making its expression way too cumbersome) will reduce incremental improvements to the codebase which is exactly the opposite of the original intentions. At the same time, it will make it more difficult to integrate new features on time. While it will presumably drive down the introduction of new issues in unhealthy teams, it will increase frustration and distrust everywhere.</p><p><em>SCA</em> reports should be kept what they are. An input for engineers to make educated decisions.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><p><strong>Special thanks to my <a href="https://www.patreon.com/sandordargo">Patreon Supporter</a>: Piotr Fusik.</strong></p><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cicd/" class="post-tag no-text-decoration" >cicd</a> <a href="/tags/quality/" class="post-tag no-text-decoration" >quality</a> <a href="/tags/automation/" class="post-tag no-text-decoration" >automation</a> <a href="/tags/devops/" class="post-tag no-text-decoration" >devops</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Should you use static code analyzers as gatekeepers? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Should you use static code analyzers as gatekeepers? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Should you use static code analyzers as gatekeepers? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Should you use static code analyzers as gatekeepers? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/01/08/zen-and-the-art-of-motorcycle-maintenance-by-robert-pirsig"><div class="card-body"> <span class="timeago small" > Jan 8, 2022 <i class="unloaded">2022-01-08T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Zen and The Art of Motorcycle Maintenance by Robert Pirsig</h3><div class="text-muted small"><p> During the last couple of years, I started to attend and present at more and more C++ conferences. Inevitably, I ended up listening to Phil Nash several times and he almost always spoke about somet...</p></div></div></a></div><div class="card"> <a href="/blog/2017/01/24/tooling"><div class="card-body"> <span class="timeago small" > Jan 24, 2017 <i class="unloaded">2017-01-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tooling is great!</h3><div class="text-muted small"><p> As I’m quite new on the underlying application I executed the procedure in one phase, just to see if it works fine, how the application responds. Then I talked to the author and we agreed, this sho...</p></div></div></a></div><div class="card"> <a href="/blog/2020/01/15/i-went-to-devops-d-day-2019"><div class="card-body"> <span class="timeago small" > Jan 15, 2020 <i class="unloaded">2020-01-15T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>I went to DevOps D-Day #5</h3><div class="text-muted small"><p> I had the chance to go to Marseille this November for the 5th Devops D-Day conference. More than that, I could also present how I see the relations between coding guidelines, code quality and dec...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/10/08/battle-hardened-developer" class="btn btn-outline-primary" prompt="Older"><p>The Battle Hardened Developer by Fiodar Sazanavets</p></a> <a href="/blog/2022/10/19/last-days-at-amadeus-after-nine-years" class="btn btn-outline-primary" prompt="Newer"><p>I'm leaving Amadeus after 9 years</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Should you use static code analyzers as gatekeepers?'; this.page.url = 'https://www.sandordargo.com/blog/2022/10/12/static-code-analyzers-as-gatekeepers'; this.page.identifier = '/blog/2022/10/12/static-code-analyzers-as-gatekeepers'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
