<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The big STL Algorithms tutorial: the memory header" /><meta property="og:locale" content="en_US" /><meta name="description" content="We are slowly reaching the end of the big STL algorithm tutorial, and in this last but one part we are going to cover a record high 14 operations that are part of the &lt;memory&gt; header. I decided to take all of them because they are quite similar to each other." /><meta property="og:description" content="We are slowly reaching the end of the big STL algorithm tutorial, and in this last but one part we are going to cover a record high 14 operations that are part of the &lt;memory&gt; header. I decided to take all of them because they are quite similar to each other." /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-02T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The big STL Algorithms tutorial: the memory header" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-02T22:02:28+01:00","datePublished":"2022-02-02T00:00:00+01:00","description":"We are slowly reaching the end of the big STL algorithm tutorial, and in this last but one part we are going to cover a record high 14 operations that are part of the &lt;memory&gt; header. I decided to take all of them because they are quite similar to each other.","headline":"The big STL Algorithms tutorial: the memory header","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header"},"url":"https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header"}</script><title>The big STL Algorithms tutorial: the memory header | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/02"> 02 </a> </span> <span>The big STL Algorithms tutorial: the memory header</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The big STL Algorithms tutorial: the memory header</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 2, 2022, 12:00 AM +0100" prep="on" > Feb 2, 2022 <i class="unloaded">2022-02-02T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 2, 2022, 10:02 PM +0100" prefix="Updated " > Feb 2, 2022 <i class="unloaded">2022-02-02T22:02:28+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1761 words">9 min</span></div></div><div class="post-content"><p>We are slowly reaching the end of <a href="http://sandordargo.com/blog/2019/01/30/stl-algos-intro">the big STL algorithm tutorial</a>, and in this last but one part we are going to cover a record high 14 operations that are part of the <code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code> header. I decided to take all of them because they are quite similar to each other.</p><ul><li><code class="language-plaintext highlighter-rouge">uninitialized_copy</code><li><code class="language-plaintext highlighter-rouge">uninitialized_copy_n</code><li><code class="language-plaintext highlighter-rouge">uninitialized_fill</code><li><code class="language-plaintext highlighter-rouge">uninitialized_fill_n</code><li><code class="language-plaintext highlighter-rouge">uninitialized_move</code><li><code class="language-plaintext highlighter-rouge">uninitialized_move_n </code><li><code class="language-plaintext highlighter-rouge">uninitialized_default_construct</code><li><code class="language-plaintext highlighter-rouge">uninitialized_default_construct_n </code><li><code class="language-plaintext highlighter-rouge">uninitialized_value_construct</code><li><code class="language-plaintext highlighter-rouge">uninitialized_value_construct_n</code><li><code class="language-plaintext highlighter-rouge">destroy</code><li><code class="language-plaintext highlighter-rouge">destroy_n </code><li><code class="language-plaintext highlighter-rouge">destroy_at</code><li><code class="language-plaintext highlighter-rouge">construct_at</code></ul><h2 id="uninitialized_copy--uninitialized_copy_n"><code class="language-plaintext highlighter-rouge">uninitialized_copy</code> / <code class="language-plaintext highlighter-rouge">uninitialized_copy_n</code></h2><p><code class="language-plaintext highlighter-rouge">std::uninitialized_copy</code> takes an input range and copies the elements to an uninitialized area that is denoted by an iterator pointing at the beginning of the output range.</p><p>Potentially, you can also set the execution policy.</p><p>The only difference <code class="language-plaintext highlighter-rouge">std::uninitialized_copy_n</code> has compared to <code class="language-plaintext highlighter-rouge">std::uninitialized_copy</code> is that it doesn’t take the input range by two iterators defining the beginning and the end of the input range, but instead it takes the beginning of the range and the size.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="s">"This"</span><span class="p">,</span> <span class="s">"is"</span><span class="p">,</span> <span class="s">"an"</span><span class="p">,</span> <span class="s">"example"</span><span class="p">};</span>
 
    <span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
 
    <span class="k">if</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">pbuf</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_alloc</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span> <span class="o">*</span> <span class="n">sz</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">try</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">first</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
            <span class="k">auto</span> <span class="n">last</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_copy</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">first</span><span class="p">);</span>
 
            <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">first</span><span class="p">;</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
 
            <span class="n">std</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span><span class="p">(...)</span> <span class="p">{}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">pbuf</span><span class="p">);</span>
    <span class="p">}</span>
    
    
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get_temporary_buffer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
    <span class="n">sz</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
 
    <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_copy_n</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">sz</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">p</span><span class="o">+</span><span class="n">sz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
        <span class="n">i</span><span class="o">-&gt;~</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">return_temporary_buffer</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="uninitialized_move--uninitialized_move_n"><code class="language-plaintext highlighter-rouge">uninitialized_move</code> / <code class="language-plaintext highlighter-rouge">uninitialized_move_n</code></h2><p><code class="language-plaintext highlighter-rouge">std::uninitialized_move</code> and <code class="language-plaintext highlighter-rouge">std::uninitialized_move_n</code> - unsurprisingly - work very similarly compared to their copy versions, but instead of copying the items from the input ranges, they move the items.</p><p>The range to be moved is either defined by two iterators denoting its beginning and end (<code class="language-plaintext highlighter-rouge">uninitialized_move</code>) or by an iterator to its beginning and the number of positions to fill (<code class="language-plaintext highlighter-rouge">uninitialized_move_n</code>).</p><p>The output range is defined only by its beginning as usual, and as a caller, we have to make sure that it can accommodate all the necessary elements to avoid undefined behaviour.</p><p>Before all the other parameters, we can also define an execution policy.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span> 
<span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">auto</span> <span class="n">rem</span><span class="p">,</span> <span class="k">auto</span> <span class="n">first</span><span class="p">,</span> <span class="k">auto</span> <span class="n">last</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">rem</span><span class="p">;</span> <span class="n">first</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">first</span><span class="p">)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="o">*</span><span class="n">first</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">in</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"Home"</span><span class="p">,</span> <span class="s">"Work!"</span> <span class="p">};</span>
    <span class="n">print</span><span class="p">(</span><span class="s">"initially, in: "</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">in</span><span class="p">));</span>
 
    <span class="k">if</span> <span class="p">(</span>
        <span class="k">constexpr</span> <span class="k">auto</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">size</span><span class="p">(</span><span class="n">in</span><span class="p">);</span>
        <span class="kt">void</span><span class="o">*</span> <span class="n">out</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_alloc</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">)</span> <span class="o">*</span> <span class="n">sz</span><span class="p">)</span>
    <span class="p">)</span> <span class="p">{</span>
        <span class="k">try</span> <span class="p">{</span>
            <span class="k">auto</span> <span class="n">first</span> <span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">out</span><span class="p">)};</span>
            <span class="k">auto</span> <span class="n">last</span> <span class="p">{</span><span class="n">first</span> <span class="o">+</span> <span class="n">sz</span><span class="p">};</span>
            
            <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_move</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">first</span><span class="p">);</span>
            <span class="c1">// comment the previous line and uncomment the next one</span>
            <span class="c1">// to see uninitialized_move_n in action</span>
            <span class="c1">// std::uninitialized_move_n(std::begin(in), sz, first);</span>
 
            <span class="n">print</span><span class="p">(</span><span class="s">"after move, in: "</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">in</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">in</span><span class="p">));</span>
            <span class="n">print</span><span class="p">(</span><span class="s">"after move, out: "</span><span class="p">,</span> <span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
 
            <span class="n">std</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">catch</span> <span class="p">(...)</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Exception!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">free</span><span class="p">(</span><span class="n">out</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="uninitialized_fill--uninitialized_fill_n"><code class="language-plaintext highlighter-rouge">uninitialized_fill</code> / <code class="language-plaintext highlighter-rouge">uninitialized_fill_n</code></h2><p><code class="language-plaintext highlighter-rouge">std::uninitialized_fill</code> and <code class="language-plaintext highlighter-rouge">std::uninitialized_fill_n</code> fills an uninitialized memory area with a given value.</p><p>The range to be filled is either defined by two iterators denoting its beginning and end (<code class="language-plaintext highlighter-rouge">uninitialized_fill</code>) or by an iterator to its beginning and the number of positions to fill (<code class="language-plaintext highlighter-rouge">uninitialized_fill_n</code>).</p><p>In both cases, the value comes after, and execution policy can also be defined.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;tuple&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">sz</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">tie</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">sz</span><span class="p">)</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get_temporary_buffer</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_fill</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="n">sz</span><span class="p">,</span> <span class="s">"Example"</span><span class="p">);</span>
    <span class="c1">// comment the previous line and uncomment the next one</span>
    <span class="c1">// to see uninitialized_fill_n in action</span>
    <span class="c1">// std::uninitialized_fill_n(p, sz, "Example");</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">*</span> <span class="n">i</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">p</span><span class="o">+</span><span class="n">sz</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">i</span><span class="o">-&gt;~</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">return_temporary_buffer</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="uninitialized_default_construct--uninitialized_default_construct_n"><code class="language-plaintext highlighter-rouge">uninitialized_default_construct</code> / <code class="language-plaintext highlighter-rouge">uninitialized_default_construct_n</code></h2><p><code class="language-plaintext highlighter-rouge">std::uninitialized_default_construct</code> and <code class="language-plaintext highlighter-rouge">std::uninitialized_default_construct_n</code> fills an uninitialized memory area with the default initialized instances of the contained type.</p><p>The range to be filled is either defined by two iterators denoting its beginning and end (<code class="language-plaintext highlighter-rouge">uninitialized_default_construct</code>) or by an iterator to its beginning and the number of positions to fill (<code class="language-plaintext highlighter-rouge">uninitialized_default_construct_n</code>).</p><p>In both cases, the value comes after, and execution policy can also be defined.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span> 
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m</span><span class="p">{</span> <span class="s">"Default value"</span> <span class="p">};</span> <span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">{</span><span class="mi">3</span><span class="p">};</span>
    <span class="k">alignas</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">S</span><span class="p">))</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mem</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)];</span>
 
    <span class="k">auto</span> <span class="n">first</span> <span class="p">{</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">S</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">mem</span><span class="p">)};</span>
    <span class="k">auto</span> <span class="n">last</span> <span class="p">{</span><span class="n">first</span> <span class="o">+</span> <span class="n">n</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_default_construct</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="c1">// comment the previous line and uncomment the next one</span>
    <span class="c1">// to see uninitialized_default_construct_n in action</span>
    <span class="c1">// std::uninitialized_default_construct_n(first, n);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="p">{</span><span class="n">first</span><span class="p">};</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We should also note that <code class="language-plaintext highlighter-rouge">std::uninitialized_default_construct</code> and <code class="language-plaintext highlighter-rouge">std::uninitialized_default_construct_n</code> do not zero-fill the memory area for trivial types!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstring&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="c1">// Notice that for "trivial types" the uninitialized_default_construct</span>
    <span class="c1">// generally does not zero-fill the given uninitialized memory area.</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">[]</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="k">const</span> <span class="kt">int</span> <span class="n">original</span><span class="p">[]</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_default_construct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
    <span class="c1">// comment the previous line and uncomment the next one</span>
    <span class="c1">// to see uninitialized_default_construct_n in action</span>
    <span class="c1">// std::uninitialized_default_construct_n(std::begin(v), std::distance(std::begin(v), std::end(v)));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// Maybe undefined behavior, pending CWG 1997.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span>
        <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">memcmp</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="n">original</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">?</span> <span class="s">"Unmodified</span><span class="se">\n</span><span class="s">"</span> <span class="o">:</span> <span class="s">"Modified</span><span class="se">\n</span><span class="s">"</span><span class="p">);</span>
    <span class="c1">// The result is unspecified.</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="uninitialized_value_construct--uninitialized_value_construct_n"><code class="language-plaintext highlighter-rouge">uninitialized_value_construct</code> / <code class="language-plaintext highlighter-rouge">uninitialized_value_construct_n</code></h2><p><code class="language-plaintext highlighter-rouge">uninitialized_value_construct</code> / <code class="language-plaintext highlighter-rouge">uninitialized_value_construct_n</code> has the same signatures as <code class="language-plaintext highlighter-rouge">uninitialized_default_construct</code> and <code class="language-plaintext highlighter-rouge">uninitialized_default_construct_n</code>.</p><p>Besides, they practically work the same way for object types, they both invoke the default constructor of the contained type. However while <code class="language-plaintext highlighter-rouge">uninitialized_default_construct</code> and <code class="language-plaintext highlighter-rouge">uninitialized_default_construct_n</code> didn’t zero-fill trival types (POD types), <code class="language-plaintext highlighter-rouge">uninitialized_value_construct</code> / <code class="language-plaintext highlighter-rouge">uninitialized_value_construct_n</code> will do it.</p><p><a href="https://stackoverflow.com/a/6032889/3238101">Here is a nice little comparison between default and value initialization.</a></p><p>Here is a merged example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m</span><span class="p">{</span> <span class="s">"Default value"</span> <span class="p">};</span> <span class="p">};</span> 

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">n</span> <span class="p">{</span><span class="mi">3</span><span class="p">};</span>
    <span class="k">alignas</span><span class="p">(</span><span class="k">alignof</span><span class="p">(</span><span class="n">S</span><span class="p">))</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">mem</span><span class="p">[</span><span class="n">n</span> <span class="o">*</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)];</span>
 
    <span class="k">auto</span> <span class="n">first</span> <span class="p">{</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">S</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">mem</span><span class="p">)};</span>
    <span class="k">auto</span> <span class="n">last</span> <span class="p">{</span><span class="n">first</span> <span class="o">+</span> <span class="n">n</span><span class="p">};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_value_construct</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
    <span class="c1">// comment the previous line and uncomment the next one</span>
    <span class="c1">// to see uninitialized_default_construct_n in action</span>
    <span class="c1">// std::uninitialized_value_construct_n(first, n);</span>

    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="p">{</span><span class="n">first</span><span class="p">};</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">last</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">it</span><span class="o">-&gt;</span><span class="n">m</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">last</span><span class="p">);</span>
 
    <span class="c1">// Notice that for "trivial types" the uninitialized_value_construct</span>
    <span class="c1">// zero-fills the given uninitialized memory area.</span>
    <span class="kt">int</span> <span class="n">v</span><span class="p">[]</span> <span class="p">{</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span> <span class="p">};</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uninitialized_value_construct</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">));</span>
    <span class="c1">// comment the previous line and uncomment the next one</span>
    <span class="c1">// to see uninitialized_default_construct_n in action</span>
    <span class="c1">// std::uninitialized_value_construct_n(std::begin(v), std::distance(std::begin(v), std::end(v)));</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="destroy--destroy_n--destroy_at"><code class="language-plaintext highlighter-rouge">destroy</code> / <code class="language-plaintext highlighter-rouge">destroy_n</code> / <code class="language-plaintext highlighter-rouge">destroy_at</code></h2><p>If you have read the code snippets thoroughly in this article, you could already see <code class="language-plaintext highlighter-rouge">std::destroy</code> at work and I’m sure you can guess how <code class="language-plaintext highlighter-rouge">std::destroy_n</code> works compared to it.</p><p><code class="language-plaintext highlighter-rouge">std::destroy</code> and <code class="language-plaintext highlighter-rouge">std::destroy_n</code> take a range of objects and invoke the destructor of those. <code class="language-plaintext highlighter-rouge">std::destroy</code> takes a pair of iterators, while <code class="language-plaintext highlighter-rouge">std::destroy_n</code> takes the beginning of a range and the number of objects to be destroyed. It’s also possible to set the execution policy.</p><p>Both can be implemented as a loop iterating over the range and in the body they call <code class="language-plaintext highlighter-rouge">std::destroy_at</code> which takes only one parameter, a pointer.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;new&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span> 
<span class="k">struct</span> <span class="nc">Tracer</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="o">~</span><span class="n">Tracer</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="s">" destructed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">alignas</span><span class="p">(</span><span class="n">Tracer</span><span class="p">)</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Tracer</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">];</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">new</span><span class="p">(</span><span class="n">buffer</span> <span class="o">+</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">Tracer</span><span class="p">)</span> <span class="o">*</span> <span class="n">i</span><span class="p">)</span> <span class="n">Tracer</span><span class="p">{</span><span class="n">i</span><span class="p">};</span> <span class="c1">//manually construct objects</span>
    <span class="p">}</span>
 
    <span class="k">auto</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">launder</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">Tracer</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">buffer</span><span class="p">));</span>
 
    <span class="n">std</span><span class="o">::</span><span class="n">destroy</span><span class="p">(</span><span class="n">ptr</span><span class="p">,</span> <span class="n">ptr</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span>
    <span class="c1">// you can alternatively try this </span>
    <span class="c1">// std::destroy_n(ptr, 8);</span>
    <span class="c1">// or this</span>
    <span class="c1">// for (int i = 0; i &lt; 8; ++i)</span>
    <span class="c1">//     std::destroy_at(ptr + i);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="construct_at"><code class="language-plaintext highlighter-rouge">construct_at</code></h2><p><code class="language-plaintext highlighter-rouge">std::construct_at</code> takes a memory address of an object of type T and a variable number of parameters and it constructs a T object with all the passed arguments.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
</span> 
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
    <span class="kt">double</span> <span class="n">z</span><span class="p">;</span>
 
    <span class="n">S</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">double</span> <span class="n">z</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">y</span><span class="p">},</span> <span class="n">z</span><span class="p">{</span><span class="n">z</span><span class="p">}</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"S::S();</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
 
    <span class="o">~</span><span class="n">S</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"S::~S();</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>

    <span class="k">friend</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">S</span><span class="o">&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"S { x="</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="s">"; y="</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;&lt;</span> <span class="s">"; z="</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="p">.</span><span class="n">z</span> <span class="o">&lt;&lt;</span> <span class="s">"; };</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">alignas</span><span class="p">(</span><span class="n">S</span><span class="p">)</span> <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">storage</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">S</span><span class="p">)];</span>
 
    <span class="n">S</span><span class="o">*</span> <span class="n">ptr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">construct_at</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">S</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">storage</span><span class="p">),</span> <span class="mi">42</span><span class="p">,</span> <span class="mf">2.71828f</span><span class="p">,</span> <span class="mf">3.1415</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
 
    <span class="n">std</span><span class="o">::</span><span class="n">destroy_at</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>This time, we learned about algorithms for dynamic memory management from the <code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code> header. To be completely honest with you, in the almost 9 years that I spent with C++, I’ve never used them and there was no situation when I would have had to use them.</p><p>Still, it’s good to know about them and even better to avoid dynamic memory management as much as you can and let the compiler do it for us.</p><p>In the very last part of this series, we are going to conclude what we learned about STL algorithms, the key points to keep in mind.</p><p>Stay tuned!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/tutorial/" class="post-tag no-text-decoration" >tutorial</a> <a href="/tags/stl/" class="post-tag no-text-decoration" >stl</a> <a href="/tags/algorithms/" class="post-tag no-text-decoration" >algorithms</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The big STL Algorithms tutorial: the memory header - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The big STL Algorithms tutorial: the memory header - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The big STL Algorithms tutorial: the memory header - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The big STL Algorithms tutorial: the memory header - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2019/01/30/stl-algos-intro"><div class="card-body"> <span class="timeago small" > Jan 30, 2019 <i class="unloaded">2019-01-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: Introduction</h3><div class="text-muted small"><p> I’ve already written quite a few articles about features introduced by C++ 11 and how much it changed how I look at the language. The feature I liked the most is probably the one of lambda expressi...</p></div></div></a></div><div class="card"> <a href="/blog/2019/02/20/stl-algorithm-tutorial-part-1-any-all-none"><div class="card-body"> <span class="timeago small" > Feb 20, 2019 <i class="unloaded">2019-02-20T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: all_of, any_of, none_of</h3><div class="text-muted small"><p> In this first part of the big STL algorithm tutorial, I’ll start with the first chunk of the non-modifying sequence operations. Namely, in this post, you are going to read about all_of, any_of an...</p></div></div></a></div><div class="card"> <a href="/blog/2019/04/03/stl-algorithm-tutorial-part-2-for_each"><div class="card-body"> <span class="timeago small" > Apr 3, 2019 <i class="unloaded">2019-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: for_each</h3><div class="text-muted small"><p> In this next part of the big STL algorithm tutorial, I’ll explain only one function. The for_each algorithm. What does it do? for_each takes a range and a function to apply on each element of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/01/26/3-tips-for-junior-developers" class="btn btn-outline-primary" prompt="Older"><p>3 piece of advice for junior developers</p></a> <a href="/blog/2022/02/05/the-gift-by-dr-edith-eger" class="btn btn-outline-primary" prompt="Newer"><p>The Gift: 12 Lessons to Save Your Life by Dr. Edith Eva Eger</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The big STL Algorithms tutorial: the memory header'; this.page.url = 'https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header'; this.page.identifier = '/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
