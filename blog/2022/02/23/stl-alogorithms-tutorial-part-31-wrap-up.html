<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The big STL Algorithms tutorial: wrapping up" /><meta property="og:locale" content="en_US" /><meta name="description" content="With the last article on algorithms about dynamic memory management, we reached the end of a 3-year-long journey that we started at the beginning of 2019. Since then, in about 30 different posts, we learned about the algorithms that the STL offers us. We are not going to have a crash course on them, if you are looking for something like that watch Jonathan Boccara’s video from CppCon2018, 105 STL Algorithms in Less Than an Hour Instead, let’s remind us of a couple of key concepts and oddities that we learned along the way. You don’t pay for what you don’t need Standard algorithms showcase perfectly that in C++ you don’t pay for what you don’t need. One example like that is bound checks. Most of the algorithms that need more than one range take only the first range via two iterators (begin and end), the rest is taken only by one iterator, by one that denotes the beginning of the range. It’s up to the caller to guarantee that the additional input containers have enough elements or that an output container has enough space to accommodate the results. There are no checks of the sizes, no extra cost for ensuring something that is up to the caller to guarantee. While this means potentially undefined behaviour, it also makes the algorithms faster and as the expectations are clearly documented we have nothing to complain about. Lack of consistency sometimes We’ve also seen that sometimes the STL lacks consistency quite a bit. Even though it is something standardized, it’s been under development for almost 3 decades, so I think it’s normal to end up with some inconsistencies. As C++ and the standard library is widely used, it’s almost impossible to alter the existing API, so we have to live with these oddities. But do I have in mind? std::find will look for an element by value, std::find_if takes a predicate. At the same time, std::find_end can either take a value or a predicate. There is no std::find_end_if. While it’s true that std::find_end_if would be a strange name, it would also be more consistent. Wile exclusive_scan can optionally take an initial value and a binary operation in this order, inclusive_scan takes these optional values in the different order, first the binary operation and then the initial value. Maybe it’s just a guarantee that you don’t mix them up accidentally? I found it strange that transform_reduce takes first you pass the reduction algorithm and then the transformation. I think the name is good because first the transformation is applied, then the reduction, but perhaps it should take the two operations in a reversed order. Algos are better than raw loops! No more raw loops as Sean Parent suggested in his talk C++ Seasoning at GoingNative 2013. But why? STL algorithms are less error-prone than raw loops as they were already written and tested - a lot. Thousands if not millions of developers are using them, if there were bugs in these algorithms, they have been already discovered and fixed. Unless you are going for the last drops of performance, algorithms will provide good enough efficiency for you and often they will not just match but outperform simple loops. The most important point is that they are more expressive. It’s straightforward to pick the good among many, but with education and practice, you’ll be able to easily find an algorithm that can replace a for loop in most cases. For more details read this article! Conclusion Thank you for following through this series on STL algorithms where we discussed functions from the &lt;algorithm&gt;, &lt;numeric and &lt;memory&gt; headers. After about 30 parts, today we wrapped up by mentioning once again some important concepts and inconsistencies of algorithms. We discussed how algorithms follow one of the main principles of C++: you don’t pay for what you don’t need. We saw three inconsistencies within the STL, such as sometimes you have to postpend an algorithm with _if to be able to use a unary predicate instead of a value, but sometimes it’s just a different overload. Finally, we reiterated the main reasons why STL algorithms are better than raw loops. Use STL algorithms in your code, no matter if it’s a personal project or at work. They’ll make your code better! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="With the last article on algorithms about dynamic memory management, we reached the end of a 3-year-long journey that we started at the beginning of 2019. Since then, in about 30 different posts, we learned about the algorithms that the STL offers us. We are not going to have a crash course on them, if you are looking for something like that watch Jonathan Boccara’s video from CppCon2018, 105 STL Algorithms in Less Than an Hour Instead, let’s remind us of a couple of key concepts and oddities that we learned along the way. You don’t pay for what you don’t need Standard algorithms showcase perfectly that in C++ you don’t pay for what you don’t need. One example like that is bound checks. Most of the algorithms that need more than one range take only the first range via two iterators (begin and end), the rest is taken only by one iterator, by one that denotes the beginning of the range. It’s up to the caller to guarantee that the additional input containers have enough elements or that an output container has enough space to accommodate the results. There are no checks of the sizes, no extra cost for ensuring something that is up to the caller to guarantee. While this means potentially undefined behaviour, it also makes the algorithms faster and as the expectations are clearly documented we have nothing to complain about. Lack of consistency sometimes We’ve also seen that sometimes the STL lacks consistency quite a bit. Even though it is something standardized, it’s been under development for almost 3 decades, so I think it’s normal to end up with some inconsistencies. As C++ and the standard library is widely used, it’s almost impossible to alter the existing API, so we have to live with these oddities. But do I have in mind? std::find will look for an element by value, std::find_if takes a predicate. At the same time, std::find_end can either take a value or a predicate. There is no std::find_end_if. While it’s true that std::find_end_if would be a strange name, it would also be more consistent. Wile exclusive_scan can optionally take an initial value and a binary operation in this order, inclusive_scan takes these optional values in the different order, first the binary operation and then the initial value. Maybe it’s just a guarantee that you don’t mix them up accidentally? I found it strange that transform_reduce takes first you pass the reduction algorithm and then the transformation. I think the name is good because first the transformation is applied, then the reduction, but perhaps it should take the two operations in a reversed order. Algos are better than raw loops! No more raw loops as Sean Parent suggested in his talk C++ Seasoning at GoingNative 2013. But why? STL algorithms are less error-prone than raw loops as they were already written and tested - a lot. Thousands if not millions of developers are using them, if there were bugs in these algorithms, they have been already discovered and fixed. Unless you are going for the last drops of performance, algorithms will provide good enough efficiency for you and often they will not just match but outperform simple loops. The most important point is that they are more expressive. It’s straightforward to pick the good among many, but with education and practice, you’ll be able to easily find an algorithm that can replace a for loop in most cases. For more details read this article! Conclusion Thank you for following through this series on STL algorithms where we discussed functions from the &lt;algorithm&gt;, &lt;numeric and &lt;memory&gt; headers. After about 30 parts, today we wrapped up by mentioning once again some important concepts and inconsistencies of algorithms. We discussed how algorithms follow one of the main principles of C++: you don’t pay for what you don’t need. We saw three inconsistencies within the STL, such as sometimes you have to postpend an algorithm with _if to be able to use a unary predicate instead of a value, but sometimes it’s just a different overload. Finally, we reiterated the main reasons why STL algorithms are better than raw loops. Use STL algorithms in your code, no matter if it’s a personal project or at work. They’ll make your code better! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-02-23T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The big STL Algorithms tutorial: wrapping up" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-02-23T00:00:00+01:00","datePublished":"2022-02-23T00:00:00+01:00","description":"With the last article on algorithms about dynamic memory management, we reached the end of a 3-year-long journey that we started at the beginning of 2019. Since then, in about 30 different posts, we learned about the algorithms that the STL offers us. We are not going to have a crash course on them, if you are looking for something like that watch Jonathan Boccara’s video from CppCon2018, 105 STL Algorithms in Less Than an Hour Instead, let’s remind us of a couple of key concepts and oddities that we learned along the way. You don’t pay for what you don’t need Standard algorithms showcase perfectly that in C++ you don’t pay for what you don’t need. One example like that is bound checks. Most of the algorithms that need more than one range take only the first range via two iterators (begin and end), the rest is taken only by one iterator, by one that denotes the beginning of the range. It’s up to the caller to guarantee that the additional input containers have enough elements or that an output container has enough space to accommodate the results. There are no checks of the sizes, no extra cost for ensuring something that is up to the caller to guarantee. While this means potentially undefined behaviour, it also makes the algorithms faster and as the expectations are clearly documented we have nothing to complain about. Lack of consistency sometimes We’ve also seen that sometimes the STL lacks consistency quite a bit. Even though it is something standardized, it’s been under development for almost 3 decades, so I think it’s normal to end up with some inconsistencies. As C++ and the standard library is widely used, it’s almost impossible to alter the existing API, so we have to live with these oddities. But do I have in mind? std::find will look for an element by value, std::find_if takes a predicate. At the same time, std::find_end can either take a value or a predicate. There is no std::find_end_if. While it’s true that std::find_end_if would be a strange name, it would also be more consistent. Wile exclusive_scan can optionally take an initial value and a binary operation in this order, inclusive_scan takes these optional values in the different order, first the binary operation and then the initial value. Maybe it’s just a guarantee that you don’t mix them up accidentally? I found it strange that transform_reduce takes first you pass the reduction algorithm and then the transformation. I think the name is good because first the transformation is applied, then the reduction, but perhaps it should take the two operations in a reversed order. Algos are better than raw loops! No more raw loops as Sean Parent suggested in his talk C++ Seasoning at GoingNative 2013. But why? STL algorithms are less error-prone than raw loops as they were already written and tested - a lot. Thousands if not millions of developers are using them, if there were bugs in these algorithms, they have been already discovered and fixed. Unless you are going for the last drops of performance, algorithms will provide good enough efficiency for you and often they will not just match but outperform simple loops. The most important point is that they are more expressive. It’s straightforward to pick the good among many, but with education and practice, you’ll be able to easily find an algorithm that can replace a for loop in most cases. For more details read this article! Conclusion Thank you for following through this series on STL algorithms where we discussed functions from the &lt;algorithm&gt;, &lt;numeric and &lt;memory&gt; headers. After about 30 parts, today we wrapped up by mentioning once again some important concepts and inconsistencies of algorithms. We discussed how algorithms follow one of the main principles of C++: you don’t pay for what you don’t need. We saw three inconsistencies within the STL, such as sometimes you have to postpend an algorithm with _if to be able to use a unary predicate instead of a value, but sometimes it’s just a different overload. Finally, we reiterated the main reasons why STL algorithms are better than raw loops. Use STL algorithms in your code, no matter if it’s a personal project or at work. They’ll make your code better! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The big STL Algorithms tutorial: wrapping up","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up"},"url":"https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up"}</script><title>The big STL Algorithms tutorial: wrapping up | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/23"> 23 </a> </span> <span>The big STL Algorithms tutorial: wrapping up</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The big STL Algorithms tutorial: wrapping up</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 23, 2022, 12:00 AM +0100" prep="on" > Feb 23, 2022 <i class="unloaded">2022-02-23T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="736 words">4 min</span></div></div><div class="post-content"><p>With the last article on algorithms about <a href="https://www.sandordargo.com/blog/2022/02/02/stl-alogorithms-tutorial-part-30-memory-header">dynamic memory management</a>, we reached the end of a 3-year-long journey that we started at the beginning of 2019.</p><p>Since then, in about 30 different posts, we learned about the algorithms that the STL offers us. We are not going to have a crash course on them, if you are looking for something like that watch Jonathan Boccara’s video from CppCon2018, <a href="https://www.youtube.com/watch?v=2olsGf6JIkU">105 STL Algorithms in Less Than an Hour</a></p><p>Instead, let’s remind us of a couple of key concepts and oddities that we learned along the way.</p><h2 id="you-dont-pay-for-what-you-dont-need">You don’t pay for what you don’t need</h2><p>Standard algorithms showcase perfectly that in C++ you don’t pay for what you don’t need.</p><p>One example like that is bound checks.</p><p>Most of the algorithms that need more than one range take only the first range via two iterators (<code class="language-plaintext highlighter-rouge">begin</code> and <code class="language-plaintext highlighter-rouge">end</code>), the rest is taken only by one iterator, by one that denotes the beginning of the range.</p><p>It’s up to the caller to guarantee that the additional input containers have enough elements or that an output container has enough space to accommodate the results. There are no checks of the sizes, no extra cost for ensuring something that is up to the caller to guarantee.</p><p>While this means potentially undefined behaviour, it also makes the algorithms faster and as the expectations are clearly documented we have nothing to complain about.</p><h2 id="lack-of-consistency-sometimes">Lack of consistency sometimes</h2><p>We’ve also seen that sometimes the STL lacks consistency quite a bit. Even though it is something standardized, it’s been under development for almost 3 decades, so I think it’s normal to end up with some inconsistencies.</p><p>As C++ and the standard library is widely used, it’s almost impossible to alter the existing API, so we have to live with these oddities.</p><p>But do I have in mind?</p><ul><li><code class="language-plaintext highlighter-rouge">std::find</code> will look for an element by value, <code class="language-plaintext highlighter-rouge">std::find_if</code> takes a predicate. At the same time, <code class="language-plaintext highlighter-rouge">std::find_end</code> can either take a value or a predicate. There is no <code class="language-plaintext highlighter-rouge">std::find_end_if</code>. While it’s true that <code class="language-plaintext highlighter-rouge">std::find_end_if</code> would be a strange name, it would also be more consistent.<li>Wile <code class="language-plaintext highlighter-rouge">exclusive_scan</code> can optionally take an initial value and a binary operation in this order, <code class="language-plaintext highlighter-rouge">inclusive_scan</code> takes these optional values in the different order, first the binary operation and then the initial value. Maybe it’s just a guarantee that you don’t mix them up accidentally?<li>I found it strange that <code class="language-plaintext highlighter-rouge">transform_reduce</code> takes first you pass the reduction algorithm and then the transformation. I think the name is good because first the transformation is applied, then the reduction, but perhaps it should take the two operations in a reversed order.</ul><h2 id="algos-are-better-than-raw-loops">Algos are better than raw loops!</h2><p>No more raw loops as Sean Parent suggested in his talk <a href="https://www.youtube.com/watch?v=W2tWOdzgXHA">C++ Seasoning</a> at GoingNative 2013. But why?</p><p>STL algorithms are less error-prone than raw loops as they were already written and tested - a lot. Thousands if not millions of developers are using them, if there were bugs in these algorithms, they have been already discovered and fixed.</p><p>Unless you are going for the last drops of performance, algorithms will provide good enough efficiency for you and often they will not just match but outperform simple loops.</p><p>The most important point is that they are more expressive. It’s straightforward to pick the good among many, but with education and practice, you’ll be able to easily find an algorithm that can replace a for loop in most cases.</p><p>For more details read <a href="https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms">this article</a>!</p><h2 id="conclusion">Conclusion</h2><p>Thank you for following through this series on STL algorithms where we discussed functions from the <code class="language-plaintext highlighter-rouge">&lt;algorithm&gt;</code>, <code class="language-plaintext highlighter-rouge">&lt;numeric</code> and <code class="language-plaintext highlighter-rouge">&lt;memory&gt;</code> headers.</p><p>After about 30 parts, today we wrapped up by mentioning once again some important concepts and inconsistencies of algorithms. We discussed how algorithms follow one of the main principles of C++: you don’t pay for what you don’t need.</p><p>We saw three inconsistencies within the STL, such as sometimes you have to postpend an algorithm with <code class="language-plaintext highlighter-rouge">_if</code> to be able to use a unary predicate instead of a value, but sometimes it’s just a different overload.</p><p>Finally, we reiterated the main reasons why STL algorithms are better than raw loops.</p><p>Use STL algorithms in your code, no matter if it’s a personal project or at work. They’ll make your code better!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/tutorial/" class="post-tag no-text-decoration" >tutorial</a> <a href="/tags/stl/" class="post-tag no-text-decoration" >stl</a> <a href="/tags/algorithms/" class="post-tag no-text-decoration" >algorithms</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The big STL Algorithms tutorial: wrapping up - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The big STL Algorithms tutorial: wrapping up - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The big STL Algorithms tutorial: wrapping up - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The big STL Algorithms tutorial: wrapping up - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2019/01/30/stl-algos-intro"><div class="card-body"> <span class="timeago small" > Jan 30, 2019 <i class="unloaded">2019-01-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: Introduction</h3><div class="text-muted small"><p> I’ve already written quite a few articles about features introduced by C++ 11 and how much it changed how I look at the language. The feature I liked the most is probably the one of lambda expressi...</p></div></div></a></div><div class="card"> <a href="/blog/2019/02/20/stl-algorithm-tutorial-part-1-any-all-none"><div class="card-body"> <span class="timeago small" > Feb 20, 2019 <i class="unloaded">2019-02-20T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: all_of, any_of, none_of</h3><div class="text-muted small"><p> In this first part of the big STL algorithm tutorial, I’ll start with the first chunk of the non-modifying sequence operations. Namely, in this post, you are going to read about all_of, any_of an...</p></div></div></a></div><div class="card"> <a href="/blog/2019/04/03/stl-algorithm-tutorial-part-2-for_each"><div class="card-body"> <span class="timeago small" > Apr 3, 2019 <i class="unloaded">2019-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: for_each</h3><div class="text-muted small"><p> In this next part of the big STL algorithm tutorial, I’ll explain only one function. The for_each algorithm. What does it do? for_each takes a range and a function to apply on each element of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/02/19/system-design-interview-by-alex-xu" class="btn btn-outline-primary" prompt="Older"><p>System Design Interview: An insider's guide by Alex Xu</p></a> <a href="/blog/2022/03/02/mocking-non-virtual-and-free-functions" class="btn btn-outline-primary" prompt="Newer"><p>Mocking virtual functions with gMock</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The big STL Algorithms tutorial: wrapping up'; this.page.url = 'https://www.sandordargo.com/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up'; this.page.identifier = '/blog/2022/02/23/stl-alogorithms-tutorial-part-31-wrap-up'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
