<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Why to use C++ in 2022" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++ is a programming language that is roughly 40 years old and it’s still unavoidable. In this article, we are going to see where and why it’s used and whether it has a future or not. Let’s get into it! Where C++ is used nowadays? C++ is everywhere. Code written in C++ is on your phone, in your washing machine, in your car, in airplanes, in your banks, and really everywhere. Let’s be a bit more specific. Many image-manipulating applications like Adobe Photoshop or Illustrator are written in C++. 3D games are also often written in C++. 3D animations, simulations, and rendering software are also mainly coded in C++. Image manipulation is a somewhat complex and resource-intensive field and it needs the fastness and hardware closeness of C++. But images are not the only field, there is a fair chance that the browser you are using to read this was also written in C++, such as Chrome or Firefox. If we go even lower and look into compilers or the operating system, many of them are written in C++. If not, it’ll most probably be C. But that was only the desktop world. In the world of enterprise software, you’ll of course find other languages, but where performance is critical, C and C++ are the default choice for a good reason. In the embedded world, where both memory and CPU are more limited than on a desktop, C++ thrives. No matter if you look at your smartwatch, your phone, or you turn on your washing machine or get into your car and turn on the ignition, you should feel a bit of grate for the unknown C++ developer who managed not to crash it with a segmentation fault right after startup. Why C++ is used? So we saw that C++ is still used pretty much anywhere. But why? There are so many skeptics out there who think it’s a legacy and should be removed from most of the modern company’s codebase. Because of legacy? Some people claim that C++ is still used only because it’s the inherited technology of old applications. By old, I often mean decades-old software. It’s only partly true. Think about the Cobol Cowboys. Few people know Cobol so if there is a need, they can earn loads of money. And there is a need! Cobol is still widely used in the financial industry. Those systems were written long decades ago and they still work pretty well. Maybe they don’t support all the modern requirements, but they are robust, reliable and so complex that nobody dares to rewrite them. C++ is not so bad, it’s not as old as Cobol, and there are more people learning it and knowing - more or less - how to use it. But it’s sometimes only used because companies are so heavily invested in it. They have their whole ecosystems evolved around C++. It’d be very costly to migrate away. Even decision-makers who don’t find C++ sexy enough would find such a migration economically nonsense. But is C++ such a legacy? C++ is evolving Not at all! C++ is predictably evolving. As I explained in detail in one of my previous articles, since 2011 C++ follows a train-like model. Every three years there is a new version released with new language and library features and with bug fixes of earlier features. The release schedule and the standardized work guarantee that the versions are the results of well-thought additions, instead of ad hoc decisions. Compiler implementors have the time to implement them properly and also the community has the time to adapt. At the same time, one of the C++ superpowers is backward compatibility. Code that compiled yesterday will most probably compile tomorrow. In fact, code that compiled in 1985 will most probably compile in 2025. The evolution of C++ has been targetting to remove the pain points of the developers and write safer code easier. One of the most important features of C++ is predictable memory management. There is no garbage collection that happens eventually (or not). It’s deterministic when and how memory will be released and given back to the operating system. While it was always perfectly deterministic, it was also quite easy to shoot yourself in the leg and mess it up by not freeing up the memory or trying to release it twice or even more times… Modern C++ introduced smart pointers that made dynamic memory management way less error-prone by adding pointers that can clean up after themselves. Another pain point for many developers has been related to templates. SFINAE, incredibly long and difficult-to-read error messages are less and less of a problem with the introduction of C++20 concepts that help us constrain the types accepted by templates and provide relevant and relatively easy-to-read error messages if something still goes wrong. During the last years, there were some big works ongoing to introduce the &lt;ranges&gt; library with which we can replace very procedural loops with a functional style. The economic advantage… C++ is close to the hardware, can easily manipulate resources, provide procedural programming over CPU-intensive functions, and is fast. It is also able to handle the complexities of 3D games and it provides multilayer networking. All these benefits of C++ make it a primary choice for developing gaming systems as well as game development suites. If you use a so-called modern language such as Python or Javascript, often you’ll fall back to writing some critical functionalities or libraries in C or in C++ just to make their speed acceptable. There are very few languages that can compete with C++ in terms of speed and one of them is C. But speed is not everything. You might say that well, you don’t care about the speed that much. You only want to serve that many transactions, you don’t have such constraints on speed. You prefer code that is easy to develop. Understandable. As we saw earlier, C++ is becoming easier and easier to develop. Of course, the ease of writing modern C++ is nowhere like that of Python, but things are not black and white. Some modern languages focus on the ease of writing code, some others focus on great functionalities. When you choose a car, you don’t only think about comfort or speed, though those can be quite important. More often than not, you’ll also have to think about fuel consumption. Do we do the same thing when we write an application? Do we think about how much energy they would consume? In that sense, the C/C++/Rust trio is performing way better than all the other languages. Basically, they play a different game. The above numbers are quite impressive. Now let’s look at this slide that was presented at CPPP by Damien Buhl. By using C++, we can save lots of CO2 emissions which is quite shocking. So it seems that in many cases even if your performance requirements do not, energy consumption and environment protection point towards the usage of C++. What are the drawbacks? If C++ is evolving and becoming easier to write and in addition, if it’s even good for energy bills and therefore the planet, what’s the problem? Why are people so reluctant to use it? Let’s see a couple of things. Bad press… Let’s face it, C++ has a bad reputation. If you read Coders At Work, there are many who wrote that C and C++ are too difficult to use and there are only a few reasons to do so. With C it’s very easy to shoot yourself in the leg, with C++ it’s a bit more difficult, but when you do, you blow your leg completely off. Not a very reassuring thing to say. These comments were definitely true, but they are less and less so. The language evolves, but the old books and the interviews will not go away. It’s very difficult to change public opinion, especially among those who don’t code anymore. Like most of the decision-makers. While the language is evolving, it’s getting more difficult to learn As I wrote several times earlier, C++ is evolving. It gets more and more features, and it’s becoming easier and easier to write expressive code. What used to be a raw loop today can be written in such a functional way: 1 2 3 4 5 6 7 8 9 10 11 12 13 const std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5}; // instead of auto count = 0; for (const auto&amp; n : numbers) { if ( n % 2 == 0) { ++count; } } // now we can write auto isEven = [](auto number) { return number % 2 == 0; }; auto count = std::ranges::count_if(numbers, isEven); While this is all fine and dandy, it also means that those who want to write better C++ code, have to learn more. Many think that C++’s biggest superpower is the fact that it’s almost completely backward-compatible. Such an important feature that Matt Godbolt dedicated to it almost all his keynote at CPPP 2021! It’s true that certain old best practices became antipatterns over time. But they still compile, they are still valid syntax, usually basic syntax, so we have to learn them. Maybe you don’t need to do pointer arithmetics anymore at least not so much, but you still need to know about it. The same goes for manual memory management, C-style arrays, and so on. I do think that such topics should not be taught in-depth, but from what I can see, most universities teach legacy C++ and people have to relearn modern C++ at companies. If the company happens to use a more modern version… Intellectual neglige As Marek Krajewski shared with me on Twitter, some people would simply not use C++ out of intellectual laziness. Yes, it’s more difficult to learn than Python or Javascript. Yes, you can build great things with the simpler-to-learn alternatives. And in fact, you don’t always need the powers of C++. That’s all true. You should use the right tool for the right job. The problem is that many are simply lazy to learn those tools or accept that sometimes those are the right tools. This happens often because of bigotry, because of narrowmindedness, and basically because of intellectual negligence. It’s our job to show, to explain when C++ (or Rust…) is an overkill, and when it is the right solution. More importantly, we have to show that it’s not the same language that it was. Ecosystem In his talk, C++ MythBusters, Victor Ciura busted the myth that C++ is not easily toolable. It is toolable and we have plenty of tools. Victor thinks that we are never going to have “standardized” tools, we always have to find the right tool and understand how it works and leverage it. While I share his view, we must admit that other languages have simpler solutions for simple problems. If you work with Python, you know exactly how and from where you should get your packages. That’s similar to Java, not to mention Javascript. These languages are not standardized, but they have standard ways to easily deliver and use libraries, to share and build code in a way that doesn’t take a long time to grasp. That’s clearly not the case for C++. Writing makefiles is difficult. Many accept CMake as the de facto standard to write build scripts, but it’s clearly not the case. Many don’t like it due to its syntax and there are many different ways to generate your build scripts. Many companies have their own systems - including Amadeus. What about package management? Well, there is Conan, vcpkg, but they don’t have the maturity as yarn, npm, PyPI or maven have. C++ has still some way to go. So the future? I asked around among some of the prominent figures of the C++ community, and here is what they said: C++, today, remains truer than ever to its original mission of providing zero-cost abstractions over low-level systems code, where possible, and low-cost abstractions that you only pay for when you use them the rest of the time. It does this while maintaining compatibility with C and earlier versions of C++ - despite constantly evolving and adopting surprisingly modern language features. - Phil Nash, author of Catch2, main organizer of C++ On Sea C++ is both our legacy and our future. For all its warts and historical problems, it has an abundance of modern features many of them specially designed to mitigate/replace old idioms/constructs. C++ programmers nowadays can easily write programs completely avoiding such perilous old things. […] The C++ STL has grown a lot with the ISO standards 11,14,17,20 and more valuable additions are coming in C++23. From new algorithms and ranges to various utilities and support libraries for IO, networking, coroutines, concurrency, heterogenous parallelism and more. Yes, there are more specialized things a programmer might need, but this is where the C++ echo-system comes in to fill the gaps with a plethora of industry-grade (and stable) libraries for all sorts of necessities. Every important piece of software we use today has some C++ in it: maybe it’s all C++, maybe it has some important components in C++, maybe its library is natively compiled in C++, maybe it’s compiler/runtime is written in C++, … C++ is still the King of programming languages. Long live the King! - Victor Ciura, Senior Software Engineer in Visual C++ team at Microsoft C++ is used in game development extensively, for console and PC games particularly. It allows direct access to hardware through zero-cost abstractions. The power and flexibility it grants make it a hard language to learn because more decisions are placed in your hands about what to do. As an international standard with a commitment to backwards compatibility, you know that there isn’t going to be a Python2/Python3 situation. The future is looking bright, with concurrency and networking looking promising for C++26 and a host of features designed to streamline and simplify the language. - J. Guy Davidson, Head of Engineering Practice at Creative Assembly, Co-author of Beautiful C++, ISO C++ Committee voting member Conclusion C++ might be considered legacy by those who were familiar only with the old patterns, with the old standards, but the language is evolving. Since 2011, since C+11, we get a new version every 3 years with bugfixes and new features. The ecosystem is growing, even though it’s far from being as straightforward as some of the other newer languages where for example package management is done the same way everywhere. Still, the language, the ecosystem is growing, the community is strong and C++ is everywhere, it’s unavoidable. It’s somehow part of almost every written software. I’m not saying that C++ is the hammer that should make everything a nail around you, but it’s something still worth learning and mastering. Even in 2022 and onwards. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="C++ is a programming language that is roughly 40 years old and it’s still unavoidable. In this article, we are going to see where and why it’s used and whether it has a future or not. Let’s get into it! Where C++ is used nowadays? C++ is everywhere. Code written in C++ is on your phone, in your washing machine, in your car, in airplanes, in your banks, and really everywhere. Let’s be a bit more specific. Many image-manipulating applications like Adobe Photoshop or Illustrator are written in C++. 3D games are also often written in C++. 3D animations, simulations, and rendering software are also mainly coded in C++. Image manipulation is a somewhat complex and resource-intensive field and it needs the fastness and hardware closeness of C++. But images are not the only field, there is a fair chance that the browser you are using to read this was also written in C++, such as Chrome or Firefox. If we go even lower and look into compilers or the operating system, many of them are written in C++. If not, it’ll most probably be C. But that was only the desktop world. In the world of enterprise software, you’ll of course find other languages, but where performance is critical, C and C++ are the default choice for a good reason. In the embedded world, where both memory and CPU are more limited than on a desktop, C++ thrives. No matter if you look at your smartwatch, your phone, or you turn on your washing machine or get into your car and turn on the ignition, you should feel a bit of grate for the unknown C++ developer who managed not to crash it with a segmentation fault right after startup. Why C++ is used? So we saw that C++ is still used pretty much anywhere. But why? There are so many skeptics out there who think it’s a legacy and should be removed from most of the modern company’s codebase. Because of legacy? Some people claim that C++ is still used only because it’s the inherited technology of old applications. By old, I often mean decades-old software. It’s only partly true. Think about the Cobol Cowboys. Few people know Cobol so if there is a need, they can earn loads of money. And there is a need! Cobol is still widely used in the financial industry. Those systems were written long decades ago and they still work pretty well. Maybe they don’t support all the modern requirements, but they are robust, reliable and so complex that nobody dares to rewrite them. C++ is not so bad, it’s not as old as Cobol, and there are more people learning it and knowing - more or less - how to use it. But it’s sometimes only used because companies are so heavily invested in it. They have their whole ecosystems evolved around C++. It’d be very costly to migrate away. Even decision-makers who don’t find C++ sexy enough would find such a migration economically nonsense. But is C++ such a legacy? C++ is evolving Not at all! C++ is predictably evolving. As I explained in detail in one of my previous articles, since 2011 C++ follows a train-like model. Every three years there is a new version released with new language and library features and with bug fixes of earlier features. The release schedule and the standardized work guarantee that the versions are the results of well-thought additions, instead of ad hoc decisions. Compiler implementors have the time to implement them properly and also the community has the time to adapt. At the same time, one of the C++ superpowers is backward compatibility. Code that compiled yesterday will most probably compile tomorrow. In fact, code that compiled in 1985 will most probably compile in 2025. The evolution of C++ has been targetting to remove the pain points of the developers and write safer code easier. One of the most important features of C++ is predictable memory management. There is no garbage collection that happens eventually (or not). It’s deterministic when and how memory will be released and given back to the operating system. While it was always perfectly deterministic, it was also quite easy to shoot yourself in the leg and mess it up by not freeing up the memory or trying to release it twice or even more times… Modern C++ introduced smart pointers that made dynamic memory management way less error-prone by adding pointers that can clean up after themselves. Another pain point for many developers has been related to templates. SFINAE, incredibly long and difficult-to-read error messages are less and less of a problem with the introduction of C++20 concepts that help us constrain the types accepted by templates and provide relevant and relatively easy-to-read error messages if something still goes wrong. During the last years, there were some big works ongoing to introduce the &lt;ranges&gt; library with which we can replace very procedural loops with a functional style. The economic advantage… C++ is close to the hardware, can easily manipulate resources, provide procedural programming over CPU-intensive functions, and is fast. It is also able to handle the complexities of 3D games and it provides multilayer networking. All these benefits of C++ make it a primary choice for developing gaming systems as well as game development suites. If you use a so-called modern language such as Python or Javascript, often you’ll fall back to writing some critical functionalities or libraries in C or in C++ just to make their speed acceptable. There are very few languages that can compete with C++ in terms of speed and one of them is C. But speed is not everything. You might say that well, you don’t care about the speed that much. You only want to serve that many transactions, you don’t have such constraints on speed. You prefer code that is easy to develop. Understandable. As we saw earlier, C++ is becoming easier and easier to develop. Of course, the ease of writing modern C++ is nowhere like that of Python, but things are not black and white. Some modern languages focus on the ease of writing code, some others focus on great functionalities. When you choose a car, you don’t only think about comfort or speed, though those can be quite important. More often than not, you’ll also have to think about fuel consumption. Do we do the same thing when we write an application? Do we think about how much energy they would consume? In that sense, the C/C++/Rust trio is performing way better than all the other languages. Basically, they play a different game. The above numbers are quite impressive. Now let’s look at this slide that was presented at CPPP by Damien Buhl. By using C++, we can save lots of CO2 emissions which is quite shocking. So it seems that in many cases even if your performance requirements do not, energy consumption and environment protection point towards the usage of C++. What are the drawbacks? If C++ is evolving and becoming easier to write and in addition, if it’s even good for energy bills and therefore the planet, what’s the problem? Why are people so reluctant to use it? Let’s see a couple of things. Bad press… Let’s face it, C++ has a bad reputation. If you read Coders At Work, there are many who wrote that C and C++ are too difficult to use and there are only a few reasons to do so. With C it’s very easy to shoot yourself in the leg, with C++ it’s a bit more difficult, but when you do, you blow your leg completely off. Not a very reassuring thing to say. These comments were definitely true, but they are less and less so. The language evolves, but the old books and the interviews will not go away. It’s very difficult to change public opinion, especially among those who don’t code anymore. Like most of the decision-makers. While the language is evolving, it’s getting more difficult to learn As I wrote several times earlier, C++ is evolving. It gets more and more features, and it’s becoming easier and easier to write expressive code. What used to be a raw loop today can be written in such a functional way: 1 2 3 4 5 6 7 8 9 10 11 12 13 const std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5}; // instead of auto count = 0; for (const auto&amp; n : numbers) { if ( n % 2 == 0) { ++count; } } // now we can write auto isEven = [](auto number) { return number % 2 == 0; }; auto count = std::ranges::count_if(numbers, isEven); While this is all fine and dandy, it also means that those who want to write better C++ code, have to learn more. Many think that C++’s biggest superpower is the fact that it’s almost completely backward-compatible. Such an important feature that Matt Godbolt dedicated to it almost all his keynote at CPPP 2021! It’s true that certain old best practices became antipatterns over time. But they still compile, they are still valid syntax, usually basic syntax, so we have to learn them. Maybe you don’t need to do pointer arithmetics anymore at least not so much, but you still need to know about it. The same goes for manual memory management, C-style arrays, and so on. I do think that such topics should not be taught in-depth, but from what I can see, most universities teach legacy C++ and people have to relearn modern C++ at companies. If the company happens to use a more modern version… Intellectual neglige As Marek Krajewski shared with me on Twitter, some people would simply not use C++ out of intellectual laziness. Yes, it’s more difficult to learn than Python or Javascript. Yes, you can build great things with the simpler-to-learn alternatives. And in fact, you don’t always need the powers of C++. That’s all true. You should use the right tool for the right job. The problem is that many are simply lazy to learn those tools or accept that sometimes those are the right tools. This happens often because of bigotry, because of narrowmindedness, and basically because of intellectual negligence. It’s our job to show, to explain when C++ (or Rust…) is an overkill, and when it is the right solution. More importantly, we have to show that it’s not the same language that it was. Ecosystem In his talk, C++ MythBusters, Victor Ciura busted the myth that C++ is not easily toolable. It is toolable and we have plenty of tools. Victor thinks that we are never going to have “standardized” tools, we always have to find the right tool and understand how it works and leverage it. While I share his view, we must admit that other languages have simpler solutions for simple problems. If you work with Python, you know exactly how and from where you should get your packages. That’s similar to Java, not to mention Javascript. These languages are not standardized, but they have standard ways to easily deliver and use libraries, to share and build code in a way that doesn’t take a long time to grasp. That’s clearly not the case for C++. Writing makefiles is difficult. Many accept CMake as the de facto standard to write build scripts, but it’s clearly not the case. Many don’t like it due to its syntax and there are many different ways to generate your build scripts. Many companies have their own systems - including Amadeus. What about package management? Well, there is Conan, vcpkg, but they don’t have the maturity as yarn, npm, PyPI or maven have. C++ has still some way to go. So the future? I asked around among some of the prominent figures of the C++ community, and here is what they said: C++, today, remains truer than ever to its original mission of providing zero-cost abstractions over low-level systems code, where possible, and low-cost abstractions that you only pay for when you use them the rest of the time. It does this while maintaining compatibility with C and earlier versions of C++ - despite constantly evolving and adopting surprisingly modern language features. - Phil Nash, author of Catch2, main organizer of C++ On Sea C++ is both our legacy and our future. For all its warts and historical problems, it has an abundance of modern features many of them specially designed to mitigate/replace old idioms/constructs. C++ programmers nowadays can easily write programs completely avoiding such perilous old things. […] The C++ STL has grown a lot with the ISO standards 11,14,17,20 and more valuable additions are coming in C++23. From new algorithms and ranges to various utilities and support libraries for IO, networking, coroutines, concurrency, heterogenous parallelism and more. Yes, there are more specialized things a programmer might need, but this is where the C++ echo-system comes in to fill the gaps with a plethora of industry-grade (and stable) libraries for all sorts of necessities. Every important piece of software we use today has some C++ in it: maybe it’s all C++, maybe it has some important components in C++, maybe its library is natively compiled in C++, maybe it’s compiler/runtime is written in C++, … C++ is still the King of programming languages. Long live the King! - Victor Ciura, Senior Software Engineer in Visual C++ team at Microsoft C++ is used in game development extensively, for console and PC games particularly. It allows direct access to hardware through zero-cost abstractions. The power and flexibility it grants make it a hard language to learn because more decisions are placed in your hands about what to do. As an international standard with a commitment to backwards compatibility, you know that there isn’t going to be a Python2/Python3 situation. The future is looking bright, with concurrency and networking looking promising for C++26 and a host of features designed to streamline and simplify the language. - J. Guy Davidson, Head of Engineering Practice at Creative Assembly, Co-author of Beautiful C++, ISO C++ Committee voting member Conclusion C++ might be considered legacy by those who were familiar only with the old patterns, with the old standards, but the language is evolving. Since 2011, since C+11, we get a new version every 3 years with bugfixes and new features. The ecosystem is growing, even though it’s far from being as straightforward as some of the other newer languages where for example package management is done the same way everywhere. Still, the language, the ecosystem is growing, the community is strong and C++ is everywhere, it’s unavoidable. It’s somehow part of almost every written software. I’m not saying that C++ is the hammer that should make everything a nail around you, but it’s something still worth learning and mastering. Even in 2022 and onwards. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-09T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Why to use C++ in 2022" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-09T19:34:28+01:00","datePublished":"2022-11-09T00:00:00+01:00","description":"C++ is a programming language that is roughly 40 years old and it’s still unavoidable. In this article, we are going to see where and why it’s used and whether it has a future or not. Let’s get into it! Where C++ is used nowadays? C++ is everywhere. Code written in C++ is on your phone, in your washing machine, in your car, in airplanes, in your banks, and really everywhere. Let’s be a bit more specific. Many image-manipulating applications like Adobe Photoshop or Illustrator are written in C++. 3D games are also often written in C++. 3D animations, simulations, and rendering software are also mainly coded in C++. Image manipulation is a somewhat complex and resource-intensive field and it needs the fastness and hardware closeness of C++. But images are not the only field, there is a fair chance that the browser you are using to read this was also written in C++, such as Chrome or Firefox. If we go even lower and look into compilers or the operating system, many of them are written in C++. If not, it’ll most probably be C. But that was only the desktop world. In the world of enterprise software, you’ll of course find other languages, but where performance is critical, C and C++ are the default choice for a good reason. In the embedded world, where both memory and CPU are more limited than on a desktop, C++ thrives. No matter if you look at your smartwatch, your phone, or you turn on your washing machine or get into your car and turn on the ignition, you should feel a bit of grate for the unknown C++ developer who managed not to crash it with a segmentation fault right after startup. Why C++ is used? So we saw that C++ is still used pretty much anywhere. But why? There are so many skeptics out there who think it’s a legacy and should be removed from most of the modern company’s codebase. Because of legacy? Some people claim that C++ is still used only because it’s the inherited technology of old applications. By old, I often mean decades-old software. It’s only partly true. Think about the Cobol Cowboys. Few people know Cobol so if there is a need, they can earn loads of money. And there is a need! Cobol is still widely used in the financial industry. Those systems were written long decades ago and they still work pretty well. Maybe they don’t support all the modern requirements, but they are robust, reliable and so complex that nobody dares to rewrite them. C++ is not so bad, it’s not as old as Cobol, and there are more people learning it and knowing - more or less - how to use it. But it’s sometimes only used because companies are so heavily invested in it. They have their whole ecosystems evolved around C++. It’d be very costly to migrate away. Even decision-makers who don’t find C++ sexy enough would find such a migration economically nonsense. But is C++ such a legacy? C++ is evolving Not at all! C++ is predictably evolving. As I explained in detail in one of my previous articles, since 2011 C++ follows a train-like model. Every three years there is a new version released with new language and library features and with bug fixes of earlier features. The release schedule and the standardized work guarantee that the versions are the results of well-thought additions, instead of ad hoc decisions. Compiler implementors have the time to implement them properly and also the community has the time to adapt. At the same time, one of the C++ superpowers is backward compatibility. Code that compiled yesterday will most probably compile tomorrow. In fact, code that compiled in 1985 will most probably compile in 2025. The evolution of C++ has been targetting to remove the pain points of the developers and write safer code easier. One of the most important features of C++ is predictable memory management. There is no garbage collection that happens eventually (or not). It’s deterministic when and how memory will be released and given back to the operating system. While it was always perfectly deterministic, it was also quite easy to shoot yourself in the leg and mess it up by not freeing up the memory or trying to release it twice or even more times… Modern C++ introduced smart pointers that made dynamic memory management way less error-prone by adding pointers that can clean up after themselves. Another pain point for many developers has been related to templates. SFINAE, incredibly long and difficult-to-read error messages are less and less of a problem with the introduction of C++20 concepts that help us constrain the types accepted by templates and provide relevant and relatively easy-to-read error messages if something still goes wrong. During the last years, there were some big works ongoing to introduce the &lt;ranges&gt; library with which we can replace very procedural loops with a functional style. The economic advantage… C++ is close to the hardware, can easily manipulate resources, provide procedural programming over CPU-intensive functions, and is fast. It is also able to handle the complexities of 3D games and it provides multilayer networking. All these benefits of C++ make it a primary choice for developing gaming systems as well as game development suites. If you use a so-called modern language such as Python or Javascript, often you’ll fall back to writing some critical functionalities or libraries in C or in C++ just to make their speed acceptable. There are very few languages that can compete with C++ in terms of speed and one of them is C. But speed is not everything. You might say that well, you don’t care about the speed that much. You only want to serve that many transactions, you don’t have such constraints on speed. You prefer code that is easy to develop. Understandable. As we saw earlier, C++ is becoming easier and easier to develop. Of course, the ease of writing modern C++ is nowhere like that of Python, but things are not black and white. Some modern languages focus on the ease of writing code, some others focus on great functionalities. When you choose a car, you don’t only think about comfort or speed, though those can be quite important. More often than not, you’ll also have to think about fuel consumption. Do we do the same thing when we write an application? Do we think about how much energy they would consume? In that sense, the C/C++/Rust trio is performing way better than all the other languages. Basically, they play a different game. The above numbers are quite impressive. Now let’s look at this slide that was presented at CPPP by Damien Buhl. By using C++, we can save lots of CO2 emissions which is quite shocking. So it seems that in many cases even if your performance requirements do not, energy consumption and environment protection point towards the usage of C++. What are the drawbacks? If C++ is evolving and becoming easier to write and in addition, if it’s even good for energy bills and therefore the planet, what’s the problem? Why are people so reluctant to use it? Let’s see a couple of things. Bad press… Let’s face it, C++ has a bad reputation. If you read Coders At Work, there are many who wrote that C and C++ are too difficult to use and there are only a few reasons to do so. With C it’s very easy to shoot yourself in the leg, with C++ it’s a bit more difficult, but when you do, you blow your leg completely off. Not a very reassuring thing to say. These comments were definitely true, but they are less and less so. The language evolves, but the old books and the interviews will not go away. It’s very difficult to change public opinion, especially among those who don’t code anymore. Like most of the decision-makers. While the language is evolving, it’s getting more difficult to learn As I wrote several times earlier, C++ is evolving. It gets more and more features, and it’s becoming easier and easier to write expressive code. What used to be a raw loop today can be written in such a functional way: 1 2 3 4 5 6 7 8 9 10 11 12 13 const std::vector&lt;int&gt; numbers = {1, 2, 3, 4, 5}; // instead of auto count = 0; for (const auto&amp; n : numbers) { if ( n % 2 == 0) { ++count; } } // now we can write auto isEven = [](auto number) { return number % 2 == 0; }; auto count = std::ranges::count_if(numbers, isEven); While this is all fine and dandy, it also means that those who want to write better C++ code, have to learn more. Many think that C++’s biggest superpower is the fact that it’s almost completely backward-compatible. Such an important feature that Matt Godbolt dedicated to it almost all his keynote at CPPP 2021! It’s true that certain old best practices became antipatterns over time. But they still compile, they are still valid syntax, usually basic syntax, so we have to learn them. Maybe you don’t need to do pointer arithmetics anymore at least not so much, but you still need to know about it. The same goes for manual memory management, C-style arrays, and so on. I do think that such topics should not be taught in-depth, but from what I can see, most universities teach legacy C++ and people have to relearn modern C++ at companies. If the company happens to use a more modern version… Intellectual neglige As Marek Krajewski shared with me on Twitter, some people would simply not use C++ out of intellectual laziness. Yes, it’s more difficult to learn than Python or Javascript. Yes, you can build great things with the simpler-to-learn alternatives. And in fact, you don’t always need the powers of C++. That’s all true. You should use the right tool for the right job. The problem is that many are simply lazy to learn those tools or accept that sometimes those are the right tools. This happens often because of bigotry, because of narrowmindedness, and basically because of intellectual negligence. It’s our job to show, to explain when C++ (or Rust…) is an overkill, and when it is the right solution. More importantly, we have to show that it’s not the same language that it was. Ecosystem In his talk, C++ MythBusters, Victor Ciura busted the myth that C++ is not easily toolable. It is toolable and we have plenty of tools. Victor thinks that we are never going to have “standardized” tools, we always have to find the right tool and understand how it works and leverage it. While I share his view, we must admit that other languages have simpler solutions for simple problems. If you work with Python, you know exactly how and from where you should get your packages. That’s similar to Java, not to mention Javascript. These languages are not standardized, but they have standard ways to easily deliver and use libraries, to share and build code in a way that doesn’t take a long time to grasp. That’s clearly not the case for C++. Writing makefiles is difficult. Many accept CMake as the de facto standard to write build scripts, but it’s clearly not the case. Many don’t like it due to its syntax and there are many different ways to generate your build scripts. Many companies have their own systems - including Amadeus. What about package management? Well, there is Conan, vcpkg, but they don’t have the maturity as yarn, npm, PyPI or maven have. C++ has still some way to go. So the future? I asked around among some of the prominent figures of the C++ community, and here is what they said: C++, today, remains truer than ever to its original mission of providing zero-cost abstractions over low-level systems code, where possible, and low-cost abstractions that you only pay for when you use them the rest of the time. It does this while maintaining compatibility with C and earlier versions of C++ - despite constantly evolving and adopting surprisingly modern language features. - Phil Nash, author of Catch2, main organizer of C++ On Sea C++ is both our legacy and our future. For all its warts and historical problems, it has an abundance of modern features many of them specially designed to mitigate/replace old idioms/constructs. C++ programmers nowadays can easily write programs completely avoiding such perilous old things. […] The C++ STL has grown a lot with the ISO standards 11,14,17,20 and more valuable additions are coming in C++23. From new algorithms and ranges to various utilities and support libraries for IO, networking, coroutines, concurrency, heterogenous parallelism and more. Yes, there are more specialized things a programmer might need, but this is where the C++ echo-system comes in to fill the gaps with a plethora of industry-grade (and stable) libraries for all sorts of necessities. Every important piece of software we use today has some C++ in it: maybe it’s all C++, maybe it has some important components in C++, maybe its library is natively compiled in C++, maybe it’s compiler/runtime is written in C++, … C++ is still the King of programming languages. Long live the King! - Victor Ciura, Senior Software Engineer in Visual C++ team at Microsoft C++ is used in game development extensively, for console and PC games particularly. It allows direct access to hardware through zero-cost abstractions. The power and flexibility it grants make it a hard language to learn because more decisions are placed in your hands about what to do. As an international standard with a commitment to backwards compatibility, you know that there isn’t going to be a Python2/Python3 situation. The future is looking bright, with concurrency and networking looking promising for C++26 and a host of features designed to streamline and simplify the language. - J. Guy Davidson, Head of Engineering Practice at Creative Assembly, Co-author of Beautiful C++, ISO C++ Committee voting member Conclusion C++ might be considered legacy by those who were familiar only with the old patterns, with the old standards, but the language is evolving. Since 2011, since C+11, we get a new version every 3 years with bugfixes and new features. The ecosystem is growing, even though it’s far from being as straightforward as some of the other newer languages where for example package management is done the same way everywhere. Still, the language, the ecosystem is growing, the community is strong and C++ is everywhere, it’s unavoidable. It’s somehow part of almost every written software. I’m not saying that C++ is the hammer that should make everything a nail around you, but it’s something still worth learning and mastering. Even in 2022 and onwards. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Why to use C++ in 2022","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022"},"url":"https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022"}</script><title>Why to use C++ in 2022 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/09"> 09 </a> </span> <span>Why to use C++ in 2022</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Why to use C++ in 2022</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 9, 2022, 12:00 AM +0100" prep="on" > Nov 9, 2022 <i class="unloaded">2022-11-09T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 9, 2022, 7:34 PM +0100" prefix="Updated " > Nov 9, 2022 <i class="unloaded">2022-11-09T19:34:28+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2501 words">13 min</span></div></div><div class="post-content"><p>C++ is a programming language that is roughly 40 years old and it’s still unavoidable. In this article, we are going to see where and why it’s used and whether it has a future or not.</p><p>Let’s get into it!</p><h2 id="where-c-is-used-nowadays">Where C++ is used nowadays?</h2><p>C++ is everywhere. Code written in C++ is on your phone, in your washing machine, in your car, in airplanes, in your banks, and really everywhere.</p><p>Let’s be a bit more specific. Many image-manipulating applications like Adobe Photoshop or Illustrator are written in C++. 3D games are also often written in C++. 3D animations, simulations, and rendering software are also mainly coded in C++. Image manipulation is a somewhat complex and resource-intensive field and it needs the fastness and hardware closeness of C++.</p><p>But images are not the only field, there is a fair chance that the browser you are using to read this was also written in C++, such as Chrome or Firefox.</p><p>If we go even lower and look into compilers or the operating system, many of them are written in C++. If not, it’ll most probably be C.</p><p>But that was only the desktop world.</p><p>In the world of enterprise software, you’ll of course find other languages, but where performance is critical, C and C++ are the default choice for a good reason.</p><p>In the embedded world, where both memory and CPU are more limited than on a desktop, C++ thrives. No matter if you look at your smartwatch, your phone, or you turn on your washing machine or get into your car and turn on the ignition, you should feel a bit of grate for the unknown C++ developer who managed not to crash it with a segmentation fault right after startup.</p><h2 id="why-c-is-used">Why C++ is used?</h2><p>So we saw that C++ is still used pretty much anywhere. But why? There are so many skeptics out there who think it’s a legacy and should be removed from most of the modern company’s codebase.</p><h3 id="because-of-legacy">Because of legacy?</h3><p>Some people claim that C++ is still used only because it’s the inherited technology of old applications. By old, I often mean decades-old software.</p><p>It’s only partly true.</p><p>Think about the <a href="http://cobolcowboys.com/">Cobol Cowboys</a>. Few people know Cobol so if there is a need, they can earn loads of money.</p><p>And there is a need!</p><p>Cobol is still widely used in the financial industry. Those systems were written long decades ago and they still work pretty well. Maybe they don’t support all the modern requirements, but they are robust, reliable and so complex that nobody dares to rewrite them.</p><p>C++ is not so bad, it’s not as old as Cobol, and there are more people learning it and knowing - more or less - how to use it.</p><p>But it’s sometimes only used because companies are so heavily invested in it. They have their whole ecosystems evolved around C++. It’d be very costly to migrate away. Even decision-makers who don’t find C++ sexy enough would find such a migration economically nonsense.</p><p>But is C++ such a legacy?</p><h3 id="c-is-evolving">C++ is evolving</h3><p>Not at all! C++ is predictably evolving. As I explained in detail <a href="https://www.sandordargo.com/blog/2022/06/29/cpp-standardized">in one of my previous articles</a>, since 2011 C++ follows a train-like model. Every three years there is a new version released with new language and library features and with bug fixes of earlier features.</p><p>The release schedule and the standardized work guarantee that the versions are the results of well-thought additions, instead of ad hoc decisions. Compiler implementors have the time to implement them properly and also the community has the time to adapt.</p><p>At the same time, one of the C++ superpowers is backward compatibility. Code that compiled yesterday will most probably compile tomorrow. In fact, code that compiled in 1985 will most probably compile in 2025.</p><p>The evolution of C++ has been targetting to remove the pain points of the developers and write safer code easier.</p><p>One of the most important features of C++ is predictable memory management. There is no garbage collection that happens eventually (or not). It’s deterministic when and how memory will be released and given back to the operating system. While it was always perfectly deterministic, it was also quite easy to shoot yourself in the leg and mess it up by not freeing up the memory or trying to release it twice or even more times…</p><p>Modern C++ introduced smart pointers that made dynamic memory management way less error-prone by adding pointers that can clean up after themselves.</p><p>Another pain point for many developers has been related to templates. <a href="https://en.cppreference.com/w/cpp/language/sfinae">SFINAE</a>, incredibly long and difficult-to-read error messages are less and less of a problem with the introduction of <a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">C++20 concepts</a> that help us constrain the types accepted by templates and provide relevant and relatively easy-to-read error messages if something still goes wrong.</p><p>During the last years, there were some big works ongoing to introduce the <a href="https://en.cppreference.com/w/cpp/ranges"><code class="language-plaintext highlighter-rouge">&lt;ranges&gt;</code> library</a> with which we can replace very procedural loops with a functional style.</p><h3 id="the-economic-advantage">The economic advantage…</h3><p>C++ is close to the hardware, can easily manipulate resources, provide procedural programming over CPU-intensive functions, and is fast. It is also able to handle the complexities of 3D games and it provides multilayer networking. All these benefits of C++ make it a primary choice for developing gaming systems as well as game development suites.</p><p>If you use a so-called modern language such as Python or Javascript, often you’ll fall back to writing some critical functionalities or libraries in C or in C++ just to make their speed acceptable.</p><p>There are very few languages that can compete with C++ in terms of speed and <a href="https://thenewstack.io/which-programming-languages-use-the-least-electricity/?s=09">one of them is C</a>.</p><p>But speed is not everything.</p><p>You might say that well, you don’t care about the speed that much. You only want to serve that many transactions, you don’t have such constraints on speed. You prefer code that is easy to develop.</p><p>Understandable.</p><p>As we saw earlier, C++ is becoming easier and easier to develop. Of course, the ease of writing modern C++ is nowhere like that of Python, but things are not black and white.</p><p>Some modern languages focus on the ease of writing code, some others focus on great functionalities.</p><p>When you choose a car, you don’t only think about comfort or speed, though those can be quite important. More often than not, you’ll also have to think about fuel consumption. Do we do the same thing when we write an application? Do we think about how much energy they would consume? In that sense, the C/C++/Rust trio is performing way better than all the other languages. Basically, they play a different game.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/energy-time-memory.png" alt="Carbon footprint" /></p><p>The above numbers are quite impressive.</p><p>Now let’s look at this slide that was presented at CPPP by Damien Buhl.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/carbon_footprint.png" alt="Carbon footprint" /></p><p>By using C++, we can save lots of CO2 emissions which is quite shocking.</p><p>So it seems that in many cases even if your performance requirements do not, energy consumption and environment protection point towards the usage of C++.</p><h2 id="what-are-the-drawbacks">What are the drawbacks?</h2><p>If C++ is evolving and becoming easier to write and in addition, if it’s even good for energy bills and therefore the planet, what’s the problem? Why are people so reluctant to use it?</p><p>Let’s see a couple of things.</p><h3 id="bad-press">Bad press…</h3><p>Let’s face it, C++ has a bad reputation.</p><p>If you read <a href="http://amzn.to/2wKEeVt">Coders At Work</a>, there are many who wrote that C and C++ are too difficult to use and there are only a few reasons to do so. With C it’s very easy to shoot yourself in the leg, with C++ it’s a bit more difficult, but when you do, you blow your leg completely off.</p><p>Not a very reassuring thing to say.</p><p>These comments were definitely true, but they are less and less so.</p><p>The language evolves, but the old books and the interviews will not go away. It’s very difficult to change public opinion, especially among those who don’t code anymore. Like most of the decision-makers.</p><h3 id="while-the-language-is-evolving-its-getting-more-difficult-to-learn">While the language is evolving, it’s getting more difficult to learn</h3><p>As I wrote several times earlier, C++ is evolving. It gets more and more features, and it’s becoming easier and easier to write expressive code.</p><p>What used to be a raw loop today can be written in such a functional way:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">numbers</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">};</span>

<span class="c1">// instead of</span>
<span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">n</span> <span class="o">:</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span> <span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">count</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// now we can write</span>
<span class="k">auto</span> <span class="n">isEven</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">number</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">number</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span> <span class="p">};</span>
<span class="k">auto</span> <span class="n">count</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">count_if</span><span class="p">(</span><span class="n">numbers</span><span class="p">,</span> <span class="n">isEven</span><span class="p">);</span>
</pre></table></code></div></div><p>While this is all fine and dandy, it also means that those who want to write better C++ code, have to learn more. Many think that C++’s biggest superpower is the fact that it’s almost completely backward-compatible. Such an important feature that Matt Godbolt dedicated to it almost all <a href="https://www.codereckons.com/keynotes/c%2B%2B's-superpower">his keynote at CPPP 2021</a>!</p><p>It’s true that certain old best practices became antipatterns over time. But they still compile, they are still valid syntax, usually basic syntax, so we have to learn them. Maybe you don’t need to do pointer arithmetics anymore at least not so much, but you still need to know about it. The same goes for manual memory management, C-style arrays, and so on.</p><p>I do think that such topics should not be taught in-depth, but from what I can see, most universities teach legacy C++ and people have to relearn modern C++ at companies. If the company happens to use a more modern version…</p><h3 id="intellectual-neglige">Intellectual neglige</h3><p>As <a href="https://twitter.com/mrkkrj/status/1467798371670925315">Marek Krajewski shared with me on Twitter</a>, some people would simply not use C++ out of intellectual laziness. Yes, it’s more difficult to learn than Python or Javascript. Yes, you can build great things with the simpler-to-learn alternatives. And in fact, you don’t always need the powers of C++. That’s all true.</p><p><strong><em>You should use the right tool for the right job.</em></strong></p><p>The problem is that many are simply lazy to learn those tools or accept that sometimes those are the right tools. This happens often because of bigotry, because of narrowmindedness, and basically because of intellectual negligence.</p><p>It’s our job to show, to explain when C++ (or Rust…) is an overkill, and when it is the right solution. More importantly, we have to show that it’s not the same language that it was.</p><h3 id="ecosystem">Ecosystem</h3><p>In his talk, <a href="https://cpponsea.uk/2022/sessions/plenary-cpp-mythbusters.html">C++ MythBusters</a>, <a href="https://twitter.com/ciura_victor">Victor Ciura</a> busted the myth that C++ is not easily toolable. It is toolable and we have plenty of tools. Victor thinks that we are never going to have <em>“standardized”</em> tools, we always have to find the right tool and understand how it works and leverage it.</p><p>While I share his view, we must admit that other languages have simpler solutions for simple problems. If you work with Python, you know exactly how and from where you should get your packages. That’s similar to Java, not to mention Javascript. These languages are not standardized, but they have standard ways to easily deliver and use libraries, to share and build code in a way that doesn’t take a long time to grasp.</p><p>That’s clearly not the case for C++.</p><p>Writing <em>makefiles</em> is difficult. Many accept <a href="https://cmake.org/">CMake</a> as the de facto standard to write build scripts, but it’s clearly not the case. Many don’t like it due to its syntax and there are many different ways to generate your build scripts. Many companies have their own systems - including Amadeus.</p><p>What about package management?</p><p>Well, there is <a href="https://conan.io/">Conan</a>, <a href="https://github.com/microsoft/vcpkg">vcpkg</a>, but they don’t have the maturity as <a href="https://yarnpkg.com/">yarn</a>, <a href="https://www.npmjs.com/">npm</a>, <a href="https://pypi.org/">PyPI</a> or <a href="https://mvnrepository.com/">maven</a> have.</p><p>C++ has still some way to go.</p><h2 id="so-the-future">So the future?</h2><p>I asked around among some of the prominent figures of the C++ community, and here is what they said:</p><p><em>C++, today, remains truer than ever to its original mission of providing zero-cost abstractions over low-level systems code, where possible, and low-cost abstractions that you only pay for when you use them the rest of the time. It does this while maintaining compatibility with C and earlier versions of C++ - despite constantly evolving and adopting surprisingly modern language features.</em> - Phil Nash, author of Catch2, main organizer of C++ On Sea</p><p><em>C++ is both our legacy and our future. For all its warts and historical problems, it has an abundance of modern features many of them specially designed to mitigate/replace old idioms/constructs. C++ programmers nowadays can easily write programs completely avoiding such perilous old things. […] The C++ STL has grown a lot with the ISO standards 11,14,17,20 and more valuable additions are coming in C++23. From new algorithms and ranges to various utilities and support libraries for IO, networking, coroutines, concurrency, heterogenous parallelism and more. Yes, there are more specialized things a programmer might need, but this is where the C++ echo-system comes in to fill the gaps with a plethora of industry-grade (and stable) libraries for all sorts of necessities. Every important piece of software we use today has some C++ in it: maybe it’s all C++, maybe it has some important components in C++, maybe its library is natively compiled in C++, maybe it’s compiler/runtime is written in C++, … C++ is still the King of programming languages. Long live the King!</em> - <a href="https://ciura.ro/blog/why-cpp">Victor Ciura</a>, Senior Software Engineer in Visual C++ team at Microsoft</p><p><em>C++ is used in game development extensively, for console and PC games particularly. It allows direct access to hardware through zero-cost abstractions. The power and flexibility it grants make it a hard language to learn because more decisions are placed in your hands about what to do. As an international standard with a commitment to backwards compatibility, you know that there isn’t going to be a Python2/Python3 situation. The future is looking bright, with concurrency and networking looking promising for C++26 and a host of features designed to streamline and simplify the language.</em> - J. Guy Davidson, Head of Engineering Practice at Creative Assembly, Co-author of <a href="https://devreads.sandordargo.com/beautiful-cpp-by-kate-gregory-and-guy-davidson/">Beautiful C++</a>, ISO C++ Committee voting member</p><h2 id="conclusion">Conclusion</h2><p>C++ might be considered legacy by those who were familiar only with the old patterns, with the old standards, but the language is evolving. Since 2011, since C+11, we get a new version every 3 years with bugfixes and new features. The ecosystem is growing, even though it’s far from being as straightforward as some of the other newer languages where for example package management is done the same way everywhere.</p><p>Still, the language, the ecosystem is growing, the community is strong and C++ is everywhere, it’s unavoidable. It’s somehow part of almost every written software. I’m not saying that C++ is the hammer that should make everything a nail around you, but it’s something still worth learning and mastering. Even in 2022 and onwards.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/watercooler/" class="post-tag no-text-decoration" >watercooler</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Why to use C++ in 2022 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Why to use C++ in 2022 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Why to use C++ in 2022 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Why to use C++ in 2022 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/11/20/trip-report-meeting-cpp2024"><div class="card-body"> <span class="timeago small" > Nov 20, 2024 <i class="unloaded">2024-11-20T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: Meeting C++ 2024</h3><div class="text-muted small"><p> Last week, I got the chance to go to Berlin and participate in the 10th edition of Meeting C++ which is as far as I know the biggest C++ conference in Europe. Considering both the online and onsite...</p></div></div></a></div><div class="card"> <a href="/blog/2025/10/15/how-to-choose-good-talks-to-go-to"><div class="card-body"> <span class="timeago small" > Oct 15 <i class="unloaded">2025-10-15T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to Pick Which Conference Talks to Attend</h3><div class="text-muted small"><p> You might say that it’s already mid-October and the conference season is over. That’s far from true! Europe’s largest C++ conference is still ahead of us: Meeting C++. At CppCon, I ended up sharin...</p></div></div></a></div><div class="card"> <a href="/blog/2022/06/29/cpp-standardized"><div class="card-body"> <span class="timeago small" > Jun 29, 2022 <i class="unloaded">2022-06-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++: standardized</h3><div class="text-muted small"><p> In this article, let’s step back from coding a little bit. We are going to discuss how C++ was born and how it’s been evolving ever since. We’ll only have a brief overview of what happened in the l...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/11/05/3-things-mongodb-can-help-you-with" class="btn btn-outline-primary" prompt="Older"><p>3 Things MongoDB Can Help You With</p></a> <a href="/blog/2022/11/16/cpp23-expected" class="btn btn-outline-primary" prompt="Newer"><p>C++23: The &lt;expected&gt; header; expect the unexpected</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Why to use C++ in 2022'; this.page.url = 'https://www.sandordargo.com/blog/2022/11/09/why-to-use-cpp-in-2022'; this.page.identifier = '/blog/2022/11/09/why-to-use-cpp-in-2022'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
