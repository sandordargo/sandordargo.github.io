<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: How lambdas are going to change?" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of the language. Okay, let’s go through these changes. Make () more optional for lambdas What is the simplest lambda function? Is it [](){}? Nope! It’s []{}. If a lambda has no parameters (in standardese: if the parameter declaration clause is empty), we can omit the parentheses! Or can’t we? It depends. In regular lambda functions we can, but there has been another not-very-intuitive rule. When you have some lambda template parameters, constexpr, consteval, mutable or noexcept specifiers, or when you benefit from attributes or trailing return types (see the next section!) or a requires clause, you cannot omit the empty parentheses. So the following lambda declaration is illegal in C++20: 1 2 // warning: parameter declaration before lambda declaration specifiers only optional with &#39;-std=c++2b&#39; or &#39;-std=gnu++2b&#39; [-Wc++23-extensions] auto l = [] mutable {}; Thanks to P1102R2, omitting empty parentheses in such circumstances becomes legitim. A small proposal that doesn’t change how existing code behaves but makes the language a bit more comfortable and more importantly, it makes the language more consistent. Change the scope of lambda trailing-return-type I found overly interesting this change and it definitely made me learn something important I had no idea about! Let’s assume that you have such a piece of code: 1 2 3 4 5 double j = 42.0; // ... auto counter = [j=0]() mutable -&gt; decltype(j) { return j++; }; I know the trailing return type makes not much sense here, but this is just a simple example to showcase the problem. What do you expect the return type of counter to be? You might argue that in the lambda capture we declare j and initialize it with 0. The 0 literal without any suffix is an int, therefore when we invoke counter it should return an int. That’s wrong, the right answer is double! Even though the j introduced in the capture is physically closer to the trailing return type and most probably developers would first think about the captured j rather than some other variable from the outer scope, still the answer is that the type of j comes from the outer scope. Whatever is in the capture list, it’s not visible in the trailing return type. This also means that the following snippet on its own would not compile: 1 2 3 auto counter = [j=0]() mutable -&gt; decltype(j) { return j++; }; To be fair, this is the luckier case. It’s better to have a clear error rather than an unexpected and often undetected behaviour like in the original example. P2036R3 is going to change this situation. Name lookups for trailing return types are going to consider captures before looking outside. While this is not going to be a backward-compatible change, it will almost always match the developer’s intent. Attributes on lambdas After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types. The attributes sequence belongs to the type of the corresponding function call operator. The paper P2173R1 argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator. After all, why couldn’t the operator and with that almost always the lambda be [[nodiscard]], [[noreturn]] or [[deprecated]]? According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause. The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a [[nodiscard]] attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones. With this change, the following piece of code becomes valid, where the function call of the operator is [[nodiscard]]: 1 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; Meaning that this would emit a warning: 1 2 3 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; // ... lm(); // warning: ignoring return value of &#39;main()::&lt;lambda()&gt;&#39;, declared with attribute &#39;nodiscard&#39; [-Wunused-result] Please note that GCC and Clang already implemented this behaviour, GCC already in version 9! Conclusion Lambdas were introduced in C++11 and each standard brought some new features. It’s not going to be different with C++23. It will bring better attributes, a more reasonable trailing return type deduction and more consistent rules for omitting an empty parameter list. Stay tuned for more articles about the coming standard! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of the language. Okay, let’s go through these changes. Make () more optional for lambdas What is the simplest lambda function? Is it [](){}? Nope! It’s []{}. If a lambda has no parameters (in standardese: if the parameter declaration clause is empty), we can omit the parentheses! Or can’t we? It depends. In regular lambda functions we can, but there has been another not-very-intuitive rule. When you have some lambda template parameters, constexpr, consteval, mutable or noexcept specifiers, or when you benefit from attributes or trailing return types (see the next section!) or a requires clause, you cannot omit the empty parentheses. So the following lambda declaration is illegal in C++20: 1 2 // warning: parameter declaration before lambda declaration specifiers only optional with &#39;-std=c++2b&#39; or &#39;-std=gnu++2b&#39; [-Wc++23-extensions] auto l = [] mutable {}; Thanks to P1102R2, omitting empty parentheses in such circumstances becomes legitim. A small proposal that doesn’t change how existing code behaves but makes the language a bit more comfortable and more importantly, it makes the language more consistent. Change the scope of lambda trailing-return-type I found overly interesting this change and it definitely made me learn something important I had no idea about! Let’s assume that you have such a piece of code: 1 2 3 4 5 double j = 42.0; // ... auto counter = [j=0]() mutable -&gt; decltype(j) { return j++; }; I know the trailing return type makes not much sense here, but this is just a simple example to showcase the problem. What do you expect the return type of counter to be? You might argue that in the lambda capture we declare j and initialize it with 0. The 0 literal without any suffix is an int, therefore when we invoke counter it should return an int. That’s wrong, the right answer is double! Even though the j introduced in the capture is physically closer to the trailing return type and most probably developers would first think about the captured j rather than some other variable from the outer scope, still the answer is that the type of j comes from the outer scope. Whatever is in the capture list, it’s not visible in the trailing return type. This also means that the following snippet on its own would not compile: 1 2 3 auto counter = [j=0]() mutable -&gt; decltype(j) { return j++; }; To be fair, this is the luckier case. It’s better to have a clear error rather than an unexpected and often undetected behaviour like in the original example. P2036R3 is going to change this situation. Name lookups for trailing return types are going to consider captures before looking outside. While this is not going to be a backward-compatible change, it will almost always match the developer’s intent. Attributes on lambdas After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types. The attributes sequence belongs to the type of the corresponding function call operator. The paper P2173R1 argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator. After all, why couldn’t the operator and with that almost always the lambda be [[nodiscard]], [[noreturn]] or [[deprecated]]? According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause. The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a [[nodiscard]] attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones. With this change, the following piece of code becomes valid, where the function call of the operator is [[nodiscard]]: 1 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; Meaning that this would emit a warning: 1 2 3 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; // ... lm(); // warning: ignoring return value of &#39;main()::&lt;lambda()&gt;&#39;, declared with attribute &#39;nodiscard&#39; [-Wunused-result] Please note that GCC and Clang already implemented this behaviour, GCC already in version 9! Conclusion Lambdas were introduced in C++11 and each standard brought some new features. It’s not going to be different with C++23. It will bring better attributes, a more reasonable trailing return type deduction and more consistent rules for omitting an empty parameter list. Stay tuned for more articles about the coming standard! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-23T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: How lambdas are going to change?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-23T00:00:00+01:00","datePublished":"2022-11-23T00:00:00+01:00","description":"C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of the language. Okay, let’s go through these changes. Make () more optional for lambdas What is the simplest lambda function? Is it [](){}? Nope! It’s []{}. If a lambda has no parameters (in standardese: if the parameter declaration clause is empty), we can omit the parentheses! Or can’t we? It depends. In regular lambda functions we can, but there has been another not-very-intuitive rule. When you have some lambda template parameters, constexpr, consteval, mutable or noexcept specifiers, or when you benefit from attributes or trailing return types (see the next section!) or a requires clause, you cannot omit the empty parentheses. So the following lambda declaration is illegal in C++20: 1 2 // warning: parameter declaration before lambda declaration specifiers only optional with &#39;-std=c++2b&#39; or &#39;-std=gnu++2b&#39; [-Wc++23-extensions] auto l = [] mutable {}; Thanks to P1102R2, omitting empty parentheses in such circumstances becomes legitim. A small proposal that doesn’t change how existing code behaves but makes the language a bit more comfortable and more importantly, it makes the language more consistent. Change the scope of lambda trailing-return-type I found overly interesting this change and it definitely made me learn something important I had no idea about! Let’s assume that you have such a piece of code: 1 2 3 4 5 double j = 42.0; // ... auto counter = [j=0]() mutable -&gt; decltype(j) { return j++; }; I know the trailing return type makes not much sense here, but this is just a simple example to showcase the problem. What do you expect the return type of counter to be? You might argue that in the lambda capture we declare j and initialize it with 0. The 0 literal without any suffix is an int, therefore when we invoke counter it should return an int. That’s wrong, the right answer is double! Even though the j introduced in the capture is physically closer to the trailing return type and most probably developers would first think about the captured j rather than some other variable from the outer scope, still the answer is that the type of j comes from the outer scope. Whatever is in the capture list, it’s not visible in the trailing return type. This also means that the following snippet on its own would not compile: 1 2 3 auto counter = [j=0]() mutable -&gt; decltype(j) { return j++; }; To be fair, this is the luckier case. It’s better to have a clear error rather than an unexpected and often undetected behaviour like in the original example. P2036R3 is going to change this situation. Name lookups for trailing return types are going to consider captures before looking outside. While this is not going to be a backward-compatible change, it will almost always match the developer’s intent. Attributes on lambdas After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types. The attributes sequence belongs to the type of the corresponding function call operator. The paper P2173R1 argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator. After all, why couldn’t the operator and with that almost always the lambda be [[nodiscard]], [[noreturn]] or [[deprecated]]? According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause. The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a [[nodiscard]] attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones. With this change, the following piece of code becomes valid, where the function call of the operator is [[nodiscard]]: 1 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; Meaning that this would emit a warning: 1 2 3 auto lm = [][[nodiscard]]()-&gt;int { return 42; }; // ... lm(); // warning: ignoring return value of &#39;main()::&lt;lambda()&gt;&#39;, declared with attribute &#39;nodiscard&#39; [-Wunused-result] Please note that GCC and Clang already implemented this behaviour, GCC already in version 9! Conclusion Lambdas were introduced in C++11 and each standard brought some new features. It’s not going to be different with C++23. It will bring better attributes, a more reasonable trailing return type deduction and more consistent rules for omitting an empty parameter list. Stay tuned for more articles about the coming standard! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: How lambdas are going to change?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas"},"url":"https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas"}</script><title>C++23: How lambdas are going to change? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/23"> 23 </a> </span> <span>C++23: How lambdas are going to change?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: How lambdas are going to change?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 23, 2022, 12:00 AM +0100" prep="on" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="881 words">4 min</span></div></div><div class="post-content"><p>C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of the language.</p><p>Okay, let’s go through these changes.</p><h2 id="make--more-optional-for-lambdas">Make <code class="language-plaintext highlighter-rouge">()</code> more optional for lambdas</h2><p>What is the simplest lambda function?</p><p>Is it <code class="language-plaintext highlighter-rouge">[](){}</code>?</p><p>Nope! It’s <code class="language-plaintext highlighter-rouge">[]{}</code>.</p><p>If a lambda has no parameters (<em>in standardese: if the parameter declaration clause is empty</em>), we can omit the parentheses!</p><p>Or can’t we?</p><p>It depends. In regular lambda functions we can, but there has been another not-very-intuitive rule. When you have some lambda template parameters, <code class="language-plaintext highlighter-rouge">constexpr</code>, <code class="language-plaintext highlighter-rouge">consteval</code>, <code class="language-plaintext highlighter-rouge">mutable</code> or <code class="language-plaintext highlighter-rouge">noexcept</code> specifiers, or when you benefit from attributes or trailing return types (see the next section!) or a <code class="language-plaintext highlighter-rouge">requires</code> clause, you cannot omit the empty parentheses.</p><p>So the following lambda declaration is illegal in C++20:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// warning: parameter declaration before lambda declaration specifiers only optional with '-std=c++2b' or '-std=gnu++2b' [-Wc++23-extensions]</span>
<span class="k">auto</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[]</span> <span class="k">mutable</span> <span class="p">{};</span>
</pre></table></code></div></div><p>Thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1102r2.html">P1102R2</a>, omitting empty parentheses in such circumstances becomes legitim. A small proposal that doesn’t change how existing code behaves but makes the language a bit more comfortable and more importantly, it makes the language more consistent.</p><h2 id="change-the-scope-of-lambda-trailing-return-type">Change the scope of lambda trailing-return-type</h2><p>I found overly interesting this change and it definitely made me learn something important I had no idea about!</p><p>Let’s assume that you have such a piece of code:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">double</span> <span class="n">j</span> <span class="o">=</span> <span class="mf">42.0</span><span class="p">;</span>
<span class="c1">// ...</span>
<span class="k">auto</span> <span class="n">counter</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">]()</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>I know the trailing return type makes not much sense here, but this is just a simple example to showcase the problem.</p><p>What do you expect the return type of <code class="language-plaintext highlighter-rouge">counter</code> to be?</p><p>You might argue that in the lambda capture we declare <code class="language-plaintext highlighter-rouge">j</code> and initialize it with <code class="language-plaintext highlighter-rouge">0</code>. The <code class="language-plaintext highlighter-rouge">0</code> literal without any suffix is an <code class="language-plaintext highlighter-rouge">int</code>, therefore when we invoke <code class="language-plaintext highlighter-rouge">counter</code> it should return an <code class="language-plaintext highlighter-rouge">int</code>.</p><p>That’s wrong, the right answer is <code class="language-plaintext highlighter-rouge">double</code>!</p><p>Even though the <code class="language-plaintext highlighter-rouge">j</code> introduced in the capture is physically closer to the trailing return type and most probably developers would first think about the captured <code class="language-plaintext highlighter-rouge">j</code> rather than some other variable from the outer scope, still the answer is that the type of <code class="language-plaintext highlighter-rouge">j</code> comes from the outer scope. Whatever is in the capture list, it’s not visible in the trailing return type.</p><p>This also means that the following snippet on its own would not compile:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">counter</span> <span class="o">=</span> <span class="p">[</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">]()</span> <span class="k">mutable</span> <span class="o">-&gt;</span> <span class="k">decltype</span><span class="p">(</span><span class="n">j</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">j</span><span class="o">++</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>To be fair, this is the luckier case. It’s better to have a clear error rather than an unexpected and often undetected behaviour like in the original example.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2036r3.html">P2036R3</a> is going to change this situation. Name lookups for trailing return types are going to consider captures before looking outside. While this is not going to be a backward-compatible change, it will almost always match the developer’s intent.</p><h2 id="attributes-on-lambdas">Attributes on lambdas</h2><p>After reading this section title, you might ask whether it’s already possible to use attributes with lambdas. The answer is yes, it is possible. The place for adding an attribute is in the lambda declarator, either before or after the parameter declaration clause, but always between the optional noexcept specifiers and trailing return types.</p><p>The attributes sequence belongs to the type of the corresponding function call operator. The paper <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2173r1.pdf">P2173R1</a> argues - and rightly so - that this should not necessarily be the case. Attributes should be allowed to belong to the function call operator.</p><p>After all, why couldn’t the operator and with that almost always the lambda be <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>, <code class="language-plaintext highlighter-rouge">[[noreturn]]</code> or <code class="language-plaintext highlighter-rouge">[[deprecated]]</code>?</p><p>According to the proposed and accepted change, regardless of the other optional elements of a lambda expression, now we can declare the attribute sequence right after the lambda introducer (and its optional capture) or right after the template parameter list including its requires clause.</p><p>The proposed wording says that an attribute specifier sequence in a lambda declarator appertains to the type of the function call operator, but if it comes before the lambda declarator, then it belongs to the function call operator itself, not its type. You might say that you cannot attach a <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code> attribute to a type, it wouldn’t make sense. You’re right, but don’t think only about the standard attributes, even the proposal mentions vendor-defined ones.</p><p>With <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2173r1.pdf">this change</a>, the following piece of code becomes valid, where the function call of the operator is <code class="language-plaintext highlighter-rouge">[[nodiscard]]</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">lm</span> <span class="o">=</span> <span class="p">[][[</span><span class="n">nodiscard</span><span class="p">]]()</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
</pre></table></code></div></div><p>Meaning that this would emit a warning:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">lm</span> <span class="o">=</span> <span class="p">[][[</span><span class="n">nodiscard</span><span class="p">]]()</span><span class="o">-&gt;</span><span class="kt">int</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">};</span>
<span class="c1">// ...</span>
<span class="n">lm</span><span class="p">();</span> <span class="c1">// warning: ignoring return value of 'main()::&lt;lambda()&gt;', declared with attribute 'nodiscard' [-Wunused-result]</span>
</pre></table></code></div></div><p>Please note that GCC and Clang already implemented this behaviour, GCC already in version 9!</p><h2 id="conclusion">Conclusion</h2><p>Lambdas were introduced in C++11 and each standard brought some new features. It’s not going to be different with C++23. It will bring better attributes, a more reasonable trailing return type deduction and more consistent rules for omitting an empty parameter list. Stay tuned for more articles about the coming standard!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/lambda/" class="post-tag no-text-decoration" >lambda</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: How lambdas are going to change? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: How lambdas are going to change? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: How lambdas are going to change? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: How lambdas are going to change? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/01/10/cpp23-and-allocators"><div class="card-body"> <span class="timeago small" > Jan 10, 2024 <i class="unloaded">2024-01-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: Allocator related changes</h3><div class="text-muted small"><p> In this post, we are going to review two changes related to allocators in C++. One is about providing size information about the allocated memory and the other is about how CTAD should happen for c...</p></div></div></a></div><div class="card"> <a href="/blog/2024/01/17/cpp23-bitwise-operations"><div class="card-body"> <span class="timeago small" > Jan 17, 2024 <i class="unloaded">2024-01-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: bitwise operations</h3><div class="text-muted small"><p> While C++ is getting increasingly expressive with each new standard, we must not forget its origins. It is inherently a low-level language which operates close to the hardware level and allows oper...</p></div></div></a></div><div class="card"> <a href="/blog/2024/01/31/cpp23-likes-to-move-it"><div class="card-body"> <span class="timeago small" > Jan 31, 2024 <i class="unloaded">2024-01-31T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23 likes to move it!</h3><div class="text-muted small"><p> C++23 is going to bring us a few changes regarding move operations. It mostly means extended support in the standard library, but there is also one change directly in the language. Let’s start with...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/11/19/the-seniority-trap-chapter-8-non-coding-roles" class="btn btn-outline-primary" prompt="Older"><p>Non-coding roles or something you like?</p></a> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy" class="btn btn-outline-primary" prompt="Newer"><p>C++23: auto(x) and decay copy</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: How lambdas are going to change?'; this.page.url = 'https://www.sandordargo.com/blog/2022/11/23/cpp23-changes-to-lambdas'; this.page.identifier = '/blog/2022/11/23/cpp23-changes-to-lambdas'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
