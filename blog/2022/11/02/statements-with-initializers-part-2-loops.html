<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The evolution of statements with initializers in C++ - part 2" /><meta property="og:locale" content="en_US" /><meta name="description" content="In these two articles, we see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code. In this previous article, we saw see how C++ evolved in terms of writing different statements that include initializers. Today, we discuss loops. If you haven’t read the first article, or if you don’t remember, let me remind you wnat a statement is. According to Wikipedia, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements. Now let’s move on and see how loops evolved over the years and they offer - or not - variable initialization. Let’s start by having a look at how we can write loops without init statements. Let’s start with its earliest format. Loops with goto statements Yes! The first way we are going to use here includes the infamous goto statement! Obviously, there are no init statements related to the goto. I hope you’ve never seen this in production code unless you’re on the job market for decades. In the old days of programming, the way to code loops was through labels and goto statements. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; LOOP: std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; ++i; if (i &lt; 10) { goto LOOP; } return 0; } Well, we can bring back the old days in C++ and we can still use goto statements and labels. There are a couple of issues though. The scope of i is not limited at all and even worse, we can go to LOOP from other places in the function, even when it wouldn’t make sense. In other words, it’s not safe and also difficult to reason about the correctness of our program. Still no initialization: the while loop The while keyword made loops a bit safer, as it’s possible to jump into the body of the loop from random places, but as you cannot initialize a variable in its control block, limiting the scope of the loop index is still not possible, unless we embrace the loop and the index initialization between braces. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; while (i &lt; 10) { std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; ++i; } return 0; } Safety is not an issue as it was with the goto, but the scope of the index is not limited. In addition, we must take care of updating the loop variable as it’s not something that can be done in the control block. Despite these issues, a while loop still can be a good solution when you want to update the loop helper variable conditionally. For example, when you use the while loop with an iterator. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; auto it = v.begin(); while (it != v.end()) { if (*it % 2 == 1) { // As erase() invalidates the iterator, we use its returned value it = v.erase(it); } else { // Otherwise, we simply increment it ++it; } } for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } But to be fair, in most cases you just want to use a standard algorithm and get rid off the problem of loops completely… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; v.erase(std::remove_if(v.begin(), v.end(), [](auto e){return e % 2 == 1;}), v.end()); for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } The good old for loop For loops are the remedy for all the issues we mentioned regarding loops. In its control block, we can create the loop variable, therefore its scope is limited and it also gets updated automatically after each iteration. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; } return 0; } What can go wrong? In the above case, we have a fixed end condition. If it wouldn’t be fixed to 10, but instead we called v.size(), it would mean a new function call before each iteration. And don’t expect the compiler to optimize it away. I mean, there is no guarantee that the size of v wouldn’t actually change and don’t write bad code leaving it to the compiler to optimize it. So often you’ll see that the end condition is fixed outside of the loop. 1 2 3 4 // ... const int vectorSize = v.size(); for(size_t i = 0; i &lt; vectorSize; ++i) { // ... In the above examples, we had full control blocks. But it’s not even necessary to use all the different parts of the control block, you can leave out the variable initialization or the increments. In fact, you can mimic a while loop with an initializer by using a for loop without the update part. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; for(auto it = v.begin(); it != v.end();) { if (*it % 2 == 1) { // As erase() invalidates the iterator, we use its returned value it = v.erase(it); } else { // Otherwise, we simply increment it ++it; } } for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } I don’t think that this is a good idea. If you really need to decouple the increments from the control block and make it conditional, the purpose of your for loop is defeated and it would be better to use a different construct. Nevertheless, it’s possible and maybe it’s better than the while loop You can also even leave out the exit condition and you’ll get an infinite loop. In that case, you have to take care of the termination in a different way. Most probably you won’t end up with a very idiomatic solution. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; ;++i) { if (i &gt;= 10) { break; } std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; } return 0; } Now, just for the sake of fun and completeness, let’s mention that you can even leave out all parts of the control block if you really wish so. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; for(;;) { if (i &gt;= 10) { break; } std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; ++i; } return 0; } These latter are kind of edge cases. Normally a simple for loop will suffice and you should strive not to use them. for loops give you safe updates and the limited scope of the loop index. So why would we need more? Range based for loop with initializer In most of the above examples, we interacted with the container through a loop index. But in reality, you’d often use an iterator. Before C++11, you couldn’t use auto, you had to scrupulously type the full type of the iterator. The below one is simpler, but with some other - possibly template - types and with a std::map it could grow really long. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(std::vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;; } return 0; } We already mentioned that storing the end, in other words, the sentinel value in a (const) variable makes sense, but to keep the control block shorter, many externalized also the iterator used for looping. With that, they ended up not limiting anymore the scope of the loop variable, thus they made the code less safe. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; std::vector&lt;int&gt;::const_iterator it; std::vector&lt;int&gt;::const_iterator end = v.end(); for(it = v.begin(); it != end; ++it) { std::cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;; } return 0; } C++11 introduced range-based for loops to avoid this problem and provide a nicer way of iterating through containers where the coder doesn’t have to dereference the iterator every time through operator*. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(const auto number: v) { std::cout &lt;&lt; number &lt;&lt; &#39;\n&#39;; } return 0; } It’s worth noting that under the hood the range-based for loop is translated into the iterator version with external iterator/sentinel definitions. This seems all fine and dandy and you might think that you won’t ever again need anything else than range-based for loops. It’s true in the vast majority of the cases (when you cannot replace it with a standard algorithm), you’ll be better of with a range-based version. Yet you should do it with care, because iterating over a reference to a temporary value is undefined behaviour. Apart from that what do you do if you also need an index? It might happen that you really want comfortable access to each item but also their positions. Check out this article on FluentC++, there are a couple of options such as using boost::adaptors::indexed(0), calculating the distance from the beginning if you use iterators, or simply creating a loop index variable outside the loop, just like we did for while loops. It comes with the same implications for lifetime. With C++20, we can have init statements even within a range based for loop’s control block: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; const auto number: v) { std::cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; number &lt;&lt; &#39;\n&#39;; ++i; } return 0; } The only inconvenience is that we still have to increment that ourselves, but at least its scope is limited. It would be nice to have something as enumerate() in Python and within the standard library. In any case, we can use init statements in range based for loops for other reasons too. Elaborating further the example of Pierre Gradot, we can get rid of the undefined behaviour I referred to earlier by initializing a variable with the temporary: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; std::vector&lt;std::string&gt; createStrings() { return {&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;vector&quot;, &quot;of&quot;, &quot;strings&quot;}; } int main() { for (auto w: createStrings()) { std::cout &lt;&lt; w &lt;&lt; &quot; &quot;; // this works fine } std::cout &lt;&lt; &#39;\n&#39;; for (auto c: createStrings()[0]) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; // this is UB } std::cout &lt;&lt; &#39;\n&#39;; for (auto strings = createStrings(); auto c: strings[0]) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; // this now works fine again } std::cout &lt;&lt; &#39;\n&#39;; } Conclusion In the last two articles, we saw how C++ evolved in terms of providing conditional statements and loops with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, that exposes less or no undefined behaviour and in general make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated. I hope that C++ will keep evolving in this direction and also that we developers keep up with the changes and don’t just stick to old practices. Do you use if/switch/range based for loops with initializers? What do you do when you need them but you are stuck on an earlier version? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In these two articles, we see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code. In this previous article, we saw see how C++ evolved in terms of writing different statements that include initializers. Today, we discuss loops. If you haven’t read the first article, or if you don’t remember, let me remind you wnat a statement is. According to Wikipedia, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements. Now let’s move on and see how loops evolved over the years and they offer - or not - variable initialization. Let’s start by having a look at how we can write loops without init statements. Let’s start with its earliest format. Loops with goto statements Yes! The first way we are going to use here includes the infamous goto statement! Obviously, there are no init statements related to the goto. I hope you’ve never seen this in production code unless you’re on the job market for decades. In the old days of programming, the way to code loops was through labels and goto statements. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; LOOP: std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; ++i; if (i &lt; 10) { goto LOOP; } return 0; } Well, we can bring back the old days in C++ and we can still use goto statements and labels. There are a couple of issues though. The scope of i is not limited at all and even worse, we can go to LOOP from other places in the function, even when it wouldn’t make sense. In other words, it’s not safe and also difficult to reason about the correctness of our program. Still no initialization: the while loop The while keyword made loops a bit safer, as it’s possible to jump into the body of the loop from random places, but as you cannot initialize a variable in its control block, limiting the scope of the loop index is still not possible, unless we embrace the loop and the index initialization between braces. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; while (i &lt; 10) { std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; ++i; } return 0; } Safety is not an issue as it was with the goto, but the scope of the index is not limited. In addition, we must take care of updating the loop variable as it’s not something that can be done in the control block. Despite these issues, a while loop still can be a good solution when you want to update the loop helper variable conditionally. For example, when you use the while loop with an iterator. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; auto it = v.begin(); while (it != v.end()) { if (*it % 2 == 1) { // As erase() invalidates the iterator, we use its returned value it = v.erase(it); } else { // Otherwise, we simply increment it ++it; } } for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } But to be fair, in most cases you just want to use a standard algorithm and get rid off the problem of loops completely… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; v.erase(std::remove_if(v.begin(), v.end(), [](auto e){return e % 2 == 1;}), v.end()); for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } The good old for loop For loops are the remedy for all the issues we mentioned regarding loops. In its control block, we can create the loop variable, therefore its scope is limited and it also gets updated automatically after each iteration. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; } return 0; } What can go wrong? In the above case, we have a fixed end condition. If it wouldn’t be fixed to 10, but instead we called v.size(), it would mean a new function call before each iteration. And don’t expect the compiler to optimize it away. I mean, there is no guarantee that the size of v wouldn’t actually change and don’t write bad code leaving it to the compiler to optimize it. So often you’ll see that the end condition is fixed outside of the loop. 1 2 3 4 // ... const int vectorSize = v.size(); for(size_t i = 0; i &lt; vectorSize; ++i) { // ... In the above examples, we had full control blocks. But it’s not even necessary to use all the different parts of the control block, you can leave out the variable initialization or the increments. In fact, you can mimic a while loop with an initializer by using a for loop without the update part. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; for(auto it = v.begin(); it != v.end();) { if (*it % 2 == 1) { // As erase() invalidates the iterator, we use its returned value it = v.erase(it); } else { // Otherwise, we simply increment it ++it; } } for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } I don’t think that this is a good idea. If you really need to decouple the increments from the control block and make it conditional, the purpose of your for loop is defeated and it would be better to use a different construct. Nevertheless, it’s possible and maybe it’s better than the while loop You can also even leave out the exit condition and you’ll get an infinite loop. In that case, you have to take care of the termination in a different way. Most probably you won’t end up with a very idiomatic solution. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; ;++i) { if (i &gt;= 10) { break; } std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; } return 0; } Now, just for the sake of fun and completeness, let’s mention that you can even leave out all parts of the control block if you really wish so. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; for(;;) { if (i &gt;= 10) { break; } std::cout &lt;&lt; v[i] &lt;&lt; &#39;\n&#39;; ++i; } return 0; } These latter are kind of edge cases. Normally a simple for loop will suffice and you should strive not to use them. for loops give you safe updates and the limited scope of the loop index. So why would we need more? Range based for loop with initializer In most of the above examples, we interacted with the container through a loop index. But in reality, you’d often use an iterator. Before C++11, you couldn’t use auto, you had to scrupulously type the full type of the iterator. The below one is simpler, but with some other - possibly template - types and with a std::map it could grow really long. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(std::vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;; } return 0; } We already mentioned that storing the end, in other words, the sentinel value in a (const) variable makes sense, but to keep the control block shorter, many externalized also the iterator used for looping. With that, they ended up not limiting anymore the scope of the loop variable, thus they made the code less safe. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; std::vector&lt;int&gt;::const_iterator it; std::vector&lt;int&gt;::const_iterator end = v.end(); for(it = v.begin(); it != end; ++it) { std::cout &lt;&lt; *it &lt;&lt; &#39;\n&#39;; } return 0; } C++11 introduced range-based for loops to avoid this problem and provide a nicer way of iterating through containers where the coder doesn’t have to dereference the iterator every time through operator*. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(const auto number: v) { std::cout &lt;&lt; number &lt;&lt; &#39;\n&#39;; } return 0; } It’s worth noting that under the hood the range-based for loop is translated into the iterator version with external iterator/sentinel definitions. This seems all fine and dandy and you might think that you won’t ever again need anything else than range-based for loops. It’s true in the vast majority of the cases (when you cannot replace it with a standard algorithm), you’ll be better of with a range-based version. Yet you should do it with care, because iterating over a reference to a temporary value is undefined behaviour. Apart from that what do you do if you also need an index? It might happen that you really want comfortable access to each item but also their positions. Check out this article on FluentC++, there are a couple of options such as using boost::adaptors::indexed(0), calculating the distance from the beginning if you use iterators, or simply creating a loop index variable outside the loop, just like we did for while loops. It comes with the same implications for lifetime. With C++20, we can have init statements even within a range based for loop’s control block: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; const auto number: v) { std::cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; number &lt;&lt; &#39;\n&#39;; ++i; } return 0; } The only inconvenience is that we still have to increment that ourselves, but at least its scope is limited. It would be nice to have something as enumerate() in Python and within the standard library. In any case, we can use init statements in range based for loops for other reasons too. Elaborating further the example of Pierre Gradot, we can get rid of the undefined behaviour I referred to earlier by initializing a variable with the temporary: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; std::vector&lt;std::string&gt; createStrings() { return {&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;vector&quot;, &quot;of&quot;, &quot;strings&quot;}; } int main() { for (auto w: createStrings()) { std::cout &lt;&lt; w &lt;&lt; &quot; &quot;; // this works fine } std::cout &lt;&lt; &#39;\n&#39;; for (auto c: createStrings()[0]) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; // this is UB } std::cout &lt;&lt; &#39;\n&#39;; for (auto strings = createStrings(); auto c: strings[0]) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; // this now works fine again } std::cout &lt;&lt; &#39;\n&#39;; } Conclusion In the last two articles, we saw how C++ evolved in terms of providing conditional statements and loops with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, that exposes less or no undefined behaviour and in general make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated. I hope that C++ will keep evolving in this direction and also that we developers keep up with the changes and don’t just stick to old practices. Do you use if/switch/range based for loops with initializers? What do you do when you need them but you are stuck on an earlier version? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-02T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The evolution of statements with initializers in C++ - part 2" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-26T06:57:31+01:00","datePublished":"2022-11-02T00:00:00+01:00","description":"In these two articles, we see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code. In this previous article, we saw see how C++ evolved in terms of writing different statements that include initializers. Today, we discuss loops. If you haven’t read the first article, or if you don’t remember, let me remind you wnat a statement is. According to Wikipedia, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements. Now let’s move on and see how loops evolved over the years and they offer - or not - variable initialization. Let’s start by having a look at how we can write loops without init statements. Let’s start with its earliest format. Loops with goto statements Yes! The first way we are going to use here includes the infamous goto statement! Obviously, there are no init statements related to the goto. I hope you’ve never seen this in production code unless you’re on the job market for decades. In the old days of programming, the way to code loops was through labels and goto statements. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; LOOP: std::cout &lt;&lt; v[i] &lt;&lt; &#39;\\n&#39;; ++i; if (i &lt; 10) { goto LOOP; } return 0; } Well, we can bring back the old days in C++ and we can still use goto statements and labels. There are a couple of issues though. The scope of i is not limited at all and even worse, we can go to LOOP from other places in the function, even when it wouldn’t make sense. In other words, it’s not safe and also difficult to reason about the correctness of our program. Still no initialization: the while loop The while keyword made loops a bit safer, as it’s possible to jump into the body of the loop from random places, but as you cannot initialize a variable in its control block, limiting the scope of the loop index is still not possible, unless we embrace the loop and the index initialization between braces. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; while (i &lt; 10) { std::cout &lt;&lt; v[i] &lt;&lt; &#39;\\n&#39;; ++i; } return 0; } Safety is not an issue as it was with the goto, but the scope of the index is not limited. In addition, we must take care of updating the loop variable as it’s not something that can be done in the control block. Despite these issues, a while loop still can be a good solution when you want to update the loop helper variable conditionally. For example, when you use the while loop with an iterator. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; auto it = v.begin(); while (it != v.end()) { if (*it % 2 == 1) { // As erase() invalidates the iterator, we use its returned value it = v.erase(it); } else { // Otherwise, we simply increment it ++it; } } for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } But to be fair, in most cases you just want to use a standard algorithm and get rid off the problem of loops completely… 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; v.erase(std::remove_if(v.begin(), v.end(), [](auto e){return e % 2 == 1;}), v.end()); for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } The good old for loop For loops are the remedy for all the issues we mentioned regarding loops. In its control block, we can create the loop variable, therefore its scope is limited and it also gets updated automatically after each iteration. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; i &lt; 10; ++i) { std::cout &lt;&lt; v[i] &lt;&lt; &#39;\\n&#39;; } return 0; } What can go wrong? In the above case, we have a fixed end condition. If it wouldn’t be fixed to 10, but instead we called v.size(), it would mean a new function call before each iteration. And don’t expect the compiler to optimize it away. I mean, there is no guarantee that the size of v wouldn’t actually change and don’t write bad code leaving it to the compiler to optimize it. So often you’ll see that the end condition is fixed outside of the loop. 1 2 3 4 // ... const int vectorSize = v.size(); for(size_t i = 0; i &lt; vectorSize; ++i) { // ... In the above examples, we had full control blocks. But it’s not even necessary to use all the different parts of the control block, you can leave out the variable initialization or the increments. In fact, you can mimic a while loop with an initializer by using a for loop without the update part. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;algorithm&gt; int main() { std::vector&lt;int&gt; v = { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9 }; for(auto it = v.begin(); it != v.end();) { if (*it % 2 == 1) { // As erase() invalidates the iterator, we use its returned value it = v.erase(it); } else { // Otherwise, we simply increment it ++it; } } for (const auto e: v) { std::cout &lt;&lt; e &lt;&lt; &#39; &#39;; } return 0; } I don’t think that this is a good idea. If you really need to decouple the increments from the control block and make it conditional, the purpose of your for loop is defeated and it would be better to use a different construct. Nevertheless, it’s possible and maybe it’s better than the while loop You can also even leave out the exit condition and you’ll get an infinite loop. In that case, you have to take care of the termination in a different way. Most probably you won’t end up with a very idiomatic solution. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; ;++i) { if (i &gt;= 10) { break; } std::cout &lt;&lt; v[i] &lt;&lt; &#39;\\n&#39;; } return 0; } Now, just for the sake of fun and completeness, let’s mention that you can even leave out all parts of the control block if you really wish so. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; size_t i = 0; for(;;) { if (i &gt;= 10) { break; } std::cout &lt;&lt; v[i] &lt;&lt; &#39;\\n&#39;; ++i; } return 0; } These latter are kind of edge cases. Normally a simple for loop will suffice and you should strive not to use them. for loops give you safe updates and the limited scope of the loop index. So why would we need more? Range based for loop with initializer In most of the above examples, we interacted with the container through a loop index. But in reality, you’d often use an iterator. Before C++11, you couldn’t use auto, you had to scrupulously type the full type of the iterator. The below one is simpler, but with some other - possibly template - types and with a std::map it could grow really long. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(std::vector&lt;int&gt;::const_iterator it = v.begin(); it != v.end(); ++it) { std::cout &lt;&lt; *it &lt;&lt; &#39;\\n&#39;; } return 0; } We already mentioned that storing the end, in other words, the sentinel value in a (const) variable makes sense, but to keep the control block shorter, many externalized also the iterator used for looping. With that, they ended up not limiting anymore the scope of the loop variable, thus they made the code less safe. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; std::vector&lt;int&gt;::const_iterator it; std::vector&lt;int&gt;::const_iterator end = v.end(); for(it = v.begin(); it != end; ++it) { std::cout &lt;&lt; *it &lt;&lt; &#39;\\n&#39;; } return 0; } C++11 introduced range-based for loops to avoid this problem and provide a nicer way of iterating through containers where the coder doesn’t have to dereference the iterator every time through operator*. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(const auto number: v) { std::cout &lt;&lt; number &lt;&lt; &#39;\\n&#39;; } return 0; } It’s worth noting that under the hood the range-based for loop is translated into the iterator version with external iterator/sentinel definitions. This seems all fine and dandy and you might think that you won’t ever again need anything else than range-based for loops. It’s true in the vast majority of the cases (when you cannot replace it with a standard algorithm), you’ll be better of with a range-based version. Yet you should do it with care, because iterating over a reference to a temporary value is undefined behaviour. Apart from that what do you do if you also need an index? It might happen that you really want comfortable access to each item but also their positions. Check out this article on FluentC++, there are a couple of options such as using boost::adaptors::indexed(0), calculating the distance from the beginning if you use iterators, or simply creating a loop index variable outside the loop, just like we did for while loops. It comes with the same implications for lifetime. With C++20, we can have init statements even within a range based for loop’s control block: 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;vector&gt; int main () { std::vector&lt;int&gt; v{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}; for(size_t i = 0; const auto number: v) { std::cout &lt;&lt; i &lt;&lt; &quot;: &quot; &lt;&lt; number &lt;&lt; &#39;\\n&#39;; ++i; } return 0; } The only inconvenience is that we still have to increment that ourselves, but at least its scope is limited. It would be nice to have something as enumerate() in Python and within the standard library. In any case, we can use init statements in range based for loops for other reasons too. Elaborating further the example of Pierre Gradot, we can get rid of the undefined behaviour I referred to earlier by initializing a variable with the temporary: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;vector&gt; std::vector&lt;std::string&gt; createStrings() { return {&quot;This&quot;, &quot;is&quot;, &quot;a&quot;, &quot;vector&quot;, &quot;of&quot;, &quot;strings&quot;}; } int main() { for (auto w: createStrings()) { std::cout &lt;&lt; w &lt;&lt; &quot; &quot;; // this works fine } std::cout &lt;&lt; &#39;\\n&#39;; for (auto c: createStrings()[0]) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; // this is UB } std::cout &lt;&lt; &#39;\\n&#39;; for (auto strings = createStrings(); auto c: strings[0]) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; // this now works fine again } std::cout &lt;&lt; &#39;\\n&#39;; } Conclusion In the last two articles, we saw how C++ evolved in terms of providing conditional statements and loops with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, that exposes less or no undefined behaviour and in general make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated. I hope that C++ will keep evolving in this direction and also that we developers keep up with the changes and don’t just stick to old practices. Do you use if/switch/range based for loops with initializers? What do you do when you need them but you are stuck on an earlier version? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The evolution of statements with initializers in C++ - part 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops"},"url":"https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops"}</script><title>The evolution of statements with initializers in C++ - part 2 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/02"> 02 </a> </span> <span>The evolution of statements with initializers in C++ - part 2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The evolution of statements with initializers in C++ - part 2</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 2, 2022, 12:00 AM +0100" prep="on" > Nov 2, 2022 <i class="unloaded">2022-11-02T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 26, 2024, 6:57 AM +0100" prefix="Updated " > Dec 26, 2024 <i class="unloaded">2024-12-26T06:57:31+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2266 words">12 min</span></div></div><div class="post-content"><p>In these two articles, we see how C++ evolved in terms of writing different statements that include initializers. Simple? Boring? I don’t think so, it just shows how far we got in C++ and in programming in general in terms of readability and maintainability of code.</p><p><a href="https://www.sandordargo.com/blog/2022/10/26/statements-with-initializers-part-1-conditionals">In this previous article</a>, we saw see how C++ evolved in terms of writing different statements that include initializers. Today, we discuss loops.</p><p>If you haven’t read the first article, or if you don’t remember, let me remind you wnat a statement is.</p><p><a href="https://en.wikipedia.org/wiki/Statement_(computer_science)">According to Wikipedia</a>, “a statement is a syntactic unit […] that expresses some action to be carried out”. Statements can be either simple such as assignments, assertions or function calls, etc. or compound such as loops and if statements.</p><p>Now let’s move on and see how loops evolved over the years and they offer - or not - variable initialization. Let’s start by having a look at how we can write loops without init statements. Let’s start with its earliest format.</p><h2 id="loops-with-goto-statements">Loops with <code class="language-plaintext highlighter-rouge">goto</code> statements</h2><p>Yes! The first way we are going to use here includes the infamous <code class="language-plaintext highlighter-rouge">goto</code> statement! Obviously, there are no init statements related to the <code class="language-plaintext highlighter-rouge">goto</code>. I hope you’ve never seen this in production code unless you’re on the job market for decades.</p><p>In the old days of programming, the way to code loops was through labels and <code class="language-plaintext highlighter-rouge">goto</code> statements.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="n">LOOP</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">goto</span> <span class="n">LOOP</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>Well, we can bring back the old days in C++ and we can still use <code class="language-plaintext highlighter-rouge">goto</code> statements and labels. There are a couple of issues though. The scope of <code class="language-plaintext highlighter-rouge">i</code> is not limited at all and even worse, we can <em>go to</em> <code class="language-plaintext highlighter-rouge">LOOP</code> from other places in the function, even when it wouldn’t make sense. In other words, it’s not safe and also difficult to reason about the correctness of our program.</p><h2 id="still-no-initialization-the-while-loop">Still no initialization: the <code class="language-plaintext highlighter-rouge">while</code> loop</h2><p>The <code class="language-plaintext highlighter-rouge">while</code> keyword made loops a bit safer, as it’s possible to jump into the body of the loop from random places, but as you cannot initialize a variable in its control block, limiting the scope of the loop index is still not possible, unless we embrace the loop and the index initialization between braces.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Safety is not an issue as it was with the <code class="language-plaintext highlighter-rouge">goto</code>, but the scope of the index is not limited. In addition, we must take care of updating the loop variable as it’s not something that can be done in the control block.</p><p>Despite these issues, a while loop still can be a good solution when you want to update the loop helper variable conditionally. For example, when you use the while loop with an iterator.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>
 
    <span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// As erase() invalidates the iterator, we use its returned value</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Otherwise, we simply increment it</span>
            <span class="o">++</span><span class="n">it</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But to be fair, in most cases <a href="https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms">you just want to use a standard algorithm</a> and get rid off the problem of loops completely…</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>
 
    <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">remove_if</span><span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="p">[](</span><span class="k">auto</span> <span class="n">e</span><span class="p">){</span><span class="k">return</span> <span class="n">e</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">;}),</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h2 id="the-good-old-for-loop">The good old <code class="language-plaintext highlighter-rouge">for</code> loop</h2><p>For loops are the remedy for all the issues we mentioned regarding loops. In its control block, we can create the loop variable, therefore its scope is limited and it also gets updated automatically after each iteration.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What can go wrong? In the above case, we have a fixed end condition. If it wouldn’t be fixed to <code class="language-plaintext highlighter-rouge">10</code>, but instead we called <code class="language-plaintext highlighter-rouge">v.size()</code>, it would mean a new function call before each iteration. And don’t expect the compiler to optimize it away. I mean, there is no guarantee that the size of <code class="language-plaintext highlighter-rouge">v</code> wouldn’t actually change and don’t write bad code leaving it to the compiler to optimize it. So often you’ll see that the end condition is fixed outside of the loop.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="c1">// ...</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">vectorSize</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
<span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">vectorSize</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// ...</span>
</pre></table></code></div></div><p>In the above examples, we had full control blocks. But it’s not even necessary to use all the different parts of the control block, you can leave out the variable initialization or the increments. In fact, you can mimic a <code class="language-plaintext highlighter-rouge">while</code> loop with an initializer by using a <code class="language-plaintext highlighter-rouge">for</code> loop without the update part.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
</span> 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span> <span class="p">};</span>
 
    <span class="k">for</span><span class="p">(</span><span class="k">auto</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">it</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// As erase() invalidates the iterator, we use its returned value</span>
            <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">it</span><span class="p">);</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// Otherwise, we simply increment it</span>
            <span class="o">++</span><span class="n">it</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
 
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">e</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">e</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="p">}</span>
 
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>I don’t think that this is a good idea. If you really need to decouple the increments from the control block and make it conditional, the purpose of your <code class="language-plaintext highlighter-rouge">for</code> loop is defeated and it would be better to use a different construct. Nevertheless, it’s possible and maybe it’s better than the <code class="language-plaintext highlighter-rouge">while</code> loop</p><p>You can also even leave out the exit condition and you’ll get an infinite loop. In that case, you have to take care of the termination in a different way. Most probably you won’t end up with a very idiomatic solution.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>  <span class="p">;</span><span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now, just for the sake of fun and completeness, let’s mention that you can even leave out all parts of the control block if you really wish so.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(;;)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">10</span><span class="p">)</span> <span class="p">{</span> <span class="k">break</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>These latter are kind of edge cases. Normally a simple <code class="language-plaintext highlighter-rouge">for</code> loop will suffice and you should strive not to use them. <code class="language-plaintext highlighter-rouge">for</code> loops give you safe updates and the limited scope of the loop index. So why would we need more?</p><h2 id="range-based-for-loop-with-initializer">Range based <code class="language-plaintext highlighter-rouge">for</code> loop with initializer</h2><p>In most of the above examples, we interacted with the container through a loop index. But in reality, you’d often use an iterator. Before C++11, you couldn’t use <code class="language-plaintext highlighter-rouge">auto</code>, you had to scrupulously type the full type of the iterator. The below one is simpler, but with some other - possibly template - types and with a <code class="language-plaintext highlighter-rouge">std::map</code> it could grow really long.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    
    <span class="k">for</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We already mentioned that storing the end, in other words, the sentinel value in a (<code class="language-plaintext highlighter-rouge">const</code>) variable makes sense, but to keep the control block shorter, many externalized also the iterator used for looping. With that, they ended up not limiting anymore the scope of the loop variable, thus they made the code less safe.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">it</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">end</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="k">for</span><span class="p">(</span><span class="n">it</span> <span class="o">=</span> <span class="n">v</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">it</span> <span class="o">!=</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">it</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">it</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>C++11 introduced range-based <code class="language-plaintext highlighter-rouge">for</code> loops to avoid this problem and provide a nicer way of iterating through containers where the coder doesn’t have to dereference the iterator every time through <code class="language-plaintext highlighter-rouge">operator*</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">number</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s worth noting that under the hood the range-based <code class="language-plaintext highlighter-rouge">for</code> loop is translated into the iterator version with external iterator/sentinel definitions. This seems all fine and dandy and you might think that you won’t ever again need anything else than range-based <code class="language-plaintext highlighter-rouge">for</code> loops. It’s true in the vast majority of the cases (when you cannot replace it with a standard algorithm), you’ll be better of with a range-based version. Yet you should do it with care, because <a href="https://www.sandordargo.com/blog/2022/04/20/range-base-p2012">iterating over a reference to a temporary value is undefined behaviour</a>.</p><p>Apart from that what do you do if you also need an index? It might happen that you really want comfortable access to each item but also their positions.</p><p>Check out <a href="https://www.fluentcpp.com/2018/10/26/how-to-access-the-index-of-the-current-element-in-a-modern-for-loop/">this article on FluentC++</a>, there are a couple of options such as using <code class="language-plaintext highlighter-rouge">boost::adaptors::indexed(0)</code>, calculating the distance from the beginning if you use iterators, or simply creating a loop index variable outside the loop, just like we did for <code class="language-plaintext highlighter-rouge">while</code> loops. It comes with the same implications for lifetime.</p><p>With C++20, we can have init statements even within a range based <code class="language-plaintext highlighter-rouge">for</code> loop’s control block:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="k">const</span> <span class="k">auto</span> <span class="n">number</span><span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="s">": "</span> <span class="o">&lt;&lt;</span> <span class="n">number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The only inconvenience is that we still have to increment that ourselves, but at least its scope is limited. It would be nice to have something as <code class="language-plaintext highlighter-rouge">enumerate()</code> in Python and within the standard library.</p><p>In any case, we can use init statements in range based <code class="language-plaintext highlighter-rouge">for</code> loops for other reasons too. Elaborating further <a href="https://dev.to/pgradot/let-s-try-c-20-range-based-for-statements-with-initializer-3m6a">the example of Pierre Gradot</a>, we can get rid of the undefined behaviour I referred to earlier by initializing a variable with the temporary:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">createStrings</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span><span class="s">"This"</span><span class="p">,</span> <span class="s">"is"</span><span class="p">,</span> <span class="s">"a"</span><span class="p">,</span> <span class="s">"vector"</span><span class="p">,</span> <span class="s">"of"</span><span class="p">,</span> <span class="s">"strings"</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">w</span><span class="o">:</span> <span class="n">createStrings</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">w</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="c1">// this works fine</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">createStrings</span><span class="p">()[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="c1">// this is UB</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">strings</span> <span class="o">=</span> <span class="n">createStrings</span><span class="p">();</span> <span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">strings</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span> <span class="c1">// this now works fine again</span>
  <span class="p">}</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>In the last two articles, we saw how C++ evolved in terms of providing conditional statements and loops with initializers. While one might think that these are just syntactic sugar and indeed, we could always achieve the same effects one way or another. But in reality, they help us write safer code that is better scoped, that exposes less or no undefined behaviour and in general make our code more expressive. The expressiveness, therefore the readability and maintainability of our code can never be overestimated.</p><p>I hope that C++ will keep evolving in this direction and also that we developers keep up with the changes and don’t just stick to old practices.</p><p>Do you use <code class="language-plaintext highlighter-rouge">if</code>/<code class="language-plaintext highlighter-rouge">switch</code>/range based <code class="language-plaintext highlighter-rouge">for</code> loops with initializers? What do you do when you need them but you are stuck on an earlier version?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/loops/" class="post-tag no-text-decoration" >loops</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/algorithms/" class="post-tag no-text-decoration" >algorithms</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The evolution of statements with initializers in C++ - part 2 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The evolution of statements with initializers in C++ - part 2 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The evolution of statements with initializers in C++ - part 2 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The evolution of statements with initializers in C++ - part 2 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/10/initializations-part-1"><div class="card-body"> <span class="timeago small" > Apr 10, 2024 <i class="unloaded">2024-04-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 1</h3><div class="text-muted small"><p> Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/10/28/template-metaprogramming-with-cpp-by-marius-bancila" class="btn btn-outline-primary" prompt="Older"><p>Template Metaprogramming with C++ by Marius Bancila</p></a> <a href="/blog/2022/11/05/3-things-mongodb-can-help-you-with" class="btn btn-outline-primary" prompt="Newer"><p>3 Things MongoDB Can Help You With</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The evolution of statements with initializers in C++ - part 2'; this.page.url = 'https://www.sandordargo.com/blog/2022/11/02/statements-with-initializers-part-2-loops'; this.page.identifier = '/blog/2022/11/02/statements-with-initializers-part-2-loops'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
