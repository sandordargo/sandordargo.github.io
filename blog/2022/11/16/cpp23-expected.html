<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: The &lt;expected&gt; header; expect the unexpected" /><meta property="og:locale" content="en_US" /><meta name="description" content="What do you do when you have to return multiple values from a function? Do you return an instance of some data structure? Do you use output variables? Maybe you throw an exception to get rid of the error codes? It’s not an obvious choice. C++23 offers a standardized solution to deal with status codes and expected return values at the same time in a sophisticated manner with the help of the &lt;expected&gt; library. How we used to do it? Handling nominal return values and status codes is a problem we have had several solutions for, though none of them is perfect. Using output parameters Probably the most ancient and most used way of returning both a status code and a nominal result (i.e. an expected value) is via “out” variables. Let’s say you have a function that returns an error code - which is often an integer - and the nominal return value via an out variable. It could be the other way around, but more often it’s like this. Why and why not the other way around? I see two reasons for that: the error code is easier to ignore if it resides in an out variable. When it’s a direct return value, you’ll check it with a higher chance usually the return values are bigger in terms of size. By passing the memory location for it by reference, you are guaranteed that it’ll be allocated only once. No (N)RVO is needed. Here is an example: 1 2 3 4 5 6 7 8 9 int fetchCitiesFromDb(const std::string&amp; query, std::vector&lt;std::string&gt;&amp; results) { // ... }; // ... std::vector&lt;std::string&gt; v; int errorCode = fetchCitiesFromDb(aQuery, v); The drawback is that such APIs are not so easy to understand. By default, one would expect to find the output at the return value and would interpret parameters as inputs, but it’s not the case with this solution. It’s simply not straightforward. Using exceptions Another option for error handling is the obvious one! Use exceptions. Well, if you can. They are not allowed in all the different environments, some teams ban their usage. It’s a controversial topic in the sense that people can be very opinionated about exceptions, many books and conference talks could be and were filled with exceptions. Some argue that they are costly. As always, it depends. If you spend most of your time reading from a database or sending data over the network, then it’s not so important. On the other hand, what is always true is that it goes completely around the normal control flow and it’s very difficult to reason about code using exceptions. Often you don’t see, or it’s very difficult to see starting from where you end up where. Many misuse exceptions, log errors several times and keep rethrowing exceptions. I think the only way it could work well is if you have an exception-handling strategy that is clearly stated as part of the documentation. Even then there is a fair chance that it won’t be respected. Especially in a big corporation where people always come and go. Using std::variant or std::optional A modern answer to this burning question is to use one of the data structures introduced by C++17, variant or optional. If you pick std::optional, then the presence of a value would mean that everything went fine, as expected. If the value is missing, or in other words, if the return value is std::nullopt, you have to deal with the error case. This approach has (at least) one shortcoming, there is no way to differentiate between different error cases. A status code can have many values, you might throw exceptions of many different types and/or with different messages, but you either have a value present or not with std::optional. That’s why for cases that would require different error codes, std::variant is often picked. A std::variant is often referred to as a type-safe union. In reality, it’s a class template taking different types and it will always hold exactly one of those. That’s why it’s mandatory for the first type to be default constructible (or use the std::monostate as a placeholder). When you instantiate a variant without specifying its value, it’ll be the default constructed version of the first type. But let’s get back to error handling. How does a variant help? You can say that you want your variant to hold either the nominal return type or a status code. That’s a neat and elegant solution. The problem here is the additional syntax you need to access either one or the other value. It’s not made for error handling, so the names are not so descriptive, and you might find the overhead a bit too much. On the other hand, the syntax for std::optional is quite straightforward and easy to read. Wouldn’t it be great to combine the capabilities of a variant with the API of an optional? What does std::expected offer? std::expected offers exactly that! The freedom of storing either the expected return value or an error code and you get a very neat optional-like API to access the different values. To get a bit more into the details, std::expected is a template class taking two parameters: std::expected&lt;T, E&gt;. The first one, T, represent the nominal return type (the expected type), and E is the type to return in case of an error. Meaning that it cannot only be an error code, it can be any type that you think would serve well to represent an error. Just like std::optional, it offers the following API: has_value() operator bool() operator*() operator-&gt;() value() value_or() In addition, it offers another API function: error() Now let’s see what each does. has_value() and operator bool() are the same. They both return true if the instance of std::expected&lt;T, E&gt; contains a value of type T, false otherwise. operator*() and operator-&gt;() are to access the nominal return type either via value or pointer semantics. But beware, should you use any of these operators while the std::expected object doesn’t contain the expected value, the behaviour is undefined. On the other hand, if you try to get a reference to the expected value via the value() function and there is nothing to return, the behaviour is well-defined, and you’ll get a std::bad_expected_access exception thrown. If you want to have a default value, in case there is none in the object, use value_or() and you can specify the default as a parameter. Last but not least, the error() member function returns the unexpected, the error value. How to use it? Is it already supported? The &lt;expected&gt; header is already supported both by gcc and msvc. You can always check the level of compiler support on C++ Reference. Now let’s see std::expected in action! Let’s continue working with fetchCitiesFromDb which uses our favourite new wrapper, std::expected, as a return type. 1 2 3 4 5 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb() { // ... ? } In order to return the expected value, we don’t have to wrap it with anything. We can simply return it as we’d do without the expected wrapper. 1 2 3 4 5 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb() { return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } Now let’s introduce an input parameter which we’ll use in a guard close to provoke an error. In case that parameter is empty let’s return an error code by using the std::unexpected constructor. 1 2 3 4 5 6 7 8 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString) { if (connectionString.empty()) { return std::unexpected&lt;ErrorCode&gt; { ErrorCode::InvalidConnectionString }; } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } Thanks to CTAD, we could also return simply std::unexpected{ErrorCode::InvalidConnectionString}. And now let’s introduce another parameter and another guard close so that we can see another way to return an unexpected value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;expected&gt; #include &lt;string&gt; enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString, std::string query) { if (connectionString.empty()) { return std::unexpected { ErrorCode::InvalidConnectionString }; // return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpected(ErrorCode::InvalidConnectionString) ); would also work if we wanted to be more verbose } if (query.empty()) { return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpect_t{}, ErrorCode::InvalidQuery ); } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } int main () { fetchCitiesFromDb(&quot;&quot;, &quot;&quot;); } In the above example, we saw how to return either an expected or an unexpected value. Now let’s see how we can use them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;expected&gt; #include &lt;string&gt; #include &lt;iomanip&gt; enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ErrorCode ec) { switch (ec) { case ErrorCode::InvalidConnectionString: os &lt;&lt; &quot;ErrorCode::InvalidConnectionString&quot;; break; case ErrorCode::InvalidQuery: os &lt;&lt; &quot;ErrorCode::InvalidQuery&quot;; break; } return os; } std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;std::string&gt;&amp; v) { os &lt;&lt; &#39;[&#39;; for (const auto&amp; s : v) { if (&amp;s != &amp;v[0]) { os &lt;&lt; &quot;, &quot;; } os &lt;&lt; std::quoted(s); } os &lt;&lt; &#39;]&#39;; return os; } std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString, std::string query) { if (connectionString.empty()) { return std::unexpected { ErrorCode::InvalidConnectionString }; } if (query.empty()) { return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpect_t{}, ErrorCode::InvalidQuery ); } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } int main () { auto r = fetchCitiesFromDb(&quot;&quot;, &quot;&quot;); if (r) { // (1) std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;\&quot;, \&quot;\&quot;) returned &quot; &lt;&lt; r.value().size() &lt;&lt; &quot; cities.\n&quot;; } else { std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;\&quot;, \&quot;\&quot;) returned an error! &quot; &lt;&lt; r.error() &lt;&lt; &#39;\n&#39;; } auto r2 = fetchCitiesFromDb(&quot;demo&quot;, &quot;&quot;); std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;\&quot;) gave us this vector: &quot; &lt;&lt; r2.value_or(std::vector&lt;std::string&gt;{}) &lt;&lt; &#39;\n&#39;; // (2) //std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;\&quot;); returned&quot; &lt;&lt; r2.value_or(r.error()) &lt;&lt; &#39;\n&#39;; auto r3 = fetchCitiesFromDb(&quot;demo&quot;, &quot;effects&quot;); if (r3.has_value()) { // (3) std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;effects\&quot;) returned &quot; &lt;&lt; *r3 &lt;&lt; &quot; which has a size of: &quot; &lt;&lt; r3-&gt;size() &lt;&lt; &#39;\n&#39;; // (4) } else { std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;effects\&quot;) returned an error! &quot; &lt;&lt; r3.error() &lt;&lt; &#39;\n&#39;; } } First, we can see at (1) that we used operator bool() and if the returned value is the expected, then it evaluates to true, otherwise to false. If operator bool() == false, then error() should return a valid unexpected value. At line (2) we see that if we don’t want to query the error, but we want to use a default value if there is no expected value available, then we can simply call value_or(&lt;default value&gt;). It’s worth noting that the default value, the one that we pass with value_or(), must be of the same type as value() would return. In other words, it must be an instance of the expected type. At lines (3) and (4) we see if has_value() returns true then we can safely use the operator-&gt;() in order to access a member of the expected value. How it fits the alternatives? When to use exceptions? After having seen all that, it’s to ask ourselves how this goes with the alternatives. What way of error handling should we choose? In my opinion, this new utility type, std::expected is clearly a superior way to all non-exception ways of error-handling. I never liked having a return type and out parameters. Such APIs are not simple enough. If there should be multiple expected return values, create a struct, a class whichever fits better your needs. If one represents the success of the operation, you might have wanted to go with optional, but if you have to deal with multiple error codes you might have wanted to go with a variant. Now all this - when error codes are involved - should be replaced with the &lt;expected&gt; header. When it comes to exceptions, the situation is a bit more tricky. First of all, there are environments, teams even companies where the usage of exceptions is banned. That’s an easy question then, &lt;expected&gt; will serve you well. Otherwise, exceptions are not easy to use well. They go completely across the normal flow of control, often logging is either neglected or it’s done multiple times. In my opinion, how exceptions are handled should be documented in a project and they should follow a clear strategy. That strategy should strike out the documentation, so both newcomers on the project and code reviewers can easily see it. Using exceptions is a decision and std::expected does not provide the same functionality. On the other hand, it’s also worth remembering the idea behind exceptions. When should they be used? In exceptional cases! An error that you expect, is not exceptional. It’s unexpected but probable. Accessing a vector out of bounds, running out of memory and therefore having an allocation issue, and accessing a value of an optional when it doesn’t contain any are exceptional cases that should not happen. I think using exceptions is allowed and meaningful in such situations. On the other hand, in situations which are likely to happen in unexceptional circumstances (like a user is passing a value out of the expected range), when you hesitate between using exceptions are error codes in any way, I think going with the &lt;expected&gt; header is the right call. Conclusion Writing functions that are supposed to return both a normal return value and a status code at the same has been painful for decades. You either had to create your custom data structure or besides return values, you had to use our parameters too. Later C++17 introduced both std::optional and ` std::variant` offering some alternatives, but they were not designed to deal with error handling. C++23 will bring as std::exceptional that is a standardized data structure with a std::optional-like API aiming to hold an expected value or an error code. It’s a readable, easy-to-use solution that will increase the readability of our APIs! Sounds very promising! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="What do you do when you have to return multiple values from a function? Do you return an instance of some data structure? Do you use output variables? Maybe you throw an exception to get rid of the error codes? It’s not an obvious choice. C++23 offers a standardized solution to deal with status codes and expected return values at the same time in a sophisticated manner with the help of the &lt;expected&gt; library. How we used to do it? Handling nominal return values and status codes is a problem we have had several solutions for, though none of them is perfect. Using output parameters Probably the most ancient and most used way of returning both a status code and a nominal result (i.e. an expected value) is via “out” variables. Let’s say you have a function that returns an error code - which is often an integer - and the nominal return value via an out variable. It could be the other way around, but more often it’s like this. Why and why not the other way around? I see two reasons for that: the error code is easier to ignore if it resides in an out variable. When it’s a direct return value, you’ll check it with a higher chance usually the return values are bigger in terms of size. By passing the memory location for it by reference, you are guaranteed that it’ll be allocated only once. No (N)RVO is needed. Here is an example: 1 2 3 4 5 6 7 8 9 int fetchCitiesFromDb(const std::string&amp; query, std::vector&lt;std::string&gt;&amp; results) { // ... }; // ... std::vector&lt;std::string&gt; v; int errorCode = fetchCitiesFromDb(aQuery, v); The drawback is that such APIs are not so easy to understand. By default, one would expect to find the output at the return value and would interpret parameters as inputs, but it’s not the case with this solution. It’s simply not straightforward. Using exceptions Another option for error handling is the obvious one! Use exceptions. Well, if you can. They are not allowed in all the different environments, some teams ban their usage. It’s a controversial topic in the sense that people can be very opinionated about exceptions, many books and conference talks could be and were filled with exceptions. Some argue that they are costly. As always, it depends. If you spend most of your time reading from a database or sending data over the network, then it’s not so important. On the other hand, what is always true is that it goes completely around the normal control flow and it’s very difficult to reason about code using exceptions. Often you don’t see, or it’s very difficult to see starting from where you end up where. Many misuse exceptions, log errors several times and keep rethrowing exceptions. I think the only way it could work well is if you have an exception-handling strategy that is clearly stated as part of the documentation. Even then there is a fair chance that it won’t be respected. Especially in a big corporation where people always come and go. Using std::variant or std::optional A modern answer to this burning question is to use one of the data structures introduced by C++17, variant or optional. If you pick std::optional, then the presence of a value would mean that everything went fine, as expected. If the value is missing, or in other words, if the return value is std::nullopt, you have to deal with the error case. This approach has (at least) one shortcoming, there is no way to differentiate between different error cases. A status code can have many values, you might throw exceptions of many different types and/or with different messages, but you either have a value present or not with std::optional. That’s why for cases that would require different error codes, std::variant is often picked. A std::variant is often referred to as a type-safe union. In reality, it’s a class template taking different types and it will always hold exactly one of those. That’s why it’s mandatory for the first type to be default constructible (or use the std::monostate as a placeholder). When you instantiate a variant without specifying its value, it’ll be the default constructed version of the first type. But let’s get back to error handling. How does a variant help? You can say that you want your variant to hold either the nominal return type or a status code. That’s a neat and elegant solution. The problem here is the additional syntax you need to access either one or the other value. It’s not made for error handling, so the names are not so descriptive, and you might find the overhead a bit too much. On the other hand, the syntax for std::optional is quite straightforward and easy to read. Wouldn’t it be great to combine the capabilities of a variant with the API of an optional? What does std::expected offer? std::expected offers exactly that! The freedom of storing either the expected return value or an error code and you get a very neat optional-like API to access the different values. To get a bit more into the details, std::expected is a template class taking two parameters: std::expected&lt;T, E&gt;. The first one, T, represent the nominal return type (the expected type), and E is the type to return in case of an error. Meaning that it cannot only be an error code, it can be any type that you think would serve well to represent an error. Just like std::optional, it offers the following API: has_value() operator bool() operator*() operator-&gt;() value() value_or() In addition, it offers another API function: error() Now let’s see what each does. has_value() and operator bool() are the same. They both return true if the instance of std::expected&lt;T, E&gt; contains a value of type T, false otherwise. operator*() and operator-&gt;() are to access the nominal return type either via value or pointer semantics. But beware, should you use any of these operators while the std::expected object doesn’t contain the expected value, the behaviour is undefined. On the other hand, if you try to get a reference to the expected value via the value() function and there is nothing to return, the behaviour is well-defined, and you’ll get a std::bad_expected_access exception thrown. If you want to have a default value, in case there is none in the object, use value_or() and you can specify the default as a parameter. Last but not least, the error() member function returns the unexpected, the error value. How to use it? Is it already supported? The &lt;expected&gt; header is already supported both by gcc and msvc. You can always check the level of compiler support on C++ Reference. Now let’s see std::expected in action! Let’s continue working with fetchCitiesFromDb which uses our favourite new wrapper, std::expected, as a return type. 1 2 3 4 5 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb() { // ... ? } In order to return the expected value, we don’t have to wrap it with anything. We can simply return it as we’d do without the expected wrapper. 1 2 3 4 5 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb() { return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } Now let’s introduce an input parameter which we’ll use in a guard close to provoke an error. In case that parameter is empty let’s return an error code by using the std::unexpected constructor. 1 2 3 4 5 6 7 8 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString) { if (connectionString.empty()) { return std::unexpected&lt;ErrorCode&gt; { ErrorCode::InvalidConnectionString }; } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } Thanks to CTAD, we could also return simply std::unexpected{ErrorCode::InvalidConnectionString}. And now let’s introduce another parameter and another guard close so that we can see another way to return an unexpected value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;expected&gt; #include &lt;string&gt; enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString, std::string query) { if (connectionString.empty()) { return std::unexpected { ErrorCode::InvalidConnectionString }; // return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpected(ErrorCode::InvalidConnectionString) ); would also work if we wanted to be more verbose } if (query.empty()) { return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpect_t{}, ErrorCode::InvalidQuery ); } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } int main () { fetchCitiesFromDb(&quot;&quot;, &quot;&quot;); } In the above example, we saw how to return either an expected or an unexpected value. Now let’s see how we can use them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;expected&gt; #include &lt;string&gt; #include &lt;iomanip&gt; enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ErrorCode ec) { switch (ec) { case ErrorCode::InvalidConnectionString: os &lt;&lt; &quot;ErrorCode::InvalidConnectionString&quot;; break; case ErrorCode::InvalidQuery: os &lt;&lt; &quot;ErrorCode::InvalidQuery&quot;; break; } return os; } std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;std::string&gt;&amp; v) { os &lt;&lt; &#39;[&#39;; for (const auto&amp; s : v) { if (&amp;s != &amp;v[0]) { os &lt;&lt; &quot;, &quot;; } os &lt;&lt; std::quoted(s); } os &lt;&lt; &#39;]&#39;; return os; } std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString, std::string query) { if (connectionString.empty()) { return std::unexpected { ErrorCode::InvalidConnectionString }; } if (query.empty()) { return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpect_t{}, ErrorCode::InvalidQuery ); } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } int main () { auto r = fetchCitiesFromDb(&quot;&quot;, &quot;&quot;); if (r) { // (1) std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;\&quot;, \&quot;\&quot;) returned &quot; &lt;&lt; r.value().size() &lt;&lt; &quot; cities.\n&quot;; } else { std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;\&quot;, \&quot;\&quot;) returned an error! &quot; &lt;&lt; r.error() &lt;&lt; &#39;\n&#39;; } auto r2 = fetchCitiesFromDb(&quot;demo&quot;, &quot;&quot;); std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;\&quot;) gave us this vector: &quot; &lt;&lt; r2.value_or(std::vector&lt;std::string&gt;{}) &lt;&lt; &#39;\n&#39;; // (2) //std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;\&quot;); returned&quot; &lt;&lt; r2.value_or(r.error()) &lt;&lt; &#39;\n&#39;; auto r3 = fetchCitiesFromDb(&quot;demo&quot;, &quot;effects&quot;); if (r3.has_value()) { // (3) std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;effects\&quot;) returned &quot; &lt;&lt; *r3 &lt;&lt; &quot; which has a size of: &quot; &lt;&lt; r3-&gt;size() &lt;&lt; &#39;\n&#39;; // (4) } else { std::cout &lt;&lt; &quot;fetchCitiesFromDb(\&quot;demo\&quot;, \&quot;effects\&quot;) returned an error! &quot; &lt;&lt; r3.error() &lt;&lt; &#39;\n&#39;; } } First, we can see at (1) that we used operator bool() and if the returned value is the expected, then it evaluates to true, otherwise to false. If operator bool() == false, then error() should return a valid unexpected value. At line (2) we see that if we don’t want to query the error, but we want to use a default value if there is no expected value available, then we can simply call value_or(&lt;default value&gt;). It’s worth noting that the default value, the one that we pass with value_or(), must be of the same type as value() would return. In other words, it must be an instance of the expected type. At lines (3) and (4) we see if has_value() returns true then we can safely use the operator-&gt;() in order to access a member of the expected value. How it fits the alternatives? When to use exceptions? After having seen all that, it’s to ask ourselves how this goes with the alternatives. What way of error handling should we choose? In my opinion, this new utility type, std::expected is clearly a superior way to all non-exception ways of error-handling. I never liked having a return type and out parameters. Such APIs are not simple enough. If there should be multiple expected return values, create a struct, a class whichever fits better your needs. If one represents the success of the operation, you might have wanted to go with optional, but if you have to deal with multiple error codes you might have wanted to go with a variant. Now all this - when error codes are involved - should be replaced with the &lt;expected&gt; header. When it comes to exceptions, the situation is a bit more tricky. First of all, there are environments, teams even companies where the usage of exceptions is banned. That’s an easy question then, &lt;expected&gt; will serve you well. Otherwise, exceptions are not easy to use well. They go completely across the normal flow of control, often logging is either neglected or it’s done multiple times. In my opinion, how exceptions are handled should be documented in a project and they should follow a clear strategy. That strategy should strike out the documentation, so both newcomers on the project and code reviewers can easily see it. Using exceptions is a decision and std::expected does not provide the same functionality. On the other hand, it’s also worth remembering the idea behind exceptions. When should they be used? In exceptional cases! An error that you expect, is not exceptional. It’s unexpected but probable. Accessing a vector out of bounds, running out of memory and therefore having an allocation issue, and accessing a value of an optional when it doesn’t contain any are exceptional cases that should not happen. I think using exceptions is allowed and meaningful in such situations. On the other hand, in situations which are likely to happen in unexceptional circumstances (like a user is passing a value out of the expected range), when you hesitate between using exceptions are error codes in any way, I think going with the &lt;expected&gt; header is the right call. Conclusion Writing functions that are supposed to return both a normal return value and a status code at the same has been painful for decades. You either had to create your custom data structure or besides return values, you had to use our parameters too. Later C++17 introduced both std::optional and ` std::variant` offering some alternatives, but they were not designed to deal with error handling. C++23 will bring as std::exceptional that is a standardized data structure with a std::optional-like API aiming to hold an expected value or an error code. It’s a readable, easy-to-use solution that will increase the readability of our APIs! Sounds very promising! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/11/16/cpp23-expected" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/11/16/cpp23-expected" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-16T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: The &lt;expected&gt; header; expect the unexpected" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-10T22:52:31+02:00","datePublished":"2022-11-16T00:00:00+01:00","description":"What do you do when you have to return multiple values from a function? Do you return an instance of some data structure? Do you use output variables? Maybe you throw an exception to get rid of the error codes? It’s not an obvious choice. C++23 offers a standardized solution to deal with status codes and expected return values at the same time in a sophisticated manner with the help of the &lt;expected&gt; library. How we used to do it? Handling nominal return values and status codes is a problem we have had several solutions for, though none of them is perfect. Using output parameters Probably the most ancient and most used way of returning both a status code and a nominal result (i.e. an expected value) is via “out” variables. Let’s say you have a function that returns an error code - which is often an integer - and the nominal return value via an out variable. It could be the other way around, but more often it’s like this. Why and why not the other way around? I see two reasons for that: the error code is easier to ignore if it resides in an out variable. When it’s a direct return value, you’ll check it with a higher chance usually the return values are bigger in terms of size. By passing the memory location for it by reference, you are guaranteed that it’ll be allocated only once. No (N)RVO is needed. Here is an example: 1 2 3 4 5 6 7 8 9 int fetchCitiesFromDb(const std::string&amp; query, std::vector&lt;std::string&gt;&amp; results) { // ... }; // ... std::vector&lt;std::string&gt; v; int errorCode = fetchCitiesFromDb(aQuery, v); The drawback is that such APIs are not so easy to understand. By default, one would expect to find the output at the return value and would interpret parameters as inputs, but it’s not the case with this solution. It’s simply not straightforward. Using exceptions Another option for error handling is the obvious one! Use exceptions. Well, if you can. They are not allowed in all the different environments, some teams ban their usage. It’s a controversial topic in the sense that people can be very opinionated about exceptions, many books and conference talks could be and were filled with exceptions. Some argue that they are costly. As always, it depends. If you spend most of your time reading from a database or sending data over the network, then it’s not so important. On the other hand, what is always true is that it goes completely around the normal control flow and it’s very difficult to reason about code using exceptions. Often you don’t see, or it’s very difficult to see starting from where you end up where. Many misuse exceptions, log errors several times and keep rethrowing exceptions. I think the only way it could work well is if you have an exception-handling strategy that is clearly stated as part of the documentation. Even then there is a fair chance that it won’t be respected. Especially in a big corporation where people always come and go. Using std::variant or std::optional A modern answer to this burning question is to use one of the data structures introduced by C++17, variant or optional. If you pick std::optional, then the presence of a value would mean that everything went fine, as expected. If the value is missing, or in other words, if the return value is std::nullopt, you have to deal with the error case. This approach has (at least) one shortcoming, there is no way to differentiate between different error cases. A status code can have many values, you might throw exceptions of many different types and/or with different messages, but you either have a value present or not with std::optional. That’s why for cases that would require different error codes, std::variant is often picked. A std::variant is often referred to as a type-safe union. In reality, it’s a class template taking different types and it will always hold exactly one of those. That’s why it’s mandatory for the first type to be default constructible (or use the std::monostate as a placeholder). When you instantiate a variant without specifying its value, it’ll be the default constructed version of the first type. But let’s get back to error handling. How does a variant help? You can say that you want your variant to hold either the nominal return type or a status code. That’s a neat and elegant solution. The problem here is the additional syntax you need to access either one or the other value. It’s not made for error handling, so the names are not so descriptive, and you might find the overhead a bit too much. On the other hand, the syntax for std::optional is quite straightforward and easy to read. Wouldn’t it be great to combine the capabilities of a variant with the API of an optional? What does std::expected offer? std::expected offers exactly that! The freedom of storing either the expected return value or an error code and you get a very neat optional-like API to access the different values. To get a bit more into the details, std::expected is a template class taking two parameters: std::expected&lt;T, E&gt;. The first one, T, represent the nominal return type (the expected type), and E is the type to return in case of an error. Meaning that it cannot only be an error code, it can be any type that you think would serve well to represent an error. Just like std::optional, it offers the following API: has_value() operator bool() operator*() operator-&gt;() value() value_or() In addition, it offers another API function: error() Now let’s see what each does. has_value() and operator bool() are the same. They both return true if the instance of std::expected&lt;T, E&gt; contains a value of type T, false otherwise. operator*() and operator-&gt;() are to access the nominal return type either via value or pointer semantics. But beware, should you use any of these operators while the std::expected object doesn’t contain the expected value, the behaviour is undefined. On the other hand, if you try to get a reference to the expected value via the value() function and there is nothing to return, the behaviour is well-defined, and you’ll get a std::bad_expected_access exception thrown. If you want to have a default value, in case there is none in the object, use value_or() and you can specify the default as a parameter. Last but not least, the error() member function returns the unexpected, the error value. How to use it? Is it already supported? The &lt;expected&gt; header is already supported both by gcc and msvc. You can always check the level of compiler support on C++ Reference. Now let’s see std::expected in action! Let’s continue working with fetchCitiesFromDb which uses our favourite new wrapper, std::expected, as a return type. 1 2 3 4 5 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb() { // ... ? } In order to return the expected value, we don’t have to wrap it with anything. We can simply return it as we’d do without the expected wrapper. 1 2 3 4 5 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb() { return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } Now let’s introduce an input parameter which we’ll use in a guard close to provoke an error. In case that parameter is empty let’s return an error code by using the std::unexpected constructor. 1 2 3 4 5 6 7 8 enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString) { if (connectionString.empty()) { return std::unexpected&lt;ErrorCode&gt; { ErrorCode::InvalidConnectionString }; } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } Thanks to CTAD, we could also return simply std::unexpected{ErrorCode::InvalidConnectionString}. And now let’s introduce another parameter and another guard close so that we can see another way to return an unexpected value. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;expected&gt; #include &lt;string&gt; enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString, std::string query) { if (connectionString.empty()) { return std::unexpected { ErrorCode::InvalidConnectionString }; // return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpected(ErrorCode::InvalidConnectionString) ); would also work if we wanted to be more verbose } if (query.empty()) { return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpect_t{}, ErrorCode::InvalidQuery ); } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } int main () { fetchCitiesFromDb(&quot;&quot;, &quot;&quot;); } In the above example, we saw how to return either an expected or an unexpected value. Now let’s see how we can use them. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 #include &lt;iostream&gt; #include &lt;vector&gt; #include &lt;expected&gt; #include &lt;string&gt; #include &lt;iomanip&gt; enum class ErrorCode { InvalidConnectionString, InvalidQuery }; std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, ErrorCode ec) { switch (ec) { case ErrorCode::InvalidConnectionString: os &lt;&lt; &quot;ErrorCode::InvalidConnectionString&quot;; break; case ErrorCode::InvalidQuery: os &lt;&lt; &quot;ErrorCode::InvalidQuery&quot;; break; } return os; } std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, const std::vector&lt;std::string&gt;&amp; v) { os &lt;&lt; &#39;[&#39;; for (const auto&amp; s : v) { if (&amp;s != &amp;v[0]) { os &lt;&lt; &quot;, &quot;; } os &lt;&lt; std::quoted(s); } os &lt;&lt; &#39;]&#39;; return os; } std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; fetchCitiesFromDb(std::string connectionString, std::string query) { if (connectionString.empty()) { return std::unexpected { ErrorCode::InvalidConnectionString }; } if (query.empty()) { return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpect_t{}, ErrorCode::InvalidQuery ); } return std::vector&lt;std::string&gt;{&quot;Budapest&quot;, &quot;Nice&quot;, &quot;Stockholm&quot;}; } int main () { auto r = fetchCitiesFromDb(&quot;&quot;, &quot;&quot;); if (r) { // (1) std::cout &lt;&lt; &quot;fetchCitiesFromDb(\\&quot;\\&quot;, \\&quot;\\&quot;) returned &quot; &lt;&lt; r.value().size() &lt;&lt; &quot; cities.\\n&quot;; } else { std::cout &lt;&lt; &quot;fetchCitiesFromDb(\\&quot;\\&quot;, \\&quot;\\&quot;) returned an error! &quot; &lt;&lt; r.error() &lt;&lt; &#39;\\n&#39;; } auto r2 = fetchCitiesFromDb(&quot;demo&quot;, &quot;&quot;); std::cout &lt;&lt; &quot;fetchCitiesFromDb(\\&quot;demo\\&quot;, \\&quot;\\&quot;) gave us this vector: &quot; &lt;&lt; r2.value_or(std::vector&lt;std::string&gt;{}) &lt;&lt; &#39;\\n&#39;; // (2) //std::cout &lt;&lt; &quot;fetchCitiesFromDb(\\&quot;demo\\&quot;, \\&quot;\\&quot;); returned&quot; &lt;&lt; r2.value_or(r.error()) &lt;&lt; &#39;\\n&#39;; auto r3 = fetchCitiesFromDb(&quot;demo&quot;, &quot;effects&quot;); if (r3.has_value()) { // (3) std::cout &lt;&lt; &quot;fetchCitiesFromDb(\\&quot;demo\\&quot;, \\&quot;effects\\&quot;) returned &quot; &lt;&lt; *r3 &lt;&lt; &quot; which has a size of: &quot; &lt;&lt; r3-&gt;size() &lt;&lt; &#39;\\n&#39;; // (4) } else { std::cout &lt;&lt; &quot;fetchCitiesFromDb(\\&quot;demo\\&quot;, \\&quot;effects\\&quot;) returned an error! &quot; &lt;&lt; r3.error() &lt;&lt; &#39;\\n&#39;; } } First, we can see at (1) that we used operator bool() and if the returned value is the expected, then it evaluates to true, otherwise to false. If operator bool() == false, then error() should return a valid unexpected value. At line (2) we see that if we don’t want to query the error, but we want to use a default value if there is no expected value available, then we can simply call value_or(&lt;default value&gt;). It’s worth noting that the default value, the one that we pass with value_or(), must be of the same type as value() would return. In other words, it must be an instance of the expected type. At lines (3) and (4) we see if has_value() returns true then we can safely use the operator-&gt;() in order to access a member of the expected value. How it fits the alternatives? When to use exceptions? After having seen all that, it’s to ask ourselves how this goes with the alternatives. What way of error handling should we choose? In my opinion, this new utility type, std::expected is clearly a superior way to all non-exception ways of error-handling. I never liked having a return type and out parameters. Such APIs are not simple enough. If there should be multiple expected return values, create a struct, a class whichever fits better your needs. If one represents the success of the operation, you might have wanted to go with optional, but if you have to deal with multiple error codes you might have wanted to go with a variant. Now all this - when error codes are involved - should be replaced with the &lt;expected&gt; header. When it comes to exceptions, the situation is a bit more tricky. First of all, there are environments, teams even companies where the usage of exceptions is banned. That’s an easy question then, &lt;expected&gt; will serve you well. Otherwise, exceptions are not easy to use well. They go completely across the normal flow of control, often logging is either neglected or it’s done multiple times. In my opinion, how exceptions are handled should be documented in a project and they should follow a clear strategy. That strategy should strike out the documentation, so both newcomers on the project and code reviewers can easily see it. Using exceptions is a decision and std::expected does not provide the same functionality. On the other hand, it’s also worth remembering the idea behind exceptions. When should they be used? In exceptional cases! An error that you expect, is not exceptional. It’s unexpected but probable. Accessing a vector out of bounds, running out of memory and therefore having an allocation issue, and accessing a value of an optional when it doesn’t contain any are exceptional cases that should not happen. I think using exceptions is allowed and meaningful in such situations. On the other hand, in situations which are likely to happen in unexceptional circumstances (like a user is passing a value out of the expected range), when you hesitate between using exceptions are error codes in any way, I think going with the &lt;expected&gt; header is the right call. Conclusion Writing functions that are supposed to return both a normal return value and a status code at the same has been painful for decades. You either had to create your custom data structure or besides return values, you had to use our parameters too. Later C++17 introduced both std::optional and ` std::variant` offering some alternatives, but they were not designed to deal with error handling. C++23 will bring as std::exceptional that is a standardized data structure with a std::optional-like API aiming to hold an expected value or an error code. It’s a readable, easy-to-use solution that will increase the readability of our APIs! Sounds very promising! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: The &lt;expected&gt; header; expect the unexpected","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/11/16/cpp23-expected"},"url":"https://www.sandordargo.com/blog/2022/11/16/cpp23-expected"}</script><title>C++23: The &lt;expected&gt; header; expect the unexpected | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/16"> 16 </a> </span> <span>C++23: The &lt;expected&gt; header; expect the unexpected</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: The &lt;expected&gt; header; expect the unexpected</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 16, 2022, 12:00 AM +0100" prep="on" > Nov 16, 2022 <i class="unloaded">2022-11-16T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, May 10, 2023, 10:52 PM +0200" prefix="Updated " > May 10, 2023 <i class="unloaded">2023-05-10T22:52:31+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2359 words">13 min</span></div></div><div class="post-content"><p>What do you do when you have to return multiple values from a function? Do you return an instance of some data structure? Do you use output variables? Maybe you throw an exception to get rid of the error codes?</p><p>It’s not an obvious choice.</p><p>C++23 offers a standardized solution to deal with status codes and expected return values at the same time in a sophisticated manner with the help of the <code class="language-plaintext highlighter-rouge">&lt;expected&gt;</code> library.</p><h2 id="how-we-used-to-do-it">How we used to do it?</h2><p>Handling nominal return values and status codes is a problem we have had several solutions for, though none of them is perfect.</p><h3 id="using-output-parameters">Using output parameters</h3><p>Probably the most ancient and most used way of returning both a status code and a nominal result (i.e. an expected value) is via “out” variables. Let’s say you have a function that returns an error code - which is often an integer - and the nominal return value via an out variable. It could be the other way around, but more often it’s like this.</p><p>Why and why not the other way around?</p><p>I see two reasons for that:</p><ul><li>the error code is easier to ignore if it resides in an out variable. When it’s a direct return value, you’ll check it with a higher chance<li>usually the return values are bigger in terms of size. By passing the memory location for it by reference, you are guaranteed that it’ll be allocated only once. No (N)RVO is needed.</ul><p>Here is an example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>
<span class="kt">int</span> <span class="nf">fetchCitiesFromDb</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">query</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">results</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="c1">// ...</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">errorCode</span> <span class="o">=</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="n">aQuery</span><span class="p">,</span> <span class="n">v</span><span class="p">);</span>
</pre></table></code></div></div><p>The drawback is that such APIs are not so easy to understand. By default, one would expect to find the output at the return value and would interpret parameters as inputs, but it’s not the case with this solution. It’s simply not straightforward.</p><h3 id="using-exceptions">Using exceptions</h3><p>Another option for error handling is the obvious one! Use exceptions. Well, if you can. They are not allowed in all the different environments, some teams ban their usage.</p><p>It’s a controversial topic in the sense that people can be very opinionated about exceptions, many books and conference talks could be and were filled with exceptions.</p><p>Some argue that they are costly. As always, it depends. If you spend most of your time reading from a database or sending data over the network, then it’s not so important.</p><p>On the other hand, what is always true is that it goes completely around the normal control flow and it’s very difficult to reason about code using exceptions. Often you don’t see, or it’s very difficult to see starting from where you end up where. Many misuse exceptions, log errors several times and keep rethrowing exceptions.</p><p>I think the only way it could work well is if you have an exception-handling strategy that is clearly stated as part of the documentation. Even then there is a fair chance that it won’t be respected. Especially in a big corporation where people always come and go.</p><h3 id="using-stdvariant-or-stdoptional">Using <code class="language-plaintext highlighter-rouge">std::variant</code> or <code class="language-plaintext highlighter-rouge">std::optional</code></h3><p>A modern answer to this burning question is to use one of the data structures introduced by C++17, <code class="language-plaintext highlighter-rouge">variant</code> or <code class="language-plaintext highlighter-rouge">optional</code>. If you pick <code class="language-plaintext highlighter-rouge">std::optional</code>, then the presence of a value would mean that everything went fine, as expected. If the value is missing, or in other words, if the return value is <code class="language-plaintext highlighter-rouge">std::nullopt</code>, you have to deal with the error case.</p><p>This approach has (at least) one shortcoming, there is no way to differentiate between different error cases.</p><p>A status code can have many values, you might throw exceptions of many different types and/or with different messages, but you either have a value present or not with <code class="language-plaintext highlighter-rouge">std::optional</code>.</p><p>That’s why for cases that would require different error codes, <code class="language-plaintext highlighter-rouge">std::variant</code> is often picked. A <code class="language-plaintext highlighter-rouge">std::variant</code> is often referred to as a type-safe union. In reality, it’s a class template taking different types and it will always hold exactly one of those. That’s why it’s mandatory for the first type to be default constructible (or use the <a href="https://en.cppreference.com/w/cpp/utility/variant/monostate"><code class="language-plaintext highlighter-rouge">std::monostate</code></a> as a placeholder). When you instantiate a variant without specifying its value, it’ll be the default constructed version of the first type.</p><p>But let’s get back to error handling. How does a <code class="language-plaintext highlighter-rouge">variant</code> help?</p><p>You can say that you want your <code class="language-plaintext highlighter-rouge">variant</code> to hold either the nominal return type or a status code.</p><p>That’s a neat and elegant solution.</p><p>The problem here is the additional syntax you need to access either one or the other value. It’s not made for error handling, so the names are not so descriptive, and you might find the overhead a bit too much.</p><p>On the other hand, the syntax for <code class="language-plaintext highlighter-rouge">std::optional</code> is quite straightforward and easy to read.</p><p>Wouldn’t it be great to combine the capabilities of a <code class="language-plaintext highlighter-rouge">variant</code> with the API of an <code class="language-plaintext highlighter-rouge">optional</code>?</p><h2 id="what-does-stdexpected-offer">What does <code class="language-plaintext highlighter-rouge">std::expected</code> offer?</h2><p><code class="language-plaintext highlighter-rouge">std::expected</code> offers exactly that! The freedom of storing either the expected return value or an error code and you get a very neat <code class="language-plaintext highlighter-rouge">optional</code>-like API to access the different values.</p><p>To get a bit more into the details, <code class="language-plaintext highlighter-rouge">std::expected</code> is a template class taking two parameters: <code class="language-plaintext highlighter-rouge">std::expected&lt;T, E&gt;</code>. The first one, <code class="language-plaintext highlighter-rouge">T</code>, represent the nominal return type (the expected type), and <code class="language-plaintext highlighter-rouge">E</code> is the type to return in case of an error. Meaning that it cannot only be an error code, it can be any type that you think would serve well to represent an error.</p><p>Just like <code class="language-plaintext highlighter-rouge">std::optional</code>, it offers the following API:</p><ul><li><code class="language-plaintext highlighter-rouge">has_value()</code><li><code class="language-plaintext highlighter-rouge">operator bool()</code><li><code class="language-plaintext highlighter-rouge">operator*()</code><li><code class="language-plaintext highlighter-rouge">operator-&gt;()</code><li><code class="language-plaintext highlighter-rouge">value()</code><li><code class="language-plaintext highlighter-rouge">value_or()</code></ul><p>In addition, it offers another API function:</p><ul><li><code class="language-plaintext highlighter-rouge">error()</code></ul><p>Now let’s see what each does.</p><p><code class="language-plaintext highlighter-rouge">has_value()</code> and <code class="language-plaintext highlighter-rouge">operator bool()</code> are the same. They both return <code class="language-plaintext highlighter-rouge">true</code> if the instance of <code class="language-plaintext highlighter-rouge">std::expected&lt;T, E&gt;</code> contains a value of type <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">false</code> otherwise.</p><p><code class="language-plaintext highlighter-rouge">operator*()</code> and <code class="language-plaintext highlighter-rouge">operator-&gt;()</code> are to access the nominal return type either via value or pointer semantics. But beware, should you use any of these operators while the <code class="language-plaintext highlighter-rouge">std::expected</code> object doesn’t contain the expected value, the behaviour is undefined.</p><p>On the other hand, if you try to get a reference to the expected value via the <code class="language-plaintext highlighter-rouge">value()</code> function and there is nothing to return, the behaviour is well-defined, and you’ll get a <code class="language-plaintext highlighter-rouge">std::bad_expected_access</code> exception thrown. If you want to have a default value, in case there is none in the object, use <code class="language-plaintext highlighter-rouge">value_or()</code> and you can specify the default as a parameter.</p><p>Last but not least, the <code class="language-plaintext highlighter-rouge">error()</code> member function returns the unexpected, the error value.</p><h2 id="how-to-use-it-is-it-already-supported">How to use it? Is it already supported?</h2><p>The <code class="language-plaintext highlighter-rouge">&lt;expected&gt;</code> header is already supported both by <em>gcc</em> and <em>msvc</em>. You can always check the level of compiler support on <a href="https://en.cppreference.com/w/cpp/compiler_support">C++ Reference</a>.</p><p>Now let’s see <code class="language-plaintext highlighter-rouge">std::expected</code> in action!</p><p>Let’s continue working with <code class="language-plaintext highlighter-rouge">fetchCitiesFromDb</code> which uses our favourite new wrapper, <code class="language-plaintext highlighter-rouge">std::expected</code>, as a return type.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorCode</span> <span class="p">{</span> <span class="n">InvalidConnectionString</span><span class="p">,</span> <span class="n">InvalidQuery</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="n">fetchCitiesFromDb</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// ... ?</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In order to return the expected value, we don’t have to wrap it with anything. We can simply return it as we’d do without the <code class="language-plaintext highlighter-rouge">expected</code> wrapper.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorCode</span> <span class="p">{</span> <span class="n">InvalidConnectionString</span><span class="p">,</span> <span class="n">InvalidQuery</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="n">fetchCitiesFromDb</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"Budapest"</span><span class="p">,</span> <span class="s">"Nice"</span><span class="p">,</span> <span class="s">"Stockholm"</span><span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now let’s introduce an input parameter which we’ll use in a guard close to provoke an error. In case that parameter is empty let’s return an error code by using the <code class="language-plaintext highlighter-rouge">std::unexpected</code> constructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorCode</span> <span class="p">{</span> <span class="n">InvalidConnectionString</span><span class="p">,</span> <span class="n">InvalidQuery</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">connectionString</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connectionString</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unexpected</span><span class="o">&lt;</span><span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="p">{</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidConnectionString</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"Budapest"</span><span class="p">,</span> <span class="s">"Nice"</span><span class="p">,</span> <span class="s">"Stockholm"</span><span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Thanks to <a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">CTAD</a>, we could also return simply <code class="language-plaintext highlighter-rouge">std::unexpected{ErrorCode::InvalidConnectionString}</code>.</p><p>And now let’s introduce another parameter and another guard close so that we can see another way to return an unexpected value.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;expected&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorCode</span> <span class="p">{</span> <span class="n">InvalidConnectionString</span><span class="p">,</span> <span class="n">InvalidQuery</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">connectionString</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">query</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connectionString</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unexpected</span> <span class="p">{</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidConnectionString</span> <span class="p">};</span> 
        <span class="c1">// return std::expected&lt;std::vector&lt;std::string&gt;, ErrorCode&gt; (std::unexpected(ErrorCode::InvalidConnectionString) ); would also work if we wanted to be more verbose</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unexpect_t</span><span class="p">{},</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidQuery</span> <span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"Budapest"</span><span class="p">,</span> <span class="s">"Nice"</span><span class="p">,</span> <span class="s">"Stockholm"</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
  <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the above example, we saw how to return either an expected or an unexpected value. Now let’s see how we can use them.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;expected&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ErrorCode</span> <span class="p">{</span> <span class="n">InvalidConnectionString</span><span class="p">,</span> <span class="n">InvalidQuery</span> <span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">ErrorCode</span> <span class="n">ec</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ec</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidConnectionString</span><span class="p">:</span> 
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"ErrorCode::InvalidConnectionString"</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidQuery</span><span class="p">:</span> 
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">"ErrorCode::InvalidQuery"</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="sc">'['</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">s</span> <span class="o">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span> <span class="o">!=</span> <span class="o">&amp;</span><span class="n">v</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
            <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="s">", "</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">s</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="sc">']'</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">os</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">connectionString</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">query</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">connectionString</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unexpected</span> <span class="p">{</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidConnectionString</span> <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">expected</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">ErrorCode</span><span class="o">&gt;</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unexpect_t</span><span class="p">{},</span> <span class="n">ErrorCode</span><span class="o">::</span><span class="n">InvalidQuery</span> <span class="p">);</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{</span><span class="s">"Budapest"</span><span class="p">,</span> <span class="s">"Nice"</span><span class="p">,</span> <span class="s">"Stockholm"</span><span class="p">};</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">r</span> <span class="o">=</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="s">""</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// (1)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fetchCitiesFromDb(</span><span class="se">\"\"</span><span class="s">, </span><span class="se">\"\"</span><span class="s">) returned "</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">value</span><span class="p">().</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" cities.</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fetchCitiesFromDb(</span><span class="se">\"\"</span><span class="s">, </span><span class="se">\"\"</span><span class="s">) returned an error! "</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">auto</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="s">"demo"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fetchCitiesFromDb(</span><span class="se">\"</span><span class="s">demo</span><span class="se">\"</span><span class="s">, </span><span class="se">\"\"</span><span class="s">) gave us this vector: "</span> <span class="o">&lt;&lt;</span> <span class="n">r2</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">{})</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>  <span class="c1">// (2)</span>
    <span class="c1">//std::cout &lt;&lt; "fetchCitiesFromDb(\"demo\", \"\"); returned" &lt;&lt; r2.value_or(r.error()) &lt;&lt; '\n'; </span>

    <span class="k">auto</span> <span class="n">r3</span> <span class="o">=</span> <span class="n">fetchCitiesFromDb</span><span class="p">(</span><span class="s">"demo"</span><span class="p">,</span> <span class="s">"effects"</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r3</span><span class="p">.</span><span class="n">has_value</span><span class="p">())</span> <span class="p">{</span> <span class="c1">// (3)</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fetchCitiesFromDb(</span><span class="se">\"</span><span class="s">demo</span><span class="se">\"</span><span class="s">, </span><span class="se">\"</span><span class="s">effects</span><span class="se">\"</span><span class="s">) returned "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">r3</span> <span class="o">&lt;&lt;</span> <span class="s">" which has a size of: "</span> <span class="o">&lt;&lt;</span> <span class="n">r3</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// (4)</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"fetchCitiesFromDb(</span><span class="se">\"</span><span class="s">demo</span><span class="se">\"</span><span class="s">, </span><span class="se">\"</span><span class="s">effects</span><span class="se">\"</span><span class="s">) returned an error! "</span> <span class="o">&lt;&lt;</span> <span class="n">r3</span><span class="p">.</span><span class="n">error</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>First, we can see at <em>(1)</em> that we used <code class="language-plaintext highlighter-rouge">operator bool()</code> and if the returned value is the expected, then it evaluates to <code class="language-plaintext highlighter-rouge">true</code>, otherwise to <code class="language-plaintext highlighter-rouge">false</code>. If <code class="language-plaintext highlighter-rouge">operator bool() == false</code>, then <code class="language-plaintext highlighter-rouge">error()</code> should return a valid unexpected value.</p><p>At line <em>(2)</em> we see that if we don’t want to query the error, but we want to use a default value if there is no expected value available, then we can simply call <code class="language-plaintext highlighter-rouge">value_or(&lt;default value&gt;)</code>. It’s worth noting that the default value, the one that we pass with <code class="language-plaintext highlighter-rouge">value_or()</code>, must be of the same type as <code class="language-plaintext highlighter-rouge">value()</code> would return. In other words, it must be an instance of the expected type.</p><p>At lines <em>(3)</em> and <em>(4)</em> we see if <code class="language-plaintext highlighter-rouge">has_value()</code> returns <code class="language-plaintext highlighter-rouge">true</code> then we can safely use the <code class="language-plaintext highlighter-rouge">operator-&gt;()</code> in order to access a member of the expected value.</p><h2 id="how-it-fits-the-alternatives-when-to-use-exceptions">How it fits the alternatives? When to use exceptions?</h2><p>After having seen all that, it’s to ask ourselves how this goes with the alternatives. What way of error handling should we choose?</p><p>In my opinion, this new utility type, <code class="language-plaintext highlighter-rouge">std::expected</code> is clearly a superior way to all non-exception ways of error-handling.</p><p>I never liked having a return type and out parameters. Such APIs are not simple enough. If there should be multiple expected return values, create a struct, a class whichever fits better your needs. If one represents the success of the operation, you might have wanted to go with <code class="language-plaintext highlighter-rouge">optional</code>, but if you have to deal with multiple error codes you might have wanted to go with a variant.</p><p>Now all this - when error codes are involved - should be replaced with the <code class="language-plaintext highlighter-rouge">&lt;expected&gt;</code> header.</p><p>When it comes to exceptions, the situation is a bit more tricky.</p><p>First of all, there are environments, teams even companies where the usage of exceptions is banned. That’s an easy question then, <code class="language-plaintext highlighter-rouge">&lt;expected&gt;</code> will serve you well. Otherwise, exceptions are not easy to use well. They go completely across the normal flow of control, often logging is either neglected or it’s done multiple times. In my opinion, how exceptions are handled should be documented in a project and they should follow a clear strategy. That strategy should strike out the documentation, so both newcomers on the project and code reviewers can easily see it.</p><p>Using exceptions is a decision and <code class="language-plaintext highlighter-rouge">std::expected</code> does not provide the same functionality.</p><p>On the other hand, it’s also worth remembering the idea behind exceptions. When should they be used? In exceptional cases! An error that you expect, is not exceptional. It’s unexpected but probable. Accessing a vector out of bounds, running out of memory and therefore having an allocation issue, and accessing a value of an optional when it doesn’t contain any are exceptional cases that should not happen. I think using exceptions is allowed and meaningful in such situations.</p><p>On the other hand, in situations which are likely to happen in unexceptional circumstances (like a user is passing a value out of the expected range), when you hesitate between using exceptions are error codes in any way, I think going with the <code class="language-plaintext highlighter-rouge">&lt;expected&gt;</code> header is the right call.</p><h2 id="conclusion">Conclusion</h2><p>Writing functions that are supposed to return both a normal return value and a status code at the same has been painful for decades. You either had to create your custom data structure or besides return values, you had to use our parameters too. Later C++17 introduced both <code class="language-plaintext highlighter-rouge">std::optional</code> and ` std::variant` offering some alternatives, but they were not designed to deal with error handling.</p><p>C++23 will bring as <code class="language-plaintext highlighter-rouge">std::exceptional</code> that is a standardized data structure with a <code class="language-plaintext highlighter-rouge">std::optional</code>-like API aiming to hold an expected value or an error code. It’s a readable, easy-to-use solution that will increase the readability of our APIs!</p><p>Sounds very promising!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/errors/" class="post-tag no-text-decoration" >errors</a> <a href="/tags/expected/" class="post-tag no-text-decoration" >expected</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: The &lt;expected&gt; header; expect the unexpected - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/16/cpp23-expected" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: The &lt;expected&gt; header; expect the unexpected - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/16/cpp23-expected" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: The &lt;expected&gt; header; expect the unexpected - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/16/cpp23-expected" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: The &lt;expected&gt; header; expect the unexpected - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/16/cpp23-expected" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/11/09/why-to-use-cpp-in-2022" class="btn btn-outline-primary" prompt="Older"><p>Why to use C++ in 2022</p></a> <a href="/blog/2022/11/19/the-seniority-trap-chapter-8-non-coding-roles" class="btn btn-outline-primary" prompt="Newer"><p>Non-coding roles or something you like?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: The &lt;expected&gt; header; expect the unexpected'; this.page.url = 'https://www.sandordargo.com/blog/2022/11/16/cpp23-expected'; this.page.identifier = '/blog/2022/11/16/cpp23-expected'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
