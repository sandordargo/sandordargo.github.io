<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: auto(x) and decay copy" /><meta property="og:locale" content="en_US" /><meta name="description" content="When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the clutter, think about iterator declarations! It removes code duplication, just think about make_shared or make_unique. But it doesn’t only reduce visual pollution, it also keeps the code more maintainable. If you extensively use auto and you decide to change the type of your container you won’t have to update so many parts of your code. We haven’t even mentioned templates. And that’s not the goal today. I just wanted to state that using auto is useful. And it also evolved a lot since it was introduced by C++11. Since C++14, we can use with lambdas, then C++17 made it possible to have auto template types and with C++20, we can constrain them with concepts. With C++23, we are going to get one more way to use it: auto(x). What problem is it going to solve? Sometimes we want to make a copy of a variable before we’d pass it on to the next function. Let’s take this example: 1 2 3 void pop_front_alike(auto&amp; x) { std::erase(x.begin(), x.end(), x.front()); } This function does not compile as std::vector::front returns a reference, while erase expects a value. It’s true that erase could also take a const&amp; and front could return that. But if x is const&amp; then erase cannot take it as it wants to modify x. So we should rather make a copy of x. We can write auto tmp = x.front(); and then pass along tmp. Sadly, this has a couple of issues: It’s still an extra line for nothing, just to create a copy You have to name that variable somehow… In a meaningful way… But what can be a meaningful name? tmp? copy? Really? We get an lvalue copy, not an rvalue copy in this case. In order to solve all these problems, we could directly pass T(x.front()). But we don’t have T, we used auto to take x! We could fall back from auto to an old-school templated solution, but to be fair, we don’t even want the type passed in, we want the decay type. Unless T appears in the context of an array or a function type, the decay of T is the original type with removed reference and removed cv-qualifiers. For (C-style) arrays, it’s the pointer type of T; for functions, it’s the “pointerized” function type. So if we wanted to get the above T, we should do it like this: 1 2 using T = std::decay_t&lt;decltype(x.front())&gt;; std::erase(x.begin(), x.end(), T(x.front())); This is probably not something we want in our code, and definitely not repeatedly. So ideally we’d put into a function that extracts both the type and returns the copy to us. But as it’s written in the paper P0848R8 such a function would also have its own issues. In particular, in terms of accessibility of non-public class members. So the accepted proposal in the end is not about a library feature of std::decay_copy, but a language feature. auto(x) will return you a decaying copy of the passed in variable and as an optimization, it’s a no-op if x is already a prvalue. A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears. In the paper, you read further interesting considerations about alternative implementations using existing functions and features and why it’s not called prvalue_cast. This one is a fairly readable proposal even for people not speaking standardese. Conclusion auto is one of the most useful features of modern C++ as it helps keep the code more concise and more maintainable. It evolved a lot since C++11, as we could use it in more and more different contexts. With C++23, we can use it to make a prvalue copy and we can use it to pass a copy to a function we want to call, without bothering to find a good name for the copy. Probably we won’t use this feature that frequently, but when we’ll need it, it’ll be really useful. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the clutter, think about iterator declarations! It removes code duplication, just think about make_shared or make_unique. But it doesn’t only reduce visual pollution, it also keeps the code more maintainable. If you extensively use auto and you decide to change the type of your container you won’t have to update so many parts of your code. We haven’t even mentioned templates. And that’s not the goal today. I just wanted to state that using auto is useful. And it also evolved a lot since it was introduced by C++11. Since C++14, we can use with lambdas, then C++17 made it possible to have auto template types and with C++20, we can constrain them with concepts. With C++23, we are going to get one more way to use it: auto(x). What problem is it going to solve? Sometimes we want to make a copy of a variable before we’d pass it on to the next function. Let’s take this example: 1 2 3 void pop_front_alike(auto&amp; x) { std::erase(x.begin(), x.end(), x.front()); } This function does not compile as std::vector::front returns a reference, while erase expects a value. It’s true that erase could also take a const&amp; and front could return that. But if x is const&amp; then erase cannot take it as it wants to modify x. So we should rather make a copy of x. We can write auto tmp = x.front(); and then pass along tmp. Sadly, this has a couple of issues: It’s still an extra line for nothing, just to create a copy You have to name that variable somehow… In a meaningful way… But what can be a meaningful name? tmp? copy? Really? We get an lvalue copy, not an rvalue copy in this case. In order to solve all these problems, we could directly pass T(x.front()). But we don’t have T, we used auto to take x! We could fall back from auto to an old-school templated solution, but to be fair, we don’t even want the type passed in, we want the decay type. Unless T appears in the context of an array or a function type, the decay of T is the original type with removed reference and removed cv-qualifiers. For (C-style) arrays, it’s the pointer type of T; for functions, it’s the “pointerized” function type. So if we wanted to get the above T, we should do it like this: 1 2 using T = std::decay_t&lt;decltype(x.front())&gt;; std::erase(x.begin(), x.end(), T(x.front())); This is probably not something we want in our code, and definitely not repeatedly. So ideally we’d put into a function that extracts both the type and returns the copy to us. But as it’s written in the paper P0848R8 such a function would also have its own issues. In particular, in terms of accessibility of non-public class members. So the accepted proposal in the end is not about a library feature of std::decay_copy, but a language feature. auto(x) will return you a decaying copy of the passed in variable and as an optimization, it’s a no-op if x is already a prvalue. A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears. In the paper, you read further interesting considerations about alternative implementations using existing functions and features and why it’s not called prvalue_cast. This one is a fairly readable proposal even for people not speaking standardese. Conclusion auto is one of the most useful features of modern C++ as it helps keep the code more concise and more maintainable. It evolved a lot since C++11, as we could use it in more and more different contexts. With C++23, we can use it to make a prvalue copy and we can use it to pass a copy to a function we want to call, without bothering to find a good name for the copy. Probably we won’t use this feature that frequently, but when we’ll need it, it’ll be really useful. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-11-30T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: auto(x) and decay copy" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-11-30T00:00:00+01:00","datePublished":"2022-11-30T00:00:00+01:00","description":"When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the clutter, think about iterator declarations! It removes code duplication, just think about make_shared or make_unique. But it doesn’t only reduce visual pollution, it also keeps the code more maintainable. If you extensively use auto and you decide to change the type of your container you won’t have to update so many parts of your code. We haven’t even mentioned templates. And that’s not the goal today. I just wanted to state that using auto is useful. And it also evolved a lot since it was introduced by C++11. Since C++14, we can use with lambdas, then C++17 made it possible to have auto template types and with C++20, we can constrain them with concepts. With C++23, we are going to get one more way to use it: auto(x). What problem is it going to solve? Sometimes we want to make a copy of a variable before we’d pass it on to the next function. Let’s take this example: 1 2 3 void pop_front_alike(auto&amp; x) { std::erase(x.begin(), x.end(), x.front()); } This function does not compile as std::vector::front returns a reference, while erase expects a value. It’s true that erase could also take a const&amp; and front could return that. But if x is const&amp; then erase cannot take it as it wants to modify x. So we should rather make a copy of x. We can write auto tmp = x.front(); and then pass along tmp. Sadly, this has a couple of issues: It’s still an extra line for nothing, just to create a copy You have to name that variable somehow… In a meaningful way… But what can be a meaningful name? tmp? copy? Really? We get an lvalue copy, not an rvalue copy in this case. In order to solve all these problems, we could directly pass T(x.front()). But we don’t have T, we used auto to take x! We could fall back from auto to an old-school templated solution, but to be fair, we don’t even want the type passed in, we want the decay type. Unless T appears in the context of an array or a function type, the decay of T is the original type with removed reference and removed cv-qualifiers. For (C-style) arrays, it’s the pointer type of T; for functions, it’s the “pointerized” function type. So if we wanted to get the above T, we should do it like this: 1 2 using T = std::decay_t&lt;decltype(x.front())&gt;; std::erase(x.begin(), x.end(), T(x.front())); This is probably not something we want in our code, and definitely not repeatedly. So ideally we’d put into a function that extracts both the type and returns the copy to us. But as it’s written in the paper P0848R8 such a function would also have its own issues. In particular, in terms of accessibility of non-public class members. So the accepted proposal in the end is not about a library feature of std::decay_copy, but a language feature. auto(x) will return you a decaying copy of the passed in variable and as an optimization, it’s a no-op if x is already a prvalue. A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears. In the paper, you read further interesting considerations about alternative implementations using existing functions and features and why it’s not called prvalue_cast. This one is a fairly readable proposal even for people not speaking standardese. Conclusion auto is one of the most useful features of modern C++ as it helps keep the code more concise and more maintainable. It evolved a lot since C++11, as we could use it in more and more different contexts. With C++23, we can use it to make a prvalue copy and we can use it to pass a copy to a function we want to call, without bothering to find a good name for the copy. Probably we won’t use this feature that frequently, but when we’ll need it, it’ll be really useful. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: auto(x) and decay copy","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy"},"url":"https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy"}</script><title>C++23: auto(x) and decay copy | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/30"> 30 </a> </span> <span>C++23: auto(x) and decay copy</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: auto(x) and decay copy</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 30, 2022, 12:00 AM +0100" prep="on" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="731 words">4 min</span></div></div><div class="post-content"><p>When I first saw <code class="language-plaintext highlighter-rouge">auto</code> I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that <code class="language-plaintext highlighter-rouge">auto</code> helps in so many different ways. It helps remove the clutter, think about iterator declarations! It removes code duplication, just think about <code class="language-plaintext highlighter-rouge">make_shared</code> or <code class="language-plaintext highlighter-rouge">make_unique</code>. But it doesn’t only reduce visual pollution, it also keeps the code more maintainable. If you extensively use <code class="language-plaintext highlighter-rouge">auto</code> and you decide to change the type of your container you won’t have to update so many parts of your code.</p><p>We haven’t even mentioned templates. And that’s not the goal today.</p><p>I just wanted to state that using <code class="language-plaintext highlighter-rouge">auto</code> is useful.</p><p>And it also evolved a lot since it was introduced by C++11. Since C++14, we can use with lambdas, then C++17 made it possible to have <code class="language-plaintext highlighter-rouge">auto</code> template types and with C++20, we can constrain them <a href="https://leanpub.com/cppconcepts">with concepts</a>. With C++23, we are going to get one more way to use it: <code class="language-plaintext highlighter-rouge">auto(x)</code>.</p><h2 id="what-problem-is-it-going-to-solve">What problem is it going to solve?</h2><p>Sometimes we want to make a copy of a variable before we’d pass it on to the next function.</p><p>Let’s take this example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">pop_front_alike</span><span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This function does not compile as <code class="language-plaintext highlighter-rouge">std::vector::front</code> returns a reference, while <code class="language-plaintext highlighter-rouge">erase</code> expects a value. It’s true that <code class="language-plaintext highlighter-rouge">erase</code> could also take a <code class="language-plaintext highlighter-rouge">const&amp;</code> and <code class="language-plaintext highlighter-rouge">front</code> could return that. But if <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">const&amp;</code> then <code class="language-plaintext highlighter-rouge">erase</code> cannot take it as it wants to modify <code class="language-plaintext highlighter-rouge">x</code>.</p><p>So we should rather make a copy of <code class="language-plaintext highlighter-rouge">x</code>.</p><p>We can write <code class="language-plaintext highlighter-rouge">auto tmp = x.front();</code> and then pass along <code class="language-plaintext highlighter-rouge">tmp</code>. Sadly, this has a couple of issues:</p><ul><li>It’s still an extra line for nothing, just to create a copy<li>You have to name that variable somehow… In a meaningful way… But what can be a meaningful name? <code class="language-plaintext highlighter-rouge">tmp</code>? <code class="language-plaintext highlighter-rouge">copy</code>? Really?<li>We get an lvalue copy, not an rvalue copy in this case.</ul><p>In order to solve all these problems, we could directly pass <code class="language-plaintext highlighter-rouge">T(x.front())</code>. But we don’t have <code class="language-plaintext highlighter-rouge">T</code>, we used <code class="language-plaintext highlighter-rouge">auto</code> to take <code class="language-plaintext highlighter-rouge">x</code>! We could fall back from <code class="language-plaintext highlighter-rouge">auto</code> to an old-school templated solution, but to be fair, we don’t even want the type passed in, we want the <a href="https://en.cppreference.com/w/cpp/types/decay">decay</a> type.</p><blockquote><p>Unless T appears in the context of an array or a function type, the decay of <code class="language-plaintext highlighter-rouge">T</code> is the original type with removed reference and removed cv-qualifiers. For (C-style) arrays, it’s the pointer type of T; for functions, it’s the “pointerized” function type.</p></blockquote><p>So if we wanted to get the above <code class="language-plaintext highlighter-rouge">T</code>, we should do it like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">T</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">decay_t</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">front</span><span class="p">())</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">erase</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">x</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">T</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">front</span><span class="p">()));</span>
</pre></table></code></div></div><p>This is probably not something we want in our code, and definitely not repeatedly. So ideally we’d put into a function that extracts both the type and returns the copy to us. But as it’s written in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0849r8.html">the paper P0848R8</a> such a function would also have its own issues. In particular, in terms of accessibility of non-public class members. So the accepted proposal in the end is not about a library feature of <code class="language-plaintext highlighter-rouge">std::decay_copy</code>, but a language feature.</p><p><code class="language-plaintext highlighter-rouge">auto(x)</code> will return you a decaying copy of the passed in variable and as an optimization, it’s a no-op if <code class="language-plaintext highlighter-rouge">x</code> is already a prvalue.</p><blockquote><p><a href="https://learn.microsoft.com/en-us/cpp/cpp/lvalues-and-rvalues-visual-cpp?view=msvc-170">A prvalue is an expression whose evaluation initializes an object or a bit-field, or computes the value of the operand of an operator, as specified by the context in which it appears.</a></p></blockquote><p>In the paper, you read further interesting considerations about alternative implementations using existing functions and features and why it’s not called <code class="language-plaintext highlighter-rouge">prvalue_cast</code>. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0849r8.html">This one</a> is a fairly readable proposal even for people not speaking standardese.</p><h2 id="conclusion">Conclusion</h2><p><code class="language-plaintext highlighter-rouge">auto</code> is one of the most useful features of modern C++ as it helps keep the code more concise and more maintainable. It evolved a lot since C++11, as we could use it in more and more different contexts. With C++23, we can use it to make a <code class="language-plaintext highlighter-rouge">prvalue</code> copy and we can use it to pass a copy to a function we want to call, without bothering to find a good name for the copy. Probably we won’t use this feature that frequently, but when we’ll need it, it’ll be really useful.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/auto/" class="post-tag no-text-decoration" >auto</a> <a href="/tags/decay/" class="post-tag no-text-decoration" >decay</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: auto(x) and decay copy - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: auto(x) and decay copy - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: auto(x) and decay copy - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: auto(x) and decay copy - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/05/29/cpp23-chrono"><div class="card-body"> <span class="timeago small" > May 29, 2024 <i class="unloaded">2024-05-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: chrono related changes</h3><div class="text-muted small"><p> Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/03/cpp23-further-small-changes"><div class="card-body"> <span class="timeago small" > Jul 3, 2024 <i class="unloaded">2024-07-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: further small changes</h3><div class="text-muted small"><p> In this article, let’s get back to exploring C++23. We are going to have a look at some unrelated small changes in the standard, including the rarest species of changes. Deprecations! Printing vol...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas" class="btn btn-outline-primary" prompt="Older"><p>C++23: How lambdas are going to change?</p></a> <a href="/blog/2022/12/03/influence-the-psychology-of-persuasion-by-robert-b-caldini" class="btn btn-outline-primary" prompt="Newer"><p>Influence: The Psychology of Persuasion by Robert B. Caldini</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: auto(x) and decay copy'; this.page.url = 'https://www.sandordargo.com/blog/2022/11/30/cpp23-auto-and-decay-copy'; this.page.identifier = '/blog/2022/11/30/cpp23-auto-and-decay-copy'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
