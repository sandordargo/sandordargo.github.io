<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: The stacktrace library" /><meta property="og:locale" content="en_US" /><meta name="description" content="So far, there was no way in C++ to get runtime information on the current call sequence. Other popular programming languages such as Java, C# or Python provide this possibility. Thanks to P0881R7 and the people behind, now we will also get a similar feature with C++23. Let’s discover in this article what exactly we get and how we can use it! Is it already available? - the meta how Before we delve into how to use this new library, we should discuss how to use it or if we can already use it at all. I mean it’s a C++23 feature and it doesn’t have wide compiler support for the time being. Following a recent C++ Weekly episode, we can use the &lt;stacktrace&gt; library by compiling against at least gcc 12.1 (no trunk is needed), we have to specify -std=c++23 and we have to add the command line option of -lstdc++_libbacktrace to link the library. As such, we can have early access to this interesting new library! What are the key features of the stacktrace library? Let’s pick some interesting and/or important decisions, features from the accepted papaer: All stack_frame functions and constructors are lazy, no information will be decoded until it’s needed to keep the library fast. Frames are stored in a dynamically sized storage as the most important piece of information is often at the bottom of the stacktrace. This also means that the stacktrace should not be constructed on performance-critical hot paths. Or at least, it should be constructed with a custom allocator. The &lt;stacktrace&gt; header provides us essentially with two classes. stacktrace_entry is the representation of one evaluation, one frame in a stacktrace and that evaluation might be empty. You can check its emptiness with operator bool. What’s in an evaluation? That’s a good question. Basically, it’s one entry in a backtrace or in other words a stacktrace. If you have a function foo() that is called from main(), your stacktrace should be composed of two items, two evaluations foo() and main - life can be a bit more complex though. In order to get more information about the evaluation, you get 3 queries. description() source_file() source_line() These names are quite self-evident, once we understand what does an evaluation of a stacktrace mean. The other class in the header is basic_stacktrace and it consists of multiple stacktrace entries. It’s either the representation of the full stacktrace or just a given part of it. std::basic_stacktrace works pretty much as a standard container with iterators and element access functions. Keep in mind, that stacktrace is just an alias for basic_stacktrace with the default allocator. Beware that this below piece of code might not do what you’d expect: 1 2 3 4 5 6 auto currentStacktrace = std::stacktrace(); // Won&#39;t work as one might expect! for (const auto&amp; entry : currentStacktrace) { std::cout &lt;&lt; entry.description() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; entry.source_file() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; entry.source_line() &lt;&lt; &#39;\n&#39;; } std::stacktrace() is just a constructor call and it instantiates a new basic_stacktrace container. If you want to get the stacktrace of the current execution context, call the current static member function instead of the constructor. 1 auto currentStacktrace = std::stacktrace::current(); Once we have a stacktrace, we can obtain the stored information in different ways. The easiest way is to actually just print the whole stacktrace all at once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); std::cout &lt;&lt; std::to_string(trace) &lt;&lt; &#39;\n&#39;; } int main() { foo(); } /* 0# foo() at /app/example.cpp:5 1# at /app/example.cpp:10 2# at :0 3# at :0 4# */ We see two interesting things above. main is not printed as a description and there are two additional frames on the top that must be related to the execution context. As stacktrace is a container, we can iterate over it and print the items one by one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); for (const auto&amp; entry: trace) { std::cout &lt;&lt; std::to_string(entry) &lt;&lt; &#39;\n&#39;; } } int main() { foo(); } /* foo() at /app/example.cpp:5 at /app/example.cpp:12 at :0 at :0 */ We have pretty much the same output, but now we lost the numbering, which would have to be put back with the help of a loop index. If we don’t want all the information from a trace, we can get the method name (description), the source file and the line number separately with the right accessors. We can iterate over it and print each entry. We can take the different attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); for (const auto&amp; entry: trace) { std::cout &lt;&lt; &quot;Description: &quot; &lt;&lt; entry.description() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;file: &quot; &lt;&lt; entry.source_file() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;line: &quot; &lt;&lt; entry.source_line() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; &#39;\n&#39;; } } int main() { foo(); } /* Description: foo() file: /app/example.cpp line: 5 ------------------------------------ Description: file: /app/example.cpp line: 15 ------------------------------------ Description: file: line: 0 ------------------------------------ Description: file: line: 0 ------------------------------------ Description: file: line: 0 ------------------------------------ */ An interesting thing I found is that if the current trace is queried when a parameter is defaulted, that function doesn’t appear in the stacktrace. Somehow it makes sense because it’s not yet executed yet, but it was already called, so I’m not sure if I like this behaviour. But it might be just me. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo(std::stacktrace trace = std::stacktrace::current()) { std::cout &lt;&lt; std::to_string(trace) &lt;&lt; &#39;\n&#39;; } int main() { foo(); } /* 0# at /app/example.cpp:9 1# at :0 2# at :0 3# */ Conclusion &lt;stacktrace&gt; library is a very useful addition to the C++ standard library that lets us query and print the backtrace. The compiler support is very limited for the time being, we can only use gcc and probably the implementation will still change here and there. Still, we can already experiment, we can already learn how to use it. I’m sure it will come in very handy for error handling in C++. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="So far, there was no way in C++ to get runtime information on the current call sequence. Other popular programming languages such as Java, C# or Python provide this possibility. Thanks to P0881R7 and the people behind, now we will also get a similar feature with C++23. Let’s discover in this article what exactly we get and how we can use it! Is it already available? - the meta how Before we delve into how to use this new library, we should discuss how to use it or if we can already use it at all. I mean it’s a C++23 feature and it doesn’t have wide compiler support for the time being. Following a recent C++ Weekly episode, we can use the &lt;stacktrace&gt; library by compiling against at least gcc 12.1 (no trunk is needed), we have to specify -std=c++23 and we have to add the command line option of -lstdc++_libbacktrace to link the library. As such, we can have early access to this interesting new library! What are the key features of the stacktrace library? Let’s pick some interesting and/or important decisions, features from the accepted papaer: All stack_frame functions and constructors are lazy, no information will be decoded until it’s needed to keep the library fast. Frames are stored in a dynamically sized storage as the most important piece of information is often at the bottom of the stacktrace. This also means that the stacktrace should not be constructed on performance-critical hot paths. Or at least, it should be constructed with a custom allocator. The &lt;stacktrace&gt; header provides us essentially with two classes. stacktrace_entry is the representation of one evaluation, one frame in a stacktrace and that evaluation might be empty. You can check its emptiness with operator bool. What’s in an evaluation? That’s a good question. Basically, it’s one entry in a backtrace or in other words a stacktrace. If you have a function foo() that is called from main(), your stacktrace should be composed of two items, two evaluations foo() and main - life can be a bit more complex though. In order to get more information about the evaluation, you get 3 queries. description() source_file() source_line() These names are quite self-evident, once we understand what does an evaluation of a stacktrace mean. The other class in the header is basic_stacktrace and it consists of multiple stacktrace entries. It’s either the representation of the full stacktrace or just a given part of it. std::basic_stacktrace works pretty much as a standard container with iterators and element access functions. Keep in mind, that stacktrace is just an alias for basic_stacktrace with the default allocator. Beware that this below piece of code might not do what you’d expect: 1 2 3 4 5 6 auto currentStacktrace = std::stacktrace(); // Won&#39;t work as one might expect! for (const auto&amp; entry : currentStacktrace) { std::cout &lt;&lt; entry.description() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; entry.source_file() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; entry.source_line() &lt;&lt; &#39;\n&#39;; } std::stacktrace() is just a constructor call and it instantiates a new basic_stacktrace container. If you want to get the stacktrace of the current execution context, call the current static member function instead of the constructor. 1 auto currentStacktrace = std::stacktrace::current(); Once we have a stacktrace, we can obtain the stored information in different ways. The easiest way is to actually just print the whole stacktrace all at once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); std::cout &lt;&lt; std::to_string(trace) &lt;&lt; &#39;\n&#39;; } int main() { foo(); } /* 0# foo() at /app/example.cpp:5 1# at /app/example.cpp:10 2# at :0 3# at :0 4# */ We see two interesting things above. main is not printed as a description and there are two additional frames on the top that must be related to the execution context. As stacktrace is a container, we can iterate over it and print the items one by one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); for (const auto&amp; entry: trace) { std::cout &lt;&lt; std::to_string(entry) &lt;&lt; &#39;\n&#39;; } } int main() { foo(); } /* foo() at /app/example.cpp:5 at /app/example.cpp:12 at :0 at :0 */ We have pretty much the same output, but now we lost the numbering, which would have to be put back with the help of a loop index. If we don’t want all the information from a trace, we can get the method name (description), the source file and the line number separately with the right accessors. We can iterate over it and print each entry. We can take the different attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); for (const auto&amp; entry: trace) { std::cout &lt;&lt; &quot;Description: &quot; &lt;&lt; entry.description() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;file: &quot; &lt;&lt; entry.source_file() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;line: &quot; &lt;&lt; entry.source_line() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; &#39;\n&#39;; } } int main() { foo(); } /* Description: foo() file: /app/example.cpp line: 5 ------------------------------------ Description: file: /app/example.cpp line: 15 ------------------------------------ Description: file: line: 0 ------------------------------------ Description: file: line: 0 ------------------------------------ Description: file: line: 0 ------------------------------------ */ An interesting thing I found is that if the current trace is queried when a parameter is defaulted, that function doesn’t appear in the stacktrace. Somehow it makes sense because it’s not yet executed yet, but it was already called, so I’m not sure if I like this behaviour. But it might be just me. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo(std::stacktrace trace = std::stacktrace::current()) { std::cout &lt;&lt; std::to_string(trace) &lt;&lt; &#39;\n&#39;; } int main() { foo(); } /* 0# at /app/example.cpp:9 1# at :0 2# at :0 3# */ Conclusion &lt;stacktrace&gt; library is a very useful addition to the C++ standard library that lets us query and print the backtrace. The compiler support is very limited for the time being, we can only use gcc and probably the implementation will still change here and there. Still, we can already experiment, we can already learn how to use it. I’m sure it will come in very handy for error handling in C++. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-09-21T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: The stacktrace library" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-26T06:57:31+01:00","datePublished":"2022-09-21T00:00:00+02:00","description":"So far, there was no way in C++ to get runtime information on the current call sequence. Other popular programming languages such as Java, C# or Python provide this possibility. Thanks to P0881R7 and the people behind, now we will also get a similar feature with C++23. Let’s discover in this article what exactly we get and how we can use it! Is it already available? - the meta how Before we delve into how to use this new library, we should discuss how to use it or if we can already use it at all. I mean it’s a C++23 feature and it doesn’t have wide compiler support for the time being. Following a recent C++ Weekly episode, we can use the &lt;stacktrace&gt; library by compiling against at least gcc 12.1 (no trunk is needed), we have to specify -std=c++23 and we have to add the command line option of -lstdc++_libbacktrace to link the library. As such, we can have early access to this interesting new library! What are the key features of the stacktrace library? Let’s pick some interesting and/or important decisions, features from the accepted papaer: All stack_frame functions and constructors are lazy, no information will be decoded until it’s needed to keep the library fast. Frames are stored in a dynamically sized storage as the most important piece of information is often at the bottom of the stacktrace. This also means that the stacktrace should not be constructed on performance-critical hot paths. Or at least, it should be constructed with a custom allocator. The &lt;stacktrace&gt; header provides us essentially with two classes. stacktrace_entry is the representation of one evaluation, one frame in a stacktrace and that evaluation might be empty. You can check its emptiness with operator bool. What’s in an evaluation? That’s a good question. Basically, it’s one entry in a backtrace or in other words a stacktrace. If you have a function foo() that is called from main(), your stacktrace should be composed of two items, two evaluations foo() and main - life can be a bit more complex though. In order to get more information about the evaluation, you get 3 queries. description() source_file() source_line() These names are quite self-evident, once we understand what does an evaluation of a stacktrace mean. The other class in the header is basic_stacktrace and it consists of multiple stacktrace entries. It’s either the representation of the full stacktrace or just a given part of it. std::basic_stacktrace works pretty much as a standard container with iterators and element access functions. Keep in mind, that stacktrace is just an alias for basic_stacktrace with the default allocator. Beware that this below piece of code might not do what you’d expect: 1 2 3 4 5 6 auto currentStacktrace = std::stacktrace(); // Won&#39;t work as one might expect! for (const auto&amp; entry : currentStacktrace) { std::cout &lt;&lt; entry.description() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; entry.source_file() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; entry.source_line() &lt;&lt; &#39;\\n&#39;; } std::stacktrace() is just a constructor call and it instantiates a new basic_stacktrace container. If you want to get the stacktrace of the current execution context, call the current static member function instead of the constructor. 1 auto currentStacktrace = std::stacktrace::current(); Once we have a stacktrace, we can obtain the stored information in different ways. The easiest way is to actually just print the whole stacktrace all at once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); std::cout &lt;&lt; std::to_string(trace) &lt;&lt; &#39;\\n&#39;; } int main() { foo(); } /* 0# foo() at /app/example.cpp:5 1# at /app/example.cpp:10 2# at :0 3# at :0 4# */ We see two interesting things above. main is not printed as a description and there are two additional frames on the top that must be related to the execution context. As stacktrace is a container, we can iterate over it and print the items one by one. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); for (const auto&amp; entry: trace) { std::cout &lt;&lt; std::to_string(entry) &lt;&lt; &#39;\\n&#39;; } } int main() { foo(); } /* foo() at /app/example.cpp:5 at /app/example.cpp:12 at :0 at :0 */ We have pretty much the same output, but now we lost the numbering, which would have to be put back with the help of a loop index. If we don’t want all the information from a trace, we can get the method name (description), the source file and the line number separately with the right accessors. We can iterate over it and print each entry. We can take the different attributes: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo() { auto trace = std::stacktrace::current(); for (const auto&amp; entry: trace) { std::cout &lt;&lt; &quot;Description: &quot; &lt;&lt; entry.description() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;file: &quot; &lt;&lt; entry.source_file() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;line: &quot; &lt;&lt; entry.source_line() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;------------------------------------&quot; &lt;&lt; &#39;\\n&#39;; } } int main() { foo(); } /* Description: foo() file: /app/example.cpp line: 5 ------------------------------------ Description: file: /app/example.cpp line: 15 ------------------------------------ Description: file: line: 0 ------------------------------------ Description: file: line: 0 ------------------------------------ Description: file: line: 0 ------------------------------------ */ An interesting thing I found is that if the current trace is queried when a parameter is defaulted, that function doesn’t appear in the stacktrace. Somehow it makes sense because it’s not yet executed yet, but it was already called, so I’m not sure if I like this behaviour. But it might be just me. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;stacktrace&gt; #include &lt;iostream&gt; void foo(std::stacktrace trace = std::stacktrace::current()) { std::cout &lt;&lt; std::to_string(trace) &lt;&lt; &#39;\\n&#39;; } int main() { foo(); } /* 0# at /app/example.cpp:9 1# at :0 2# at :0 3# */ Conclusion &lt;stacktrace&gt; library is a very useful addition to the C++ standard library that lets us query and print the backtrace. The compiler support is very limited for the time being, we can only use gcc and probably the implementation will still change here and there. Still, we can already experiment, we can already learn how to use it. I’m sure it will come in very handy for error handling in C++. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: The stacktrace library","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library"},"url":"https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library"}</script><title>C++23: The stacktrace library | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/09"> 09 </a> </span> <span> <a href="/21"> 21 </a> </span> <span>C++23: The stacktrace library</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: The stacktrace library</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 21, 2022, 12:00 AM +0200" prep="on" > Sep 21, 2022 <i class="unloaded">2022-09-21T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 26, 2024, 6:57 AM +0100" prefix="Updated " > Dec 26, 2024 <i class="unloaded">2024-12-26T06:57:31+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1114 words">6 min</span></div></div><div class="post-content"><p>So far, there was no way in C++ to get runtime information on the current call sequence. Other popular programming languages such as Java, C# or Python provide this possibility. Thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html">P0881R7</a> and the people behind, now we will also get a similar feature with C++23.</p><p>Let’s discover in this article what exactly we get and how we can use it!</p><h2 id="is-it-already-available---the-meta-how">Is it already available? - the meta how</h2><p>Before we delve into how to use this new library, we should discuss how to use it or if we can already use it at all. I mean it’s a C++23 feature and it doesn’t have wide compiler support for the time being. Following a recent <a href="https://www.youtube.com/watch?v=9IcxniCxKlQ">C++ Weekly episode</a>, we can use the <code class="language-plaintext highlighter-rouge">&lt;stacktrace&gt;</code> library by compiling against at least gcc 12.1 (no trunk is needed), we have to specify <code class="language-plaintext highlighter-rouge">-std=c++23</code> and we have to add the command line option of <code class="language-plaintext highlighter-rouge">-lstdc++_libbacktrace</code> to link the library.</p><p>As such, we can have early access to this interesting new library!</p><h2 id="what-are-the-key-features-of-the-stacktrace-library">What are the key features of the stacktrace library?</h2><p>Let’s pick some interesting and/or important decisions, features from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p0881r7.html">the accepted papaer</a>:</p><ul><li><p>All <em>stack_frame</em> functions and constructors are lazy, no information will be decoded until it’s needed to keep the library fast.</p><li><p>Frames are stored in a dynamically sized storage as the most important piece of information is often at the bottom of the stacktrace. This also means that the stacktrace should not be constructed on performance-critical hot paths. Or at least, it should be constructed with a custom allocator.</p><li><p>The <code class="language-plaintext highlighter-rouge">&lt;stacktrace&gt;</code> header provides us essentially with two classes. <code class="language-plaintext highlighter-rouge">stacktrace_entry</code> is the representation of one evaluation, one frame in a stacktrace and that evaluation might be empty. You can check its emptiness with <code class="language-plaintext highlighter-rouge">operator bool</code>.</p></ul><p>What’s in an evaluation? That’s a good question. Basically, it’s one entry in a backtrace or in other words a stacktrace. If you have a function <code class="language-plaintext highlighter-rouge">foo()</code> that is called from <code class="language-plaintext highlighter-rouge">main()</code>, your stacktrace should be composed of two items, two evaluations <code class="language-plaintext highlighter-rouge">foo()</code> and <code class="language-plaintext highlighter-rouge">main</code> - life can be a bit more complex though.</p><p>In order to get more information about the evaluation, you get 3 queries.</p><ul><li><code class="language-plaintext highlighter-rouge">description()</code><li><code class="language-plaintext highlighter-rouge">source_file()</code><li><code class="language-plaintext highlighter-rouge">source_line()</code></ul><p>These names are quite self-evident, once we understand what does an evaluation of a stacktrace mean.</p><p>The other class in the header is <code class="language-plaintext highlighter-rouge">basic_stacktrace</code> and it consists of multiple stacktrace entries. It’s either the representation of the full stacktrace or just a given part of it. <code class="language-plaintext highlighter-rouge">std::basic_stacktrace</code> works pretty much as a standard container with iterators and element access functions.</p><p>Keep in mind, that <code class="language-plaintext highlighter-rouge">stacktrace</code> is just an alias for <code class="language-plaintext highlighter-rouge">basic_stacktrace</code> with the default allocator.</p><p>Beware that this below piece of code might not do what you’d expect:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">currentStacktrace</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span><span class="p">();</span> <span class="c1">// Won't work as one might expect!</span>
<span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">currentStacktrace</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">description</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">source_file</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">source_line</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">std::stacktrace()</code> is just a constructor call and it instantiates a new <code class="language-plaintext highlighter-rouge">basic_stacktrace</code> container. If you want to get the stacktrace of the current execution context, call the <code class="language-plaintext highlighter-rouge">current</code> <code class="language-plaintext highlighter-rouge">static</code> member function instead of the constructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">currentStacktrace</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
</pre></table></code></div></div><p>Once we have a stacktrace, we can obtain the stored information in different ways. The easiest way is to actually just print the whole stacktrace all at once.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stacktrace&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
   0# foo() at /app/example.cpp:5
   1#      at /app/example.cpp:10
   2#      at :0
   3#      at :0
   4# 
*/</span>
</pre></table></code></div></div><p>We see two interesting things above. <code class="language-plaintext highlighter-rouge">main</code> is not printed as a description and there are two additional frames on the top that must be related to the execution context.</p><p>As <code class="language-plaintext highlighter-rouge">stacktrace</code> is a container, we can iterate over it and print the items one by one.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stacktrace&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span><span class="o">:</span> <span class="n">trace</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">entry</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
foo() at /app/example.cpp:5
     at /app/example.cpp:12
     at :0
     at :0

*/</span>
</pre></table></code></div></div><p>We have pretty much the same output, but now we lost the numbering, which would have to be put back with the help of a loop index.</p><p>If we don’t want all the information from a trace, we can get the method name (<em>description</em>), the source file and the line number separately with the right accessors.</p><p>We can iterate over it and print each entry. We can take the different attributes:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stacktrace&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span><span class="o">::</span><span class="n">current</span><span class="p">();</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span><span class="o">:</span> <span class="n">trace</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Description: "</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">description</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">source_file</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"line: "</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span><span class="p">.</span><span class="n">source_line</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"------------------------------------"</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
Description: foo()
file: /app/example.cpp
line: 5
------------------------------------
Description: 
file: /app/example.cpp
line: 15
------------------------------------
Description: 
file: 
line: 0
------------------------------------
Description: 
file: 
line: 0
------------------------------------
Description: 
file: 
line: 0
------------------------------------
*/</span>

</pre></table></code></div></div><p>An interesting thing I found is that if the current trace is queried when a parameter is defaulted, that function doesn’t appear in the stacktrace. Somehow it makes sense because it’s not yet executed yet, but it was already called, so I’m not sure if I like this behaviour. But it might be just me.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;stacktrace&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span> <span class="n">trace</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stacktrace</span><span class="o">::</span><span class="n">current</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">trace</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>

<span class="cm">/*
   0#      at /app/example.cpp:9
   1#      at :0
   2#      at :0
   3# 
*/</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p><code class="language-plaintext highlighter-rouge">&lt;stacktrace&gt;</code> library is a very useful addition to the C++ standard library that lets us query and print the backtrace. The compiler support is very limited for the time being, we can only use gcc and probably the implementation will still change here and there. Still, we can already experiment, we can already learn how to use it. I’m sure it will come in very handy for error handling in C++.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/stacktrace/" class="post-tag no-text-decoration" >stacktrace</a> <a href="/tags/backtrace/" class="post-tag no-text-decoration" >backtrace</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: The stacktrace library - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: The stacktrace library - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: The stacktrace library - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: The stacktrace library - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/09/14/dont-feel-bad-just-learn" class="btn btn-outline-primary" prompt="Older"><p>Don't feel bad because of failed interviews, just keep learning!</p></a> <a href="/blog/2022/09/28/5-tips-to-find-your-next-job" class="btn btn-outline-primary" prompt="Newer"><p>5 tips to find your next job</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: The stacktrace library'; this.page.url = 'https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library'; this.page.identifier = '/blog/2022/09/21/cpp23-stacktrace-library'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
