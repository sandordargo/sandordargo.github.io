<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="What are string_views and why should we use them?" /><meta property="og:locale" content="en_US" /><meta name="description" content="std::string_view has been introduced by C++17 and its purpose is to provide read-only access to character sequences. It potentially replaces const string&amp; parameters and offers a significant performance gain. Let’s delve into some details. How is it implemented? A typical implementation of a string_view needs two pieces of information. A pointer to the character sequence and its length. The character sequence can be both a C++ or a C-string. After all, std::string_view is a non-owning reference to a string. If we check the major implementations, we can observe that indeed all of them implemented string_view by storing a pointer to the string data and the size of the string. You can have a look at the implementations here: gcc clang Microsoft Why is it useful? This type is particularly useful! It’s quite cheap to copy it as it only needs the above-mentioned copy and its length. It’s so cheap to copy it that you should never see a string_view passed around by reference. It’s so cheap to copy that makes const string&amp; parameters superfluous in the vast majority of the cases. If a function doesn’t need to take ownership of its string argument and it only performs read operations (plus some modifications, to be discussed later) then you can use a string_view instead. When you need to own a character sequence, you should use a std::string as the Core Guidelines reminds us. Otherwise, string_views provide an easy way to get a view of strings no matter how they are allocated or stored. By that I mean that it doesn’t matter whether the underlying string has an implicit null termination (std::string) or not (const char *), string_view will be useable. If for some reason though you need that implicit null termination, you still must stick with a const string&amp;. If you want to get a bit more information about the performance of std::string_view against std::string, I highly recommend checking out this article from ModernesC++. In the last sections, Rainer Grimm shows the time difference it takes to create substrings either with std::string::substr or with std::string_view::substr and the results are just amazing. The difference depends a lot on the size of the substring which is due to the cost allocation a string needs and also due to small string optimization eliminating this need. All in all, the bigger substrings we create the more we save. Having -O3 turned on for smaller strings, Rainer achieved an improvement of almost 10x at least, but for big enough strings it was beyond an astonishing x7500 improvement. What API does string_view offers? As mentioned ealier, even though string_view is not owning the underlying string, it offers some modifying operations. I’d say std::string_view::swap is obvious, it simply exchanges views between two string_views. remove_prefix and remove_suffix are more interesting, how is that possible? These modifiers take a number (size_type) n to be removed. As we discussed earlier, a string_view usually has two data members. A pointer to the underlying character list and its size. In order to remove the suffix, so the end of the string, it’s enough to decrease the size data member by n. And in order to remove the prefix, besides decreasing the size, the pointer pointing at the character list should also be increased. It’s as easy, assuming that the characters are stored in a contiguous memory area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; std::cout &lt;&lt; sv &lt;&lt; &#39;\n&#39;; sv.remove_prefix(5); std::cout &lt;&lt; sv &lt;&lt; &#39;\n&#39;; sv.remove_suffix(8); std::cout &lt;&lt; sv &lt;&lt; &#39;\n&#39;; } /* here this is a string_view example this is a string_view example this is a string_view */ Apart from these, the string_view offered from the beginning the following functionalities: copy substr compare a bit set of find methods Let’s have a look at copy and compare! std::string_view::copy I wanted to zoom in on this method because when I first saw, I asked myself the question what do we copy there? And from there? std::string_view::copy takes three parameters with the last one having a default value. The first parameter is the destination, the second one is the length of the substring you want to copy and the third one is the starting point. If you don’t specify the last one, it’s the beginning of the string by default. So with std::string_view::copy we copy from the underlying view to somewhere else. Where can we copy? It can be any container of characters. Here are a few examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; std::array&lt;char, 8&gt; destinationArray{}; sv.copy(destinationArray.data(), 4); for (auto c: destinationArray) { std::cout &lt;&lt; c; } std::cout &lt;&lt; &#39;\n&#39;; std::string destinationStringNoSpace; sv.copy(destinationStringNoSpace.data(), 9); std::cout &lt;&lt; destinationStringNoSpace &lt;&lt; &#39;\n&#39;; std::string destinationStringWithSpace(&#39; &#39;, 9); sv.copy(destinationStringWithSpace.data(), 9); std::cout &lt;&lt; destinationStringWithSpace &lt;&lt; &#39;\n&#39;; } It’s worth noting that we can copy to char*, therefore we always pass in the result of the data() accessor. It’s also worth nothing that we have to make sure that a string is big enough. And reserve is not good enough as it only makes sure that there is enough space to grow, not that there is space initialized. std::string_view::compare I wanted to zoom in on std::string_view::compare as it’s always worth having a look at comparisons that return an integer value? What do they mean? But having a look at the available signatures poses some other questions. There are two straightforward ones. The compare member method can be called with either another string_view or with a const char*. But that is not all! You don’t have to compare the full string_view. You might pass in a starting position and a count for the underlying script_view, they precede the other character sequence. In addition, if you compare with another string_view, you can pass in the starting position and the size for the other view too. If you compare with a const char*, you cannot define the starting position, but you can still pass in the size. And what are the available return values? 0 if both are equal. You get a positive value if the underlying string is greater. You get a negative value if the other string is greater. Let’s have a look at some examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;string_view&gt; int main() { using std::operator&quot;&quot;sv; static_assert( &quot;abc&quot;sv.compare(&quot;abcd&quot;sv) &lt; 0 ); // Other is greater static_assert( &quot;abcd&quot;sv.compare(0, 3, &quot;abcd&quot;sv) &lt; 0 ); // Other is greater static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;abcd&quot;sv) &gt; 0 ); // This is greater static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;abcd&quot;sv, 1, 3) == 0 ); // Both are equal static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;bcde&quot;, 3) == 0 ); // Both are equal static_assert( &quot;abcd&quot;sv.compare(&quot;abc&quot;sv) &gt; 0 ); // This is greater static_assert( &quot;abc&quot;sv.compare(&quot;abc&quot;sv) == 0 ); // Both are equal static_assert( &quot;&quot;sv.compare(&quot;&quot;sv) == 0 );// Both are equal } Novelties of string_view in C++23/C++20 But since its introduction in C++17, string_view has received some new functionalities in both C++20 and 23. starts_with / ends_with added in C++20 These two queries were added to string_view in C++20. They help us to write more expressive code. We can simply call them to check whether a string starts or ends with a given substring. Look at the below example to see how it simplifies life. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; if (sv.starts_with(&quot;here&quot;)) { std::cout &lt;&lt; std::quoted(sv) &lt;&lt; &quot; starts with \&quot;here\&quot;\n&quot;; } if (!sv.ends_with(&quot;view&quot;)) { std::cout &lt;&lt; std::quoted(sv) &lt;&lt; &quot; does not end with \&quot;view\&quot;\n&quot;; } } How much does it simplify life? Just check out this or this article and you’ll see! This is just a super addition! std::string_view now have contains One of C++20’s useful addition to maps were the contains member function. We could replace the cumbersome to read query of myMap.find(key) != myMap.end() with the very easy to understand myMap.contains(key). With C++23, std::string and std::string_view will have similar capabilities. You can call contains() with either a string or a character and it will return true or false depending on whether the queried string or string_view contains the input parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; int main() { std::string s{&quot;there is a needle in the haystack&quot;}; std::string_view sv{&quot;acdef&quot;}; if (s.contains(&quot;needle&quot;)) { std::cout &lt;&lt; &quot;we found a needle in: &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\n&#39;; } if (!sv.contains(&#39;b&#39;)) { std::cout &lt;&lt; &quot;we did not find a &#39;b&#39; in: &quot; &lt;&lt; std::quoted(sv) &lt;&lt; &#39;\n&#39;; } } /* we found a needle in: &quot;there is a needle in the haystack&quot; we did not find a &#39;b&#39; in: &quot;acdef&quot; */ Build std::string_view from ranges With C++23, our favourite string_view doesn’t only loses a constructor (the overload with a nullptr gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly. So far, if we wanted to create a string_view out of a “range”, we had to invoke the constructor with a begin and and end iterators: std::string_view sv(myRange.begin(), myRange.end());. Now we’ll be able to directly construct a string_view based on a range: std::string_view sv(myRange);. Require span &amp; basic_string_view to be TriviallyCopyable P2251R1 updates the requirements the standard has for std::span and std::string_view. Starting from C++23 they must satisfy the TriviallyCopyable concepts. As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a size_t and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so. Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing. Conclusion In this post, we discussed what string_views are and howthey simplify our lives. We saw that they don’t just offer superior performance due to fewer copies but they also provide an easy-to-use interface that gets better with each version. Have you started using more and more the string_view instead of const string&amp; in your projects? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="std::string_view has been introduced by C++17 and its purpose is to provide read-only access to character sequences. It potentially replaces const string&amp; parameters and offers a significant performance gain. Let’s delve into some details. How is it implemented? A typical implementation of a string_view needs two pieces of information. A pointer to the character sequence and its length. The character sequence can be both a C++ or a C-string. After all, std::string_view is a non-owning reference to a string. If we check the major implementations, we can observe that indeed all of them implemented string_view by storing a pointer to the string data and the size of the string. You can have a look at the implementations here: gcc clang Microsoft Why is it useful? This type is particularly useful! It’s quite cheap to copy it as it only needs the above-mentioned copy and its length. It’s so cheap to copy it that you should never see a string_view passed around by reference. It’s so cheap to copy that makes const string&amp; parameters superfluous in the vast majority of the cases. If a function doesn’t need to take ownership of its string argument and it only performs read operations (plus some modifications, to be discussed later) then you can use a string_view instead. When you need to own a character sequence, you should use a std::string as the Core Guidelines reminds us. Otherwise, string_views provide an easy way to get a view of strings no matter how they are allocated or stored. By that I mean that it doesn’t matter whether the underlying string has an implicit null termination (std::string) or not (const char *), string_view will be useable. If for some reason though you need that implicit null termination, you still must stick with a const string&amp;. If you want to get a bit more information about the performance of std::string_view against std::string, I highly recommend checking out this article from ModernesC++. In the last sections, Rainer Grimm shows the time difference it takes to create substrings either with std::string::substr or with std::string_view::substr and the results are just amazing. The difference depends a lot on the size of the substring which is due to the cost allocation a string needs and also due to small string optimization eliminating this need. All in all, the bigger substrings we create the more we save. Having -O3 turned on for smaller strings, Rainer achieved an improvement of almost 10x at least, but for big enough strings it was beyond an astonishing x7500 improvement. What API does string_view offers? As mentioned ealier, even though string_view is not owning the underlying string, it offers some modifying operations. I’d say std::string_view::swap is obvious, it simply exchanges views between two string_views. remove_prefix and remove_suffix are more interesting, how is that possible? These modifiers take a number (size_type) n to be removed. As we discussed earlier, a string_view usually has two data members. A pointer to the underlying character list and its size. In order to remove the suffix, so the end of the string, it’s enough to decrease the size data member by n. And in order to remove the prefix, besides decreasing the size, the pointer pointing at the character list should also be increased. It’s as easy, assuming that the characters are stored in a contiguous memory area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; std::cout &lt;&lt; sv &lt;&lt; &#39;\n&#39;; sv.remove_prefix(5); std::cout &lt;&lt; sv &lt;&lt; &#39;\n&#39;; sv.remove_suffix(8); std::cout &lt;&lt; sv &lt;&lt; &#39;\n&#39;; } /* here this is a string_view example this is a string_view example this is a string_view */ Apart from these, the string_view offered from the beginning the following functionalities: copy substr compare a bit set of find methods Let’s have a look at copy and compare! std::string_view::copy I wanted to zoom in on this method because when I first saw, I asked myself the question what do we copy there? And from there? std::string_view::copy takes three parameters with the last one having a default value. The first parameter is the destination, the second one is the length of the substring you want to copy and the third one is the starting point. If you don’t specify the last one, it’s the beginning of the string by default. So with std::string_view::copy we copy from the underlying view to somewhere else. Where can we copy? It can be any container of characters. Here are a few examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; std::array&lt;char, 8&gt; destinationArray{}; sv.copy(destinationArray.data(), 4); for (auto c: destinationArray) { std::cout &lt;&lt; c; } std::cout &lt;&lt; &#39;\n&#39;; std::string destinationStringNoSpace; sv.copy(destinationStringNoSpace.data(), 9); std::cout &lt;&lt; destinationStringNoSpace &lt;&lt; &#39;\n&#39;; std::string destinationStringWithSpace(&#39; &#39;, 9); sv.copy(destinationStringWithSpace.data(), 9); std::cout &lt;&lt; destinationStringWithSpace &lt;&lt; &#39;\n&#39;; } It’s worth noting that we can copy to char*, therefore we always pass in the result of the data() accessor. It’s also worth nothing that we have to make sure that a string is big enough. And reserve is not good enough as it only makes sure that there is enough space to grow, not that there is space initialized. std::string_view::compare I wanted to zoom in on std::string_view::compare as it’s always worth having a look at comparisons that return an integer value? What do they mean? But having a look at the available signatures poses some other questions. There are two straightforward ones. The compare member method can be called with either another string_view or with a const char*. But that is not all! You don’t have to compare the full string_view. You might pass in a starting position and a count for the underlying script_view, they precede the other character sequence. In addition, if you compare with another string_view, you can pass in the starting position and the size for the other view too. If you compare with a const char*, you cannot define the starting position, but you can still pass in the size. And what are the available return values? 0 if both are equal. You get a positive value if the underlying string is greater. You get a negative value if the other string is greater. Let’s have a look at some examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;string_view&gt; int main() { using std::operator&quot;&quot;sv; static_assert( &quot;abc&quot;sv.compare(&quot;abcd&quot;sv) &lt; 0 ); // Other is greater static_assert( &quot;abcd&quot;sv.compare(0, 3, &quot;abcd&quot;sv) &lt; 0 ); // Other is greater static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;abcd&quot;sv) &gt; 0 ); // This is greater static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;abcd&quot;sv, 1, 3) == 0 ); // Both are equal static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;bcde&quot;, 3) == 0 ); // Both are equal static_assert( &quot;abcd&quot;sv.compare(&quot;abc&quot;sv) &gt; 0 ); // This is greater static_assert( &quot;abc&quot;sv.compare(&quot;abc&quot;sv) == 0 ); // Both are equal static_assert( &quot;&quot;sv.compare(&quot;&quot;sv) == 0 );// Both are equal } Novelties of string_view in C++23/C++20 But since its introduction in C++17, string_view has received some new functionalities in both C++20 and 23. starts_with / ends_with added in C++20 These two queries were added to string_view in C++20. They help us to write more expressive code. We can simply call them to check whether a string starts or ends with a given substring. Look at the below example to see how it simplifies life. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; if (sv.starts_with(&quot;here&quot;)) { std::cout &lt;&lt; std::quoted(sv) &lt;&lt; &quot; starts with \&quot;here\&quot;\n&quot;; } if (!sv.ends_with(&quot;view&quot;)) { std::cout &lt;&lt; std::quoted(sv) &lt;&lt; &quot; does not end with \&quot;view\&quot;\n&quot;; } } How much does it simplify life? Just check out this or this article and you’ll see! This is just a super addition! std::string_view now have contains One of C++20’s useful addition to maps were the contains member function. We could replace the cumbersome to read query of myMap.find(key) != myMap.end() with the very easy to understand myMap.contains(key). With C++23, std::string and std::string_view will have similar capabilities. You can call contains() with either a string or a character and it will return true or false depending on whether the queried string or string_view contains the input parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; int main() { std::string s{&quot;there is a needle in the haystack&quot;}; std::string_view sv{&quot;acdef&quot;}; if (s.contains(&quot;needle&quot;)) { std::cout &lt;&lt; &quot;we found a needle in: &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\n&#39;; } if (!sv.contains(&#39;b&#39;)) { std::cout &lt;&lt; &quot;we did not find a &#39;b&#39; in: &quot; &lt;&lt; std::quoted(sv) &lt;&lt; &#39;\n&#39;; } } /* we found a needle in: &quot;there is a needle in the haystack&quot; we did not find a &#39;b&#39; in: &quot;acdef&quot; */ Build std::string_view from ranges With C++23, our favourite string_view doesn’t only loses a constructor (the overload with a nullptr gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly. So far, if we wanted to create a string_view out of a “range”, we had to invoke the constructor with a begin and and end iterators: std::string_view sv(myRange.begin(), myRange.end());. Now we’ll be able to directly construct a string_view based on a range: std::string_view sv(myRange);. Require span &amp; basic_string_view to be TriviallyCopyable P2251R1 updates the requirements the standard has for std::span and std::string_view. Starting from C++23 they must satisfy the TriviallyCopyable concepts. As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a size_t and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so. Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing. Conclusion In this post, we discussed what string_views are and howthey simplify our lives. We saw that they don’t just offer superior performance due to fewer copies but they also provide an easy-to-use interface that gets better with each version. Have you started using more and more the string_view instead of const string&amp; in your projects? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-13T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="What are string_views and why should we use them?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-07-13T00:00:00+02:00","datePublished":"2022-07-13T00:00:00+02:00","description":"std::string_view has been introduced by C++17 and its purpose is to provide read-only access to character sequences. It potentially replaces const string&amp; parameters and offers a significant performance gain. Let’s delve into some details. How is it implemented? A typical implementation of a string_view needs two pieces of information. A pointer to the character sequence and its length. The character sequence can be both a C++ or a C-string. After all, std::string_view is a non-owning reference to a string. If we check the major implementations, we can observe that indeed all of them implemented string_view by storing a pointer to the string data and the size of the string. You can have a look at the implementations here: gcc clang Microsoft Why is it useful? This type is particularly useful! It’s quite cheap to copy it as it only needs the above-mentioned copy and its length. It’s so cheap to copy it that you should never see a string_view passed around by reference. It’s so cheap to copy that makes const string&amp; parameters superfluous in the vast majority of the cases. If a function doesn’t need to take ownership of its string argument and it only performs read operations (plus some modifications, to be discussed later) then you can use a string_view instead. When you need to own a character sequence, you should use a std::string as the Core Guidelines reminds us. Otherwise, string_views provide an easy way to get a view of strings no matter how they are allocated or stored. By that I mean that it doesn’t matter whether the underlying string has an implicit null termination (std::string) or not (const char *), string_view will be useable. If for some reason though you need that implicit null termination, you still must stick with a const string&amp;. If you want to get a bit more information about the performance of std::string_view against std::string, I highly recommend checking out this article from ModernesC++. In the last sections, Rainer Grimm shows the time difference it takes to create substrings either with std::string::substr or with std::string_view::substr and the results are just amazing. The difference depends a lot on the size of the substring which is due to the cost allocation a string needs and also due to small string optimization eliminating this need. All in all, the bigger substrings we create the more we save. Having -O3 turned on for smaller strings, Rainer achieved an improvement of almost 10x at least, but for big enough strings it was beyond an astonishing x7500 improvement. What API does string_view offers? As mentioned ealier, even though string_view is not owning the underlying string, it offers some modifying operations. I’d say std::string_view::swap is obvious, it simply exchanges views between two string_views. remove_prefix and remove_suffix are more interesting, how is that possible? These modifiers take a number (size_type) n to be removed. As we discussed earlier, a string_view usually has two data members. A pointer to the underlying character list and its size. In order to remove the suffix, so the end of the string, it’s enough to decrease the size data member by n. And in order to remove the prefix, besides decreasing the size, the pointer pointing at the character list should also be increased. It’s as easy, assuming that the characters are stored in a contiguous memory area. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; std::cout &lt;&lt; sv &lt;&lt; &#39;\\n&#39;; sv.remove_prefix(5); std::cout &lt;&lt; sv &lt;&lt; &#39;\\n&#39;; sv.remove_suffix(8); std::cout &lt;&lt; sv &lt;&lt; &#39;\\n&#39;; } /* here this is a string_view example this is a string_view example this is a string_view */ Apart from these, the string_view offered from the beginning the following functionalities: copy substr compare a bit set of find methods Let’s have a look at copy and compare! std::string_view::copy I wanted to zoom in on this method because when I first saw, I asked myself the question what do we copy there? And from there? std::string_view::copy takes three parameters with the last one having a default value. The first parameter is the destination, the second one is the length of the substring you want to copy and the third one is the starting point. If you don’t specify the last one, it’s the beginning of the string by default. So with std::string_view::copy we copy from the underlying view to somewhere else. Where can we copy? It can be any container of characters. Here are a few examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;array&gt; #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; std::array&lt;char, 8&gt; destinationArray{}; sv.copy(destinationArray.data(), 4); for (auto c: destinationArray) { std::cout &lt;&lt; c; } std::cout &lt;&lt; &#39;\\n&#39;; std::string destinationStringNoSpace; sv.copy(destinationStringNoSpace.data(), 9); std::cout &lt;&lt; destinationStringNoSpace &lt;&lt; &#39;\\n&#39;; std::string destinationStringWithSpace(&#39; &#39;, 9); sv.copy(destinationStringWithSpace.data(), 9); std::cout &lt;&lt; destinationStringWithSpace &lt;&lt; &#39;\\n&#39;; } It’s worth noting that we can copy to char*, therefore we always pass in the result of the data() accessor. It’s also worth nothing that we have to make sure that a string is big enough. And reserve is not good enough as it only makes sure that there is enough space to grow, not that there is space initialized. std::string_view::compare I wanted to zoom in on std::string_view::compare as it’s always worth having a look at comparisons that return an integer value? What do they mean? But having a look at the available signatures poses some other questions. There are two straightforward ones. The compare member method can be called with either another string_view or with a const char*. But that is not all! You don’t have to compare the full string_view. You might pass in a starting position and a count for the underlying script_view, they precede the other character sequence. In addition, if you compare with another string_view, you can pass in the starting position and the size for the other view too. If you compare with a const char*, you cannot define the starting position, but you can still pass in the size. And what are the available return values? 0 if both are equal. You get a positive value if the underlying string is greater. You get a negative value if the other string is greater. Let’s have a look at some examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;string_view&gt; int main() { using std::operator&quot;&quot;sv; static_assert( &quot;abc&quot;sv.compare(&quot;abcd&quot;sv) &lt; 0 ); // Other is greater static_assert( &quot;abcd&quot;sv.compare(0, 3, &quot;abcd&quot;sv) &lt; 0 ); // Other is greater static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;abcd&quot;sv) &gt; 0 ); // This is greater static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;abcd&quot;sv, 1, 3) == 0 ); // Both are equal static_assert( &quot;abcd&quot;sv.compare(1, 3, &quot;bcde&quot;, 3) == 0 ); // Both are equal static_assert( &quot;abcd&quot;sv.compare(&quot;abc&quot;sv) &gt; 0 ); // This is greater static_assert( &quot;abc&quot;sv.compare(&quot;abc&quot;sv) == 0 ); // Both are equal static_assert( &quot;&quot;sv.compare(&quot;&quot;sv) == 0 );// Both are equal } Novelties of string_view in C++23/C++20 But since its introduction in C++17, string_view has received some new functionalities in both C++20 and 23. starts_with / ends_with added in C++20 These two queries were added to string_view in C++20. They help us to write more expressive code. We can simply call them to check whether a string starts or ends with a given substring. Look at the below example to see how it simplifies life. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;iomanip&gt; #include &lt;string_view&gt; int main() { std::string_view sv{&quot;here this is a string_view example&quot;}; if (sv.starts_with(&quot;here&quot;)) { std::cout &lt;&lt; std::quoted(sv) &lt;&lt; &quot; starts with \\&quot;here\\&quot;\\n&quot;; } if (!sv.ends_with(&quot;view&quot;)) { std::cout &lt;&lt; std::quoted(sv) &lt;&lt; &quot; does not end with \\&quot;view\\&quot;\\n&quot;; } } How much does it simplify life? Just check out this or this article and you’ll see! This is just a super addition! std::string_view now have contains One of C++20’s useful addition to maps were the contains member function. We could replace the cumbersome to read query of myMap.find(key) != myMap.end() with the very easy to understand myMap.contains(key). With C++23, std::string and std::string_view will have similar capabilities. You can call contains() with either a string or a character and it will return true or false depending on whether the queried string or string_view contains the input parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; int main() { std::string s{&quot;there is a needle in the haystack&quot;}; std::string_view sv{&quot;acdef&quot;}; if (s.contains(&quot;needle&quot;)) { std::cout &lt;&lt; &quot;we found a needle in: &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\\n&#39;; } if (!sv.contains(&#39;b&#39;)) { std::cout &lt;&lt; &quot;we did not find a &#39;b&#39; in: &quot; &lt;&lt; std::quoted(sv) &lt;&lt; &#39;\\n&#39;; } } /* we found a needle in: &quot;there is a needle in the haystack&quot; we did not find a &#39;b&#39; in: &quot;acdef&quot; */ Build std::string_view from ranges With C++23, our favourite string_view doesn’t only loses a constructor (the overload with a nullptr gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly. So far, if we wanted to create a string_view out of a “range”, we had to invoke the constructor with a begin and and end iterators: std::string_view sv(myRange.begin(), myRange.end());. Now we’ll be able to directly construct a string_view based on a range: std::string_view sv(myRange);. Require span &amp; basic_string_view to be TriviallyCopyable P2251R1 updates the requirements the standard has for std::span and std::string_view. Starting from C++23 they must satisfy the TriviallyCopyable concepts. As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a size_t and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so. Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing. Conclusion In this post, we discussed what string_views are and howthey simplify our lives. We saw that they don’t just offer superior performance due to fewer copies but they also provide an easy-to-use interface that gets better with each version. Have you started using more and more the string_view instead of const string&amp; in your projects? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"What are string_views and why should we use them?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views"},"url":"https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views"}</script><title>What are string_views and why should we use them? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/13"> 13 </a> </span> <span>What are string_views and why should we use them?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>What are string_views and why should we use them?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 13, 2022, 12:00 AM +0200" prep="on" > Jul 13, 2022 <i class="unloaded">2022-07-13T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1770 words">9 min</span></div></div><div class="post-content"><p><code class="language-plaintext highlighter-rouge">std::string_view</code> has been introduced by C++17 and its purpose is to provide read-only access to character sequences. It potentially replaces <code class="language-plaintext highlighter-rouge">const string&amp;</code> parameters and offers a significant performance gain. Let’s delve into some details.</p><h2 id="how-is-it-implemented">How is it implemented?</h2><p>A typical implementation of a <code class="language-plaintext highlighter-rouge">string_view</code> needs two pieces of information. A pointer to the character sequence and its length. The character sequence can be both a C++ or a C-string. After all, <code class="language-plaintext highlighter-rouge">std::string_view</code> is a non-owning reference to a string.</p><p>If we check the major implementations, we can observe that indeed all of them implemented <code class="language-plaintext highlighter-rouge">string_view</code> by storing a pointer to the string data and the size of the string. You can have a look at the implementations here:</p><ul><li><a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/string_view">gcc</a><li><a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/string_view">clang</a><li><a href="https://github.com/microsoft/STL/blob/main/stl/inc/xstring">Microsoft</a></ul><h2 id="why-is-it-useful">Why is it useful?</h2><p>This type is particularly useful! It’s quite cheap to copy it as it only needs the above-mentioned copy and its length. It’s so cheap to copy it that you should never see a <code class="language-plaintext highlighter-rouge">string_view</code> passed around by reference. It’s so cheap to copy that makes <code class="language-plaintext highlighter-rouge">const string&amp;</code> parameters superfluous in the vast majority of the cases.</p><p>If a function doesn’t need to take ownership of its <code class="language-plaintext highlighter-rouge">string</code> argument and it only performs read operations (plus some modifications, to be discussed later) then you can use a <code class="language-plaintext highlighter-rouge">string_view</code> instead.</p><p>When you need to own a character sequence, you should use a <code class="language-plaintext highlighter-rouge">std::string</code> <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#slstr1-use-stdstring-to-own-character-sequences">as the Core Guidelines reminds us</a>. Otherwise, <code class="language-plaintext highlighter-rouge">string_view</code>s provide an easy way to get a view of strings no matter how they are allocated or stored. By that I mean that it doesn’t matter whether the underlying string has an implicit null termination (<code class="language-plaintext highlighter-rouge">std::string</code>) or not (<code class="language-plaintext highlighter-rouge">const char *</code>), <code class="language-plaintext highlighter-rouge">string_view</code> will be useable.</p><p>If for some reason though you need that implicit null termination, you still must stick with a <code class="language-plaintext highlighter-rouge">const string&amp;</code>.</p><p>If you want to get a bit more information about the performance of <code class="language-plaintext highlighter-rouge">std::string_view</code> against <code class="language-plaintext highlighter-rouge">std::string</code>, I highly recommend checking out <a href="https://www.modernescpp.com/index.php/c-17-avoid-copying-with-std-string-view">this article from ModernesC++</a>. In the last sections, Rainer Grimm shows the time difference it takes to create substrings either with <code class="language-plaintext highlighter-rouge">std::string::substr</code> or with <code class="language-plaintext highlighter-rouge">std::string_view::substr</code> and the results are just amazing.</p><p>The difference depends a lot on the size of the substring which is due to the cost allocation a <code class="language-plaintext highlighter-rouge">string</code> needs and also due to small string optimization eliminating this need. All in all, the bigger substrings we create the more we save. Having <code class="language-plaintext highlighter-rouge">-O3</code> turned on for smaller strings, Rainer achieved an improvement of almost 10x at least, but for big enough strings it was beyond an astonishing x7500 improvement.</p><h3 id="what-api-does-string_view-offers">What API does <code class="language-plaintext highlighter-rouge">string_view</code> offers?</h3><p>As mentioned ealier, even though <code class="language-plaintext highlighter-rouge">string_view</code> is not owning the underlying string, it offers some modifying operations. I’d say</p><ul><li><code class="language-plaintext highlighter-rouge">std::string_view::swap</code> is obvious, it simply exchanges views between two <code class="language-plaintext highlighter-rouge">string_views</code>.<li><code class="language-plaintext highlighter-rouge">remove_prefix</code> and <code class="language-plaintext highlighter-rouge">remove_suffix</code> are more interesting, how is that possible?</ul><p>These modifiers take a number (<code class="language-plaintext highlighter-rouge">size_type</code>) <code class="language-plaintext highlighter-rouge">n</code> to be removed. As we discussed earlier, a <code class="language-plaintext highlighter-rouge">string_view</code> usually has two data members. A pointer to the underlying character list and its size. In order to remove the suffix, so the end of the string, it’s enough to decrease the size data member by <code class="language-plaintext highlighter-rouge">n</code>. And in order to remove the prefix, besides decreasing the size, the pointer pointing at the character list should also be increased. It’s as easy, assuming that the characters are stored in a contiguous memory area.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">{</span><span class="s">"here this is a string_view example"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sv</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">remove_prefix</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sv</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">remove_suffix</span><span class="p">(</span><span class="mi">8</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sv</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
here this is a string_view example
this is a string_view example
this is a string_view
*/</span>
</pre></table></code></div></div><p>Apart from these, the <code class="language-plaintext highlighter-rouge">string_view</code> offered from the beginning the following functionalities:</p><ul><li><code class="language-plaintext highlighter-rouge">copy</code><li><code class="language-plaintext highlighter-rouge">substr</code><li><code class="language-plaintext highlighter-rouge">compare</code><li>a bit set of <code class="language-plaintext highlighter-rouge">find</code> methods</ul><p>Let’s have a look at <code class="language-plaintext highlighter-rouge">copy</code> and <code class="language-plaintext highlighter-rouge">compare</code>!</p><h3 id="stdstring_viewcopy">std::string_view::copy</h3><p>I wanted to zoom in on this method because when I first saw, I asked myself the question what do we copy there? And from there?</p><p><code class="language-plaintext highlighter-rouge">std::string_view::copy</code> takes three parameters with the last one having a default value. The first parameter is the destination, the second one is the length of the substring you want to copy and the third one is the starting point. If you don’t specify the last one, it’s the beginning of the string by default.</p><p>So with <code class="language-plaintext highlighter-rouge">std::string_view::copy</code> we copy from the underlying view to somewhere else.</p><p>Where can we <code class="language-plaintext highlighter-rouge">copy</code>? It can be any container of characters. Here are a few examples.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">{</span><span class="s">"here this is a string_view example"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">destinationArray</span><span class="p">{};</span>
    
    
    <span class="n">sv</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">destinationArray</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">4</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">destinationArray</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">destinationStringNoSpace</span><span class="p">;</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">destinationStringNoSpace</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">destinationStringNoSpace</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">destinationStringWithSpace</span><span class="p">(</span><span class="sc">' '</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">sv</span><span class="p">.</span><span class="n">copy</span><span class="p">(</span><span class="n">destinationStringWithSpace</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="mi">9</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">destinationStringWithSpace</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s worth noting that we can copy to <code class="language-plaintext highlighter-rouge">char*</code>, therefore we always pass in the result of the <code class="language-plaintext highlighter-rouge">data()</code> accessor. It’s also worth nothing that we have to make sure that a <code class="language-plaintext highlighter-rouge">string</code> is big enough. And <code class="language-plaintext highlighter-rouge">reserve</code> is not good enough as it only makes sure that there is enough space to grow, not that there is space initialized.</p><h3 id="stdstring_viewcompare"><code class="language-plaintext highlighter-rouge">std::string_view::compare</code></h3><p>I wanted to zoom in on <code class="language-plaintext highlighter-rouge">std::string_view::compare</code> as it’s always worth having a look at comparisons that return an integer value? What do they mean?</p><p>But having a look at the <a href="https://en.cppreference.com/w/cpp/string/basic_string_view/compare">available signatures</a> poses some other questions.</p><p>There are two straightforward ones. The <code class="language-plaintext highlighter-rouge">compare</code> member method can be called with either another <code class="language-plaintext highlighter-rouge">string_view</code> or with a <code class="language-plaintext highlighter-rouge">const char*</code>. But that is not all! You don’t have to compare the full <code class="language-plaintext highlighter-rouge">string_view</code>. You might pass in a starting position and a count for the underlying <code class="language-plaintext highlighter-rouge">script_view</code>, they precede the other character sequence.</p><p>In addition, if you compare with another <code class="language-plaintext highlighter-rouge">string_view</code>, you can pass in the starting position and the size for the other view too. If you compare with a <code class="language-plaintext highlighter-rouge">const char*</code>, you cannot define the starting position, but you can still pass in the size.</p><p>And what are the available return values?</p><ul><li><code class="language-plaintext highlighter-rouge">0</code> if both are equal.<li>You get a positive value if the underlying string is greater.<li>You get a negative value if the other string is greater.</ul><p>Let’s have a look at some examples.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="k">operator</span><span class="s">""</span><span class="n">sv</span><span class="p">;</span>

    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abc"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">"abcd"</span><span class="n">sv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// Other is greater</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// Other is greater</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// This is greater</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// Both are equal</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="s">"bcde"</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// Both are equal</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abcd"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">"abc"</span><span class="n">sv</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// This is greater</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">"abc"</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">"abc"</span><span class="n">sv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span> <span class="c1">// Both are equal</span>
    <span class="k">static_assert</span><span class="p">(</span> <span class="s">""</span><span class="n">sv</span><span class="p">.</span><span class="n">compare</span><span class="p">(</span><span class="s">""</span><span class="n">sv</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span> <span class="p">);</span><span class="c1">// Both are equal</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="novelties-of-string_view-in-c23c20">Novelties of string_view in C++23/C++20</h2><p>But since its introduction in C++17, <code class="language-plaintext highlighter-rouge">string_view</code> has received some new functionalities in both C++20 and 23.</p><h3 id="starts_with--ends_with-added-in-c20"><code class="language-plaintext highlighter-rouge">starts_with</code> / <code class="language-plaintext highlighter-rouge">ends_with</code> added in C++20</h3><p>These two queries were added to <code class="language-plaintext highlighter-rouge">string_view</code> in C++20. They help us to write more expressive code. We can simply call them to check whether a string starts or ends with a given substring. Look at the below example to see how it simplifies life.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string_view&gt;</span><span class="cp">
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">{</span><span class="s">"here this is a string_view example"</span><span class="p">};</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">sv</span><span class="p">.</span><span class="n">starts_with</span><span class="p">(</span><span class="s">"here"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" starts with </span><span class="se">\"</span><span class="s">here</span><span class="se">\"\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sv</span><span class="p">.</span><span class="n">ends_with</span><span class="p">(</span><span class="s">"view"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">" does not end with </span><span class="se">\"</span><span class="s">view</span><span class="se">\"\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>How much does it simplify life? Just check out <a href="https://www.techiedelight.com/check-if-a-string-starts-with-a-certain-string-in-cpp/">this</a> or <a href="https://stackoverflow.com/questions/1878001/how-do-i-check-if-a-c-stdstring-starts-with-a-certain-string-and-convert-a">this</a> article and you’ll see! This is just a super addition!</p><h3 id="stdstring_view-now-have-contains"><code class="language-plaintext highlighter-rouge">std::string_view</code> now have <code class="language-plaintext highlighter-rouge">contains</code></h3><p>One of C++20’s useful addition to maps were the <code class="language-plaintext highlighter-rouge">contains</code> member function. We could replace the cumbersome to read query of <code class="language-plaintext highlighter-rouge">myMap.find(key) != myMap.end()</code> with the very easy to understand <code class="language-plaintext highlighter-rouge">myMap.contains(key)</code>. With C++23, <code class="language-plaintext highlighter-rouge">std::string</code> and <code class="language-plaintext highlighter-rouge">std::string_view</code> will have similar capabilities. You can call <code class="language-plaintext highlighter-rouge">contains()</code> with either a string or a character and it will return <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> depending on whether the queried <code class="language-plaintext highlighter-rouge">string</code> or <code class="language-plaintext highlighter-rouge">string_view</code> contains the input parameter.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">"there is a needle in the haystack"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">{</span><span class="s">"acdef"</span><span class="p">};</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">"needle"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"we found a needle in: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sv</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="sc">'b'</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"we did not find a 'b' in: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
we found a needle in: "there is a needle in the haystack"
we did not find a 'b' in: "acdef"
*/</span>
</pre></table></code></div></div><h3 id="build-stdstring_view-from-ranges">Build <code class="language-plaintext highlighter-rouge">std::string_view</code> from ranges</h3><p>With C++23, our favourite <code class="language-plaintext highlighter-rouge">string_view</code> doesn’t only loses a constructor (the overload with a <code class="language-plaintext highlighter-rouge">nullptr</code> gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly.</p><p>So far, if we wanted to create a <code class="language-plaintext highlighter-rouge">string_view</code> out of a <em>“range”</em>, we had to invoke the constructor with a <code class="language-plaintext highlighter-rouge">begin</code> and and <code class="language-plaintext highlighter-rouge">end</code> iterators: <code class="language-plaintext highlighter-rouge">std::string_view sv(myRange.begin(), myRange.end());</code>. Now we’ll be able to directly construct a <code class="language-plaintext highlighter-rouge">string_view</code> based on a range: <code class="language-plaintext highlighter-rouge">std::string_view sv(myRange);</code>.</p><h3 id="require-span--basic_string_view-to-be-triviallycopyable">Require span &amp; basic_string_view to be TriviallyCopyable</h3><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf">P2251R1</a> updates the requirements the standard has for <code class="language-plaintext highlighter-rouge">std::span</code> and <code class="language-plaintext highlighter-rouge">std::string_view</code>. Starting from C++23 they must satisfy the <code class="language-plaintext highlighter-rouge">TriviallyCopyable</code> concepts.</p><p>As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a <code class="language-plaintext highlighter-rouge">size_t</code> and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so.</p><p>Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing.</p><h2 id="conclusion">Conclusion</h2><p>In this post, we discussed what <code class="language-plaintext highlighter-rouge">string_view</code>s are and howthey simplify our lives. We saw that they don’t just offer superior performance due to fewer copies but they also provide an easy-to-use interface that gets better with each version.</p><p>Have you started using more and more the <code class="language-plaintext highlighter-rouge">string_view</code> instead of <code class="language-plaintext highlighter-rouge">const string&amp;</code> in your projects?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/string-view/" class="post-tag no-text-decoration" >string_view</a> <a href="/tags/bestpractices/" class="post-tag no-text-decoration" >bestpractices</a> <a href="/tags/string/" class="post-tag no-text-decoration" >string</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=What are string_views and why should we use them? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=What are string_views and why should we use them? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=What are string_views and why should we use them? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=What are string_views and why should we use them? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23"><div class="card-body"> <span class="timeago small" > Jul 20, 2022 <i class="unloaded">2022-07-20T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>6 C++23 features improving string and string_view</h3><div class="text-muted small"><p> In this blog post, let’s collect a couple of changes that are going to be shipped with C++23 and are all related to strings or string_views. std::string and std::string_view have contains One of ...</p></div></div></a></div><div class="card"> <a href="/blog/2021/06/05/cpp-best-practices-by-jason-turner"><div class="card-body"> <span class="timeago small" > Jun 5, 2021 <i class="unloaded">2021-06-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ Best Practices by Jason Turner</h3><div class="text-muted small"><p> This is a book that I’ve been waiting for to finally read for a long time. I could have bought it, but I decided that it’ll be the first book that I buy from the royalties I earned with How to use ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/04/16/beautiful-cpp-by-kate-gregory-and-guy-davidson"><div class="card-body"> <span class="timeago small" > Apr 16, 2022 <i class="unloaded">2022-04-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Beautiful C++: 30 Core Guidelines for Writing Clean, Safe and Fast Code by J. Guy Davidson and Kate Gregory</h3><div class="text-muted small"><p> If you are familiar with the Pluralsight courses of Kate Gregory, you won’t be surprised by the name of this book. While many consider C++ a complex language that always results in difficult to rea...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/07/06/lifetime-extension-bughunt" class="btn btn-outline-primary" prompt="Older"><p>Won't extend it more than once!</p></a> <a href="/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" class="btn btn-outline-primary" prompt="Newer"><p>6 C++23 features improving string and string_view</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'What are string_views and why should we use them?'; this.page.url = 'https://www.sandordargo.com/blog/2022/07/13/why_to_use_string_views'; this.page.identifier = '/blog/2022/07/13/why_to_use_string_views'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
