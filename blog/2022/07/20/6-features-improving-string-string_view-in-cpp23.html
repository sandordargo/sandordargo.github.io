<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="6 C++23 features improving string and string_view" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this blog post, let’s collect a couple of changes that are going to be shipped with C++23 and are all related to strings or string_views. std::string and std::string_view have contains One of C++20’s useful addition to maps were the contains member function. We could replace the cumbersome to read query of myMap.find(key) != myMap.end() with the very easy to understand myMap.contains(key). With C++23, std::string and std::string_view will have similar capabilities. You can call contains() with either a string or a character and it will return true or false depending on whether the queried string or string_view contains the input parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; int main() { std::string s{&quot;there is a needle in the haystack&quot;}; std::string_view sv{&quot;acdef&quot;}; if (s.contains(&quot;needle&quot;)) { std::cout &lt;&lt; &quot;we found a needle in: &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\n&#39;; } if (!sv.contains(&#39;b&#39;)) { std::cout &lt;&lt; &quot;we did not find a &#39;b&#39; in: &quot; &lt;&lt; std::quoted(sv) &lt;&lt; &#39;\n&#39;; } } /* we found a needle in: &quot;there is a needle in the haystack&quot; we did not find a &#39;b&#39; in: &quot;acdef&quot; */ No more undefined behaviour due to construction from nullptr In an earlier newsletter, we discussed that initializing a string from a nullptr is undefined behaviour. In practice, this might happen when you convert a const char * to a string. What happens then? It depends on the compiler, gcc for example, throws a runtime exception. Thanks to P2166R1, this is not something to worry about. Instead of undefined behaviour, the constructor and assignment operator overloaded with nullptr_t are deleted and therefore compilation fails when you attempt to construct a new string out of a nullptr. 1 2 3 4 5 6 7 8 9 std::string s(nullptr); /* &lt;source&gt;:18:26: error: use of deleted function &#39;std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string(std::nullptr_t) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Alloc = std::allocator&lt;char&gt;; std::nullptr_t = std::nullptr_t]&#39; 18 | std::string s(nullptr); | ^ /opt/compiler-explorer/gcc-12.1.0/include/c++/12.1.0/bits/basic_string.h:734:7: note: declared here 734 | basic_string(nullptr_t) = delete; | ^~~~~~~~~~~~ */ While this change is good and points in a good direction, not all of our problems disappear with nullptrs. Taking a nullptr and a size in the constructor (e.g. std::string s(nullptr, 3)) is still valid and remains undefined behaviour. These changes are also valid for string_view. Build std::string_view from ranges With C++23, our favourite string_view doesn’t only loses a constructor (the overload with a nullptr gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly. So far, if we wanted to create a string_view out of a “range”, we had to invoke the constructor with a begin and and end iterators: std::string_view sv(myRange.begin(), myRange.end());. Now we’ll be able to directly construct a string_view based on a range: std::string_view sv(myRange);. basic_string::resize_and_overwrite() One of the main reasons to use C++ is its high performance. An area where we often use the language in a non-efficient way is string handling. C++23 will bring us another string member function that will help us to handle strings in a more performant way. std::string::resize_and_overwrite() takes two parameters, a count and an operation and does the following (while returns nothing): if the count is smaller or equal to the size() ofthe string, it erases the last size() - count elements if count is larger than size(), appends n - size() default-initialized elements it also invokes erase(begin() + op(data(), count), end()). In other words, resize_and_overwrite() will make sure that the given string has continuous storage containing count + 1 characters. If op() throws, the behaviour is undefined. It’s also undefined if it tries to modify count. But what can be an operation? An operation is a function or function object to set the new contents of the string and it takes two parameters. The first one is the pointer to the first character in the string’s storage and the second one is the same as count, the maximal possible new size of the string. It should return the actual new length of the string. You have to pay attention that this operation doesn’t modify the maximum size, does not try to set a longer string and doesn’t modify the address of the first character either. That would mean undefined behaviour. If correctly used, it’ll help add some new content or rewrite the existing one. Or you can actually remove content. To illustrate this latter example, let’s have a look at the second example of the original documentation. 1 2 3 4 5 6 std::string s { &quot;Food: &quot; }; s.resize_and_overwrite(10, [](char* buf, int n) { return std::find(buf, buf + n, &#39;:&#39;) - buf; }); std::cout &lt;&lt; &quot;2. &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\n&#39;; // 2. &quot;Food&quot; Even though s is resized to 10, the operation will return the position of : in the string meaning that it will be truncated from that point. A new tool to help us write performant string handling code. Require span &amp; basic_string_view to be TriviallyCopyable P2251R1 updates the requirements the standard has for std::span and std::string_view. Starting from C++23 they must satisfy the TriviallyCopyable concepts. As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a size_t and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so. Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing. : string-stream with std::span-based buffer C++23 is introducing the &lt;spanstream&gt; header. Streams are an old part of the C++ standard library. Nowadays stringtreams are widely used. Strings (and vectors) store data outside of themselves. When the data to be stored grows, the storage and the already stored data might be automatically and dynamically reallocated. This is often acceptable, but when it’s not, we need another option. &lt;spanstream&gt; is going to provide such an option, they provide fixed buffers. You have to take care of the allocation when you create your stream, but you don’t have to worry about the costly reallocation of the underlying buffer once it’s exhausted. When I wrote that you have to take care of the bugger allocation, I really meant it. The buffer is not owned by the stream object, its life has to be managed by the programmer. Conclusion I hope you enjoyed this article and you also got excited by all these various string/string_view related features that C++23 is going to bring us. What are you waiting for the most? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this blog post, let’s collect a couple of changes that are going to be shipped with C++23 and are all related to strings or string_views. std::string and std::string_view have contains One of C++20’s useful addition to maps were the contains member function. We could replace the cumbersome to read query of myMap.find(key) != myMap.end() with the very easy to understand myMap.contains(key). With C++23, std::string and std::string_view will have similar capabilities. You can call contains() with either a string or a character and it will return true or false depending on whether the queried string or string_view contains the input parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; int main() { std::string s{&quot;there is a needle in the haystack&quot;}; std::string_view sv{&quot;acdef&quot;}; if (s.contains(&quot;needle&quot;)) { std::cout &lt;&lt; &quot;we found a needle in: &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\n&#39;; } if (!sv.contains(&#39;b&#39;)) { std::cout &lt;&lt; &quot;we did not find a &#39;b&#39; in: &quot; &lt;&lt; std::quoted(sv) &lt;&lt; &#39;\n&#39;; } } /* we found a needle in: &quot;there is a needle in the haystack&quot; we did not find a &#39;b&#39; in: &quot;acdef&quot; */ No more undefined behaviour due to construction from nullptr In an earlier newsletter, we discussed that initializing a string from a nullptr is undefined behaviour. In practice, this might happen when you convert a const char * to a string. What happens then? It depends on the compiler, gcc for example, throws a runtime exception. Thanks to P2166R1, this is not something to worry about. Instead of undefined behaviour, the constructor and assignment operator overloaded with nullptr_t are deleted and therefore compilation fails when you attempt to construct a new string out of a nullptr. 1 2 3 4 5 6 7 8 9 std::string s(nullptr); /* &lt;source&gt;:18:26: error: use of deleted function &#39;std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string(std::nullptr_t) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Alloc = std::allocator&lt;char&gt;; std::nullptr_t = std::nullptr_t]&#39; 18 | std::string s(nullptr); | ^ /opt/compiler-explorer/gcc-12.1.0/include/c++/12.1.0/bits/basic_string.h:734:7: note: declared here 734 | basic_string(nullptr_t) = delete; | ^~~~~~~~~~~~ */ While this change is good and points in a good direction, not all of our problems disappear with nullptrs. Taking a nullptr and a size in the constructor (e.g. std::string s(nullptr, 3)) is still valid and remains undefined behaviour. These changes are also valid for string_view. Build std::string_view from ranges With C++23, our favourite string_view doesn’t only loses a constructor (the overload with a nullptr gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly. So far, if we wanted to create a string_view out of a “range”, we had to invoke the constructor with a begin and and end iterators: std::string_view sv(myRange.begin(), myRange.end());. Now we’ll be able to directly construct a string_view based on a range: std::string_view sv(myRange);. basic_string::resize_and_overwrite() One of the main reasons to use C++ is its high performance. An area where we often use the language in a non-efficient way is string handling. C++23 will bring us another string member function that will help us to handle strings in a more performant way. std::string::resize_and_overwrite() takes two parameters, a count and an operation and does the following (while returns nothing): if the count is smaller or equal to the size() ofthe string, it erases the last size() - count elements if count is larger than size(), appends n - size() default-initialized elements it also invokes erase(begin() + op(data(), count), end()). In other words, resize_and_overwrite() will make sure that the given string has continuous storage containing count + 1 characters. If op() throws, the behaviour is undefined. It’s also undefined if it tries to modify count. But what can be an operation? An operation is a function or function object to set the new contents of the string and it takes two parameters. The first one is the pointer to the first character in the string’s storage and the second one is the same as count, the maximal possible new size of the string. It should return the actual new length of the string. You have to pay attention that this operation doesn’t modify the maximum size, does not try to set a longer string and doesn’t modify the address of the first character either. That would mean undefined behaviour. If correctly used, it’ll help add some new content or rewrite the existing one. Or you can actually remove content. To illustrate this latter example, let’s have a look at the second example of the original documentation. 1 2 3 4 5 6 std::string s { &quot;Food: &quot; }; s.resize_and_overwrite(10, [](char* buf, int n) { return std::find(buf, buf + n, &#39;:&#39;) - buf; }); std::cout &lt;&lt; &quot;2. &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\n&#39;; // 2. &quot;Food&quot; Even though s is resized to 10, the operation will return the position of : in the string meaning that it will be truncated from that point. A new tool to help us write performant string handling code. Require span &amp; basic_string_view to be TriviallyCopyable P2251R1 updates the requirements the standard has for std::span and std::string_view. Starting from C++23 they must satisfy the TriviallyCopyable concepts. As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a size_t and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so. Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing. : string-stream with std::span-based buffer C++23 is introducing the &lt;spanstream&gt; header. Streams are an old part of the C++ standard library. Nowadays stringtreams are widely used. Strings (and vectors) store data outside of themselves. When the data to be stored grows, the storage and the already stored data might be automatically and dynamically reallocated. This is often acceptable, but when it’s not, we need another option. &lt;spanstream&gt; is going to provide such an option, they provide fixed buffers. You have to take care of the allocation when you create your stream, but you don’t have to worry about the costly reallocation of the underlying buffer once it’s exhausted. When I wrote that you have to take care of the bugger allocation, I really meant it. The buffer is not owned by the stream object, its life has to be managed by the programmer. Conclusion I hope you enjoyed this article and you also got excited by all these various string/string_view related features that C++23 is going to bring us. What are you waiting for the most? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-07-20T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="6 C++23 features improving string and string_view" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-29T06:44:54+01:00","datePublished":"2022-07-20T00:00:00+02:00","description":"In this blog post, let’s collect a couple of changes that are going to be shipped with C++23 and are all related to strings or string_views. std::string and std::string_view have contains One of C++20’s useful addition to maps were the contains member function. We could replace the cumbersome to read query of myMap.find(key) != myMap.end() with the very easy to understand myMap.contains(key). With C++23, std::string and std::string_view will have similar capabilities. You can call contains() with either a string or a character and it will return true or false depending on whether the queried string or string_view contains the input parameter. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;string&gt; #include &lt;iomanip&gt; int main() { std::string s{&quot;there is a needle in the haystack&quot;}; std::string_view sv{&quot;acdef&quot;}; if (s.contains(&quot;needle&quot;)) { std::cout &lt;&lt; &quot;we found a needle in: &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\\n&#39;; } if (!sv.contains(&#39;b&#39;)) { std::cout &lt;&lt; &quot;we did not find a &#39;b&#39; in: &quot; &lt;&lt; std::quoted(sv) &lt;&lt; &#39;\\n&#39;; } } /* we found a needle in: &quot;there is a needle in the haystack&quot; we did not find a &#39;b&#39; in: &quot;acdef&quot; */ No more undefined behaviour due to construction from nullptr In an earlier newsletter, we discussed that initializing a string from a nullptr is undefined behaviour. In practice, this might happen when you convert a const char * to a string. What happens then? It depends on the compiler, gcc for example, throws a runtime exception. Thanks to P2166R1, this is not something to worry about. Instead of undefined behaviour, the constructor and assignment operator overloaded with nullptr_t are deleted and therefore compilation fails when you attempt to construct a new string out of a nullptr. 1 2 3 4 5 6 7 8 9 std::string s(nullptr); /* &lt;source&gt;:18:26: error: use of deleted function &#39;std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string(std::nullptr_t) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Alloc = std::allocator&lt;char&gt;; std::nullptr_t = std::nullptr_t]&#39; 18 | std::string s(nullptr); | ^ /opt/compiler-explorer/gcc-12.1.0/include/c++/12.1.0/bits/basic_string.h:734:7: note: declared here 734 | basic_string(nullptr_t) = delete; | ^~~~~~~~~~~~ */ While this change is good and points in a good direction, not all of our problems disappear with nullptrs. Taking a nullptr and a size in the constructor (e.g. std::string s(nullptr, 3)) is still valid and remains undefined behaviour. These changes are also valid for string_view. Build std::string_view from ranges With C++23, our favourite string_view doesn’t only loses a constructor (the overload with a nullptr gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly. So far, if we wanted to create a string_view out of a “range”, we had to invoke the constructor with a begin and and end iterators: std::string_view sv(myRange.begin(), myRange.end());. Now we’ll be able to directly construct a string_view based on a range: std::string_view sv(myRange);. basic_string::resize_and_overwrite() One of the main reasons to use C++ is its high performance. An area where we often use the language in a non-efficient way is string handling. C++23 will bring us another string member function that will help us to handle strings in a more performant way. std::string::resize_and_overwrite() takes two parameters, a count and an operation and does the following (while returns nothing): if the count is smaller or equal to the size() ofthe string, it erases the last size() - count elements if count is larger than size(), appends n - size() default-initialized elements it also invokes erase(begin() + op(data(), count), end()). In other words, resize_and_overwrite() will make sure that the given string has continuous storage containing count + 1 characters. If op() throws, the behaviour is undefined. It’s also undefined if it tries to modify count. But what can be an operation? An operation is a function or function object to set the new contents of the string and it takes two parameters. The first one is the pointer to the first character in the string’s storage and the second one is the same as count, the maximal possible new size of the string. It should return the actual new length of the string. You have to pay attention that this operation doesn’t modify the maximum size, does not try to set a longer string and doesn’t modify the address of the first character either. That would mean undefined behaviour. If correctly used, it’ll help add some new content or rewrite the existing one. Or you can actually remove content. To illustrate this latter example, let’s have a look at the second example of the original documentation. 1 2 3 4 5 6 std::string s { &quot;Food: &quot; }; s.resize_and_overwrite(10, [](char* buf, int n) { return std::find(buf, buf + n, &#39;:&#39;) - buf; }); std::cout &lt;&lt; &quot;2. &quot; &lt;&lt; std::quoted(s) &lt;&lt; &#39;\\n&#39;; // 2. &quot;Food&quot; Even though s is resized to 10, the operation will return the position of : in the string meaning that it will be truncated from that point. A new tool to help us write performant string handling code. Require span &amp; basic_string_view to be TriviallyCopyable P2251R1 updates the requirements the standard has for std::span and std::string_view. Starting from C++23 they must satisfy the TriviallyCopyable concepts. As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a size_t and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so. Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing. : string-stream with std::span-based buffer C++23 is introducing the &lt;spanstream&gt; header. Streams are an old part of the C++ standard library. Nowadays stringtreams are widely used. Strings (and vectors) store data outside of themselves. When the data to be stored grows, the storage and the already stored data might be automatically and dynamically reallocated. This is often acceptable, but when it’s not, we need another option. &lt;spanstream&gt; is going to provide such an option, they provide fixed buffers. You have to take care of the allocation when you create your stream, but you don’t have to worry about the costly reallocation of the underlying buffer once it’s exhausted. When I wrote that you have to take care of the bugger allocation, I really meant it. The buffer is not owned by the stream object, its life has to be managed by the programmer. Conclusion I hope you enjoyed this article and you also got excited by all these various string/string_view related features that C++23 is going to bring us. What are you waiting for the most? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"6 C++23 features improving string and string_view","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23"},"url":"https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23"}</script><title>6 C++23 features improving string and string_view | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/20"> 20 </a> </span> <span>6 C++23 features improving string and string_view</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>6 C++23 features improving string and string_view</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 20, 2022, 12:00 AM +0200" prep="on" > Jul 20, 2022 <i class="unloaded">2022-07-20T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Nov 29, 2024, 6:44 AM +0100" prefix="Updated " > Nov 29, 2024 <i class="unloaded">2024-11-29T06:44:54+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1132 words">6 min</span></div></div><div class="post-content"><p>In this blog post, let’s collect a couple of changes that are going to be shipped with C++23 and are all related to <code class="language-plaintext highlighter-rouge">string</code>s or <code class="language-plaintext highlighter-rouge">string_view</code>s.</p><h2 id="stdstring-and-stdstring_view-have-contains"><code class="language-plaintext highlighter-rouge">std::string</code> and <code class="language-plaintext highlighter-rouge">std::string_view</code> have <code class="language-plaintext highlighter-rouge">contains</code></h2><p>One of C++20’s useful addition to maps were the <code class="language-plaintext highlighter-rouge">contains</code> member function. We could replace the cumbersome to read query of <code class="language-plaintext highlighter-rouge">myMap.find(key) != myMap.end()</code> with the very easy to understand <code class="language-plaintext highlighter-rouge">myMap.contains(key)</code>. With C++23, <code class="language-plaintext highlighter-rouge">std::string</code> and <code class="language-plaintext highlighter-rouge">std::string_view</code> will have similar capabilities. You can call <code class="language-plaintext highlighter-rouge">contains()</code> with either a string or a character and it will return <code class="language-plaintext highlighter-rouge">true</code> or <code class="language-plaintext highlighter-rouge">false</code> depending on whether the queried <code class="language-plaintext highlighter-rouge">string</code> or <code class="language-plaintext highlighter-rouge">string_view</code> contains the input parameter.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iomanip&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="s">"there is a needle in the haystack"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">sv</span><span class="p">{</span><span class="s">"acdef"</span><span class="p">};</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">s</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="s">"needle"</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"we found a needle in: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">sv</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="sc">'b'</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"we did not find a 'b' in: "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">sv</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
we found a needle in: "there is a needle in the haystack"
we did not find a 'b' in: "acdef"
*/</span>
</pre></table></code></div></div><h2 id="no-more-undefined-behaviour-due-to-construction-from-nullptr">No more undefined behaviour due to construction from <code class="language-plaintext highlighter-rouge">nullptr</code></h2><p>In an earlier newsletter, we discussed that initializing a <code class="language-plaintext highlighter-rouge">string</code> from a <code class="language-plaintext highlighter-rouge">nullptr</code> is undefined behaviour. In practice, this might happen when you convert a <code class="language-plaintext highlighter-rouge">const char *</code> to a <code class="language-plaintext highlighter-rouge">string</code>. What happens then? It depends on the compiler, <code class="language-plaintext highlighter-rouge">gcc</code> for example, throws a runtime exception.</p><p>Thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2166r1.html">P2166R1</a>, this is not something to worry about.</p><p>Instead of undefined behaviour, the constructor and assignment operator overloaded with <code class="language-plaintext highlighter-rouge">nullptr_t</code> are deleted and therefore compilation fails when you attempt to construct a new <code class="language-plaintext highlighter-rouge">string</code> out of a <code class="language-plaintext highlighter-rouge">nullptr</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="nf">s</span><span class="p">(</span><span class="nb">nullptr</span><span class="p">);</span>
<span class="cm">/*
&lt;source&gt;:18:26: error: use of deleted function 'std::__cxx11::basic_string&lt;_CharT, _Traits, _Alloc&gt;::basic_string(std::nullptr_t) [with _CharT = char; _Traits = std::char_traits&lt;char&gt;; _Alloc = std::allocator&lt;char&gt;; std::nullptr_t = std::nullptr_t]'
   18 |     std::string s(nullptr);
      |                          ^
/opt/compiler-explorer/gcc-12.1.0/include/c++/12.1.0/bits/basic_string.h:734:7: note: declared here
  734 |       basic_string(nullptr_t) = delete;
      |       ^~~~~~~~~~~~
*/</span>
</pre></table></code></div></div><p>While this change is good and points in a good direction, not all of our problems disappear with <code class="language-plaintext highlighter-rouge">nullptr</code>s. Taking a <code class="language-plaintext highlighter-rouge">nullptr</code> and a size in the constructor (e.g. <code class="language-plaintext highlighter-rouge">std::string s(nullptr, 3)</code>) is still valid and remains undefined behaviour.</p><p>These changes are also valid for <code class="language-plaintext highlighter-rouge">string_view</code>.</p><h2 id="build-stdstring_view-from-ranges">Build <code class="language-plaintext highlighter-rouge">std::string_view</code> from ranges</h2><p>With C++23, our favourite <code class="language-plaintext highlighter-rouge">string_view</code> doesn’t only loses a constructor (the overload with a <code class="language-plaintext highlighter-rouge">nullptr</code> gets deleted), but also receives a new one. Soon, we’ll be able to construct one out of a range directly.</p><p>So far, if we wanted to create a <code class="language-plaintext highlighter-rouge">string_view</code> out of a <em>“range”</em>, we had to invoke the constructor with a <code class="language-plaintext highlighter-rouge">begin</code> and and <code class="language-plaintext highlighter-rouge">end</code> iterators: <code class="language-plaintext highlighter-rouge">std::string_view sv(myRange.begin(), myRange.end());</code>. Now we’ll be able to directly construct a <code class="language-plaintext highlighter-rouge">string_view</code> based on a range: <code class="language-plaintext highlighter-rouge">std::string_view sv(myRange);</code>.</p><h2 id="basic_stringresize_and_overwrite"><code class="language-plaintext highlighter-rouge">basic_string::resize_and_overwrite()</code></h2><p>One of the main reasons to use C++ is its high performance. An area where we often use the language in a non-efficient way is string handling. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1072r10.html">C++23 will bring us another <code class="language-plaintext highlighter-rouge">string</code> member function</a> that will help us to handle strings in a more performant way.</p><p><a href="https://en.cppreference.com/w/cpp/string/basic_string/resize_and_overwrite"><code class="language-plaintext highlighter-rouge">std::string::resize_and_overwrite()</code></a> takes two parameters, a count and an operation and does the following (while returns nothing):</p><ul><li>if the <code class="language-plaintext highlighter-rouge">count</code> is smaller or equal to the <code class="language-plaintext highlighter-rouge">size()</code> ofthe string, it erases the last <code class="language-plaintext highlighter-rouge">size() - count</code> elements<li>if <code class="language-plaintext highlighter-rouge">count</code> is larger than <code class="language-plaintext highlighter-rouge">size()</code>, appends <code class="language-plaintext highlighter-rouge">n - size()</code> default-initialized elements<li>it also invokes <code class="language-plaintext highlighter-rouge">erase(begin() + op(data(), count), end())</code>.</ul><p>In other words, <code class="language-plaintext highlighter-rouge">resize_and_overwrite()</code> will make sure that the given string has continuous storage containing <code class="language-plaintext highlighter-rouge">count + 1</code> characters.</p><p>If <code class="language-plaintext highlighter-rouge">op()</code> throws, the behaviour is undefined. It’s also undefined if it tries to modify <code class="language-plaintext highlighter-rouge">count</code>.</p><p>But what can be an operation?</p><p>An operation is a function or function object to set the new contents of the string and it takes two parameters. The first one is the pointer to the first character in the string’s storage and the second one is the same as <code class="language-plaintext highlighter-rouge">count</code>, the maximal possible new size of the string. It should return the actual new length of the string.</p><p>You have to pay attention that this operation doesn’t modify the maximum size, does not try to set a longer string and doesn’t modify the address of the first character either. That would mean undefined behaviour.</p><p>If correctly used, it’ll help add some new content or rewrite the existing one. Or you can actually remove content. To illustrate this latter example, let’s have a look at the second example of the original documentation.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span> <span class="p">{</span> <span class="s">"Food: "</span> <span class="p">};</span>
<span class="n">s</span><span class="p">.</span><span class="n">resize_and_overwrite</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="p">[](</span><span class="kt">char</span><span class="o">*</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="n">buf</span> <span class="o">+</span> <span class="n">n</span><span class="p">,</span> <span class="sc">':'</span><span class="p">)</span> <span class="o">-</span> <span class="n">buf</span><span class="p">;</span>
<span class="p">});</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"2. "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">quoted</span><span class="p">(</span><span class="n">s</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="c1">// 2. "Food"</span>
</pre></table></code></div></div><p>Even though <code class="language-plaintext highlighter-rouge">s</code> is resized to 10, the operation will return the position of <code class="language-plaintext highlighter-rouge">:</code> in the string meaning that it will be truncated from that point.</p><p>A new tool to help us write performant string handling code.</p><h2 id="require-span--basic_string_view-to-be-triviallycopyable">Require span &amp; basic_string_view to be TriviallyCopyable</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2251r1.pdf">P2251R1</a> updates the requirements the standard has for <code class="language-plaintext highlighter-rouge">std::span</code> and <code class="language-plaintext highlighter-rouge">std::string_view</code>. Starting from C++23 they must satisfy the <code class="language-plaintext highlighter-rouge">TriviallyCopyable</code> concepts.</p><p>As both of these objects already have default copy assignment operators and constructs and also destructors and besides they only expose a <code class="language-plaintext highlighter-rouge">size_t</code> and a raw pointer, it is implied that these types can be trivially copyable and in fact, the major compilers already implemented them as so.</p><p>Ensuring this trait for the future makes sure developers can continue depending on these characteristics and less courageous developers can start using them as such for example in heterogeneous computing.</p><h2 id="--string-stream-with-stdspan-based-buffer"><spanstream> : string-stream with std::span-based buffer</spanstream></h2><p>C++23 is introducing <a href="https://en.cppreference.com/w/cpp/header/spanstream">the <code class="language-plaintext highlighter-rouge">&lt;spanstream&gt;</code> header</a>. Streams are an old part of the C++ standard library. Nowadays <em>stringtreams</em> are widely used. Strings (and vectors) store data <em>outside</em> of themselves. When the data to be stored grows, the storage and the already stored data might be automatically and dynamically reallocated. This is often acceptable, but when it’s not, we need another option.</p><p><code class="language-plaintext highlighter-rouge">&lt;spanstream&gt;</code> is going to provide such an option, they provide fixed buffers. You have to take care of the allocation when you create your stream, but you don’t have to worry about the costly reallocation of the underlying buffer once it’s exhausted. When I wrote that you have to take care of the bugger allocation, I really meant it. The buffer is not owned by the stream object, its life has to be managed by the programmer.</p><h2 id="conclusion">Conclusion</h2><p>I hope you enjoyed this article and you also got excited by all these various <code class="language-plaintext highlighter-rouge">string</code>/<code class="language-plaintext highlighter-rouge">string_view</code> related features that C++23 is going to bring us. What are you waiting for the most?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/string/" class="post-tag no-text-decoration" >string</a> <a href="/tags/string-view/" class="post-tag no-text-decoration" >string_view</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=6 C++23 features improving string and string_view - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=6 C++23 features improving string and string_view - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=6 C++23 features improving string and string_view - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=6 C++23 features improving string and string_view - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/02/07/cpp23-small-changes-2"><div class="card-body"> <span class="timeago small" > Feb 7, 2024 <i class="unloaded">2024-02-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: More small changes</h3><div class="text-muted small"><p> In this post, we continue discovering the changes introduced by C++23. We are going to look into three (and a half) small changes, each affecting constructors of some standard library types. We’re ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/07/13/why_to_use_string_views"><div class="card-body"> <span class="timeago small" > Jul 13, 2022 <i class="unloaded">2022-07-13T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What are string_views and why should we use them?</h3><div class="text-muted small"><p> std::string_view has been introduced by C++17 and its purpose is to provide read-only access to character sequences. It potentially replaces const string&amp; parameters and offers a significant pe...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/07/13/why_to_use_string_views" class="btn btn-outline-primary" prompt="Older"><p>What are string_views and why should we use them?</p></a> <a href="/blog/2022/07/23/hands-on-design-patterns-by-fedor-pikus" class="btn btn-outline-primary" prompt="Newer"><p>Hands-On Design Patterns with C++ by Fedor Pikus</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = '6 C++23 features improving string and string_view'; this.page.url = 'https://www.sandordargo.com/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23'; this.page.identifier = '/blog/2022/07/20/6-features-improving-string-string_view-in-cpp23'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
