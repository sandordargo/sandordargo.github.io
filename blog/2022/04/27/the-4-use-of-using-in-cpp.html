<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The 4 use of using in C++" /><meta property="og:locale" content="en_US" /><meta name="description" content="When I write code I don’t only want to write code that is correct. I also want to write code that is understandable, and maintainable. I want to deliver code that is easy to read not only for the compiler but also for other human beings. After all, humans will read my code more frequently than compilers. I have been thinking what are the single most important keywords that help us write readable code. Probably this question doesn’t make much sense, but const and using are definitely among these. We already discussed const a lot, this time it’s time to see how using using can improve our code. We are going to review the 4 ways we can use it: type aliasing with using introducing complete namespaces with using-directive introducing members of another namespace with using-declaration importing class members with using-declaration Aliasing In old C++ we could use typedef to give another name, to give an alias for our types. Sometimes you might want to use it instead of strong typing, just to benefit from more meaningful names like int. 1 typedef int Horsepower; Other times you want to shorten long types for easier usage: 1 typedef std::vector&lt;std::string&gt;::iterator Iterator; Since C++11 we can use using instead of typedef to achieve the same results. 1 2 using Horsepower = int; using Iterator = std::vector&lt;std::string&gt;::iterator; Why would you use using over the good old typedef? Just read the above statements! Exactly like the T.43 core guideline says, it’s more readable! The keyword has a very clear meaining, then the name comes first and the old comes after a =. Besides, using can be used more generally. It can be used for template aliases where typedef would lead to a compilation error. 1 2 3 4 5 template&lt;typename T&gt; typedef std::map&lt;int, T&gt; MapT; // error template&lt;typename T&gt; using MapT = std::map&lt;int, T&gt;; // OK Using-directive in namespace and block scope You’ve probably seen many code examples that right after the #include statements contain the line using namespace std. You’ve probably seen lots of such application code. You’ve probably been told that it’s bad. It’s particularly bad if you do in at the global scope in a header file, just like [SF.7 from the Core Guidelines says]: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // bad.h #include &lt;iostream&gt; using namespace std; // bad // user.cpp #include &quot;bad.h&quot; // some function that happens to be named copy bool copy(/*... some parameters ...*/); int main() { // now overloads local ::copy and std::copy, could be ambiguous copy(/*...*/); } In my opinion, even the fact that as a reader you cannot be sure where a function comes from is bad. This is a simplistic example, but when you use using namespace in a long .cpp file it’s hard to keep track of where certain objects come from. I prefer having using-declarations instead and I also often introduce alias namespaces. 1 2 3 4 5 6 7 8 9 10 11 12 //some.h #include &lt;other.h&gt; using mcs = mynamespace::component::subcomponent; msc::Class foo(); //some.cpp msc::Class foo() { using msc::AnotherClass; AnotherClass bar; // ... } As such, I don’t pollute the global namespace. What you have to keep in mind is that when you introduce a using-directive into a header file at the global namespace header, you don’t just mess things up in the current scope. If you include the header file in other files, you’ll also bring the inclusion of all those introduced symbols. If you introduce different header files with different global levels using-directives, the situation becomes even worse and the results of name lookup might depend on the order of inclusion. To avoid all such problems, just follow SF.7 and don’t write using namespace at global scope in a header file. Using-declaration in namespace and block scope While the using-directive brings all the symbols of a namespace into the current scope, a using-declaration will bring only one item! 1 2 using std::string; string foo{&quot;bar&quot;}; In the above example, we just demonstrated how it works. After using std::string, we can refer to std::string without mentioning the std namespace. It’s still something not to overuse! A using-declaration may also expand an overload set. It’s less dangerous to use it at a file scope than having a using-directive at the same scope, but risks still remain. Starting from C++20, you can also introduce scoped enumerators into a namespace of block scope! 1 2 3 4 5 6 enum class Color { red, green, blue }; class MyClass { using Color::red; Color c = red; // This is OK from C++20 }; In fact, it would also work with the old-style unscoped enum, but why would we do that? Importing base class members with using-declaration With using-declaration, you can introduce base class members - including constructors - into derived classes. It’s an easy way of exposing protected base class members as public in the derived class. It can be used both for functions and variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; class Base { protected: void foo() { std::cout &lt;&lt; &quot;Base::foo()\n&quot;; } int m_i = 42; }; class Derived : public Base { public: using Base::foo; using Base::m_i; }; int main() { Derived d; d.foo(); std::cout &lt;&lt; d.m_i &lt;&lt; &#39;\n&#39;; } /* Base::foo() 42 */ If you try to modify the above example and remove any of the two using-declarations, you’ll see the compilation failing. If the derived class already has a member with the same name, the compilation will not. The imported symbol from the base class will be hidden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; class Base { protected: void foo() { std::cout &lt;&lt; &quot;Base::foo()\n&quot;; } }; class Derived : public Base { public: using Base::foo; void foo() { std::cout &lt;&lt; &quot;Derived::foo()\n&quot;; } }; int main() { Derived d; d.foo(); } /* Derived::foo() */ I find this technique really useful for unit testing. When you’re writing a mock by hand, you often have to expose protected member functions from the base class, from the class that you are about to mock. One way of doing it is forwarding the call. Hopefully, the function’s name in the mock is not changed, but I’ve seen it a couple of times. It really puts an extra burden on the maintainers when they realize that there is a better option. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class ClassUnderTest { public: virtual void testMe() { } virtual void testMeToo() { } }; class MockClassUnderTest : public ClassUnderTest { public: void testMe() override { ClassUnderTest::testMe(); } void mockedTestMeToo() { ClassUnderTest::testMeToo(); } }; Apart from tying a lot of unnecessary code, the problem above is that if the parameter list of testMe or testMeToo changes, you’ll also have to update MockClassUnderTest. You can get rid of that need by using using. 1 2 3 4 5 class MockClassUnderTest : public ClassUnderTest { public: using ClassUnderTest::testMe; using ClassUnderTest::testMeToo; }; Now we have less code and it’s more understandable what’s happening. As a bonus, even the maintenance is simplified. Conclusion In this article, we discussed the 4 different ways that we can use the using keyword. It’s the right way to create aliases and import base class members in derived classes. At the same time, they can be also used to introduce whole namespaces into the current scope which can be particularly dangerous. Last but not least, using can also introduce single types to the current scope which is a less dangerous option than introducing whole namespaces, still, it should be used with care. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="When I write code I don’t only want to write code that is correct. I also want to write code that is understandable, and maintainable. I want to deliver code that is easy to read not only for the compiler but also for other human beings. After all, humans will read my code more frequently than compilers. I have been thinking what are the single most important keywords that help us write readable code. Probably this question doesn’t make much sense, but const and using are definitely among these. We already discussed const a lot, this time it’s time to see how using using can improve our code. We are going to review the 4 ways we can use it: type aliasing with using introducing complete namespaces with using-directive introducing members of another namespace with using-declaration importing class members with using-declaration Aliasing In old C++ we could use typedef to give another name, to give an alias for our types. Sometimes you might want to use it instead of strong typing, just to benefit from more meaningful names like int. 1 typedef int Horsepower; Other times you want to shorten long types for easier usage: 1 typedef std::vector&lt;std::string&gt;::iterator Iterator; Since C++11 we can use using instead of typedef to achieve the same results. 1 2 using Horsepower = int; using Iterator = std::vector&lt;std::string&gt;::iterator; Why would you use using over the good old typedef? Just read the above statements! Exactly like the T.43 core guideline says, it’s more readable! The keyword has a very clear meaining, then the name comes first and the old comes after a =. Besides, using can be used more generally. It can be used for template aliases where typedef would lead to a compilation error. 1 2 3 4 5 template&lt;typename T&gt; typedef std::map&lt;int, T&gt; MapT; // error template&lt;typename T&gt; using MapT = std::map&lt;int, T&gt;; // OK Using-directive in namespace and block scope You’ve probably seen many code examples that right after the #include statements contain the line using namespace std. You’ve probably seen lots of such application code. You’ve probably been told that it’s bad. It’s particularly bad if you do in at the global scope in a header file, just like [SF.7 from the Core Guidelines says]: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // bad.h #include &lt;iostream&gt; using namespace std; // bad // user.cpp #include &quot;bad.h&quot; // some function that happens to be named copy bool copy(/*... some parameters ...*/); int main() { // now overloads local ::copy and std::copy, could be ambiguous copy(/*...*/); } In my opinion, even the fact that as a reader you cannot be sure where a function comes from is bad. This is a simplistic example, but when you use using namespace in a long .cpp file it’s hard to keep track of where certain objects come from. I prefer having using-declarations instead and I also often introduce alias namespaces. 1 2 3 4 5 6 7 8 9 10 11 12 //some.h #include &lt;other.h&gt; using mcs = mynamespace::component::subcomponent; msc::Class foo(); //some.cpp msc::Class foo() { using msc::AnotherClass; AnotherClass bar; // ... } As such, I don’t pollute the global namespace. What you have to keep in mind is that when you introduce a using-directive into a header file at the global namespace header, you don’t just mess things up in the current scope. If you include the header file in other files, you’ll also bring the inclusion of all those introduced symbols. If you introduce different header files with different global levels using-directives, the situation becomes even worse and the results of name lookup might depend on the order of inclusion. To avoid all such problems, just follow SF.7 and don’t write using namespace at global scope in a header file. Using-declaration in namespace and block scope While the using-directive brings all the symbols of a namespace into the current scope, a using-declaration will bring only one item! 1 2 using std::string; string foo{&quot;bar&quot;}; In the above example, we just demonstrated how it works. After using std::string, we can refer to std::string without mentioning the std namespace. It’s still something not to overuse! A using-declaration may also expand an overload set. It’s less dangerous to use it at a file scope than having a using-directive at the same scope, but risks still remain. Starting from C++20, you can also introduce scoped enumerators into a namespace of block scope! 1 2 3 4 5 6 enum class Color { red, green, blue }; class MyClass { using Color::red; Color c = red; // This is OK from C++20 }; In fact, it would also work with the old-style unscoped enum, but why would we do that? Importing base class members with using-declaration With using-declaration, you can introduce base class members - including constructors - into derived classes. It’s an easy way of exposing protected base class members as public in the derived class. It can be used both for functions and variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; class Base { protected: void foo() { std::cout &lt;&lt; &quot;Base::foo()\n&quot;; } int m_i = 42; }; class Derived : public Base { public: using Base::foo; using Base::m_i; }; int main() { Derived d; d.foo(); std::cout &lt;&lt; d.m_i &lt;&lt; &#39;\n&#39;; } /* Base::foo() 42 */ If you try to modify the above example and remove any of the two using-declarations, you’ll see the compilation failing. If the derived class already has a member with the same name, the compilation will not. The imported symbol from the base class will be hidden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; class Base { protected: void foo() { std::cout &lt;&lt; &quot;Base::foo()\n&quot;; } }; class Derived : public Base { public: using Base::foo; void foo() { std::cout &lt;&lt; &quot;Derived::foo()\n&quot;; } }; int main() { Derived d; d.foo(); } /* Derived::foo() */ I find this technique really useful for unit testing. When you’re writing a mock by hand, you often have to expose protected member functions from the base class, from the class that you are about to mock. One way of doing it is forwarding the call. Hopefully, the function’s name in the mock is not changed, but I’ve seen it a couple of times. It really puts an extra burden on the maintainers when they realize that there is a better option. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class ClassUnderTest { public: virtual void testMe() { } virtual void testMeToo() { } }; class MockClassUnderTest : public ClassUnderTest { public: void testMe() override { ClassUnderTest::testMe(); } void mockedTestMeToo() { ClassUnderTest::testMeToo(); } }; Apart from tying a lot of unnecessary code, the problem above is that if the parameter list of testMe or testMeToo changes, you’ll also have to update MockClassUnderTest. You can get rid of that need by using using. 1 2 3 4 5 class MockClassUnderTest : public ClassUnderTest { public: using ClassUnderTest::testMe; using ClassUnderTest::testMeToo; }; Now we have less code and it’s more understandable what’s happening. As a bonus, even the maintenance is simplified. Conclusion In this article, we discussed the 4 different ways that we can use the using keyword. It’s the right way to create aliases and import base class members in derived classes. At the same time, they can be also used to introduce whole namespaces into the current scope which can be particularly dangerous. Last but not least, using can also introduce single types to the current scope which is a less dangerous option than introducing whole namespaces, still, it should be used with care. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-27T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The 4 use of using in C++" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-09-20T23:07:27+02:00","datePublished":"2022-04-27T00:00:00+02:00","description":"When I write code I don’t only want to write code that is correct. I also want to write code that is understandable, and maintainable. I want to deliver code that is easy to read not only for the compiler but also for other human beings. After all, humans will read my code more frequently than compilers. I have been thinking what are the single most important keywords that help us write readable code. Probably this question doesn’t make much sense, but const and using are definitely among these. We already discussed const a lot, this time it’s time to see how using using can improve our code. We are going to review the 4 ways we can use it: type aliasing with using introducing complete namespaces with using-directive introducing members of another namespace with using-declaration importing class members with using-declaration Aliasing In old C++ we could use typedef to give another name, to give an alias for our types. Sometimes you might want to use it instead of strong typing, just to benefit from more meaningful names like int. 1 typedef int Horsepower; Other times you want to shorten long types for easier usage: 1 typedef std::vector&lt;std::string&gt;::iterator Iterator; Since C++11 we can use using instead of typedef to achieve the same results. 1 2 using Horsepower = int; using Iterator = std::vector&lt;std::string&gt;::iterator; Why would you use using over the good old typedef? Just read the above statements! Exactly like the T.43 core guideline says, it’s more readable! The keyword has a very clear meaining, then the name comes first and the old comes after a =. Besides, using can be used more generally. It can be used for template aliases where typedef would lead to a compilation error. 1 2 3 4 5 template&lt;typename T&gt; typedef std::map&lt;int, T&gt; MapT; // error template&lt;typename T&gt; using MapT = std::map&lt;int, T&gt;; // OK Using-directive in namespace and block scope You’ve probably seen many code examples that right after the #include statements contain the line using namespace std. You’ve probably seen lots of such application code. You’ve probably been told that it’s bad. It’s particularly bad if you do in at the global scope in a header file, just like [SF.7 from the Core Guidelines says]: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // bad.h #include &lt;iostream&gt; using namespace std; // bad // user.cpp #include &quot;bad.h&quot; // some function that happens to be named copy bool copy(/*... some parameters ...*/); int main() { // now overloads local ::copy and std::copy, could be ambiguous copy(/*...*/); } In my opinion, even the fact that as a reader you cannot be sure where a function comes from is bad. This is a simplistic example, but when you use using namespace in a long .cpp file it’s hard to keep track of where certain objects come from. I prefer having using-declarations instead and I also often introduce alias namespaces. 1 2 3 4 5 6 7 8 9 10 11 12 //some.h #include &lt;other.h&gt; using mcs = mynamespace::component::subcomponent; msc::Class foo(); //some.cpp msc::Class foo() { using msc::AnotherClass; AnotherClass bar; // ... } As such, I don’t pollute the global namespace. What you have to keep in mind is that when you introduce a using-directive into a header file at the global namespace header, you don’t just mess things up in the current scope. If you include the header file in other files, you’ll also bring the inclusion of all those introduced symbols. If you introduce different header files with different global levels using-directives, the situation becomes even worse and the results of name lookup might depend on the order of inclusion. To avoid all such problems, just follow SF.7 and don’t write using namespace at global scope in a header file. Using-declaration in namespace and block scope While the using-directive brings all the symbols of a namespace into the current scope, a using-declaration will bring only one item! 1 2 using std::string; string foo{&quot;bar&quot;}; In the above example, we just demonstrated how it works. After using std::string, we can refer to std::string without mentioning the std namespace. It’s still something not to overuse! A using-declaration may also expand an overload set. It’s less dangerous to use it at a file scope than having a using-directive at the same scope, but risks still remain. Starting from C++20, you can also introduce scoped enumerators into a namespace of block scope! 1 2 3 4 5 6 enum class Color { red, green, blue }; class MyClass { using Color::red; Color c = red; // This is OK from C++20 }; In fact, it would also work with the old-style unscoped enum, but why would we do that? Importing base class members with using-declaration With using-declaration, you can introduce base class members - including constructors - into derived classes. It’s an easy way of exposing protected base class members as public in the derived class. It can be used both for functions and variables. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;iostream&gt; class Base { protected: void foo() { std::cout &lt;&lt; &quot;Base::foo()\\n&quot;; } int m_i = 42; }; class Derived : public Base { public: using Base::foo; using Base::m_i; }; int main() { Derived d; d.foo(); std::cout &lt;&lt; d.m_i &lt;&lt; &#39;\\n&#39;; } /* Base::foo() 42 */ If you try to modify the above example and remove any of the two using-declarations, you’ll see the compilation failing. If the derived class already has a member with the same name, the compilation will not. The imported symbol from the base class will be hidden. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; class Base { protected: void foo() { std::cout &lt;&lt; &quot;Base::foo()\\n&quot;; } }; class Derived : public Base { public: using Base::foo; void foo() { std::cout &lt;&lt; &quot;Derived::foo()\\n&quot;; } }; int main() { Derived d; d.foo(); } /* Derived::foo() */ I find this technique really useful for unit testing. When you’re writing a mock by hand, you often have to expose protected member functions from the base class, from the class that you are about to mock. One way of doing it is forwarding the call. Hopefully, the function’s name in the mock is not changed, but I’ve seen it a couple of times. It really puts an extra burden on the maintainers when they realize that there is a better option. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 class ClassUnderTest { public: virtual void testMe() { } virtual void testMeToo() { } }; class MockClassUnderTest : public ClassUnderTest { public: void testMe() override { ClassUnderTest::testMe(); } void mockedTestMeToo() { ClassUnderTest::testMeToo(); } }; Apart from tying a lot of unnecessary code, the problem above is that if the parameter list of testMe or testMeToo changes, you’ll also have to update MockClassUnderTest. You can get rid of that need by using using. 1 2 3 4 5 class MockClassUnderTest : public ClassUnderTest { public: using ClassUnderTest::testMe; using ClassUnderTest::testMeToo; }; Now we have less code and it’s more understandable what’s happening. As a bonus, even the maintenance is simplified. Conclusion In this article, we discussed the 4 different ways that we can use the using keyword. It’s the right way to create aliases and import base class members in derived classes. At the same time, they can be also used to introduce whole namespaces into the current scope which can be particularly dangerous. Last but not least, using can also introduce single types to the current scope which is a less dangerous option than introducing whole namespaces, still, it should be used with care. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The 4 use of using in C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp"},"url":"https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp"}</script><title>The 4 use of using in C++ | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/27"> 27 </a> </span> <span>The 4 use of using in C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The 4 use of using in C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 27, 2022, 12:00 AM +0200" prep="on" > Apr 27, 2022 <i class="unloaded">2022-04-27T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Sep 20, 2022, 11:07 PM +0200" prefix="Updated " > Sep 20, 2022 <i class="unloaded">2022-09-20T23:07:27+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1333 words">7 min</span></div></div><div class="post-content"><p>When I write code I don’t only want to write code that is correct. I also want to write code that is understandable, and maintainable. I want to deliver code that is easy to read not only for the compiler but also for other human beings. After all, humans will read my code more frequently than compilers.</p><p>I have been thinking what are the single most important keywords that help us write readable code. Probably this question doesn’t make much sense, but <code class="language-plaintext highlighter-rouge">const</code> and <code class="language-plaintext highlighter-rouge">using</code> are definitely among these. We <a href="https://leanpub.com/cppconst/">already discussed <code class="language-plaintext highlighter-rouge">const</code> a lot</a>, this time it’s time to see how using <code class="language-plaintext highlighter-rouge">using</code> can improve our code.</p><p>We are going to review the 4 ways we can use it:</p><ul><li>type aliasing with <code class="language-plaintext highlighter-rouge">using</code><li>introducing complete namespaces with <code class="language-plaintext highlighter-rouge">using</code>-directive<li>introducing members of another namespace with <code class="language-plaintext highlighter-rouge">using</code>-declaration<li>importing class members with <code class="language-plaintext highlighter-rouge">using</code>-declaration</ul><h2 id="aliasing">Aliasing</h2><p>In old C++ we could use <code class="language-plaintext highlighter-rouge">typedef</code> to give another name, to give an alias for our types. Sometimes you might want to use it instead of <a href="https://www.sandordargo.com/blog/2020/10/14/strong-types-for-containers">strong typing</a>, just to benefit from more meaningful names like <code class="language-plaintext highlighter-rouge">int</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="kt">int</span> <span class="n">Horsepower</span><span class="p">;</span>
</pre></table></code></div></div><p>Other times you want to shorten long types for easier usage:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">Iterator</span><span class="p">;</span>
</pre></table></code></div></div><p>Since C++11 we can use <code class="language-plaintext highlighter-rouge">using</code> instead of <code class="language-plaintext highlighter-rouge">typedef</code> to achieve the same results.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">Horsepower</span> <span class="o">=</span> <span class="kt">int</span><span class="p">;</span>
<span class="k">using</span> <span class="n">Iterator</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;::</span><span class="n">iterator</span><span class="p">;</span>
</pre></table></code></div></div><p>Why would you use <code class="language-plaintext highlighter-rouge">using</code> over the good old <code class="language-plaintext highlighter-rouge">typedef</code>? Just read the above statements! Exactly like the <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#t43-prefer-using-over-typedef-for-defining-aliases">T.43 core guideline</a> says, it’s more readable! The keyword has a very clear meaining, then the name comes first and the old comes after a <code class="language-plaintext highlighter-rouge">=</code>.</p><p>Besides, <code class="language-plaintext highlighter-rouge">using</code> can be used more generally. It can be used for template aliases where <code class="language-plaintext highlighter-rouge">typedef</code> would lead to a compilation error.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span> <span class="n">MapT</span><span class="p">;</span>      <span class="c1">// error</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">using</span> <span class="n">MapT</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>   <span class="c1">// OK</span>
</pre></table></code></div></div><h2 id="using-directive-in-namespace-and-block-scope">Using-directive in namespace and block scope</h2><p>You’ve probably seen many code examples that right after the <code class="language-plaintext highlighter-rouge">#include</code> statements contain the line <code class="language-plaintext highlighter-rouge">using namespace std</code>.</p><p>You’ve probably seen lots of such application code.</p><p>You’ve probably been told that it’s bad.</p><p>It’s particularly bad if you do in at the global scope in a header file, just like [SF.7 from the Core Guidelines says]:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// bad.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span><span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span> <span class="c1">// bad </span>

<span class="c1">// user.cpp</span>
<span class="cp">#include</span> <span class="cpf">"bad.h"</span><span class="cp">
</span>
<span class="c1">// some function that happens to be named copy</span>
<span class="kt">bool</span> <span class="nf">copy</span><span class="p">(</span><span class="cm">/*... some parameters ...*/</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="c1">// now overloads local ::copy and std::copy, could be ambiguous</span>
  <span class="n">copy</span><span class="p">(</span><span class="cm">/*...*/</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In my opinion, even the fact that as a reader you cannot be sure where a function comes from is bad. This is a simplistic example, but when you use <code class="language-plaintext highlighter-rouge">using namespace</code> in a long <code class="language-plaintext highlighter-rouge">.cpp</code> file it’s hard to keep track of where certain objects come from. I prefer having <code class="language-plaintext highlighter-rouge">using</code>-declarations instead and I also often introduce alias namespaces.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">//some.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;other.h&gt;</span><span class="cp">
</span>
<span class="k">using</span> <span class="n">mcs</span> <span class="o">=</span> <span class="n">mynamespace</span><span class="o">::</span><span class="n">component</span><span class="o">::</span><span class="n">subcomponent</span><span class="p">;</span>

<span class="n">msc</span><span class="o">::</span><span class="n">Class</span> <span class="nf">foo</span><span class="p">();</span>
<span class="c1">//some.cpp</span>
<span class="n">msc</span><span class="o">::</span><span class="n">Class</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">msc</span><span class="o">::</span><span class="n">AnotherClass</span><span class="p">;</span>
  <span class="n">AnotherClass</span> <span class="n">bar</span><span class="p">;</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As such, I don’t pollute the global namespace. What you have to keep in mind is that when you introduce a <code class="language-plaintext highlighter-rouge">using</code>-directive into a header file at the global namespace header, you don’t just mess things up in the current scope.</p><p>If you include the header file in other files, you’ll also bring the inclusion of all those introduced symbols. If you introduce different header files with different global levels <code class="language-plaintext highlighter-rouge">using</code>-directives, the situation becomes even worse and the results of name lookup might depend on the order of inclusion.</p><p>To avoid all such problems, just follow <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf7-dont-write-using-namespace-at-global-scope-in-a-header-file">SF.7</a> and <em>don’t write using namespace at global scope in a header file</em>.</p><h2 id="using-declaration-in-namespace-and-block-scope">Using-declaration in namespace and block scope</h2><p>While the <code class="language-plaintext highlighter-rouge">using</code>-directive brings all the symbols of a namespace into the current scope, a <code class="language-plaintext highlighter-rouge">using</code>-declaration will bring only one item!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">;</span>
<span class="n">string</span> <span class="n">foo</span><span class="p">{</span><span class="s">"bar"</span><span class="p">};</span>
</pre></table></code></div></div><p>In the above example, we just demonstrated how it works. After <code class="language-plaintext highlighter-rouge">using std::string</code>, we can refer to <code class="language-plaintext highlighter-rouge">std::string</code> without mentioning the <code class="language-plaintext highlighter-rouge">std</code> namespace.</p><p>It’s still something not to overuse! A <code class="language-plaintext highlighter-rouge">using</code>-declaration may also expand an overload set. It’s less dangerous to use it at a file scope than having a <code class="language-plaintext highlighter-rouge">using</code>-directive at the same scope, but risks still remain.</p><p>Starting from C++20, you can also introduce scoped enumerators into a namespace of block scope!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>

<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
  <span class="n">Color</span> <span class="n">c</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span> <span class="c1">// This is OK from C++20</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In fact, it would also work with the old-style unscoped <code class="language-plaintext highlighter-rouge">enum</code>, but why would we do that?</p><h2 id="importing-base-class-members-with-using-declaration">Importing base class members with <code class="language-plaintext highlighter-rouge">using</code>-declaration</h2><p>With <code class="language-plaintext highlighter-rouge">using</code>-declaration, you can introduce base class members - including constructors - into derived classes. It’s an easy way of exposing <code class="language-plaintext highlighter-rouge">protected</code> base class members as <code class="language-plaintext highlighter-rouge">public</code> in the derived class. It can be used both for functions and variables.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
 <span class="nl">protected:</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::foo()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
 
 <span class="kt">int</span> <span class="n">m_i</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">m_i</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">d</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">m_i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
Base::foo()
42
*/</span>
</pre></table></code></div></div><p>If you try to modify the above example and remove any of the two <code class="language-plaintext highlighter-rouge">using</code>-declarations, you’ll see the compilation failing.</p><p>If the derived class already has a member with the same name, the compilation will not. The imported symbol from the base class will be hidden.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
 <span class="nl">protected:</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Base::foo()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">using</span> <span class="n">Base</span><span class="o">::</span><span class="n">foo</span><span class="p">;</span>
  
  <span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Derived::foo()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
  <span class="n">d</span><span class="p">.</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
Derived::foo()
*/</span>
</pre></table></code></div></div><p>I find this technique really useful for unit testing. When you’re writing a mock by hand, you often have to expose protected member functions from the base class, from the class that you are about to mock.</p><p>One way of doing it is forwarding the call.</p><p>Hopefully, the function’s name in the mock is not changed, but I’ve seen it a couple of times. It really puts an extra burden on the maintainers when they realize that there is a better option.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ClassUnderTest</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">testMe</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>
  
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">testMeToo</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">MockClassUnderTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ClassUnderTest</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">testMe</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
     <span class="n">ClassUnderTest</span><span class="o">::</span><span class="n">testMe</span><span class="p">();</span> 
  <span class="p">}</span>
  
  <span class="kt">void</span> <span class="nf">mockedTestMeToo</span><span class="p">()</span> <span class="p">{</span>
      <span class="n">ClassUnderTest</span><span class="o">::</span><span class="n">testMeToo</span><span class="p">();</span> 
  <span class="p">}</span> 
<span class="p">};</span>
</pre></table></code></div></div><p>Apart from tying a lot of unnecessary code, the problem above is that if the parameter list of <code class="language-plaintext highlighter-rouge">testMe</code> or <code class="language-plaintext highlighter-rouge">testMeToo</code> changes, you’ll also have to update <code class="language-plaintext highlighter-rouge">MockClassUnderTest</code>. You can get rid of that need by using <code class="language-plaintext highlighter-rouge">using</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MockClassUnderTest</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ClassUnderTest</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">using</span> <span class="n">ClassUnderTest</span><span class="o">::</span><span class="n">testMe</span><span class="p">;</span> 
  <span class="k">using</span> <span class="n">ClassUnderTest</span><span class="o">::</span><span class="n">testMeToo</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Now we have less code and it’s more understandable what’s happening. As a bonus, even the maintenance is simplified.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we discussed the 4 different ways that we can use the <code class="language-plaintext highlighter-rouge">using</code> keyword. It’s the right way to create aliases and import base class members in derived classes. At the same time, they can be also used to introduce whole namespaces into the current scope which can be particularly dangerous. Last but not least, <code class="language-plaintext highlighter-rouge">using</code> can also introduce single types to the current scope which is a less dangerous option than introducing whole namespaces, still, it should be used with care.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/bestpractices/" class="post-tag no-text-decoration" >bestpractices</a> <a href="/tags/using/" class="post-tag no-text-decoration" >using</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The 4 use of using in C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The 4 use of using in C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The 4 use of using in C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The 4 use of using in C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2021/06/05/cpp-best-practices-by-jason-turner"><div class="card-body"> <span class="timeago small" > Jun 5, 2021 <i class="unloaded">2021-06-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ Best Practices by Jason Turner</h3><div class="text-muted small"><p> This is a book that I’ve been waiting for to finally read for a long time. I could have bought it, but I decided that it’ll be the first book that I buy from the royalties I earned with How to use ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/04/16/beautiful-cpp-by-kate-gregory-and-guy-davidson"><div class="card-body"> <span class="timeago small" > Apr 16, 2022 <i class="unloaded">2022-04-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Beautiful C++: 30 Core Guidelines for Writing Clean, Safe and Fast Code by J. Guy Davidson and Kate Gregory</h3><div class="text-muted small"><p> If you are familiar with the Pluralsight courses of Kate Gregory, you won’t be surprised by the name of this book. While many consider C++ a complex language that always results in difficult to rea...</p></div></div></a></div><div class="card"> <a href="/blog/2023/06/21/3-best-books-you-level-up-your-cpp"><div class="card-body"> <span class="timeago small" > Jun 21, 2023 <i class="unloaded">2023-06-21T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The 3 best books to level up your C++</h3><div class="text-muted small"><p> In this article, I’ll present you 3 books that can level up your C++. For this article, I’m assuming that you have little or medium experience with C++ and you’re looking for ways to reach the next...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/04/20/range-base-p2012" class="btn btn-outline-primary" prompt="Older"><p>The infamous bug of range-based for loops</p></a> <a href="/blog/2022/04/30/the-goal-a-process-of-ongoing-improvement-by-eliyahu-m-goldratt" class="btn btn-outline-primary" prompt="Newer"><p>The Goal: A Process Of Ongoing Improvement by Eliyahu M. Goldratt</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The 4 use of using in C++'; this.page.url = 'https://www.sandordargo.com/blog/2022/04/27/the-4-use-of-using-in-cpp'; this.page.identifier = '/blog/2022/04/27/the-4-use-of-using-in-cpp'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
