<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="My first work experience with C++20" /><meta property="og:locale" content="en_US" /><meta name="description" content="I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in reality about five versions. The different releases are using different toolchains supporting different versions of C++. Starting from C++11 we have all the versions up to C++20. While I had already been studying C++20 on my own, I didn’t have to chance to use it in a real-world corporate context. In fact, not even C++17 - though it doesn’t offer so many novelties. In this small post, I’d like to reflect on our so called innovation week that I could spend on modernizing some our codebases. Not even C++11 Using a new version is not just l’art pour l’art. Using a new standard can and should simplify quite a bit your code, it should make the life of maintainers easier. Long years after introducing C++11 to our codebases, I barely found the use of range-based for loops. Okay, okay, range-based for loops do have an important bug, but I clearly doubt that it’s the reason behind not having these readable loops. Instead, I found many long constructs of iterators, or even the good old for loops with the use of an incremented index along with the subscription operator ([]). And then I haven’t even mentioned the lack of using smart pointers, default member initalization, etc. Maps and sets now have contains If you have to work with std::map or std::set or their unordered versions, you most probably know how cumbersome is to find out whether they have a certain item (as a key) or not. Using a find() and then comparing its result with the end() iterator is verbose, not very readable and not elegant. With C++20 we can replace all that with contains! 1 2 3 4 5 6 7 8 9 10 11 12 13 std::map&lt;std::string, int&gt; myMap; // ... //before C++20 if (myMap.find(aKey) != myMap.end()) { // the map contains a key // ... } // with C++20 if (myMap.contains(aKey)) { // ... } Of course, if you need an iterator to that item, you’ll still need to use find, but contains will simplify your code in lots of cases. Iterate over maps with structured bindings I often saw that people created an iterator outside the loop because the type is very long, then in the first lines of the loop body they took references to the key and value of the given map element. 1 2 3 4 5 6 7 8 std::map&lt;std::string, SomeLengthClassName&gt;::const_iterator aIt; for (aIt = myMap.begin(); aIt != myMap.end(); ++aIt) { const std::string&amp; aKey = aIt-&gt;first; const SomeLengthClassName&amp; aValue = aIt-&gt;second; // ... } With C++17, we can use structured bindings and we can get rid of these complex loops including the manual creation of those references. 1 2 3 4 for (const auto&amp; [aPhase, aValue]: myMap) { // ... } That’s shorter and way more readable. But what you should you do when you only need the key or the value? Ranges and what is missing But there is more than that we can do with C++20 when we don’t use the keys or the values! Continuing the idea of structured bindings, when you don’t need one of the key-value pair, with C++17 you used to simple name the not needed one as an _. With C++20 ranges there are these possibilities instead! 1 2 3 4 5 6 7 8 9 10 11 std::map&lt;std::string, int&gt; myMap { {&quot;one&quot;, 1}, {&quot;two&quot;, 2}, {&quot;three&quot;, 3} }; for (auto aIt = myMap.begin(); aIt != myMap.end(); ++aIt) { std::cout &lt;&lt; aIt-&gt;second &lt;&lt; &#39;\n&#39;; } for (auto const&amp; aValue: std::views::values(myMap)) // or... for (auto const&amp; aKey: std::views::keys(myMap)) That’s already more readable and we haven’t even tried to use the “pipe-syntax” that must be a kind of a satisfaction for programmers working on Linux. 1 2 3 for (auto const&amp; aValue: myMap | std::views::keys) { std::cout &lt;&lt; aValue &lt;&lt; &#39;\n&#39;; } This pipe-syntax shows best it’s potential when we chain multiple algorithms, views, etc. together and instead of building layers around the initial range we can simply read from the left to the right and quickly understand what goes on. This is all possible as functions in the ranges and views namespace do not take a pair of iterators but the containers directly. More on that in another article. Is there a difference in performance between the good old way, the loop with structured bindings and with ranges/views? I did some analyzes on quick bench and I found no difference between the C++17 and C++20 way of iterating over keys or values, but they are both a bit faster than dealing manually with the iterators. Not surprisingly, I didn’t find many usages of standard algorithms. But when I did I could almost always replace them with the range version, meaning that I don’t have to pass the begin and end iterators anymore just the container - which is treated as a whole as a range. I already showed how ranges could help me simplify loops to iterate over the keys of map or how I could replace simple standard algorithms with standard range-based algorithms. 1 2 3 4 std::copy(myVec.begin(), myVec.end(), std::back_inserter(results)); // The above example would become std::copy(myVec, std::back_inserter(results)); At a first glance, it seems that there is a small performance penalty on the ranges version. Something I have to analyze further. It’s definitely not significant in applications were most time is lost in database and network class, but maybe it’s too much in other cases. In any case, the increase in readability might justify a bit of loss in CPU time. It depends on your situation. I found ranges the best when I wanted to replace full for loops. Let me share an example with you. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool Configuration::warnOnMissingData(const Date&amp; iCheckDate) { bool aWasAWarningIssued(false); Date aLastValidDate; std::vector&lt;ImportantData&gt;::const_iterator aDataIterator; for (aDataIterator = _data.begin(); aDataIterator != _data.end(); ++aDataIterator) { aLastValidDate = aDataIterator-&gt;second-&gt;getLastDate(); if (aLastValidDate &lt; iCheckDate) { LOG_ERROR(aDataIterator-&gt;second); aWasAWarningIssued = true; } } return aWasAWarningIssued; } That loop was never great. Like why do we keep looping after the first matching condition? Because of logging maybe? It’s not a great explanation. Even C++11 had great options for simplifying the above loop. But it’s hard to find time to change working code. But when you do, don’t be shy. Make sure that the code is tested and refactor it according to your best knowledge. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool Configuration::warnOnMissingDataKeys(const Date&amp; iCheckDate) { auto isDataLastDateOlderThan = [&amp;iCheckDate](const auto&amp; aData) { if (aData == nullptr) { return false; } return aData-&gt;getLastDate() &lt; iCheckDate; }; const auto&amp; aPotentialMatch = std::ranges::find_if( _data, isDataLastDateOlderThan, &amp;std::vector&lt;ImportantData&gt;::value_type::second ); if (aPotentialMatch == _data.end()) { return false; } LOG_ERROR(aPotentialMatch-&gt;first); return true; } With this refactoring, we could introduce an algorithm instead of a raw loop and we could give a name even to the condition. We only lost some logging which was probably not even meant. Concepts for templates Last but not least, I followed the T.10 core guideline’s recommendation of not having bare template parameters. Each of them is constrained by some concepts now. Sometimes I only used a standard concept, but often I had to create the our own concepts first. How did I come of with these new concepts? I had a deep look into the templates to see how they use their template parameters. With that, I understood what API we have to require from any type. Then I also had a look into each instantiation to see if I can find a pattern. Often I realized that the API I require is the API defined by an abstract base class which each template argument type used as a base. Nowing this fact let you decide whether I wanted to describe once more the interface or just require that the incoming parameters are implementing that base class, that interface. Ultimately I might even think about removing the base class if it is just for an interface, turn it into a concept and make sure that the used-to-be child class satisfies that base constraint. With that I’d basically introduce duck-typing, but I’d remove some virtual tables and pointers and runtime interface in general. But let’s come back to the creation of concepts. Only when I had a couple of rounds of this investigation I could focus on coming up with a good name for the concept. I found this part the most difficult one. Should I use a noun or an adjective? I’m not all set on that question. So far I used nouns that seemed to read slightly better. What do you think? Conclusion In this article I shared my first experience with C++20 and production code. I didn’t only introduce C++20 features, in some cases, C++17 suffice - bear in mind structures mindings. C++20 introduced some great library features like contains for maps and sets, but also new the ranges library and concepts. All this require some learning, but they can greatly simplify your code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in reality about five versions. The different releases are using different toolchains supporting different versions of C++. Starting from C++11 we have all the versions up to C++20. While I had already been studying C++20 on my own, I didn’t have to chance to use it in a real-world corporate context. In fact, not even C++17 - though it doesn’t offer so many novelties. In this small post, I’d like to reflect on our so called innovation week that I could spend on modernizing some our codebases. Not even C++11 Using a new version is not just l’art pour l’art. Using a new standard can and should simplify quite a bit your code, it should make the life of maintainers easier. Long years after introducing C++11 to our codebases, I barely found the use of range-based for loops. Okay, okay, range-based for loops do have an important bug, but I clearly doubt that it’s the reason behind not having these readable loops. Instead, I found many long constructs of iterators, or even the good old for loops with the use of an incremented index along with the subscription operator ([]). And then I haven’t even mentioned the lack of using smart pointers, default member initalization, etc. Maps and sets now have contains If you have to work with std::map or std::set or their unordered versions, you most probably know how cumbersome is to find out whether they have a certain item (as a key) or not. Using a find() and then comparing its result with the end() iterator is verbose, not very readable and not elegant. With C++20 we can replace all that with contains! 1 2 3 4 5 6 7 8 9 10 11 12 13 std::map&lt;std::string, int&gt; myMap; // ... //before C++20 if (myMap.find(aKey) != myMap.end()) { // the map contains a key // ... } // with C++20 if (myMap.contains(aKey)) { // ... } Of course, if you need an iterator to that item, you’ll still need to use find, but contains will simplify your code in lots of cases. Iterate over maps with structured bindings I often saw that people created an iterator outside the loop because the type is very long, then in the first lines of the loop body they took references to the key and value of the given map element. 1 2 3 4 5 6 7 8 std::map&lt;std::string, SomeLengthClassName&gt;::const_iterator aIt; for (aIt = myMap.begin(); aIt != myMap.end(); ++aIt) { const std::string&amp; aKey = aIt-&gt;first; const SomeLengthClassName&amp; aValue = aIt-&gt;second; // ... } With C++17, we can use structured bindings and we can get rid of these complex loops including the manual creation of those references. 1 2 3 4 for (const auto&amp; [aPhase, aValue]: myMap) { // ... } That’s shorter and way more readable. But what you should you do when you only need the key or the value? Ranges and what is missing But there is more than that we can do with C++20 when we don’t use the keys or the values! Continuing the idea of structured bindings, when you don’t need one of the key-value pair, with C++17 you used to simple name the not needed one as an _. With C++20 ranges there are these possibilities instead! 1 2 3 4 5 6 7 8 9 10 11 std::map&lt;std::string, int&gt; myMap { {&quot;one&quot;, 1}, {&quot;two&quot;, 2}, {&quot;three&quot;, 3} }; for (auto aIt = myMap.begin(); aIt != myMap.end(); ++aIt) { std::cout &lt;&lt; aIt-&gt;second &lt;&lt; &#39;\n&#39;; } for (auto const&amp; aValue: std::views::values(myMap)) // or... for (auto const&amp; aKey: std::views::keys(myMap)) That’s already more readable and we haven’t even tried to use the “pipe-syntax” that must be a kind of a satisfaction for programmers working on Linux. 1 2 3 for (auto const&amp; aValue: myMap | std::views::keys) { std::cout &lt;&lt; aValue &lt;&lt; &#39;\n&#39;; } This pipe-syntax shows best it’s potential when we chain multiple algorithms, views, etc. together and instead of building layers around the initial range we can simply read from the left to the right and quickly understand what goes on. This is all possible as functions in the ranges and views namespace do not take a pair of iterators but the containers directly. More on that in another article. Is there a difference in performance between the good old way, the loop with structured bindings and with ranges/views? I did some analyzes on quick bench and I found no difference between the C++17 and C++20 way of iterating over keys or values, but they are both a bit faster than dealing manually with the iterators. Not surprisingly, I didn’t find many usages of standard algorithms. But when I did I could almost always replace them with the range version, meaning that I don’t have to pass the begin and end iterators anymore just the container - which is treated as a whole as a range. I already showed how ranges could help me simplify loops to iterate over the keys of map or how I could replace simple standard algorithms with standard range-based algorithms. 1 2 3 4 std::copy(myVec.begin(), myVec.end(), std::back_inserter(results)); // The above example would become std::copy(myVec, std::back_inserter(results)); At a first glance, it seems that there is a small performance penalty on the ranges version. Something I have to analyze further. It’s definitely not significant in applications were most time is lost in database and network class, but maybe it’s too much in other cases. In any case, the increase in readability might justify a bit of loss in CPU time. It depends on your situation. I found ranges the best when I wanted to replace full for loops. Let me share an example with you. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool Configuration::warnOnMissingData(const Date&amp; iCheckDate) { bool aWasAWarningIssued(false); Date aLastValidDate; std::vector&lt;ImportantData&gt;::const_iterator aDataIterator; for (aDataIterator = _data.begin(); aDataIterator != _data.end(); ++aDataIterator) { aLastValidDate = aDataIterator-&gt;second-&gt;getLastDate(); if (aLastValidDate &lt; iCheckDate) { LOG_ERROR(aDataIterator-&gt;second); aWasAWarningIssued = true; } } return aWasAWarningIssued; } That loop was never great. Like why do we keep looping after the first matching condition? Because of logging maybe? It’s not a great explanation. Even C++11 had great options for simplifying the above loop. But it’s hard to find time to change working code. But when you do, don’t be shy. Make sure that the code is tested and refactor it according to your best knowledge. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool Configuration::warnOnMissingDataKeys(const Date&amp; iCheckDate) { auto isDataLastDateOlderThan = [&amp;iCheckDate](const auto&amp; aData) { if (aData == nullptr) { return false; } return aData-&gt;getLastDate() &lt; iCheckDate; }; const auto&amp; aPotentialMatch = std::ranges::find_if( _data, isDataLastDateOlderThan, &amp;std::vector&lt;ImportantData&gt;::value_type::second ); if (aPotentialMatch == _data.end()) { return false; } LOG_ERROR(aPotentialMatch-&gt;first); return true; } With this refactoring, we could introduce an algorithm instead of a raw loop and we could give a name even to the condition. We only lost some logging which was probably not even meant. Concepts for templates Last but not least, I followed the T.10 core guideline’s recommendation of not having bare template parameters. Each of them is constrained by some concepts now. Sometimes I only used a standard concept, but often I had to create the our own concepts first. How did I come of with these new concepts? I had a deep look into the templates to see how they use their template parameters. With that, I understood what API we have to require from any type. Then I also had a look into each instantiation to see if I can find a pattern. Often I realized that the API I require is the API defined by an abstract base class which each template argument type used as a base. Nowing this fact let you decide whether I wanted to describe once more the interface or just require that the incoming parameters are implementing that base class, that interface. Ultimately I might even think about removing the base class if it is just for an interface, turn it into a concept and make sure that the used-to-be child class satisfies that base constraint. With that I’d basically introduce duck-typing, but I’d remove some virtual tables and pointers and runtime interface in general. But let’s come back to the creation of concepts. Only when I had a couple of rounds of this investigation I could focus on coming up with a good name for the concept. I found this part the most difficult one. Should I use a noun or an adjective? I’m not all set on that question. So far I used nouns that seemed to read slightly better. What do you think? Conclusion In this article I shared my first experience with C++20 and production code. I didn’t only introduce C++20 features, in some cases, C++17 suffice - bear in mind structures mindings. C++20 introduced some great library features like contains for maps and sets, but also new the ranges library and concepts. All this require some learning, but they can greatly simplify your code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20" /><meta property="og:url" content="https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2022-04-13T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="My first work experience with C++20" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2022-04-13T00:00:00+02:00","datePublished":"2022-04-13T00:00:00+02:00","description":"I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in reality about five versions. The different releases are using different toolchains supporting different versions of C++. Starting from C++11 we have all the versions up to C++20. While I had already been studying C++20 on my own, I didn’t have to chance to use it in a real-world corporate context. In fact, not even C++17 - though it doesn’t offer so many novelties. In this small post, I’d like to reflect on our so called innovation week that I could spend on modernizing some our codebases. Not even C++11 Using a new version is not just l’art pour l’art. Using a new standard can and should simplify quite a bit your code, it should make the life of maintainers easier. Long years after introducing C++11 to our codebases, I barely found the use of range-based for loops. Okay, okay, range-based for loops do have an important bug, but I clearly doubt that it’s the reason behind not having these readable loops. Instead, I found many long constructs of iterators, or even the good old for loops with the use of an incremented index along with the subscription operator ([]). And then I haven’t even mentioned the lack of using smart pointers, default member initalization, etc. Maps and sets now have contains If you have to work with std::map or std::set or their unordered versions, you most probably know how cumbersome is to find out whether they have a certain item (as a key) or not. Using a find() and then comparing its result with the end() iterator is verbose, not very readable and not elegant. With C++20 we can replace all that with contains! 1 2 3 4 5 6 7 8 9 10 11 12 13 std::map&lt;std::string, int&gt; myMap; // ... //before C++20 if (myMap.find(aKey) != myMap.end()) { // the map contains a key // ... } // with C++20 if (myMap.contains(aKey)) { // ... } Of course, if you need an iterator to that item, you’ll still need to use find, but contains will simplify your code in lots of cases. Iterate over maps with structured bindings I often saw that people created an iterator outside the loop because the type is very long, then in the first lines of the loop body they took references to the key and value of the given map element. 1 2 3 4 5 6 7 8 std::map&lt;std::string, SomeLengthClassName&gt;::const_iterator aIt; for (aIt = myMap.begin(); aIt != myMap.end(); ++aIt) { const std::string&amp; aKey = aIt-&gt;first; const SomeLengthClassName&amp; aValue = aIt-&gt;second; // ... } With C++17, we can use structured bindings and we can get rid of these complex loops including the manual creation of those references. 1 2 3 4 for (const auto&amp; [aPhase, aValue]: myMap) { // ... } That’s shorter and way more readable. But what you should you do when you only need the key or the value? Ranges and what is missing But there is more than that we can do with C++20 when we don’t use the keys or the values! Continuing the idea of structured bindings, when you don’t need one of the key-value pair, with C++17 you used to simple name the not needed one as an _. With C++20 ranges there are these possibilities instead! 1 2 3 4 5 6 7 8 9 10 11 std::map&lt;std::string, int&gt; myMap { {&quot;one&quot;, 1}, {&quot;two&quot;, 2}, {&quot;three&quot;, 3} }; for (auto aIt = myMap.begin(); aIt != myMap.end(); ++aIt) { std::cout &lt;&lt; aIt-&gt;second &lt;&lt; &#39;\\n&#39;; } for (auto const&amp; aValue: std::views::values(myMap)) // or... for (auto const&amp; aKey: std::views::keys(myMap)) That’s already more readable and we haven’t even tried to use the “pipe-syntax” that must be a kind of a satisfaction for programmers working on Linux. 1 2 3 for (auto const&amp; aValue: myMap | std::views::keys) { std::cout &lt;&lt; aValue &lt;&lt; &#39;\\n&#39;; } This pipe-syntax shows best it’s potential when we chain multiple algorithms, views, etc. together and instead of building layers around the initial range we can simply read from the left to the right and quickly understand what goes on. This is all possible as functions in the ranges and views namespace do not take a pair of iterators but the containers directly. More on that in another article. Is there a difference in performance between the good old way, the loop with structured bindings and with ranges/views? I did some analyzes on quick bench and I found no difference between the C++17 and C++20 way of iterating over keys or values, but they are both a bit faster than dealing manually with the iterators. Not surprisingly, I didn’t find many usages of standard algorithms. But when I did I could almost always replace them with the range version, meaning that I don’t have to pass the begin and end iterators anymore just the container - which is treated as a whole as a range. I already showed how ranges could help me simplify loops to iterate over the keys of map or how I could replace simple standard algorithms with standard range-based algorithms. 1 2 3 4 std::copy(myVec.begin(), myVec.end(), std::back_inserter(results)); // The above example would become std::copy(myVec, std::back_inserter(results)); At a first glance, it seems that there is a small performance penalty on the ranges version. Something I have to analyze further. It’s definitely not significant in applications were most time is lost in database and network class, but maybe it’s too much in other cases. In any case, the increase in readability might justify a bit of loss in CPU time. It depends on your situation. I found ranges the best when I wanted to replace full for loops. Let me share an example with you. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 bool Configuration::warnOnMissingData(const Date&amp; iCheckDate) { bool aWasAWarningIssued(false); Date aLastValidDate; std::vector&lt;ImportantData&gt;::const_iterator aDataIterator; for (aDataIterator = _data.begin(); aDataIterator != _data.end(); ++aDataIterator) { aLastValidDate = aDataIterator-&gt;second-&gt;getLastDate(); if (aLastValidDate &lt; iCheckDate) { LOG_ERROR(aDataIterator-&gt;second); aWasAWarningIssued = true; } } return aWasAWarningIssued; } That loop was never great. Like why do we keep looping after the first matching condition? Because of logging maybe? It’s not a great explanation. Even C++11 had great options for simplifying the above loop. But it’s hard to find time to change working code. But when you do, don’t be shy. Make sure that the code is tested and refactor it according to your best knowledge. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 bool Configuration::warnOnMissingDataKeys(const Date&amp; iCheckDate) { auto isDataLastDateOlderThan = [&amp;iCheckDate](const auto&amp; aData) { if (aData == nullptr) { return false; } return aData-&gt;getLastDate() &lt; iCheckDate; }; const auto&amp; aPotentialMatch = std::ranges::find_if( _data, isDataLastDateOlderThan, &amp;std::vector&lt;ImportantData&gt;::value_type::second ); if (aPotentialMatch == _data.end()) { return false; } LOG_ERROR(aPotentialMatch-&gt;first); return true; } With this refactoring, we could introduce an algorithm instead of a raw loop and we could give a name even to the condition. We only lost some logging which was probably not even meant. Concepts for templates Last but not least, I followed the T.10 core guideline’s recommendation of not having bare template parameters. Each of them is constrained by some concepts now. Sometimes I only used a standard concept, but often I had to create the our own concepts first. How did I come of with these new concepts? I had a deep look into the templates to see how they use their template parameters. With that, I understood what API we have to require from any type. Then I also had a look into each instantiation to see if I can find a pattern. Often I realized that the API I require is the API defined by an abstract base class which each template argument type used as a base. Nowing this fact let you decide whether I wanted to describe once more the interface or just require that the incoming parameters are implementing that base class, that interface. Ultimately I might even think about removing the base class if it is just for an interface, turn it into a concept and make sure that the used-to-be child class satisfies that base constraint. With that I’d basically introduce duck-typing, but I’d remove some virtual tables and pointers and runtime interface in general. But let’s come back to the creation of concepts. Only when I had a couple of rounds of this investigation I could focus on coming up with a good name for the concept. I found this part the most difficult one. Should I use a noun or an adjective? I’m not all set on that question. So far I used nouns that seemed to read slightly better. What do you think? Conclusion In this article I shared my first experience with C++20 and production code. I didn’t only introduce C++20 features, in some cases, C++17 suffice - bear in mind structures mindings. C++20 introduced some great library features like contains for maps and sets, but also new the ranges library and concepts. All this require some learning, but they can greatly simplify your code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"My first work experience with C++20","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20"},"url":"https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20"}</script><title>My first work experience with C++20 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2022"> 2022 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/13"> 13 </a> </span> <span>My first work experience with C++20</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>My first work experience with C++20</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 13, 2022, 12:00 AM +0200" prep="on" > Apr 13, 2022 <i class="unloaded">2022-04-13T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1560 words">8 min</span></div></div><div class="post-content"><p>I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in reality about five versions.</p><p>The different releases are using different toolchains supporting different versions of C++. Starting from C++11 we have all the versions up to C++20. While I had already been studying C++20 on my own, I didn’t have to chance to use it in a real-world corporate context. In fact, not even C++17 - though it doesn’t offer so many novelties.</p><p>In this small post, I’d like to reflect on our so called innovation week that I could spend on modernizing some our codebases.</p><h2 id="not-even-c11">Not even C++11</h2><p>Using a new version is not just <em>l’art pour l’art</em>. Using a new standard can and should simplify quite a bit your code, it should make the life of maintainers easier. Long years after introducing C++11 to our codebases, I barely found the use of range-based for loops. Okay, okay, range-based for loops do have an important bug, but I clearly doubt that it’s the reason behind not having these readable loops.</p><p>Instead, I found many long constructs of iterators, or even the good old for loops with the use of an incremented index along with the subscription operator (<code class="language-plaintext highlighter-rouge">[]</code>).</p><p>And then I haven’t even mentioned the lack of using smart pointers, <a href="https://en.cppreference.com/w/cpp/language/data_members#Member_initialization">default member initalization</a>, etc.</p><h2 id="maps-and-sets-now-have-contains">Maps and sets now have contains</h2><p>If you have to work with <code class="language-plaintext highlighter-rouge">std::map</code> or <code class="language-plaintext highlighter-rouge">std::set</code> or their unordered versions, you most probably know how cumbersome is to find out whether they have a certain item (as a key) or not. Using a <code class="language-plaintext highlighter-rouge">find()</code> and then comparing its result with the <code class="language-plaintext highlighter-rouge">end()</code> iterator is verbose, not very readable and not elegant.</p><p>With C++20 we can replace all that with <a href="https://en.cppreference.com/w/cpp/container/unordered_set/contains"><code class="language-plaintext highlighter-rouge">contains</code></a>!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">myMap</span><span class="p">;</span>
<span class="c1">// ...</span>

<span class="c1">//before C++20</span>
<span class="k">if</span> <span class="p">(</span><span class="n">myMap</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="n">aKey</span><span class="p">)</span> <span class="o">!=</span> <span class="n">myMap</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// the map contains a key</span>
    <span class="c1">// ...</span>
<span class="p">}</span>

<span class="c1">// with C++20</span>
<span class="k">if</span> <span class="p">(</span><span class="n">myMap</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">aKey</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Of course, if you need an iterator to that item, you’ll still need to use <code class="language-plaintext highlighter-rouge">find</code>, but <code class="language-plaintext highlighter-rouge">contains</code> will simplify your code in lots of cases.</p><h2 id="iterate-over-maps-with-structured-bindings">Iterate over maps with structured bindings</h2><p>I often saw that people created an iterator outside the loop because the type is very long, then in the first lines of the loop body they took references to the key and value of the given <code class="language-plaintext highlighter-rouge">map</code> element.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">SomeLengthClassName</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">aIt</span><span class="p">;</span>

<span class="k">for</span> <span class="p">(</span><span class="n">aIt</span> <span class="o">=</span> <span class="n">myMap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">aIt</span> <span class="o">!=</span> <span class="n">myMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">aIt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">aKey</span> <span class="o">=</span> <span class="n">aIt</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">SomeLengthClassName</span><span class="o">&amp;</span> <span class="n">aValue</span> <span class="o">=</span> <span class="n">aIt</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">;</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With C++17, we can use <a href="https://en.cppreference.com/w/cpp/language/structured_binding">structured bindings</a> and we can get rid of these complex loops including the manual creation of those references.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="p">[</span><span class="n">aPhase</span><span class="p">,</span> <span class="n">aValue</span><span class="p">]</span><span class="o">:</span> <span class="n">myMap</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That’s shorter and way more readable.</p><p>But what you should you do when you only need the key or the value?</p><h2 id="ranges-and-what-is-missing">Ranges and what is missing</h2><p>But there is more than that we can do with C++20 when we don’t use the keys or the values!</p><p>Continuing the idea of structured bindings, when you don’t need one of the key-value pair, with C++17 you used to simple name the not needed one as an <code class="language-plaintext highlighter-rouge">_</code>. With C++20 ranges there are these possibilities instead!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">myMap</span> <span class="p">{</span> <span class="p">{</span><span class="s">"one"</span><span class="p">,</span> <span class="mi">1</span><span class="p">},</span> <span class="p">{</span><span class="s">"two"</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="s">"three"</span><span class="p">,</span> <span class="mi">3</span><span class="p">}</span> <span class="p">};</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">aIt</span> <span class="o">=</span> <span class="n">myMap</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">aIt</span> <span class="o">!=</span> <span class="n">myMap</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">aIt</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">aIt</span><span class="o">-&gt;</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>


<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">aValue</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">values</span><span class="p">(</span><span class="n">myMap</span><span class="p">))</span>    
<span class="c1">// or...</span>
<span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">aKey</span><span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">keys</span><span class="p">(</span><span class="n">myMap</span><span class="p">))</span>

</pre></table></code></div></div><p>That’s already more readable and we haven’t even tried to use the “pipe-syntax” that must be a kind of a satisfaction for programmers working on Linux.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">aValue</span><span class="o">:</span> <span class="n">myMap</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">keys</span><span class="p">)</span> <span class="p">{</span>
       <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">aValue</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This pipe-syntax shows best it’s potential when we chain multiple algorithms, views, etc. together and instead of building layers around the initial range we can simply read from the left to the right and quickly understand what goes on. This is all possible as functions in the <code class="language-plaintext highlighter-rouge">ranges</code> and <code class="language-plaintext highlighter-rouge">views</code> namespace do not take a pair of iterators but the containers directly. More on that in another article.</p><p>Is there a difference in performance between the good old way, the loop with structured bindings and with ranges/views?</p><p>I did some analyzes on quick bench and I found no difference between the C++17 and C++20 way of iterating over keys or values, but they are both a bit faster than dealing manually with the iterators.</p><p>Not surprisingly, I didn’t find many usages of <a href="https://www.sandordargo.com/blog/2019/01/30/stl-algos-intro">standard algorithms</a>. But when I did I could almost always replace them with the range version, meaning that I don’t have to pass the begin and end iterators anymore just the container - which is treated as a whole as a range.</p><p>I already showed how ranges could help me simplify loops to iterate over the keys of map or how I could replace simple standard algorithms with standard range-based algorithms.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">myVec</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">myVec</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">));</span>

<span class="c1">// The above example would become</span>
<span class="n">std</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">myVec</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">back_inserter</span><span class="p">(</span><span class="n">results</span><span class="p">));</span>
</pre></table></code></div></div><p>At a first glance, it seems that there is a small performance penalty on the ranges version. Something I have to analyze further. It’s definitely not significant in applications were most time is lost in database and network class, but maybe it’s too much in other cases.</p><p>In any case, the increase in readability might justify a bit of loss in CPU time. It depends on your situation.</p><p>I found ranges the best when I wanted to replace full for loops. Let me share an example with you.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">Configuration</span><span class="o">::</span><span class="n">warnOnMissingData</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">iCheckDate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">bool</span> <span class="n">aWasAWarningIssued</span><span class="p">(</span><span class="nb">false</span><span class="p">);</span>

    <span class="n">Date</span> <span class="n">aLastValidDate</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ImportantData</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">aDataIterator</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">aDataIterator</span> <span class="o">=</span> <span class="n">_data</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">aDataIterator</span> <span class="o">!=</span> <span class="n">_data</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">aDataIterator</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">aLastValidDate</span> <span class="o">=</span> <span class="n">aDataIterator</span><span class="o">-&gt;</span><span class="n">second</span><span class="o">-&gt;</span><span class="n">getLastDate</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">aLastValidDate</span> <span class="o">&lt;</span> <span class="n">iCheckDate</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">LOG_ERROR</span><span class="p">(</span><span class="n">aDataIterator</span><span class="o">-&gt;</span><span class="n">second</span><span class="p">);</span>
            <span class="n">aWasAWarningIssued</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">aWasAWarningIssued</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>That loop was never great. Like why do we keep looping after the first matching condition? Because of logging maybe? It’s not a great explanation. Even C++11 had great options for simplifying the above loop. But it’s hard to find time to change working code. But when you do, don’t be shy. Make sure that the code is tested and refactor it according to your best knowledge.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="kt">bool</span> <span class="n">Configuration</span><span class="o">::</span><span class="n">warnOnMissingDataKeys</span><span class="p">(</span><span class="k">const</span> <span class="n">Date</span><span class="o">&amp;</span> <span class="n">iCheckDate</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">isDataLastDateOlderThan</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">iCheckDate</span><span class="p">](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">aData</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">aData</span> <span class="o">==</span> <span class="nb">nullptr</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="k">return</span> <span class="n">aData</span><span class="o">-&gt;</span><span class="n">getLastDate</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">iCheckDate</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">aPotentialMatch</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find_if</span><span class="p">(</span>
            <span class="n">_data</span><span class="p">,</span>
            <span class="n">isDataLastDateOlderThan</span><span class="p">,</span>
            <span class="o">&amp;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ImportantData</span><span class="o">&gt;::</span><span class="n">value_type</span><span class="o">::</span><span class="n">second</span>
    <span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">aPotentialMatch</span> <span class="o">==</span> <span class="n">_data</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
    <span class="n">LOG_ERROR</span><span class="p">(</span><span class="n">aPotentialMatch</span><span class="o">-&gt;</span><span class="n">first</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With this refactoring, we could introduce an algorithm instead of a raw loop and we could give a name even to the condition. We only lost some logging which was probably not even meant.</p><h2 id="concepts-for-templates">Concepts for templates</h2><p>Last but not least, I followed the <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#t10-specify-concepts-for-all-template-arguments">T.10 core guideline</a>’s recommendation of not having bare template parameters. Each of them is constrained by some concepts now. Sometimes I only used a standard concept, but often I had to create the our own concepts first.</p><p>How did I come of with these new concepts?</p><p>I had a deep look into the templates to see how they use their template parameters. With that, I understood what API we have to require from any type. Then I also had a look into each instantiation to see if I can find a pattern. Often I realized that the API I require is the API defined by an abstract base class which each template argument type used as a base.</p><p>Nowing this fact let you decide whether I wanted to describe once more the interface or just require that the incoming parameters are implementing that base class, that interface. Ultimately I might even think about removing the base class if it is just for an interface, turn it into a concept and make sure that the used-to-be child class satisfies that base constraint. With that I’d basically introduce duck-typing, but I’d remove some virtual tables and pointers and runtime interface in general.</p><p>But let’s come back to the creation of concepts. Only when I had a couple of rounds of this investigation I could focus on coming up with a good name for the concept. I found this part the most difficult one. Should I use a noun or an adjective? I’m not all set on that question. So far I used nouns that seemed to read slightly better. What do you think?</p><h2 id="conclusion">Conclusion</h2><p>In this article I shared my first experience with C++20 and production code. I didn’t only introduce C++20 features, in some cases, C++17 suffice - bear in mind structures mindings. C++20 introduced some great library features like <code class="language-plaintext highlighter-rouge">contains</code> for maps and sets, but also new the <code class="language-plaintext highlighter-rouge">ranges</code> library and concepts. All this require some learning, but they can greatly simplify your code.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/books/'>books</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/ranges/" class="post-tag no-text-decoration" >ranges</a> <a href="/tags/concepts/" class="post-tag no-text-decoration" >concepts</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=My first work experience with C++20 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=My first work experience with C++20 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=My first work experience with C++20 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=My first work experience with C++20 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/04/16/raw-loops-for-performance"><div class="card-body"> <span class="timeago small" > Apr 16, 2025 <i class="unloaded">2025-04-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Raw loops for performance?</h3><div class="text-muted small"><p> To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I rai...</p></div></div></a></div><div class="card"> <a href="/blog/2021/02/10/cpp-concepts-motivations"><div class="card-body"> <span class="timeago small" > Feb 10, 2021 <i class="unloaded">2021-02-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The concept behind C++ concepts</h3><div class="text-muted small"><p> The idea of concepts is one of the major new features added to C++20. Concepts are an extension for templates. They can be used to perform compile-time validation of template arguments through bool...</p></div></div></a></div><div class="card"> <a href="/blog/2021/03/24/concepts-in-real-life"><div class="card-body"> <span class="timeago small" > Mar 24, 2021 <i class="unloaded">2021-03-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ concepts in real life</h3><div class="text-muted small"><p> During the last month or so, we examined the ins and outs of C++ concepts. We checked their main motivations, we saw how we can use them with functions, with classes and what kind of concepts are s...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2022/04/06/use-strong-types-instead-booleans" class="btn btn-outline-primary" prompt="Older"><p>Use strong types instead of bool parameters</p></a> <a href="/blog/2022/04/16/beautiful-cpp-by-kate-gregory-and-guy-davidson" class="btn btn-outline-primary" prompt="Newer"><p>Beautiful C++: 30 Core Guidelines for Writing Clean, Safe and Fast Code by J. Guy Davidson and Kate Gregory</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'My first work experience with C++20'; this.page.url = 'https://www.sandordargo.com/blog/2022/04/13/first-company-project-experience-with-cpp20'; this.page.identifier = '/blog/2022/04/13/first-company-project-experience-with-cpp20'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
