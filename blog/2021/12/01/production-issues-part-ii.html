<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="I broke production 3 times in 3 weeks - Part II" /><meta property="og:locale" content="en_US" /><meta name="description" content="Last week I shared with you that despite that I consider myself a careful coder, I managed to break production several times in a row. It can happen to anyone, though one shouldn’t forget about his responsibility leading to such events. We can complain about how useless the test systems are, we can blame the reviewers, but at the end of the day, the code was written by one person. In these cases, by me. Last week, I shared how I slipped and introduced undefined behaviour by not initializing a pointer correctly. Now let’s continue with two other stories, with two other bugs. A memory leak Another issue I introduced was once again about pointers. A very knowledgeable C++ engineer told me recently for a good reason that for dynamic memory management you should always use smart pointers, but it’s even better if you can avoid using dynamic allocations at all. So in one of another monster classes, I found a pointer that was initialized to nullptr in the initializer list, some objects were assigned to it at many different places and at the end, in the destructor, it was not deleted and I couldn’t find where it was cleaned up. A memory leak - unless I missed the cleanup. The pointer was passed to another object several times, it updated the pointed object and then it was taken back. Somehow like this: 1 2 3 4 5 6 7 8 9 10 11 auto aStatus = STATUS::UNDEFINED; auto aService = MyService{}; aService.setAdapter(m_serviceAdapter); try { aStatus = aService.resume(); } catch (std::exception&amp; e) { // ... } // should now contain the right data! m_serviceAdapter = static_cast&lt;MyServiceAdapter*&gt;(aService.getAdapter()); All problems can be avoided by using smart pointers. A very easy option could have been using a shared pointer, but I didn’t want to do it for two reasons: MyService lives in another repository and it takes about a day to change, review and deliver a new version (and this is such a lousy reason!) in most cases where you use a shared pointer, it’s not necessary. It’s simply the easier road to take. I didn’t want to take the easier road. So I went on using a unique pointer, m_serviceAdapter became a std::unique_ptr&lt;MyServiceAdapter&gt; instead of MyServiceAdapter* and I changed the code like this: 1 2 3 4 5 6 7 8 9 10 11 auto aStatus = STATUS::UNDEFINED; auto aService = MyService{}; aService.setAdapter(m_serviceAdapter.release()); // 1 try { aStatus = aService.resume(); } catch (std::exception&amp; e) { // ... } // should now contain the right data! m_serviceAdapter.reset(static_cast&lt;MyServiceAdapter*&gt;(aService.getAdapter())); //2 My reasoning was that at // 1, we don’t want to own the service adapter anymore, we pass the ownership to the service - even if we happen to know that it won’t delete it, it’ll just give back the ownership a few lines later. At step // 2, we just reset the local adapter from the other service’s adapter. All is fine, right? At step 1, we released the ownership and at step 2 we got it back. What can go wrong? What if MyServiceAdapter assigns another pointer without deleting what it got? It’s a memory leak, but it’s a problem in MyServiceAdapter, not at the call place. So we could argue that all is fine. There were about 5-6 functions following the above pattern. But there was another one where there was only the release part, there was no reset. And with this, I clearly introduced a memory leak and it required a fallback! So how it is possible that from a small memory leak we went to a bigger one? That’s something I still don’t understand. I think that with the above change I should have reduced the memory leak because in most cases the pointer got deleted - unlike before. Yet, the stats from production was very clear. The takeaways for this second issue: When it comes to memory management, be extra cautious. Don’t go with half solutions. If you assume you pass ownership, go all way through the chain and fix the whole flow. Use valgrind more to understand better what happens to your allocated memory. Know your tools This last one will be shorter, probably a bit less technical. Do you know this meme? I think this is a great one, and what you can see on the bottom half is actually a quite frequent situation. Why do I say so? You have some piece of code that doesn’t work and you have no idea why. Then you fix it. Do you even think it through? Do you understand why it works? If so, great! But what if not? Do you keep investigating? Or do you simply move on to the next issue? I’m not here to judge. Often, we don’t have time to continue the investigation and we must take things in the pipe. But it has a serious implication. Often, what works will not function because it’s the good solution. I wouldn’t even call it a good enough solution. Sometimes it’s just a brittle repair that happens to work under the given circumstances, but it can break any time. C++ still doesn’t have a build management system that would be the de-facto standard, many companies have their own one, just like us. Therefore I will not go into deep technical details of what happened, but I give you a more high-level view. Some dependencies were grouped into a package and I made the necessary updates in our descriptors. We were already depending on several packages which were pretty much listed in alphabetical order. By the way, the two most important packages happened to be at the beginning of this sorting. So I updated the dependencies, put the package in its alphabetical place, then I ran launched the build and the tests. They were all fine. We loaded into test systems. Nobody raised a word. Later, we loaded into production. People started to complain. We broke our stats collector. We understood quickly that it’s coming from the load so we did a fallback. But what could it be? I was preparing for an important and high-risk change and I didn’t want to mix it with a routine version update, so I performed this version update separately. Even that broke our software? I changed two things: I updated the versions of some of our dependencies And I changed from where we take those exact same dependencies. I checked the release notes, the source code of our dependencies. Nothing. I checked with the maintainers of the package, they had no idea. I checked the documentation of the build management system and it had nothing on the order of the dependencies. But as we were out of ideas, we changed the order and lo and behold, that actually worked. The order of the included dependencies matters when it comes to resolving some non-matching versions. Many things made this investigation more painful than it should have been: the problem was not noticed before the production load, even though it was visible in test already for the users it’s not reproducible in local, so there was only a very limited number of chances to try something new each day the documentation is clearly incomplete on how versions are inferred What are the lessons learned? Things only work by chance more often than you think If you want to grow to the next level, take time to understand your tools If you are unsure about your changes, take baby steps and validate them as soon as possible. Conclusion Often, things are accidentally working and they can break anytime! You can break them with the best intention, even when you think you introduce some changes that you consider technical improvements. I’d go even further, those are the moments when it’s the easiest to break the system; when you are convinced that you are delivering improvements. My advice is to take time to understand what exactly are you doing and don’t be afraid of taking baby steps. The smaller the iterations, the easier it will be to understand and debug. And if shit happens, don’t be discouraged. Keep improving the system! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Last week I shared with you that despite that I consider myself a careful coder, I managed to break production several times in a row. It can happen to anyone, though one shouldn’t forget about his responsibility leading to such events. We can complain about how useless the test systems are, we can blame the reviewers, but at the end of the day, the code was written by one person. In these cases, by me. Last week, I shared how I slipped and introduced undefined behaviour by not initializing a pointer correctly. Now let’s continue with two other stories, with two other bugs. A memory leak Another issue I introduced was once again about pointers. A very knowledgeable C++ engineer told me recently for a good reason that for dynamic memory management you should always use smart pointers, but it’s even better if you can avoid using dynamic allocations at all. So in one of another monster classes, I found a pointer that was initialized to nullptr in the initializer list, some objects were assigned to it at many different places and at the end, in the destructor, it was not deleted and I couldn’t find where it was cleaned up. A memory leak - unless I missed the cleanup. The pointer was passed to another object several times, it updated the pointed object and then it was taken back. Somehow like this: 1 2 3 4 5 6 7 8 9 10 11 auto aStatus = STATUS::UNDEFINED; auto aService = MyService{}; aService.setAdapter(m_serviceAdapter); try { aStatus = aService.resume(); } catch (std::exception&amp; e) { // ... } // should now contain the right data! m_serviceAdapter = static_cast&lt;MyServiceAdapter*&gt;(aService.getAdapter()); All problems can be avoided by using smart pointers. A very easy option could have been using a shared pointer, but I didn’t want to do it for two reasons: MyService lives in another repository and it takes about a day to change, review and deliver a new version (and this is such a lousy reason!) in most cases where you use a shared pointer, it’s not necessary. It’s simply the easier road to take. I didn’t want to take the easier road. So I went on using a unique pointer, m_serviceAdapter became a std::unique_ptr&lt;MyServiceAdapter&gt; instead of MyServiceAdapter* and I changed the code like this: 1 2 3 4 5 6 7 8 9 10 11 auto aStatus = STATUS::UNDEFINED; auto aService = MyService{}; aService.setAdapter(m_serviceAdapter.release()); // 1 try { aStatus = aService.resume(); } catch (std::exception&amp; e) { // ... } // should now contain the right data! m_serviceAdapter.reset(static_cast&lt;MyServiceAdapter*&gt;(aService.getAdapter())); //2 My reasoning was that at // 1, we don’t want to own the service adapter anymore, we pass the ownership to the service - even if we happen to know that it won’t delete it, it’ll just give back the ownership a few lines later. At step // 2, we just reset the local adapter from the other service’s adapter. All is fine, right? At step 1, we released the ownership and at step 2 we got it back. What can go wrong? What if MyServiceAdapter assigns another pointer without deleting what it got? It’s a memory leak, but it’s a problem in MyServiceAdapter, not at the call place. So we could argue that all is fine. There were about 5-6 functions following the above pattern. But there was another one where there was only the release part, there was no reset. And with this, I clearly introduced a memory leak and it required a fallback! So how it is possible that from a small memory leak we went to a bigger one? That’s something I still don’t understand. I think that with the above change I should have reduced the memory leak because in most cases the pointer got deleted - unlike before. Yet, the stats from production was very clear. The takeaways for this second issue: When it comes to memory management, be extra cautious. Don’t go with half solutions. If you assume you pass ownership, go all way through the chain and fix the whole flow. Use valgrind more to understand better what happens to your allocated memory. Know your tools This last one will be shorter, probably a bit less technical. Do you know this meme? I think this is a great one, and what you can see on the bottom half is actually a quite frequent situation. Why do I say so? You have some piece of code that doesn’t work and you have no idea why. Then you fix it. Do you even think it through? Do you understand why it works? If so, great! But what if not? Do you keep investigating? Or do you simply move on to the next issue? I’m not here to judge. Often, we don’t have time to continue the investigation and we must take things in the pipe. But it has a serious implication. Often, what works will not function because it’s the good solution. I wouldn’t even call it a good enough solution. Sometimes it’s just a brittle repair that happens to work under the given circumstances, but it can break any time. C++ still doesn’t have a build management system that would be the de-facto standard, many companies have their own one, just like us. Therefore I will not go into deep technical details of what happened, but I give you a more high-level view. Some dependencies were grouped into a package and I made the necessary updates in our descriptors. We were already depending on several packages which were pretty much listed in alphabetical order. By the way, the two most important packages happened to be at the beginning of this sorting. So I updated the dependencies, put the package in its alphabetical place, then I ran launched the build and the tests. They were all fine. We loaded into test systems. Nobody raised a word. Later, we loaded into production. People started to complain. We broke our stats collector. We understood quickly that it’s coming from the load so we did a fallback. But what could it be? I was preparing for an important and high-risk change and I didn’t want to mix it with a routine version update, so I performed this version update separately. Even that broke our software? I changed two things: I updated the versions of some of our dependencies And I changed from where we take those exact same dependencies. I checked the release notes, the source code of our dependencies. Nothing. I checked with the maintainers of the package, they had no idea. I checked the documentation of the build management system and it had nothing on the order of the dependencies. But as we were out of ideas, we changed the order and lo and behold, that actually worked. The order of the included dependencies matters when it comes to resolving some non-matching versions. Many things made this investigation more painful than it should have been: the problem was not noticed before the production load, even though it was visible in test already for the users it’s not reproducible in local, so there was only a very limited number of chances to try something new each day the documentation is clearly incomplete on how versions are inferred What are the lessons learned? Things only work by chance more often than you think If you want to grow to the next level, take time to understand your tools If you are unsure about your changes, take baby steps and validate them as soon as possible. Conclusion Often, things are accidentally working and they can break anytime! You can break them with the best intention, even when you think you introduce some changes that you consider technical improvements. I’d go even further, those are the moments when it’s the easiest to break the system; when you are convinced that you are delivering improvements. My advice is to take time to understand what exactly are you doing and don’t be afraid of taking baby steps. The smaller the iterations, the easier it will be to understand and debug. And if shit happens, don’t be discouraged. Keep improving the system! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii" /><meta property="og:url" content="https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2021-12-01T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="I broke production 3 times in 3 weeks - Part II" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2021-12-01T00:00:00+01:00","datePublished":"2021-12-01T00:00:00+01:00","description":"Last week I shared with you that despite that I consider myself a careful coder, I managed to break production several times in a row. It can happen to anyone, though one shouldn’t forget about his responsibility leading to such events. We can complain about how useless the test systems are, we can blame the reviewers, but at the end of the day, the code was written by one person. In these cases, by me. Last week, I shared how I slipped and introduced undefined behaviour by not initializing a pointer correctly. Now let’s continue with two other stories, with two other bugs. A memory leak Another issue I introduced was once again about pointers. A very knowledgeable C++ engineer told me recently for a good reason that for dynamic memory management you should always use smart pointers, but it’s even better if you can avoid using dynamic allocations at all. So in one of another monster classes, I found a pointer that was initialized to nullptr in the initializer list, some objects were assigned to it at many different places and at the end, in the destructor, it was not deleted and I couldn’t find where it was cleaned up. A memory leak - unless I missed the cleanup. The pointer was passed to another object several times, it updated the pointed object and then it was taken back. Somehow like this: 1 2 3 4 5 6 7 8 9 10 11 auto aStatus = STATUS::UNDEFINED; auto aService = MyService{}; aService.setAdapter(m_serviceAdapter); try { aStatus = aService.resume(); } catch (std::exception&amp; e) { // ... } // should now contain the right data! m_serviceAdapter = static_cast&lt;MyServiceAdapter*&gt;(aService.getAdapter()); All problems can be avoided by using smart pointers. A very easy option could have been using a shared pointer, but I didn’t want to do it for two reasons: MyService lives in another repository and it takes about a day to change, review and deliver a new version (and this is such a lousy reason!) in most cases where you use a shared pointer, it’s not necessary. It’s simply the easier road to take. I didn’t want to take the easier road. So I went on using a unique pointer, m_serviceAdapter became a std::unique_ptr&lt;MyServiceAdapter&gt; instead of MyServiceAdapter* and I changed the code like this: 1 2 3 4 5 6 7 8 9 10 11 auto aStatus = STATUS::UNDEFINED; auto aService = MyService{}; aService.setAdapter(m_serviceAdapter.release()); // 1 try { aStatus = aService.resume(); } catch (std::exception&amp; e) { // ... } // should now contain the right data! m_serviceAdapter.reset(static_cast&lt;MyServiceAdapter*&gt;(aService.getAdapter())); //2 My reasoning was that at // 1, we don’t want to own the service adapter anymore, we pass the ownership to the service - even if we happen to know that it won’t delete it, it’ll just give back the ownership a few lines later. At step // 2, we just reset the local adapter from the other service’s adapter. All is fine, right? At step 1, we released the ownership and at step 2 we got it back. What can go wrong? What if MyServiceAdapter assigns another pointer without deleting what it got? It’s a memory leak, but it’s a problem in MyServiceAdapter, not at the call place. So we could argue that all is fine. There were about 5-6 functions following the above pattern. But there was another one where there was only the release part, there was no reset. And with this, I clearly introduced a memory leak and it required a fallback! So how it is possible that from a small memory leak we went to a bigger one? That’s something I still don’t understand. I think that with the above change I should have reduced the memory leak because in most cases the pointer got deleted - unlike before. Yet, the stats from production was very clear. The takeaways for this second issue: When it comes to memory management, be extra cautious. Don’t go with half solutions. If you assume you pass ownership, go all way through the chain and fix the whole flow. Use valgrind more to understand better what happens to your allocated memory. Know your tools This last one will be shorter, probably a bit less technical. Do you know this meme? I think this is a great one, and what you can see on the bottom half is actually a quite frequent situation. Why do I say so? You have some piece of code that doesn’t work and you have no idea why. Then you fix it. Do you even think it through? Do you understand why it works? If so, great! But what if not? Do you keep investigating? Or do you simply move on to the next issue? I’m not here to judge. Often, we don’t have time to continue the investigation and we must take things in the pipe. But it has a serious implication. Often, what works will not function because it’s the good solution. I wouldn’t even call it a good enough solution. Sometimes it’s just a brittle repair that happens to work under the given circumstances, but it can break any time. C++ still doesn’t have a build management system that would be the de-facto standard, many companies have their own one, just like us. Therefore I will not go into deep technical details of what happened, but I give you a more high-level view. Some dependencies were grouped into a package and I made the necessary updates in our descriptors. We were already depending on several packages which were pretty much listed in alphabetical order. By the way, the two most important packages happened to be at the beginning of this sorting. So I updated the dependencies, put the package in its alphabetical place, then I ran launched the build and the tests. They were all fine. We loaded into test systems. Nobody raised a word. Later, we loaded into production. People started to complain. We broke our stats collector. We understood quickly that it’s coming from the load so we did a fallback. But what could it be? I was preparing for an important and high-risk change and I didn’t want to mix it with a routine version update, so I performed this version update separately. Even that broke our software? I changed two things: I updated the versions of some of our dependencies And I changed from where we take those exact same dependencies. I checked the release notes, the source code of our dependencies. Nothing. I checked with the maintainers of the package, they had no idea. I checked the documentation of the build management system and it had nothing on the order of the dependencies. But as we were out of ideas, we changed the order and lo and behold, that actually worked. The order of the included dependencies matters when it comes to resolving some non-matching versions. Many things made this investigation more painful than it should have been: the problem was not noticed before the production load, even though it was visible in test already for the users it’s not reproducible in local, so there was only a very limited number of chances to try something new each day the documentation is clearly incomplete on how versions are inferred What are the lessons learned? Things only work by chance more often than you think If you want to grow to the next level, take time to understand your tools If you are unsure about your changes, take baby steps and validate them as soon as possible. Conclusion Often, things are accidentally working and they can break anytime! You can break them with the best intention, even when you think you introduce some changes that you consider technical improvements. I’d go even further, those are the moments when it’s the easiest to break the system; when you are convinced that you are delivering improvements. My advice is to take time to understand what exactly are you doing and don’t be afraid of taking baby steps. The smaller the iterations, the easier it will be to understand and debug. And if shit happens, don’t be discouraged. Keep improving the system! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"I broke production 3 times in 3 weeks - Part II","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii"},"url":"https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii"}</script><title>I broke production 3 times in 3 weeks - Part II | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2021"> 2021 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/01"> 01 </a> </span> <span>I broke production 3 times in 3 weeks - Part II</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>I broke production 3 times in 3 weeks - Part II</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 1, 2021, 12:00 AM +0100" prep="on" > Dec 1, 2021 <i class="unloaded">2021-12-01T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1377 words">7 min</span></div></div><div class="post-content"><p>Last week I shared with you that despite that I consider myself a careful coder, <a href="https://www.sandordargo.com/blog/2021/11/24/production-issues-part-i-undefined-behaviour">I managed to break production several times in a row</a>.</p><p>It can happen to anyone, though one shouldn’t forget about his responsibility leading to such events.</p><p>We can complain about how useless the test systems are, we can blame the reviewers, but at the end of the day, the code was written by one person. In these cases, by me.</p><p>Last week, I shared how I slipped and introduced undefined behaviour by not initializing a pointer correctly. Now let’s continue with two other stories, with two other bugs.</p><h2 id="a-memory-leak">A memory leak</h2><p>Another issue I introduced was once again about pointers. A very knowledgeable C++ engineer told me recently for a good reason that for dynamic memory management you should always use smart pointers, but it’s even better if you can avoid using dynamic allocations at all.</p><p>So in one of another monster classes, I found a pointer that was initialized to <code class="language-plaintext highlighter-rouge">nullptr</code> in the initializer list, some objects were assigned to it at many different places and at the end, in the destructor, it was not deleted and I couldn’t find where it was cleaned up. A memory leak - unless I missed the cleanup.</p><p>The pointer was passed to another object several times, it updated the pointed object and then it was taken back.</p><p>Somehow like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">aStatus</span> <span class="o">=</span> <span class="n">STATUS</span><span class="o">::</span><span class="n">UNDEFINED</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">aService</span> <span class="o">=</span> <span class="n">MyService</span><span class="p">{};</span>
<span class="n">aService</span><span class="p">.</span><span class="n">setAdapter</span><span class="p">(</span><span class="n">m_serviceAdapter</span><span class="p">);</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">aStatus</span> <span class="o">=</span> <span class="n">aService</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// should now contain the right data!</span>
<span class="n">m_serviceAdapter</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyServiceAdapter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">aService</span><span class="p">.</span><span class="n">getAdapter</span><span class="p">());</span>
</pre></table></code></div></div><p>All problems can be avoided by using smart pointers.</p><p>A very easy option could have been using a shared pointer, but I didn’t want to do it for two reasons:</p><ul><li><code class="language-plaintext highlighter-rouge">MyService</code> lives in another repository and it takes about a day to change, review and deliver a new version (and this is such a lousy reason!)<li>in most cases where you use a shared pointer, it’s not necessary. It’s simply the easier road to take. I didn’t want to take the easier road.</ul><p>So I went on using a unique pointer, <code class="language-plaintext highlighter-rouge">m_serviceAdapter</code> became a <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;MyServiceAdapter&gt;</code> instead of <code class="language-plaintext highlighter-rouge">MyServiceAdapter*</code> and I changed the code like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">aStatus</span> <span class="o">=</span> <span class="n">STATUS</span><span class="o">::</span><span class="n">UNDEFINED</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">aService</span> <span class="o">=</span> <span class="n">MyService</span><span class="p">{};</span>
<span class="n">aService</span><span class="p">.</span><span class="n">setAdapter</span><span class="p">(</span><span class="n">m_serviceAdapter</span><span class="p">.</span><span class="n">release</span><span class="p">());</span> <span class="c1">// 1</span>
<span class="k">try</span> <span class="p">{</span>
  <span class="n">aStatus</span> <span class="o">=</span> <span class="n">aService</span><span class="p">.</span><span class="n">resume</span><span class="p">();</span>
<span class="p">}</span>
<span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">exception</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
<span class="c1">// should now contain the right data!</span>
<span class="n">m_serviceAdapter</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">MyServiceAdapter</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">aService</span><span class="p">.</span><span class="n">getAdapter</span><span class="p">()));</span> <span class="c1">//2</span>
</pre></table></code></div></div><p>My reasoning was that at <code class="language-plaintext highlighter-rouge">// 1</code>, we don’t want to own the service adapter anymore, we pass the ownership to the service - even if we happen to know that it won’t delete it, it’ll just give back the ownership a few lines later.</p><p>At step <code class="language-plaintext highlighter-rouge">// 2</code>, we just reset the local adapter from the other service’s adapter. All is fine, right?</p><p>At step 1, we released the ownership and at step 2 we got it back.</p><p>What can go wrong?</p><p>What if <code class="language-plaintext highlighter-rouge">MyServiceAdapter</code> assigns another pointer without deleting what it got? It’s a memory leak, but it’s a problem in <code class="language-plaintext highlighter-rouge">MyServiceAdapter</code>, not at the call place.</p><p>So we could argue that all is fine.</p><p>There were about 5-6 functions following the above pattern. But there was another one where there was only the release part, there was no reset.</p><p>And with this, I clearly introduced a memory leak and it required a fallback!</p><p>So how it is possible that from a small memory leak we went to a bigger one?</p><p>That’s something I still don’t understand. I think that with the above change I should have reduced the memory leak because in most cases the pointer got deleted - unlike before. Yet, the stats from production was very clear.</p><p>The takeaways for this second issue:</p><ul><li>When it comes to memory management, be extra cautious.<li>Don’t go with half solutions. If you assume you pass ownership, go all way through the chain and fix the whole flow.<li>Use valgrind more to understand better what happens to your allocated memory.</ul><h2 id="know-your-tools">Know your tools</h2><p>This last one will be shorter, probably a bit less technical. Do you know this meme?</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/works-doesnt-work.jpg" alt="Works - does not work" /></p><p>I think this is a great one, and what you can see on the bottom half is actually a quite frequent situation.</p><p>Why do I say so?</p><p>You have some piece of code that doesn’t work and you have no idea why. Then you fix it.</p><ul><li>Do you even think it through? Do you understand why it works?<li>If so, great! But what if not? Do you keep investigating? Or do you simply move on to the next issue?</ul><p>I’m not here to judge. Often, we don’t have time to continue the investigation and we must take things in the pipe. But it has a serious implication.</p><p>Often, what works will not function because it’s the good solution. I wouldn’t even call it a good enough solution. Sometimes it’s just a brittle repair that happens to work under the given circumstances, but it can break any time.</p><p>C++ still doesn’t have a build management system that would be the de-facto standard, many companies have their own one, just like us. Therefore I will not go into deep technical details of what happened, but I give you a more high-level view.</p><p>Some dependencies were grouped into a package and I made the necessary updates in our descriptors. We were already depending on several packages which were pretty much listed in alphabetical order. By the way, the two most important packages happened to be at the beginning of this sorting.</p><p>So I updated the dependencies, put the package in its alphabetical place, then I ran launched the build and the tests. They were all fine.</p><p>We loaded into test systems. Nobody raised a word.</p><p>Later, we loaded into production. People started to complain.</p><p>We broke our stats collector.</p><p>We understood quickly that it’s coming from the load so we did a fallback. But what could it be?</p><p>I was preparing for an important and high-risk change and I didn’t want to mix it with a routine version update, so I performed this version update separately.</p><p>Even that broke our software?</p><p>I changed two things:</p><ul><li>I updated the versions of some of our dependencies<li>And I changed from where we take those exact same dependencies.</ul><p>I checked the release notes, the source code of our dependencies. Nothing.</p><p>I checked with the maintainers of the package, they had no idea.</p><p>I checked the documentation of the build management system and it had nothing on the order of the dependencies.</p><p>But as we were out of ideas, we changed the order and lo and behold, that actually worked.</p><p>The order of the included dependencies matters when it comes to resolving some non-matching versions.</p><p>Many things made this investigation more painful than it should have been:</p><ul><li>the problem was not noticed before the production load, even though it was visible in test already for the users<li>it’s not reproducible in local, so there was only a very limited number of chances to try something new each day<li>the documentation is clearly incomplete on how versions are inferred</ul><p>What are the lessons learned?</p><ul><li>Things only work by chance more often than you think<li>If you want to grow to the next level, take time to understand your tools<li>If you are unsure about your changes, take baby steps and validate them as soon as possible.</ul><h2 id="conclusion">Conclusion</h2><p>Often, things are accidentally working and they can break anytime! You can break them with the best intention, even when you think you introduce some changes that you consider technical improvements. I’d go even further, those are the moments when it’s the easiest to break the system; when you are convinced that you are delivering improvements.</p><p>My advice is to take time to understand what exactly are you doing and don’t be afraid of taking baby steps. The smaller the iterations, the easier it will be to understand and debug.</p><p>And if shit happens, don’t be discouraged. Keep improving the system!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/virtual/" class="post-tag no-text-decoration" >virtual</a> <a href="/tags/pointers/" class="post-tag no-text-decoration" >pointers</a> <a href="/tags/dependencies/" class="post-tag no-text-decoration" >dependencies</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=I broke production 3 times in 3 weeks - Part II - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=I broke production 3 times in 3 weeks - Part II - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=I broke production 3 times in 3 weeks - Part II - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=I broke production 3 times in 3 weeks - Part II - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2021/11/24/production-issues-part-i-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Nov 24, 2021 <i class="unloaded">2021-11-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>I broke production 3 times in 3 weeks - Part I</h3><div class="text-muted small"><p> Are you a careful coder who barely introduces errors? How do you feel when still manage to bring production down? You might feel horrible, but I think you should take it as an opportunity. You can...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/12/builds-and-dependencies"><div class="card-body"> <span class="timeago small" > Jun 12, 2024 <i class="unloaded">2024-06-12T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Limit the number of library dependencies</h3><div class="text-muted small"><p> First, let’s discuss what a dependency is. When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about dependency inj...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2021/11/27/courage-is-calling-ryan-holiday" class="btn btn-outline-primary" prompt="Older"><p>Courage Is Calling: Fortune Favors The Brave by Ryan Holiday</p></a> <a href="/blog/2021/12/08/top-7-reasons-to-change-a-team" class="btn btn-outline-primary" prompt="Newer"><p>Top 7 reasons to join another team</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'I broke production 3 times in 3 weeks - Part II'; this.page.url = 'https://www.sandordargo.com/blog/2021/12/01/production-issues-part-ii'; this.page.identifier = '/blog/2021/12/01/production-issues-part-ii'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
