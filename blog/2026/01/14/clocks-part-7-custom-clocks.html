<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Time in C++: Creating Your Own Clocks with &lt;chrono&gt;" /><meta property="og:locale" content="en_US" /><meta name="description" content="In earlier articles of this series, we walked through the foundations of &lt;chrono&gt;, explored the essential clocks (system_clock, steady_clock, high_resolution_clock), and even looked at the extra clocks introduced in C++20 — not to mention why converting between clocks is trickier than it seems. Today, we’ll shift gears a bit: what if the clock you need… doesn’t exist? C++ lets you build your own clocks. And it’s surprisingly approachable. Custom clocks aren’t just a fun experiment — they’re genuinely useful in simulations, testing, deterministic workflows, and anywhere you’re not fully satisfied with how time is provided by the operating system. Let’s dive in. Why Would You Want a Custom Clock? Most applications happily rely on system_clock or steady_clock. But sometimes, real time is the wrong tool: Testing You don’t want your unit tests sleeping for 200 ms or relying on the host system’s clock. A fake clock lets you explicitly control time, freeze it, fast-forward it, or make it deterministic. Simulations and Virtual Time Game engines, physics simulations, backtesting systems, and distributed systems often operate on virtual time where you choose when time increases. Replaying Events Maybe you’re analyzing logs or reproducing a bug. A replay clock can step through events using their original timestamps. External Time Sources Some systems pull time from hardware sensors, an external server, a GPS unit, or a custom synchronization source. Wrapping that in a custom clock makes the rest of your system oblivious to how time is obtained. In short: if your program’s notion of time isn’t the computer’s notion of time, you probably want a custom clock. What Makes a Clock a “Clock” in &lt;chrono&gt;? To be a proper Clock according to the C++ standard, a type must satisfy a very small interface. You’ve already met these in earlier posts, but here they are explicitly: A Clock must define: rep — the underlying representation type (e.g., std::int64_t) period — a std::ratio describing tick duration duration — an alias for std::chrono::duration&lt;rep, period&gt; time_point — an alias for std::chrono::time_point&lt;Clock&gt; static time_point now() noexcept; — returning the current time is_steady — true if the clock never goes backwards That’s it! A clock in C++ is just a thin struct with a few typedefs and one static function. You can always check if a type satisfies the clock requirements with the help of the std::chrono::is_clock type trait. A Simple Example: A Manually-Advanced Clock Let’s build the simplest meaningful custom clock: a clock whose time only moves when we tell it to. A clock you might use for testing of simulations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://godbolt.org/z/Keq1xxv37 #include &lt;chrono&gt; #include &lt;cstdint&gt; #include &lt;iostream&gt; class ManualClock { public: using rep = std::int64_t; using period = std::nano; using duration = std::chrono::duration&lt;rep, period&gt;; using time_point = std::chrono::time_point&lt;ManualClock&gt;; static time_point now() noexcept { return time_point(current_time); } static constexpr bool is_steady = true; static void advance(duration d) noexcept { current_time += d; } private: static inline time_point current_time{duration{0}}; }; static_assert(std::chrono::is_clock_v&lt;ManualClock&gt;); Notice how one by one we satisfy the requirements listed above. And now let’s use it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // https://godbolt.org/z/Keq1xxv37 // ... int main() { using namespace std::chrono_literals; ManualClock::advance(500ms); auto t1 = ManualClock::now(); ManualClock::advance(200ms); auto t2 = ManualClock::now(); std::cout &lt;&lt; (t2 - t1).count() &lt;&lt; &quot; ns\n&quot;; return 0; } This prints 200000000 ns — because you decided how time flows. Also notice that custom clocks integrate seamlessly with &lt;chrono&gt; types because they follow the same contract as the built-in ones. You can check the full example on Compiler Exlorer. Interoperability with Standard Clocks Earlier in this series, we talked about inter-clock conversions and how the C++ standard deliberately avoids providing implicit conversions between clock epochs. That same rule applies to your clocks. There is no automatic conversion between standard clocks and your custom clock. If you want meaningful conversions, you must define how your clock relates to another: Does it follow system_clock with some offset? Does it map to real time at all? Is its epoch aligned with Unix epoch or something arbitrary? You might define a relationship like this: 1 2 3 4 5 6 7 8 auto system_now = std::chrono::system_clock::now(); auto manual_now = manual_clock::now(); auto offset = system_now.time_since_epoch() - manual_now.time_since_epoch(); // later... auto estimated_system_time = manual_t + offset; But as discussed in the earlier article on converting between clocks: this only works as long as both clocks behave as you expect, and one of them (usually system_clock) doesn’t jump. With your own clocks, you control the behavior — so you get to define the rules. A More Realistic Example: A Scaling Clock Here’s a playful clock that runs faster or slower than real time: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // https://godbolt.org/z/639zjsbd8 #include &lt;chrono&gt; #include &lt;cstdint&gt; struct ScaledClock { using rep = std::int64_t; using period = std::nano; using duration = std::chrono::duration&lt;rep, period&gt;; using time_point = std::chrono::time_point&lt;ScaledClock&gt;; static time_point now() noexcept { auto real = std::chrono::steady_clock::now().time_since_epoch(); // Convert to this clock&#39;s duration type (nanoseconds with int64_t) auto real_in_duration = std::chrono::duration_cast&lt;duration&gt;(real); // Scale the count as double, then cast back to rep double scaled_count = static_cast&lt;double&gt;(real_in_duration.count()) * multiplier; return time_point{duration{static_cast&lt;rep&gt;(scaled_count)}}; } static constexpr bool is_steady = false; static void set_speed(double mul) { multiplier = mul; } private: static inline double multiplier{1.0}; }; static_assert(std::chrono::is_clock_v&lt;ScaledClock&gt;); int main() { return 0; } A clock like this can simulate slow-motion or time dilation effects in games, animations, or test scenarios. Practical Advice for Designing Custom Clocks Keep epochs consistent: If your clock relates to real time at all, decide clearly how its epoch aligns with system_clock. Think about thread safety: Clocks are accessed globally — ensure your clock behaves well under concurrency. Something I usually ignore on the blog to keep examples fairly simple. Consider is_steady carefully: If your clock can jump, set is_steady = false. Don’t reinvent the wheel: If you’re only trying to mock time in tests, libraries like GoogleTest offer helpers — but custom clocks offer the ultimate flexibility. Conclusion Standard clocks take you far, and in earlier articles we’ve seen how powerful they are for measuring durations, producing timestamps, and handling real-world time scales like UTC and TAI. But sometimes real time isn’t the right time. Custom clocks let you: simulate, test, control, and bend time to your will. They’re surprisingly simple to implement and plug neatly into the &lt;chrono&gt; ecosystem with almost no plumbing. In the next part of this series, we’ll continue exploring how to build robust time abstractions on top of &lt;chrono&gt;, including adapters, wrappers, and patterns for safer time handling. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In earlier articles of this series, we walked through the foundations of &lt;chrono&gt;, explored the essential clocks (system_clock, steady_clock, high_resolution_clock), and even looked at the extra clocks introduced in C++20 — not to mention why converting between clocks is trickier than it seems. Today, we’ll shift gears a bit: what if the clock you need… doesn’t exist? C++ lets you build your own clocks. And it’s surprisingly approachable. Custom clocks aren’t just a fun experiment — they’re genuinely useful in simulations, testing, deterministic workflows, and anywhere you’re not fully satisfied with how time is provided by the operating system. Let’s dive in. Why Would You Want a Custom Clock? Most applications happily rely on system_clock or steady_clock. But sometimes, real time is the wrong tool: Testing You don’t want your unit tests sleeping for 200 ms or relying on the host system’s clock. A fake clock lets you explicitly control time, freeze it, fast-forward it, or make it deterministic. Simulations and Virtual Time Game engines, physics simulations, backtesting systems, and distributed systems often operate on virtual time where you choose when time increases. Replaying Events Maybe you’re analyzing logs or reproducing a bug. A replay clock can step through events using their original timestamps. External Time Sources Some systems pull time from hardware sensors, an external server, a GPS unit, or a custom synchronization source. Wrapping that in a custom clock makes the rest of your system oblivious to how time is obtained. In short: if your program’s notion of time isn’t the computer’s notion of time, you probably want a custom clock. What Makes a Clock a “Clock” in &lt;chrono&gt;? To be a proper Clock according to the C++ standard, a type must satisfy a very small interface. You’ve already met these in earlier posts, but here they are explicitly: A Clock must define: rep — the underlying representation type (e.g., std::int64_t) period — a std::ratio describing tick duration duration — an alias for std::chrono::duration&lt;rep, period&gt; time_point — an alias for std::chrono::time_point&lt;Clock&gt; static time_point now() noexcept; — returning the current time is_steady — true if the clock never goes backwards That’s it! A clock in C++ is just a thin struct with a few typedefs and one static function. You can always check if a type satisfies the clock requirements with the help of the std::chrono::is_clock type trait. A Simple Example: A Manually-Advanced Clock Let’s build the simplest meaningful custom clock: a clock whose time only moves when we tell it to. A clock you might use for testing of simulations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://godbolt.org/z/Keq1xxv37 #include &lt;chrono&gt; #include &lt;cstdint&gt; #include &lt;iostream&gt; class ManualClock { public: using rep = std::int64_t; using period = std::nano; using duration = std::chrono::duration&lt;rep, period&gt;; using time_point = std::chrono::time_point&lt;ManualClock&gt;; static time_point now() noexcept { return time_point(current_time); } static constexpr bool is_steady = true; static void advance(duration d) noexcept { current_time += d; } private: static inline time_point current_time{duration{0}}; }; static_assert(std::chrono::is_clock_v&lt;ManualClock&gt;); Notice how one by one we satisfy the requirements listed above. And now let’s use it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // https://godbolt.org/z/Keq1xxv37 // ... int main() { using namespace std::chrono_literals; ManualClock::advance(500ms); auto t1 = ManualClock::now(); ManualClock::advance(200ms); auto t2 = ManualClock::now(); std::cout &lt;&lt; (t2 - t1).count() &lt;&lt; &quot; ns\n&quot;; return 0; } This prints 200000000 ns — because you decided how time flows. Also notice that custom clocks integrate seamlessly with &lt;chrono&gt; types because they follow the same contract as the built-in ones. You can check the full example on Compiler Exlorer. Interoperability with Standard Clocks Earlier in this series, we talked about inter-clock conversions and how the C++ standard deliberately avoids providing implicit conversions between clock epochs. That same rule applies to your clocks. There is no automatic conversion between standard clocks and your custom clock. If you want meaningful conversions, you must define how your clock relates to another: Does it follow system_clock with some offset? Does it map to real time at all? Is its epoch aligned with Unix epoch or something arbitrary? You might define a relationship like this: 1 2 3 4 5 6 7 8 auto system_now = std::chrono::system_clock::now(); auto manual_now = manual_clock::now(); auto offset = system_now.time_since_epoch() - manual_now.time_since_epoch(); // later... auto estimated_system_time = manual_t + offset; But as discussed in the earlier article on converting between clocks: this only works as long as both clocks behave as you expect, and one of them (usually system_clock) doesn’t jump. With your own clocks, you control the behavior — so you get to define the rules. A More Realistic Example: A Scaling Clock Here’s a playful clock that runs faster or slower than real time: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // https://godbolt.org/z/639zjsbd8 #include &lt;chrono&gt; #include &lt;cstdint&gt; struct ScaledClock { using rep = std::int64_t; using period = std::nano; using duration = std::chrono::duration&lt;rep, period&gt;; using time_point = std::chrono::time_point&lt;ScaledClock&gt;; static time_point now() noexcept { auto real = std::chrono::steady_clock::now().time_since_epoch(); // Convert to this clock&#39;s duration type (nanoseconds with int64_t) auto real_in_duration = std::chrono::duration_cast&lt;duration&gt;(real); // Scale the count as double, then cast back to rep double scaled_count = static_cast&lt;double&gt;(real_in_duration.count()) * multiplier; return time_point{duration{static_cast&lt;rep&gt;(scaled_count)}}; } static constexpr bool is_steady = false; static void set_speed(double mul) { multiplier = mul; } private: static inline double multiplier{1.0}; }; static_assert(std::chrono::is_clock_v&lt;ScaledClock&gt;); int main() { return 0; } A clock like this can simulate slow-motion or time dilation effects in games, animations, or test scenarios. Practical Advice for Designing Custom Clocks Keep epochs consistent: If your clock relates to real time at all, decide clearly how its epoch aligns with system_clock. Think about thread safety: Clocks are accessed globally — ensure your clock behaves well under concurrency. Something I usually ignore on the blog to keep examples fairly simple. Consider is_steady carefully: If your clock can jump, set is_steady = false. Don’t reinvent the wheel: If you’re only trying to mock time in tests, libraries like GoogleTest offer helpers — but custom clocks offer the ultimate flexibility. Conclusion Standard clocks take you far, and in earlier articles we’ve seen how powerful they are for measuring durations, producing timestamps, and handling real-world time scales like UTC and TAI. But sometimes real time isn’t the right time. Custom clocks let you: simulate, test, control, and bend time to your will. They’re surprisingly simple to implement and plug neatly into the &lt;chrono&gt; ecosystem with almost no plumbing. In the next part of this series, we’ll continue exploring how to build robust time abstractions on top of &lt;chrono&gt;, including adapters, wrappers, and patterns for safer time handling. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks" /><meta property="og:url" content="https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-01-14T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Time in C++: Creating Your Own Clocks with &lt;chrono&gt;" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-14T14:04:40+01:00","datePublished":"2026-01-14T00:00:00+01:00","description":"In earlier articles of this series, we walked through the foundations of &lt;chrono&gt;, explored the essential clocks (system_clock, steady_clock, high_resolution_clock), and even looked at the extra clocks introduced in C++20 — not to mention why converting between clocks is trickier than it seems. Today, we’ll shift gears a bit: what if the clock you need… doesn’t exist? C++ lets you build your own clocks. And it’s surprisingly approachable. Custom clocks aren’t just a fun experiment — they’re genuinely useful in simulations, testing, deterministic workflows, and anywhere you’re not fully satisfied with how time is provided by the operating system. Let’s dive in. Why Would You Want a Custom Clock? Most applications happily rely on system_clock or steady_clock. But sometimes, real time is the wrong tool: Testing You don’t want your unit tests sleeping for 200 ms or relying on the host system’s clock. A fake clock lets you explicitly control time, freeze it, fast-forward it, or make it deterministic. Simulations and Virtual Time Game engines, physics simulations, backtesting systems, and distributed systems often operate on virtual time where you choose when time increases. Replaying Events Maybe you’re analyzing logs or reproducing a bug. A replay clock can step through events using their original timestamps. External Time Sources Some systems pull time from hardware sensors, an external server, a GPS unit, or a custom synchronization source. Wrapping that in a custom clock makes the rest of your system oblivious to how time is obtained. In short: if your program’s notion of time isn’t the computer’s notion of time, you probably want a custom clock. What Makes a Clock a “Clock” in &lt;chrono&gt;? To be a proper Clock according to the C++ standard, a type must satisfy a very small interface. You’ve already met these in earlier posts, but here they are explicitly: A Clock must define: rep — the underlying representation type (e.g., std::int64_t) period — a std::ratio describing tick duration duration — an alias for std::chrono::duration&lt;rep, period&gt; time_point — an alias for std::chrono::time_point&lt;Clock&gt; static time_point now() noexcept; — returning the current time is_steady — true if the clock never goes backwards That’s it! A clock in C++ is just a thin struct with a few typedefs and one static function. You can always check if a type satisfies the clock requirements with the help of the std::chrono::is_clock type trait. A Simple Example: A Manually-Advanced Clock Let’s build the simplest meaningful custom clock: a clock whose time only moves when we tell it to. A clock you might use for testing of simulations: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 // https://godbolt.org/z/Keq1xxv37 #include &lt;chrono&gt; #include &lt;cstdint&gt; #include &lt;iostream&gt; class ManualClock { public: using rep = std::int64_t; using period = std::nano; using duration = std::chrono::duration&lt;rep, period&gt;; using time_point = std::chrono::time_point&lt;ManualClock&gt;; static time_point now() noexcept { return time_point(current_time); } static constexpr bool is_steady = true; static void advance(duration d) noexcept { current_time += d; } private: static inline time_point current_time{duration{0}}; }; static_assert(std::chrono::is_clock_v&lt;ManualClock&gt;); Notice how one by one we satisfy the requirements listed above. And now let’s use it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 // https://godbolt.org/z/Keq1xxv37 // ... int main() { using namespace std::chrono_literals; ManualClock::advance(500ms); auto t1 = ManualClock::now(); ManualClock::advance(200ms); auto t2 = ManualClock::now(); std::cout &lt;&lt; (t2 - t1).count() &lt;&lt; &quot; ns\\n&quot;; return 0; } This prints 200000000 ns — because you decided how time flows. Also notice that custom clocks integrate seamlessly with &lt;chrono&gt; types because they follow the same contract as the built-in ones. You can check the full example on Compiler Exlorer. Interoperability with Standard Clocks Earlier in this series, we talked about inter-clock conversions and how the C++ standard deliberately avoids providing implicit conversions between clock epochs. That same rule applies to your clocks. There is no automatic conversion between standard clocks and your custom clock. If you want meaningful conversions, you must define how your clock relates to another: Does it follow system_clock with some offset? Does it map to real time at all? Is its epoch aligned with Unix epoch or something arbitrary? You might define a relationship like this: 1 2 3 4 5 6 7 8 auto system_now = std::chrono::system_clock::now(); auto manual_now = manual_clock::now(); auto offset = system_now.time_since_epoch() - manual_now.time_since_epoch(); // later... auto estimated_system_time = manual_t + offset; But as discussed in the earlier article on converting between clocks: this only works as long as both clocks behave as you expect, and one of them (usually system_clock) doesn’t jump. With your own clocks, you control the behavior — so you get to define the rules. A More Realistic Example: A Scaling Clock Here’s a playful clock that runs faster or slower than real time: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // https://godbolt.org/z/639zjsbd8 #include &lt;chrono&gt; #include &lt;cstdint&gt; struct ScaledClock { using rep = std::int64_t; using period = std::nano; using duration = std::chrono::duration&lt;rep, period&gt;; using time_point = std::chrono::time_point&lt;ScaledClock&gt;; static time_point now() noexcept { auto real = std::chrono::steady_clock::now().time_since_epoch(); // Convert to this clock&#39;s duration type (nanoseconds with int64_t) auto real_in_duration = std::chrono::duration_cast&lt;duration&gt;(real); // Scale the count as double, then cast back to rep double scaled_count = static_cast&lt;double&gt;(real_in_duration.count()) * multiplier; return time_point{duration{static_cast&lt;rep&gt;(scaled_count)}}; } static constexpr bool is_steady = false; static void set_speed(double mul) { multiplier = mul; } private: static inline double multiplier{1.0}; }; static_assert(std::chrono::is_clock_v&lt;ScaledClock&gt;); int main() { return 0; } A clock like this can simulate slow-motion or time dilation effects in games, animations, or test scenarios. Practical Advice for Designing Custom Clocks Keep epochs consistent: If your clock relates to real time at all, decide clearly how its epoch aligns with system_clock. Think about thread safety: Clocks are accessed globally — ensure your clock behaves well under concurrency. Something I usually ignore on the blog to keep examples fairly simple. Consider is_steady carefully: If your clock can jump, set is_steady = false. Don’t reinvent the wheel: If you’re only trying to mock time in tests, libraries like GoogleTest offer helpers — but custom clocks offer the ultimate flexibility. Conclusion Standard clocks take you far, and in earlier articles we’ve seen how powerful they are for measuring durations, producing timestamps, and handling real-world time scales like UTC and TAI. But sometimes real time isn’t the right time. Custom clocks let you: simulate, test, control, and bend time to your will. They’re surprisingly simple to implement and plug neatly into the &lt;chrono&gt; ecosystem with almost no plumbing. In the next part of this series, we’ll continue exploring how to build robust time abstractions on top of &lt;chrono&gt;, including adapters, wrappers, and patterns for safer time handling. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Time in C++: Creating Your Own Clocks with &lt;chrono&gt;","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks"},"url":"https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks"}</script><title>Time in C++: Creating Your Own Clocks with &lt;chrono&gt; | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2026"> 2026 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/14"> 14 </a> </span> <span>Time in C++: Creating Your Own Clocks with &lt;chrono&gt;</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Time in C++: Creating Your Own Clocks with &lt;chrono&gt;</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 14, 2026, 12:00 AM +0100" prep="on" > Jan 14 <i class="unloaded">2026-01-14T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 14, 2026, 2:04 PM +0100" prefix="Updated " > Jan 14 <i class="unloaded">2026-01-14T14:04:40+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1156 words">6 min</span></div></div><div class="post-content"><p>In earlier articles of this series, <a href="https://www.sandordargo.com/blog/2025/11/19/clocks-part-1-intro-to-chrono">we walked through the foundations of <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code></a>, explored the essential clocks (<a href="https://www.sandordargo.com/blog/2025/11/26/clocks-part-2-system_clock">system_clock</a>, <a href="https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock">steady_clock</a>, <a href="https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock">high_resolution_clock</a>), and even looked at <a href="https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock">the extra clocks introduced in C++20</a> — not to mention why <a href="https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions">converting between clocks</a> is trickier than it seems.</p><p>Today, we’ll shift gears a bit: what if the clock you need… doesn’t exist?</p><p>C++ lets you build your own clocks. And it’s surprisingly approachable.</p><p>Custom clocks aren’t just a fun experiment — they’re genuinely useful in simulations, testing, deterministic workflows, and anywhere you’re not fully satisfied with how time is provided by the operating system.</p><p>Let’s dive in.</p><h2 id="why-would-you-want-a-custom-clock">Why Would You Want a Custom Clock?</h2><p>Most applications happily rely on <code class="language-plaintext highlighter-rouge">system_clock</code> or <code class="language-plaintext highlighter-rouge">steady_clock</code>. But sometimes, real time is the wrong tool:</p><p><strong>Testing</strong></p><p>You don’t want your unit tests sleeping for 200 ms or relying on the host system’s clock. A fake clock lets you explicitly control time, freeze it, fast-forward it, or make it deterministic.</p><p><strong>Simulations and Virtual Time</strong></p><p>Game engines, physics simulations, backtesting systems, and distributed systems often operate on virtual time where you choose when time increases.</p><p><strong>Replaying Events</strong></p><p>Maybe you’re analyzing logs or reproducing a bug. A replay clock can step through events using their original timestamps.</p><p><strong>External Time Sources</strong></p><p>Some systems pull time from hardware sensors, an external server, a GPS unit, or a custom synchronization source. Wrapping that in a custom clock makes the rest of your system oblivious to how time is obtained.</p><p>In short: <strong>if your program’s notion of time isn’t the computer’s notion of time, you probably want a custom clock.</strong></p><h2 id="what-makes-a-clock-a-clock-in-chrono">What Makes a Clock a “Clock” in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code>?</h2><p>To be a proper <em>Clock</em> according to the C++ standard, a type must satisfy a very small interface. You’ve already met these in earlier posts, but here they are explicitly:</p><p>A Clock must define:</p><ul><li><code class="language-plaintext highlighter-rouge">rep</code> — the underlying representation type (e.g., <code class="language-plaintext highlighter-rouge">std::int64_t</code>)<li><code class="language-plaintext highlighter-rouge">period</code> — a <code class="language-plaintext highlighter-rouge">std::ratio</code> describing tick duration<li><code class="language-plaintext highlighter-rouge">duration</code> — an alias for <code class="language-plaintext highlighter-rouge">std::chrono::duration&lt;rep, period&gt;</code><li><code class="language-plaintext highlighter-rouge">time_point</code> — an alias for <code class="language-plaintext highlighter-rouge">std::chrono::time_point&lt;Clock&gt;</code><li><code class="language-plaintext highlighter-rouge">static time_point now() noexcept</code>; — returning the current time<li><code class="language-plaintext highlighter-rouge">is_steady</code> — <code class="language-plaintext highlighter-rouge">true</code> if the clock never goes backwards</ul><p>That’s it! A clock in C++ is just a thin struct with a few typedefs and one static function. You can always check if a type satisfies the clock requirements with the help of <a href="https://en.cppreference.com/w/cpp/chrono/is_clock.html">the <code class="language-plaintext highlighter-rouge">std::chrono::is_clock</code> type trait</a>.</p><h2 id="a-simple-example-a-manually-advanced-clock">A Simple Example: A Manually-Advanced Clock</h2><p>Let’s build the simplest meaningful custom clock: a clock whose time only moves when we tell it to. A clock you might use for testing of simulations:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/Keq1xxv37</span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">ManualClock</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="k">using</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">period</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nano</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">rep</span><span class="p">,</span> <span class="n">period</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">ManualClock</span><span class="o">&gt;</span><span class="p">;</span>

    <span class="k">static</span> <span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="k">return</span> <span class="n">time_point</span><span class="p">(</span><span class="n">current_time</span><span class="p">);</span> <span class="p">}</span>

    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_steady</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">void</span> <span class="n">advance</span><span class="p">(</span><span class="n">duration</span> <span class="n">d</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">current_time</span> <span class="o">+=</span> <span class="n">d</span><span class="p">;</span> <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="k">static</span> <span class="kr">inline</span> <span class="n">time_point</span> <span class="n">current_time</span><span class="p">{</span><span class="n">duration</span><span class="p">{</span><span class="mi">0</span><span class="p">}};</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">is_clock_v</span><span class="o">&lt;</span><span class="n">ManualClock</span><span class="o">&gt;</span><span class="p">);</span>
</pre></table></code></div></div><p>Notice how one by one we satisfy the requirements listed above.</p><p>And now let’s use it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/Keq1xxv37</span>
<span class="c1">// ...</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono_literals</span><span class="p">;</span>

    <span class="n">ManualClock</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="mx">500ms</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">t1</span> <span class="o">=</span> <span class="n">ManualClock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="n">ManualClock</span><span class="o">::</span><span class="n">advance</span><span class="p">(</span><span class="mx">200ms</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">t2</span> <span class="o">=</span> <span class="n">ManualClock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">t2</span> <span class="o">-</span> <span class="n">t1</span><span class="p">).</span><span class="n">count</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">" ns</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This prints <em>200000000 ns</em> — because you decided how time flows.</p><p>Also notice that custom clocks integrate seamlessly with <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> types because they follow the same contract as the built-in ones.</p><p>You can <a href="https://godbolt.org/z/Keq1xxv37">check the full example on Compiler Exlorer</a>.</p><h2 id="interoperability-with-standard-clocks">Interoperability with Standard Clocks</h2><p>Earlier in this series, <a href="https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions">we talked about inter-clock conversions</a> and how the C++ standard deliberately avoids providing implicit conversions between clock epochs.</p><p>That same rule applies to your clocks.</p><p><strong>There is no automatic conversion between standard clocks and your custom clock.</strong></p><p>If you want meaningful conversions, you must define how your clock relates to another:</p><ul><li>Does it follow system_clock with some offset?<li>Does it map to real time at all?<li>Is its epoch aligned with Unix epoch or something arbitrary?</ul><p>You might define a relationship like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">system_now</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
<span class="k">auto</span> <span class="n">manual_now</span> <span class="o">=</span> <span class="n">manual_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>

<span class="k">auto</span> <span class="n">offset</span> <span class="o">=</span> <span class="n">system_now</span><span class="p">.</span><span class="n">time_since_epoch</span><span class="p">()</span> 
            <span class="o">-</span> <span class="n">manual_now</span><span class="p">.</span><span class="n">time_since_epoch</span><span class="p">();</span>

<span class="c1">// later...</span>
<span class="k">auto</span> <span class="n">estimated_system_time</span> <span class="o">=</span> <span class="n">manual_t</span> <span class="o">+</span> <span class="n">offset</span><span class="p">;</span>
</pre></table></code></div></div><p>But as discussed in the earlier article on converting between clocks: <strong>this only works as long as both clocks behave as you expect</strong>, and one of them (usually <code class="language-plaintext highlighter-rouge">system_clock</code>) doesn’t jump.</p><p>With your own clocks, you control the behavior — so you get to define the rules.</p><h2 id="a-more-realistic-example-a-scaling-clock">A More Realistic Example: A Scaling Clock</h2><p>Here’s a playful clock that runs faster or slower than real time:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/639zjsbd8</span>
<span class="cp">#include</span> <span class="cpf">&lt;chrono&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">ScaledClock</span> <span class="p">{</span>
  <span class="k">using</span> <span class="n">rep</span>        <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="kt">int64_t</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">period</span>     <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nano</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">duration</span>   <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="n">rep</span><span class="p">,</span> <span class="n">period</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="k">using</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">time_point</span><span class="o">&lt;</span><span class="n">ScaledClock</span><span class="o">&gt;</span><span class="p">;</span>

  <span class="k">static</span> <span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">real</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">steady_clock</span><span class="o">::</span><span class="n">now</span><span class="p">().</span><span class="n">time_since_epoch</span><span class="p">();</span>
    <span class="c1">// Convert to this clock's duration type (nanoseconds with int64_t)</span>
    <span class="k">auto</span> <span class="n">real_in_duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration_cast</span><span class="o">&lt;</span><span class="n">duration</span><span class="o">&gt;</span><span class="p">(</span><span class="n">real</span><span class="p">);</span>

    <span class="c1">// Scale the count as double, then cast back to rep</span>
    <span class="kt">double</span> <span class="n">scaled_count</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">real_in_duration</span><span class="p">.</span><span class="n">count</span><span class="p">())</span> <span class="o">*</span> <span class="n">multiplier</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">time_point</span><span class="p">{</span><span class="n">duration</span><span class="p">{</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="n">rep</span><span class="o">&gt;</span><span class="p">(</span><span class="n">scaled_count</span><span class="p">)}};</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_steady</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">static</span> <span class="kt">void</span> <span class="nf">set_speed</span><span class="p">(</span><span class="kt">double</span> <span class="n">mul</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">multiplier</span> <span class="o">=</span> <span class="n">mul</span><span class="p">;</span>
  <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
  <span class="k">static</span> <span class="kr">inline</span> <span class="kt">double</span> <span class="n">multiplier</span><span class="p">{</span><span class="mf">1.0</span><span class="p">};</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">is_clock_v</span><span class="o">&lt;</span><span class="n">ScaledClock</span><span class="o">&gt;</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>A clock like this can simulate slow-motion or time dilation effects in games, animations, or test scenarios.</p><h2 id="practical-advice-for-designing-custom-clocks">Practical Advice for Designing Custom Clocks</h2><p><strong>Keep epochs consistent</strong>: If your clock relates to real time at all, decide clearly how its epoch aligns with <code class="language-plaintext highlighter-rouge">system_clock</code>.</p><p><strong>Think about thread safety</strong>: Clocks are accessed globally — ensure your clock behaves well under concurrency. Something I usually ignore on the blog to keep examples fairly simple.</p><p><strong>Consider <code class="language-plaintext highlighter-rouge">is_steady</code> carefully</strong>: If your clock can jump, set <code class="language-plaintext highlighter-rouge">is_steady = false</code>.</p><p><strong>Don’t reinvent the wheel</strong>: If you’re only trying to mock time in tests, libraries like GoogleTest offer helpers — but custom clocks offer the ultimate flexibility.</p><h2 id="conclusion">Conclusion</h2><p>Standard clocks take you far, and in earlier articles we’ve seen how powerful they are for measuring durations, producing timestamps, and handling real-world time scales like UTC and TAI.</p><p>But sometimes real time isn’t the right time. Custom clocks let you:</p><ul><li>simulate,<li>test,<li>control,<li>and bend time to your will.</ul><p>They’re surprisingly simple to implement and plug neatly into the <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> ecosystem with almost no plumbing. In the next part of this series, we’ll continue exploring how to build robust time abstractions on top of <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code>, including adapters, wrappers, and patterns for safer time handling. Stay tuned!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/clocks/" class="post-tag no-text-decoration" >clocks</a> <a href="/tags/time/" class="post-tag no-text-decoration" >time</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Time in C++: Creating Your Own Clocks with &lt;chrono&gt; - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Time in C++: Creating Your Own Clocks with &lt;chrono&gt; - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Time in C++: Creating Your Own Clocks with &lt;chrono&gt; - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Time in C++: Creating Your Own Clocks with &lt;chrono&gt; - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/10/clocks-part-4-high_resolution_clock"><div class="card-body"> <span class="timeago small" > Dec 10, 2025 <i class="unloaded">2025-12-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</h3><div class="text-muted small"><p> If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like m...</p></div></div></a></div><div class="card"> <a href="/blog/2025/12/24/clocks-part-5-conversions"><div class="card-body"> <span class="timeago small" > Dec 24, 2025 <i class="unloaded">2025-12-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Inter-clock Conversions, Epochs, and Durations</h3><div class="text-muted small"><p> By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today,...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/07/clocks-part-6-cpp20"><div class="card-body"> <span class="timeago small" > Jan 7 <i class="unloaded">2026-01-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Additional clocks in C++20</h3><div class="text-muted small"><p> In this series, we’ve already talked about the main pillars behind &lt;chrono&gt;, the most widely used clocks, and even inter-clock conversions. Those clocks — system_clock, steady_clock, and hig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2026/01/07/clocks-part-6-cpp20" class="btn btn-outline-primary" prompt="Older"><p>Time in C++: Additional clocks in C++20</p></a> <a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones" class="btn btn-outline-primary" prompt="Newer"><p>Time in C++: C++20 Brought Us Time Zones</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Time in C++: Creating Your Own Clocks with &lt;chrono&gt;'; this.page.url = 'https://www.sandordargo.com/blog/2026/01/14/clocks-part-7-custom-clocks'; this.page.identifier = '/blog/2026/01/14/clocks-part-7-custom-clocks'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
