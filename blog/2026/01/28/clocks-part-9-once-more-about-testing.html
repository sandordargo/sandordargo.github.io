<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Time in C++: Once More About Testing" /><meta property="og:locale" content="en_US" /><meta name="description" content="I planned to finish this series this week. But then I realized that there are still a couple of important things about testing that I haven’t written about yet. We already touched on the problem of testing when we discussed system_clock, but it definitely deserves a bit more attention. We said that as it’s not really possible to mock system_clock, it’s a good idea to wrap your clock and pass that wrapper into your functions. That way, in tests, you can substitute it with a fake implementation where you control the returned time. Let’s first look at the problem in a bit more detail, and then walk through a few possible solutions. The problem of time and testing Let’s say you have a function that takes some values, combines them into a record, and stores that record in a database. Oh, and besides the values, it also adds the time of creation. For the sake of simplicity, our “database” will just be a std::vector, and the record will contain only one value besides a timestamp: 1 2 3 4 5 6 7 8 9 10 struct Record { int value; std::chrono::system_clock::time_point created_at; }; std::vector&lt;Record&gt; db; void store(int value) { db.emplace_back(value, std::chrono::system_clock::now()); } Now the problem is… how do you test that the database contains a record with the expected properties? You can check the value field easily, but validating created_at is tricky. You could approximate it (for example, assert that it’s within a certain range), but that approach is brittle, inaccurate, and often leads to flaky tests. What we really want is control. We want to decide what “now” means during the test. A hiearchy of clocks In one of the earlier articles of this series — where we talked about system_clock — I mentioned that wrapping your clock improves testability. One straightforward solution is to create a hierarchy of clocks. First, let’s define an interface (an abstract base class in C++): 1 2 3 4 struct Clock { virtual ~Clock() = default; virtual std::chrono::system_clock::time_point now() const = 0; }; Next, we can define a real clock and a fake one. The fake clock will return a predefined timestamp, while the real clock simply forwards the call to std::chrono::system_clock. 1 2 3 4 5 6 7 8 9 10 struct RealClock : Clock { std::chrono::system_clock::time_point now() const override { return std::chrono::system_clock::now(); } }; struct FakeClock : Clock { std::chrono::system_clock::time_point provided{}; std::chrono::system_clock::time_point now() const override { return provided; } }; With this in place, testing becomes straightforward. We only need to inject the clock into store: 1 2 3 void store(int value, const Clock&amp; clock) { db.emplace_back(value, clock.now()); } Now your test can fully control time by passing in a FakeClock. (You can find a complete example linked here.) Use the trait, use concepts You might not like the idea of inheritance - and that’s fair. You might ask: why not just pass in a clock-like type directly? After all, the standard library even defines a trait for clock-like types. And since we’re in modern C++, we should try to use concepts, right? If you’re not familiar with concepts, check out my series on them. It would be great to declare store like this: 1 void store(int value, ClockLike auto clock); That’s absolutely possible. We just need to define our own concept, because we can’t directly use the type trait itself. A first attempt could look like this: 1 2 template &lt;class C&gt; concept ClockLike = std::chrono::is_clock_v&lt;C&gt;; This concept is both more and less permissive than the interface-based solution from the previous section. It’s less permissive, because it requires all the characteristics of a standard clock — not just the existence of a now() function. But it’s also more permissive, because it allows passing a steady_clock into store. If we do that, the code won’t compile, because this line will fail: 1 db.emplace_back(value, clock.now()); The compiler cannot assign a steady_clock::time_point to a std::chrono::system_clock::time_point. Still, store() itself happily accepted the clock. So let’s tighten the concept: 1 2 3 4 template &lt;class C&gt; concept SystemClockLike = std::chrono::is_clock_v&lt;C&gt; &amp;&amp; requires { { C::now() } -&gt; std::same_as&lt;std::chrono::system_clock::time_point&gt;; }; That does the trick. Now we need to update our fake clock — and we can completely remove the class hierarchy: 1 2 3 4 5 6 7 8 9 10 11 struct FakeClock { using rep = std::chrono::system_clock::rep; using period = std::chrono::system_clock::period; using duration = std::chrono::system_clock::duration; using time_point = std::chrono::system_clock::time_point; static constexpr bool is_steady = false; static inline time_point provided{}; static time_point now() { return provided; } }; Now our test looks like this (and here is the full example): 1 2 3 4 5 6 7 8 // Full example is here: https://godbolt.org/z/h68M5rGdv void testStore() { FakeClock clock; clock.provided = std::chrono::system_clock::now(); store(42, clock); assert(db[0].value == 42); assert(db[0].created_at == clock.provided); } A time provider lambda You might not have access to C++20 — or you might simply not want to emulate concepts with SFINAE, which is completely understandable. There’s another, much simpler option. If you think about it, all we really need is something that returns a std::chrono::system_clock::time_point. We could use a function pointer or a template, but probably the most readable and flexible solution is a std::function (you can read about the trade-offs here) 1 using TimeProvider = std::function&lt;std::chrono::system_clock::time_point()&gt;; Now we can remove FakeClock entirely. All we need to do is pass a lambda that returns a predefined timestamp. Here’s what the test looks like (full example is here): 1 2 3 4 5 6 7 8 9 10 // Full example: https://godbolt.org/z/WYTxKMaYs void testStore() { auto expected_created_at = std::chrono::system_clock::now(); TimeProvider time_provider = [&amp;expected_created_at]() { return expected_created_at; }; store(42, time_provider); assert(db[0].value == 42); assert(db[0].created_at == expected_created_at); } Which one to choose? As usual, the answer is: it depends. Inheritance-based clocks are explicit and easy to understand, especially in object-oriented codebases. They work well when you already rely on runtime polymorphism and dependency injection. Concept-based solutions are zero-overhead, expressive, and scale nicely in template-heavy or header-only code. They shine when you want compile-time guarantees and flexibility. Time provider functions are the simplest option. They require no custom types, no inheritance, and no concepts. If all you need is “give me the current time”, this approach is often more than enough. In practice, I tend to start with the time provider approach. It’s minimal, readable, and easy to refactor later if the design grows more complex. Conclusion Time is one of those dependencies that silently makes code harder to test. As soon as you call now(), you give up control and tests suffer. The good news is that C++ gives us plenty of tools to deal with this problem. Whether you prefer classic polymorphism, modern concepts, or simple callables, the key idea is the same: don’t hardcode the source of time. Once you treat time as an injectable dependency, your tests become deterministic, expressive, and far less fragile. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I planned to finish this series this week. But then I realized that there are still a couple of important things about testing that I haven’t written about yet. We already touched on the problem of testing when we discussed system_clock, but it definitely deserves a bit more attention. We said that as it’s not really possible to mock system_clock, it’s a good idea to wrap your clock and pass that wrapper into your functions. That way, in tests, you can substitute it with a fake implementation where you control the returned time. Let’s first look at the problem in a bit more detail, and then walk through a few possible solutions. The problem of time and testing Let’s say you have a function that takes some values, combines them into a record, and stores that record in a database. Oh, and besides the values, it also adds the time of creation. For the sake of simplicity, our “database” will just be a std::vector, and the record will contain only one value besides a timestamp: 1 2 3 4 5 6 7 8 9 10 struct Record { int value; std::chrono::system_clock::time_point created_at; }; std::vector&lt;Record&gt; db; void store(int value) { db.emplace_back(value, std::chrono::system_clock::now()); } Now the problem is… how do you test that the database contains a record with the expected properties? You can check the value field easily, but validating created_at is tricky. You could approximate it (for example, assert that it’s within a certain range), but that approach is brittle, inaccurate, and often leads to flaky tests. What we really want is control. We want to decide what “now” means during the test. A hiearchy of clocks In one of the earlier articles of this series — where we talked about system_clock — I mentioned that wrapping your clock improves testability. One straightforward solution is to create a hierarchy of clocks. First, let’s define an interface (an abstract base class in C++): 1 2 3 4 struct Clock { virtual ~Clock() = default; virtual std::chrono::system_clock::time_point now() const = 0; }; Next, we can define a real clock and a fake one. The fake clock will return a predefined timestamp, while the real clock simply forwards the call to std::chrono::system_clock. 1 2 3 4 5 6 7 8 9 10 struct RealClock : Clock { std::chrono::system_clock::time_point now() const override { return std::chrono::system_clock::now(); } }; struct FakeClock : Clock { std::chrono::system_clock::time_point provided{}; std::chrono::system_clock::time_point now() const override { return provided; } }; With this in place, testing becomes straightforward. We only need to inject the clock into store: 1 2 3 void store(int value, const Clock&amp; clock) { db.emplace_back(value, clock.now()); } Now your test can fully control time by passing in a FakeClock. (You can find a complete example linked here.) Use the trait, use concepts You might not like the idea of inheritance - and that’s fair. You might ask: why not just pass in a clock-like type directly? After all, the standard library even defines a trait for clock-like types. And since we’re in modern C++, we should try to use concepts, right? If you’re not familiar with concepts, check out my series on them. It would be great to declare store like this: 1 void store(int value, ClockLike auto clock); That’s absolutely possible. We just need to define our own concept, because we can’t directly use the type trait itself. A first attempt could look like this: 1 2 template &lt;class C&gt; concept ClockLike = std::chrono::is_clock_v&lt;C&gt;; This concept is both more and less permissive than the interface-based solution from the previous section. It’s less permissive, because it requires all the characteristics of a standard clock — not just the existence of a now() function. But it’s also more permissive, because it allows passing a steady_clock into store. If we do that, the code won’t compile, because this line will fail: 1 db.emplace_back(value, clock.now()); The compiler cannot assign a steady_clock::time_point to a std::chrono::system_clock::time_point. Still, store() itself happily accepted the clock. So let’s tighten the concept: 1 2 3 4 template &lt;class C&gt; concept SystemClockLike = std::chrono::is_clock_v&lt;C&gt; &amp;&amp; requires { { C::now() } -&gt; std::same_as&lt;std::chrono::system_clock::time_point&gt;; }; That does the trick. Now we need to update our fake clock — and we can completely remove the class hierarchy: 1 2 3 4 5 6 7 8 9 10 11 struct FakeClock { using rep = std::chrono::system_clock::rep; using period = std::chrono::system_clock::period; using duration = std::chrono::system_clock::duration; using time_point = std::chrono::system_clock::time_point; static constexpr bool is_steady = false; static inline time_point provided{}; static time_point now() { return provided; } }; Now our test looks like this (and here is the full example): 1 2 3 4 5 6 7 8 // Full example is here: https://godbolt.org/z/h68M5rGdv void testStore() { FakeClock clock; clock.provided = std::chrono::system_clock::now(); store(42, clock); assert(db[0].value == 42); assert(db[0].created_at == clock.provided); } A time provider lambda You might not have access to C++20 — or you might simply not want to emulate concepts with SFINAE, which is completely understandable. There’s another, much simpler option. If you think about it, all we really need is something that returns a std::chrono::system_clock::time_point. We could use a function pointer or a template, but probably the most readable and flexible solution is a std::function (you can read about the trade-offs here) 1 using TimeProvider = std::function&lt;std::chrono::system_clock::time_point()&gt;; Now we can remove FakeClock entirely. All we need to do is pass a lambda that returns a predefined timestamp. Here’s what the test looks like (full example is here): 1 2 3 4 5 6 7 8 9 10 // Full example: https://godbolt.org/z/WYTxKMaYs void testStore() { auto expected_created_at = std::chrono::system_clock::now(); TimeProvider time_provider = [&amp;expected_created_at]() { return expected_created_at; }; store(42, time_provider); assert(db[0].value == 42); assert(db[0].created_at == expected_created_at); } Which one to choose? As usual, the answer is: it depends. Inheritance-based clocks are explicit and easy to understand, especially in object-oriented codebases. They work well when you already rely on runtime polymorphism and dependency injection. Concept-based solutions are zero-overhead, expressive, and scale nicely in template-heavy or header-only code. They shine when you want compile-time guarantees and flexibility. Time provider functions are the simplest option. They require no custom types, no inheritance, and no concepts. If all you need is “give me the current time”, this approach is often more than enough. In practice, I tend to start with the time provider approach. It’s minimal, readable, and easy to refactor later if the design grows more complex. Conclusion Time is one of those dependencies that silently makes code harder to test. As soon as you call now(), you give up control and tests suffer. The good news is that C++ gives us plenty of tools to deal with this problem. Whether you prefer classic polymorphism, modern concepts, or simple callables, the key idea is the same: don’t hardcode the source of time. Once you treat time as an injectable dependency, your tests become deterministic, expressive, and far less fragile. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing" /><meta property="og:url" content="https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-01-28T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Time in C++: Once More About Testing" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-01-28T00:00:00+01:00","datePublished":"2026-01-28T00:00:00+01:00","description":"I planned to finish this series this week. But then I realized that there are still a couple of important things about testing that I haven’t written about yet. We already touched on the problem of testing when we discussed system_clock, but it definitely deserves a bit more attention. We said that as it’s not really possible to mock system_clock, it’s a good idea to wrap your clock and pass that wrapper into your functions. That way, in tests, you can substitute it with a fake implementation where you control the returned time. Let’s first look at the problem in a bit more detail, and then walk through a few possible solutions. The problem of time and testing Let’s say you have a function that takes some values, combines them into a record, and stores that record in a database. Oh, and besides the values, it also adds the time of creation. For the sake of simplicity, our “database” will just be a std::vector, and the record will contain only one value besides a timestamp: 1 2 3 4 5 6 7 8 9 10 struct Record { int value; std::chrono::system_clock::time_point created_at; }; std::vector&lt;Record&gt; db; void store(int value) { db.emplace_back(value, std::chrono::system_clock::now()); } Now the problem is… how do you test that the database contains a record with the expected properties? You can check the value field easily, but validating created_at is tricky. You could approximate it (for example, assert that it’s within a certain range), but that approach is brittle, inaccurate, and often leads to flaky tests. What we really want is control. We want to decide what “now” means during the test. A hiearchy of clocks In one of the earlier articles of this series — where we talked about system_clock — I mentioned that wrapping your clock improves testability. One straightforward solution is to create a hierarchy of clocks. First, let’s define an interface (an abstract base class in C++): 1 2 3 4 struct Clock { virtual ~Clock() = default; virtual std::chrono::system_clock::time_point now() const = 0; }; Next, we can define a real clock and a fake one. The fake clock will return a predefined timestamp, while the real clock simply forwards the call to std::chrono::system_clock. 1 2 3 4 5 6 7 8 9 10 struct RealClock : Clock { std::chrono::system_clock::time_point now() const override { return std::chrono::system_clock::now(); } }; struct FakeClock : Clock { std::chrono::system_clock::time_point provided{}; std::chrono::system_clock::time_point now() const override { return provided; } }; With this in place, testing becomes straightforward. We only need to inject the clock into store: 1 2 3 void store(int value, const Clock&amp; clock) { db.emplace_back(value, clock.now()); } Now your test can fully control time by passing in a FakeClock. (You can find a complete example linked here.) Use the trait, use concepts You might not like the idea of inheritance - and that’s fair. You might ask: why not just pass in a clock-like type directly? After all, the standard library even defines a trait for clock-like types. And since we’re in modern C++, we should try to use concepts, right? If you’re not familiar with concepts, check out my series on them. It would be great to declare store like this: 1 void store(int value, ClockLike auto clock); That’s absolutely possible. We just need to define our own concept, because we can’t directly use the type trait itself. A first attempt could look like this: 1 2 template &lt;class C&gt; concept ClockLike = std::chrono::is_clock_v&lt;C&gt;; This concept is both more and less permissive than the interface-based solution from the previous section. It’s less permissive, because it requires all the characteristics of a standard clock — not just the existence of a now() function. But it’s also more permissive, because it allows passing a steady_clock into store. If we do that, the code won’t compile, because this line will fail: 1 db.emplace_back(value, clock.now()); The compiler cannot assign a steady_clock::time_point to a std::chrono::system_clock::time_point. Still, store() itself happily accepted the clock. So let’s tighten the concept: 1 2 3 4 template &lt;class C&gt; concept SystemClockLike = std::chrono::is_clock_v&lt;C&gt; &amp;&amp; requires { { C::now() } -&gt; std::same_as&lt;std::chrono::system_clock::time_point&gt;; }; That does the trick. Now we need to update our fake clock — and we can completely remove the class hierarchy: 1 2 3 4 5 6 7 8 9 10 11 struct FakeClock { using rep = std::chrono::system_clock::rep; using period = std::chrono::system_clock::period; using duration = std::chrono::system_clock::duration; using time_point = std::chrono::system_clock::time_point; static constexpr bool is_steady = false; static inline time_point provided{}; static time_point now() { return provided; } }; Now our test looks like this (and here is the full example): 1 2 3 4 5 6 7 8 // Full example is here: https://godbolt.org/z/h68M5rGdv void testStore() { FakeClock clock; clock.provided = std::chrono::system_clock::now(); store(42, clock); assert(db[0].value == 42); assert(db[0].created_at == clock.provided); } A time provider lambda You might not have access to C++20 — or you might simply not want to emulate concepts with SFINAE, which is completely understandable. There’s another, much simpler option. If you think about it, all we really need is something that returns a std::chrono::system_clock::time_point. We could use a function pointer or a template, but probably the most readable and flexible solution is a std::function (you can read about the trade-offs here) 1 using TimeProvider = std::function&lt;std::chrono::system_clock::time_point()&gt;; Now we can remove FakeClock entirely. All we need to do is pass a lambda that returns a predefined timestamp. Here’s what the test looks like (full example is here): 1 2 3 4 5 6 7 8 9 10 // Full example: https://godbolt.org/z/WYTxKMaYs void testStore() { auto expected_created_at = std::chrono::system_clock::now(); TimeProvider time_provider = [&amp;expected_created_at]() { return expected_created_at; }; store(42, time_provider); assert(db[0].value == 42); assert(db[0].created_at == expected_created_at); } Which one to choose? As usual, the answer is: it depends. Inheritance-based clocks are explicit and easy to understand, especially in object-oriented codebases. They work well when you already rely on runtime polymorphism and dependency injection. Concept-based solutions are zero-overhead, expressive, and scale nicely in template-heavy or header-only code. They shine when you want compile-time guarantees and flexibility. Time provider functions are the simplest option. They require no custom types, no inheritance, and no concepts. If all you need is “give me the current time”, this approach is often more than enough. In practice, I tend to start with the time provider approach. It’s minimal, readable, and easy to refactor later if the design grows more complex. Conclusion Time is one of those dependencies that silently makes code harder to test. As soon as you call now(), you give up control and tests suffer. The good news is that C++ gives us plenty of tools to deal with this problem. Whether you prefer classic polymorphism, modern concepts, or simple callables, the key idea is the same: don’t hardcode the source of time. Once you treat time as an injectable dependency, your tests become deterministic, expressive, and far less fragile. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Time in C++: Once More About Testing","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing"},"url":"https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing"}</script><title>Time in C++: Once More About Testing | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2026"> 2026 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/28"> 28 </a> </span> <span>Time in C++: Once More About Testing</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Time in C++: Once More About Testing</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 28, 2026, 12:00 AM +0100" prep="on" > Jan 28 <i class="unloaded">2026-01-28T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1164 words">6 min</span></div></div><div class="post-content"><p>I planned to finish this series this week. But then I realized that there are still a couple of important things about testing that I haven’t written about yet. We already touched on the problem of testing when we discussed <a href="https://www.sandordargo.com/blog/2025/11/26/clocks-part-2-system_clock"><code class="language-plaintext highlighter-rouge">system_clock</code></a>, but it definitely deserves a bit more attention.</p><p>We said that as it’s not really possible to mock <code class="language-plaintext highlighter-rouge">system_clock</code>, it’s a good idea to wrap your clock and pass that wrapper into your functions. That way, in tests, you can substitute it with a fake implementation where you control the returned time.</p><p>Let’s first look at the problem in a bit more detail, and then walk through a few possible solutions.</p><h2 id="the-problem-of-time-and-testing">The problem of time and testing</h2><p>Let’s say you have a function that takes some values, combines them into a record, and stores that record in a database. Oh, and besides the values, it also adds the time of creation.</p><p>For the sake of simplicity, our “database” will just be a <code class="language-plaintext highlighter-rouge">std::vector</code>, and the record will contain only one value besides a timestamp:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Record</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">created_at</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Record</span><span class="o">&gt;</span> <span class="n">db</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">store</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">db</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now the problem is… how do you test that the database contains a record with the expected properties?</p><p>You can check the value field easily, but validating <code class="language-plaintext highlighter-rouge">created_at</code> is tricky. You could approximate it (for example, assert that it’s within a certain range), but that approach is brittle, inaccurate, and often leads to flaky tests.</p><p>What we really want is control. We want to decide what “now” means during the test.</p><h2 id="a-hiearchy-of-clocks">A hiearchy of clocks</h2><p>In one of the earlier articles of this series — where we talked about <code class="language-plaintext highlighter-rouge">system_clock</code> — I mentioned that wrapping your clock improves testability. One straightforward solution is to create a hierarchy of clocks.</p><p>First, let’s define an interface (an abstract base class in C++):</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Clock</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Clock</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Next, we can define a real clock and a fake one. The fake clock will return a predefined timestamp, while the real clock simply forwards the call to <code class="language-plaintext highlighter-rouge">std::chrono::system_clock</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">RealClock</span> <span class="o">:</span> <span class="n">Clock</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">FakeClock</span> <span class="o">:</span> <span class="n">Clock</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">provided</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span> <span class="n">now</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">provided</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>With this in place, testing becomes straightforward. We only need to inject the clock into store:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">store</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="k">const</span> <span class="n">Clock</span><span class="o">&amp;</span> <span class="n">clock</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">db</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">clock</span><span class="p">.</span><span class="n">now</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now your test can fully control time by passing in a <code class="language-plaintext highlighter-rouge">FakeClock</code>. (You can find a complete example <a href="https://godbolt.org/z/qcMdvMKM5">linked here</a>.)</p><h2 id="use-the-trait-use-concepts">Use the trait, use concepts</h2><p>You might not like the idea of inheritance - and that’s fair. You might ask: why not just pass in a clock-like type <em>directly</em>? After all, the standard library even defines a trait for clock-like types.</p><p>And since we’re in modern C++, we should try to use concepts, right?</p><blockquote><p>If you’re not familiar with concepts, <a href="https://www.sandordargo.com/tags/concepts/">check out my series on them</a>.</p></blockquote><p>It would be great to declare store like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">store</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="n">ClockLike</span> <span class="k">auto</span> <span class="n">clock</span><span class="p">);</span>
</pre></table></code></div></div><p>That’s absolutely possible. We just need to define our own <code class="language-plaintext highlighter-rouge">concept</code>, because we can’t directly use the type trait itself.</p><p>A first attempt could look like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">ClockLike</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">is_clock_v</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>This <code class="language-plaintext highlighter-rouge">concept</code> is both more and less permissive than the interface-based solution from the previous section.</p><p>It’s less permissive, because it requires all the characteristics of a standard clock — not just the existence of a <code class="language-plaintext highlighter-rouge">now()</code> function.</p><p>But it’s also more permissive, because it allows passing a <code class="language-plaintext highlighter-rouge">steady_clock</code> into store. If we do that, the code won’t compile, because this line will fail:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">db</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">value</span><span class="p">,</span> <span class="n">clock</span><span class="p">.</span><span class="n">now</span><span class="p">());</span>
</pre></table></code></div></div><p>The compiler cannot assign a <code class="language-plaintext highlighter-rouge">steady_clock::time_point</code> to a <code class="language-plaintext highlighter-rouge">std::chrono::system_clock::time_point</code>. Still, store() itself happily accepted the clock.</p><p>So let’s tighten the concept:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">C</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">SystemClockLike</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">is_clock_v</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="k">requires</span> <span class="p">{</span>
    <span class="p">{</span> <span class="n">C</span><span class="o">::</span><span class="n">now</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>That does the trick.</p><p>Now we need to update our fake clock — and we can completely remove the class hierarchy:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">FakeClock</span> <span class="p">{</span>
    <span class="k">using</span> <span class="n">rep</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">rep</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">period</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">period</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">duration</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">duration</span><span class="p">;</span>
    <span class="k">using</span> <span class="n">time_point</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">;</span>
    <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">is_steady</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

    <span class="k">static</span> <span class="kr">inline</span> <span class="n">time_point</span> <span class="n">provided</span><span class="p">{};</span>

    <span class="k">static</span> <span class="n">time_point</span> <span class="nf">now</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">provided</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Now our test looks like this (and <a href="https://godbolt.org/z/h68M5rGdv">here is the full example</a>):</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="c1">// Full example is here: https://godbolt.org/z/h68M5rGdv</span>
<span class="kt">void</span> <span class="nf">testStore</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">FakeClock</span> <span class="n">clock</span><span class="p">;</span>
    <span class="n">clock</span><span class="p">.</span><span class="n">provided</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">clock</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">created_at</span> <span class="o">==</span> <span class="n">clock</span><span class="p">.</span><span class="n">provided</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="a-time-provider-lambda">A time provider lambda</h2><p>You might not have access to C++20 — or you might simply not want to emulate concepts with SFINAE, which is completely understandable. There’s another, much simpler option.</p><p>If you think about it, all we really need is <em>something</em> that returns a <code class="language-plaintext highlighter-rouge">std::chrono::system_clock::time_point</code>.</p><p>We could use a function pointer or a template, but probably the most readable and flexible solution is a <code class="language-plaintext highlighter-rouge">std::function</code> (you can <a href="https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates">read about the trade-offs here</a>)</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">TimeProvider</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">time_point</span><span class="p">()</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>Now we can remove <code class="language-plaintext highlighter-rouge">FakeClock</code> entirely. All we need to do is pass a lambda that returns a predefined timestamp.</p><p>Here’s what the test looks like (<a href="https://godbolt.org/z/WYTxKMaYs">full example is here</a>):</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="c1">// Full example: https://godbolt.org/z/WYTxKMaYs</span>
<span class="kt">void</span> <span class="nf">testStore</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">expected_created_at</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">system_clock</span><span class="o">::</span><span class="n">now</span><span class="p">();</span>
    <span class="n">TimeProvider</span> <span class="n">time_provider</span> <span class="o">=</span> <span class="p">[</span><span class="o">&amp;</span><span class="n">expected_created_at</span><span class="p">]()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">expected_created_at</span><span class="p">;</span>
    <span class="p">};</span>
    <span class="n">store</span><span class="p">(</span><span class="mi">42</span><span class="p">,</span> <span class="n">time_provider</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">value</span> <span class="o">==</span> <span class="mi">42</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">db</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">created_at</span> <span class="o">==</span> <span class="n">expected_created_at</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="which-one-to-choose">Which one to choose?</h2><p>As usual, the answer is: it depends.</p><ul><li><p><strong>Inheritance-based clocks</strong> are explicit and easy to understand, especially in object-oriented codebases. They work well when you already rely on runtime polymorphism and dependency injection.</p><li><p><strong>Concept-based solutions</strong> are zero-overhead, expressive, and scale nicely in template-heavy or header-only code. They shine when you want compile-time guarantees and flexibility.</p><li><p><strong>Time provider functions</strong> are the simplest option. They require no custom types, no inheritance, and no concepts. If all you need is “give me the current time”, this approach is often more than enough.</p></ul><p>In practice, I tend to start with the time provider approach. It’s minimal, readable, and easy to refactor later if the design grows more complex.</p><h2 id="conclusion">Conclusion</h2><p>Time is one of those dependencies that silently makes code harder to test. As soon as you call <code class="language-plaintext highlighter-rouge">now()</code>, you give up control and tests suffer.</p><p>The good news is that C++ gives us plenty of tools to deal with this problem. Whether you prefer classic polymorphism, modern concepts, or simple callables, the key idea is the same: don’t hardcode the source of time.</p><p>Once you treat time as an injectable dependency, your tests become deterministic, expressive, and far less fragile.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/clocks/" class="post-tag no-text-decoration" >clocks</a> <a href="/tags/time/" class="post-tag no-text-decoration" >time</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Time in C++: Once More About Testing - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Time in C++: Once More About Testing - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Time in C++: Once More About Testing - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Time in C++: Once More About Testing - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/10/clocks-part-4-high_resolution_clock"><div class="card-body"> <span class="timeago small" > Dec 10, 2025 <i class="unloaded">2025-12-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</h3><div class="text-muted small"><p> If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like m...</p></div></div></a></div><div class="card"> <a href="/blog/2025/12/24/clocks-part-5-conversions"><div class="card-body"> <span class="timeago small" > Dec 24, 2025 <i class="unloaded">2025-12-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Inter-clock Conversions, Epochs, and Durations</h3><div class="text-muted small"><p> By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today,...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/07/clocks-part-6-cpp20"><div class="card-body"> <span class="timeago small" > Jan 7 <i class="unloaded">2026-01-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Additional clocks in C++20</h3><div class="text-muted small"><p> In this series, we’ve already talked about the main pillars behind &lt;chrono&gt;, the most widely used clocks, and even inter-clock conversions. Those clocks — system_clock, steady_clock, and hig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones" class="btn btn-outline-primary" prompt="Older"><p>Time in C++: C++20 Brought Us Time Zones</p></a> <a href="/blog/2026/02/04/clocks-part-10-conclusion" class="btn btn-outline-primary" prompt="Newer"><p>Time in C++: Closing Thoughts</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Time in C++: Once More About Testing'; this.page.url = 'https://www.sandordargo.com/blog/2026/01/28/clocks-part-9-once-more-about-testing'; this.page.identifier = '/blog/2026/01/28/clocks-part-9-once-more-about-testing'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
