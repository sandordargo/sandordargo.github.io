<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Deferred member initialization" /><meta property="og:locale" content="en_US" /><meta name="description" content="At Meeting C++ 2025, I had an interesting discussion with another attendee. Here’s the problem we talked about: There is a class controlling a piece of hardware to which several other hardware modules could be installed. To manage the available modules, we want to pass a mapping to this class where the map would contain hardware IDs and corresponding module names. A perfect fit for a map&lt;int, string&gt;! Since the available modules would never change at runtime, the map should ideally be const. However, due to some hard constraints, the map cannot be initialized at construction time. It can happen later through an init function. Let’s explore a few possible solutions—and I’d love to hear your thoughts too. A well-encapsulated non-const member You might argue that there’s no need for _available_modules to be const. As long as it’s private, not exposed through getters, and not modified after initialization, you could rely on discipline and convention. After all, as the owner of the MyHardwareController class, you’ll ensure no code will ever modify it again. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // https://godbolt.org/z/Kbx55nn73 #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;optional&gt; #include &lt;string&gt; std::map&lt;int, std::string&gt; list_available_modules() { return { {1, &quot;widget&quot;}, {2, &quot;gadget&quot;}, {42, &quot;bar&quot;} }; } class MyHardwareController { public: void init() { _available_modules = list_available_modules(); } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_available_modules.contains(id)) { return _available_modules.at(id); } return std::nullopt; } private: std::map&lt;int, std::string&gt; _available_modules; }; int main() { MyHardwareController bar; bar.init(); for (int id : {1, 2, 3, 42}) { std::cout &lt;&lt; &quot;Module &quot; &lt;&lt; id &lt;&lt; &quot; is named &quot; &lt;&lt; bar.get_module_name(id).value_or(&quot;&lt;unknown&gt;&quot;) &lt;&lt; &quot;.\n&quot;; } return 0; } To make it safer, you can ensure that init() cannot be called twice — either by returning early, signaling an error, or throwing an exception. While some embedded environments avoid exceptions, it’s still worth reconsidering whether that restriction truly applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // https://godbolt.org/z/549qqrj9c class MyHardwareController { public: void init() { if (_already_initialized) { throw std::logic_error{&quot;Object already initialized&quot;}; } _available_modules = list_available_modules(); _already_initialized = true; } // ... rest of the class private: bool _already_initialized {false}; std::map&lt;int, std::string&gt; _available_modules; }; The downside? Nothing in the type system explicitly communicates that _available_modules should never be modified after initialization. It’s a convention, not an enforced guarantee. Use an optional&lt;const map&gt; Instead of a plain, mutable map, we can use an optional&lt;const map&gt;. What does this express to the reader? It says: there might or might not be a map yet — but once it exists, it cannot be modified. That’s a strong and useful semantic. You can still replace the entire map using std::optional::emplace(), but the underlying data remains immutable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // https://godbolt.org/z/hcjsvKnGd class MyHardwareController { public: void init() { if (_already_initialized) { throw std::logic_error{&quot;Object already initialized&quot;}; } _available_modules.emplace(list_available_modules()); _already_initialized = true; } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_available_modules-&gt;contains(id)) { return _available_modules-&gt;at(id); } return std::nullopt; } private: bool _already_initialized {false}; std::optional&lt;std::map&lt;int, std::string&gt;&gt; _available_modules; }; This solution is already quite robust — it enforces immutability once initialized, yet still allows deferred setup. For many cases, it’s more than good enough. Have a registry class But can we communicate our intent even better? Let’s encapsulate the map in a small helper class, ModuleRegistry, responsible for enforcing single initialization and const access. This separation makes the ownership and lifecycle of the data explicit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ModuleRegistry { public: void set_once(std::map&lt;int, std::string&gt; m) { if (modules) { throw std::logic_error(&quot;Modules already initialized&quot;); } modules = std::move(m); } bool is_initialized() const { return modules.has_value(); } const std::map&lt;int, std::string&gt;&amp; get_modules() const { if (!modules) { throw std::logic_error(&quot;Modules not initialized yet&quot;); } return modules.value(); } private: std::optional&lt;std::map&lt;int, std::string&gt;&gt; modules; }; Then, our controller simply delegates initialization and access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyHardwareController { public: void init() { if (_module_registry.is_initialized()) { throw std::logic_error{&quot;Module registry already initialized&quot;}; } _module_registry.set_once(list_available_modules()); } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_module_registry.is_initialized() &amp;&amp; _module_registry.get_modules().contains(id)) { return _module_registry.get_modules().at(id); } return std::nullopt; } private: ModuleRegistry _module_registry; }; In this setup, ModuleRegistry fully encapsulates the deferred initialization logic. It cannot be partially modified or reused incorrectly. You can even delete assignment operators to make replacement impossible — just remember the rule of five. See the full example on Compiler Explorer. Conclusion Deferred initialization is a tricky balance between expressiveness, safety, and practicality. If runtime constraints prevent you from initializing const data at construction time, there are still clean ways to express your intent: A private non-const member works but relies on discipline. An optional&lt;const T&gt; clearly communicates immutability after initialization. A dedicated registry or wrapper class adds even stronger guarantees and separation of concerns. In the end, the best solution depends on your context. But the key takeaway is this: even when constraints prevent you from using const directly, you can still design for immutability. That mindset — of expressing intent through types - is one of the most powerful tools in modern C++. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="At Meeting C++ 2025, I had an interesting discussion with another attendee. Here’s the problem we talked about: There is a class controlling a piece of hardware to which several other hardware modules could be installed. To manage the available modules, we want to pass a mapping to this class where the map would contain hardware IDs and corresponding module names. A perfect fit for a map&lt;int, string&gt;! Since the available modules would never change at runtime, the map should ideally be const. However, due to some hard constraints, the map cannot be initialized at construction time. It can happen later through an init function. Let’s explore a few possible solutions—and I’d love to hear your thoughts too. A well-encapsulated non-const member You might argue that there’s no need for _available_modules to be const. As long as it’s private, not exposed through getters, and not modified after initialization, you could rely on discipline and convention. After all, as the owner of the MyHardwareController class, you’ll ensure no code will ever modify it again. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // https://godbolt.org/z/Kbx55nn73 #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;optional&gt; #include &lt;string&gt; std::map&lt;int, std::string&gt; list_available_modules() { return { {1, &quot;widget&quot;}, {2, &quot;gadget&quot;}, {42, &quot;bar&quot;} }; } class MyHardwareController { public: void init() { _available_modules = list_available_modules(); } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_available_modules.contains(id)) { return _available_modules.at(id); } return std::nullopt; } private: std::map&lt;int, std::string&gt; _available_modules; }; int main() { MyHardwareController bar; bar.init(); for (int id : {1, 2, 3, 42}) { std::cout &lt;&lt; &quot;Module &quot; &lt;&lt; id &lt;&lt; &quot; is named &quot; &lt;&lt; bar.get_module_name(id).value_or(&quot;&lt;unknown&gt;&quot;) &lt;&lt; &quot;.\n&quot;; } return 0; } To make it safer, you can ensure that init() cannot be called twice — either by returning early, signaling an error, or throwing an exception. While some embedded environments avoid exceptions, it’s still worth reconsidering whether that restriction truly applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // https://godbolt.org/z/549qqrj9c class MyHardwareController { public: void init() { if (_already_initialized) { throw std::logic_error{&quot;Object already initialized&quot;}; } _available_modules = list_available_modules(); _already_initialized = true; } // ... rest of the class private: bool _already_initialized {false}; std::map&lt;int, std::string&gt; _available_modules; }; The downside? Nothing in the type system explicitly communicates that _available_modules should never be modified after initialization. It’s a convention, not an enforced guarantee. Use an optional&lt;const map&gt; Instead of a plain, mutable map, we can use an optional&lt;const map&gt;. What does this express to the reader? It says: there might or might not be a map yet — but once it exists, it cannot be modified. That’s a strong and useful semantic. You can still replace the entire map using std::optional::emplace(), but the underlying data remains immutable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // https://godbolt.org/z/hcjsvKnGd class MyHardwareController { public: void init() { if (_already_initialized) { throw std::logic_error{&quot;Object already initialized&quot;}; } _available_modules.emplace(list_available_modules()); _already_initialized = true; } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_available_modules-&gt;contains(id)) { return _available_modules-&gt;at(id); } return std::nullopt; } private: bool _already_initialized {false}; std::optional&lt;std::map&lt;int, std::string&gt;&gt; _available_modules; }; This solution is already quite robust — it enforces immutability once initialized, yet still allows deferred setup. For many cases, it’s more than good enough. Have a registry class But can we communicate our intent even better? Let’s encapsulate the map in a small helper class, ModuleRegistry, responsible for enforcing single initialization and const access. This separation makes the ownership and lifecycle of the data explicit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ModuleRegistry { public: void set_once(std::map&lt;int, std::string&gt; m) { if (modules) { throw std::logic_error(&quot;Modules already initialized&quot;); } modules = std::move(m); } bool is_initialized() const { return modules.has_value(); } const std::map&lt;int, std::string&gt;&amp; get_modules() const { if (!modules) { throw std::logic_error(&quot;Modules not initialized yet&quot;); } return modules.value(); } private: std::optional&lt;std::map&lt;int, std::string&gt;&gt; modules; }; Then, our controller simply delegates initialization and access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyHardwareController { public: void init() { if (_module_registry.is_initialized()) { throw std::logic_error{&quot;Module registry already initialized&quot;}; } _module_registry.set_once(list_available_modules()); } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_module_registry.is_initialized() &amp;&amp; _module_registry.get_modules().contains(id)) { return _module_registry.get_modules().at(id); } return std::nullopt; } private: ModuleRegistry _module_registry; }; In this setup, ModuleRegistry fully encapsulates the deferred initialization logic. It cannot be partially modified or reused incorrectly. You can even delete assignment operators to make replacement impossible — just remember the rule of five. See the full example on Compiler Explorer. Conclusion Deferred initialization is a tricky balance between expressiveness, safety, and practicality. If runtime constraints prevent you from initializing const data at construction time, there are still clean ways to express your intent: A private non-const member works but relies on discipline. An optional&lt;const T&gt; clearly communicates immutability after initialization. A dedicated registry or wrapper class adds even stronger guarantees and separation of concerns. In the end, the best solution depends on your context. But the key takeaway is this: even when constraints prevent you from using const directly, you can still design for immutability. That mindset — of expressing intent through types - is one of the most powerful tools in modern C++. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization" /><meta property="og:url" content="https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-02-11T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Deferred member initialization" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-02-11T00:00:00+01:00","datePublished":"2026-02-11T00:00:00+01:00","description":"At Meeting C++ 2025, I had an interesting discussion with another attendee. Here’s the problem we talked about: There is a class controlling a piece of hardware to which several other hardware modules could be installed. To manage the available modules, we want to pass a mapping to this class where the map would contain hardware IDs and corresponding module names. A perfect fit for a map&lt;int, string&gt;! Since the available modules would never change at runtime, the map should ideally be const. However, due to some hard constraints, the map cannot be initialized at construction time. It can happen later through an init function. Let’s explore a few possible solutions—and I’d love to hear your thoughts too. A well-encapsulated non-const member You might argue that there’s no need for _available_modules to be const. As long as it’s private, not exposed through getters, and not modified after initialization, you could rely on discipline and convention. After all, as the owner of the MyHardwareController class, you’ll ensure no code will ever modify it again. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 // https://godbolt.org/z/Kbx55nn73 #include &lt;iostream&gt; #include &lt;map&gt; #include &lt;optional&gt; #include &lt;string&gt; std::map&lt;int, std::string&gt; list_available_modules() { return { {1, &quot;widget&quot;}, {2, &quot;gadget&quot;}, {42, &quot;bar&quot;} }; } class MyHardwareController { public: void init() { _available_modules = list_available_modules(); } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_available_modules.contains(id)) { return _available_modules.at(id); } return std::nullopt; } private: std::map&lt;int, std::string&gt; _available_modules; }; int main() { MyHardwareController bar; bar.init(); for (int id : {1, 2, 3, 42}) { std::cout &lt;&lt; &quot;Module &quot; &lt;&lt; id &lt;&lt; &quot; is named &quot; &lt;&lt; bar.get_module_name(id).value_or(&quot;&lt;unknown&gt;&quot;) &lt;&lt; &quot;.\\n&quot;; } return 0; } To make it safer, you can ensure that init() cannot be called twice — either by returning early, signaling an error, or throwing an exception. While some embedded environments avoid exceptions, it’s still worth reconsidering whether that restriction truly applies. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 // https://godbolt.org/z/549qqrj9c class MyHardwareController { public: void init() { if (_already_initialized) { throw std::logic_error{&quot;Object already initialized&quot;}; } _available_modules = list_available_modules(); _already_initialized = true; } // ... rest of the class private: bool _already_initialized {false}; std::map&lt;int, std::string&gt; _available_modules; }; The downside? Nothing in the type system explicitly communicates that _available_modules should never be modified after initialization. It’s a convention, not an enforced guarantee. Use an optional&lt;const map&gt; Instead of a plain, mutable map, we can use an optional&lt;const map&gt;. What does this express to the reader? It says: there might or might not be a map yet — but once it exists, it cannot be modified. That’s a strong and useful semantic. You can still replace the entire map using std::optional::emplace(), but the underlying data remains immutable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // https://godbolt.org/z/hcjsvKnGd class MyHardwareController { public: void init() { if (_already_initialized) { throw std::logic_error{&quot;Object already initialized&quot;}; } _available_modules.emplace(list_available_modules()); _already_initialized = true; } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_available_modules-&gt;contains(id)) { return _available_modules-&gt;at(id); } return std::nullopt; } private: bool _already_initialized {false}; std::optional&lt;std::map&lt;int, std::string&gt;&gt; _available_modules; }; This solution is already quite robust — it enforces immutability once initialized, yet still allows deferred setup. For many cases, it’s more than good enough. Have a registry class But can we communicate our intent even better? Let’s encapsulate the map in a small helper class, ModuleRegistry, responsible for enforcing single initialization and const access. This separation makes the ownership and lifecycle of the data explicit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class ModuleRegistry { public: void set_once(std::map&lt;int, std::string&gt; m) { if (modules) { throw std::logic_error(&quot;Modules already initialized&quot;); } modules = std::move(m); } bool is_initialized() const { return modules.has_value(); } const std::map&lt;int, std::string&gt;&amp; get_modules() const { if (!modules) { throw std::logic_error(&quot;Modules not initialized yet&quot;); } return modules.value(); } private: std::optional&lt;std::map&lt;int, std::string&gt;&gt; modules; }; Then, our controller simply delegates initialization and access: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class MyHardwareController { public: void init() { if (_module_registry.is_initialized()) { throw std::logic_error{&quot;Module registry already initialized&quot;}; } _module_registry.set_once(list_available_modules()); } std::optional&lt;std::string&gt; get_module_name(int id) const { if (_module_registry.is_initialized() &amp;&amp; _module_registry.get_modules().contains(id)) { return _module_registry.get_modules().at(id); } return std::nullopt; } private: ModuleRegistry _module_registry; }; In this setup, ModuleRegistry fully encapsulates the deferred initialization logic. It cannot be partially modified or reused incorrectly. You can even delete assignment operators to make replacement impossible — just remember the rule of five. See the full example on Compiler Explorer. Conclusion Deferred initialization is a tricky balance between expressiveness, safety, and practicality. If runtime constraints prevent you from initializing const data at construction time, there are still clean ways to express your intent: A private non-const member works but relies on discipline. An optional&lt;const T&gt; clearly communicates immutability after initialization. A dedicated registry or wrapper class adds even stronger guarantees and separation of concerns. In the end, the best solution depends on your context. But the key takeaway is this: even when constraints prevent you from using const directly, you can still design for immutability. That mindset — of expressing intent through types - is one of the most powerful tools in modern C++. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Deferred member initialization","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization"},"url":"https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization"}</script><title>Deferred member initialization | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2026"> 2026 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/11"> 11 </a> </span> <span>Deferred member initialization</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Deferred member initialization</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 11, 2026, 12:00 AM +0100" prep="on" > Feb 11 <i class="unloaded">2026-02-11T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="927 words">5 min</span></div></div><div class="post-content"><p>At Meeting C++ 2025, I had an interesting discussion with another attendee. Here’s the problem we talked about:</p><blockquote><p><em>There is a class controlling a piece of hardware to which several other hardware modules could be installed. To manage the available modules, we want to pass a mapping to this class where the map would contain hardware IDs and corresponding module names.</em></p><p><em>A perfect fit for a <code class="language-plaintext highlighter-rouge">map&lt;int, string&gt;</code>!</em></p><p><em>Since the available modules would never change at runtime, the map should ideally be <code class="language-plaintext highlighter-rouge">const</code>.</em></p><p><em>However, due to some hard constraints, the map cannot be initialized at construction time. It can happen later through an <code class="language-plaintext highlighter-rouge">init</code> function.</em></p></blockquote><p>Let’s explore a few possible solutions—and I’d love to hear your thoughts too.</p><h2 id="a-well-encapsulated-non-const-member">A well-encapsulated non-<code class="language-plaintext highlighter-rouge">const</code> member</h2><p>You might argue that there’s no need for <code class="language-plaintext highlighter-rouge">_available_modules</code> to be <code class="language-plaintext highlighter-rouge">const</code>. As long as it’s <code class="language-plaintext highlighter-rouge">private</code>, not exposed through getters, and not modified after initialization, you could rely on discipline and convention. After all, as the owner of the <code class="language-plaintext highlighter-rouge">MyHardwareController</code> class, you’ll ensure no code will ever modify it again.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/Kbx55nn73</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">list_available_modules</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">{</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="s">"widget"</span><span class="p">},</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="s">"gadget"</span><span class="p">},</span> <span class="p">{</span><span class="mi">42</span><span class="p">,</span> <span class="s">"bar"</span><span class="p">}</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">MyHardwareController</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> <span class="n">_available_modules</span> <span class="o">=</span> <span class="n">list_available_modules</span><span class="p">();</span> <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_module_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_available_modules</span><span class="p">.</span><span class="n">contains</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_available_modules</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">_available_modules</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyHardwareController</span> <span class="n">bar</span><span class="p">;</span>
    <span class="n">bar</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">id</span> <span class="o">:</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">42</span><span class="p">})</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Module "</span> <span class="o">&lt;&lt;</span> <span class="n">id</span> <span class="o">&lt;&lt;</span> <span class="s">" is named "</span>
                  <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="p">.</span><span class="n">get_module_name</span><span class="p">(</span><span class="n">id</span><span class="p">).</span><span class="n">value_or</span><span class="p">(</span><span class="s">"&lt;unknown&gt;"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">".</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>To make it safer, you can ensure that <code class="language-plaintext highlighter-rouge">init()</code> cannot be called twice — either by returning early, signaling an error, or throwing an exception. While some embedded environments avoid exceptions, <a href="https://www.youtube.com/watch?v=bY2FlayomlE">it’s still worth reconsidering whether that restriction truly applies</a>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/549qqrj9c</span>
<span class="k">class</span> <span class="nc">MyHardwareController</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">_already_initialized</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">{</span><span class="s">"Object already initialized"</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="n">_available_modules</span> <span class="o">=</span> <span class="n">list_available_modules</span><span class="p">();</span> 
        <span class="n">_already_initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// ... rest of the class</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">_already_initialized</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">_available_modules</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The downside? Nothing in the type system explicitly communicates that <code class="language-plaintext highlighter-rouge">_available_modules</code> should never be modified after initialization. It’s a convention, not an enforced guarantee.</p><h2 id="use-an-optionalconst-map">Use an <code class="language-plaintext highlighter-rouge">optional&lt;const map&gt;</code></h2><p>Instead of a plain, mutable map, we can use an <code class="language-plaintext highlighter-rouge">optional&lt;const map&gt;</code>. What does this express to the reader?</p><p>It says: <em>there might or might not be a map yet — but once it exists, it cannot be modified</em>.</p><p>That’s a strong and useful semantic. You can still replace the entire map using <code class="language-plaintext highlighter-rouge">std::optional::emplace()</code>, but the underlying data remains immutable.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// https://godbolt.org/z/hcjsvKnGd</span>
<span class="k">class</span> <span class="nc">MyHardwareController</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">_already_initialized</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">{</span><span class="s">"Object already initialized"</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="n">_available_modules</span><span class="p">.</span><span class="n">emplace</span><span class="p">(</span><span class="n">list_available_modules</span><span class="p">());</span> 
        <span class="n">_already_initialized</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_module_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_available_modules</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_available_modules</span><span class="o">-&gt;</span><span class="n">at</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="kt">bool</span> <span class="n">_already_initialized</span> <span class="p">{</span><span class="nb">false</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">_available_modules</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>This solution is already quite robust — it enforces immutability once initialized, yet still allows deferred setup. For many cases, it’s more than good enough.</p><h2 id="have-a-registry-class">Have a registry class</h2><p>But can we communicate our intent even better?</p><p>Let’s encapsulate the map in a small helper class, <code class="language-plaintext highlighter-rouge">ModuleRegistry</code>, responsible for enforcing single initialization and <code class="language-plaintext highlighter-rouge">const</code> access. This separation makes the ownership and lifecycle of the data explicit.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">ModuleRegistry</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">set_once</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">"Modules already initialized"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">modules</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">m</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="nf">is_initialized</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">modules</span><span class="p">.</span><span class="n">has_value</span><span class="p">();</span> <span class="p">}</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">get_modules</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">modules</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">(</span><span class="s">"Modules not initialized yet"</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="n">modules</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">modules</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Then, our controller simply delegates initialization and access:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyHardwareController</span> <span class="p">{</span>
   <span class="nl">public:</span>
    <span class="kt">void</span> <span class="n">init</span><span class="p">()</span> <span class="p">{</span> 
        <span class="k">if</span> <span class="p">(</span><span class="n">_module_registry</span><span class="p">.</span><span class="n">is_initialized</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">throw</span> <span class="n">std</span><span class="o">::</span><span class="n">logic_error</span><span class="p">{</span><span class="s">"Module registry already initialized"</span><span class="p">};</span>
        <span class="p">}</span>
        <span class="n">_module_registry</span><span class="p">.</span><span class="n">set_once</span><span class="p">(</span><span class="n">list_available_modules</span><span class="p">());</span> 
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">get_module_name</span><span class="p">(</span><span class="kt">int</span> <span class="n">id</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">_module_registry</span><span class="p">.</span><span class="n">is_initialized</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">_module_registry</span><span class="p">.</span><span class="n">get_modules</span><span class="p">().</span><span class="n">contains</span><span class="p">(</span><span class="n">id</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">_module_registry</span><span class="p">.</span><span class="n">get_modules</span><span class="p">().</span><span class="n">at</span><span class="p">(</span><span class="n">id</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
    <span class="p">}</span>

   <span class="k">private</span><span class="o">:</span>
    <span class="n">ModuleRegistry</span> <span class="n">_module_registry</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In this setup, <code class="language-plaintext highlighter-rouge">ModuleRegistry</code> fully encapsulates the deferred initialization logic. It cannot be partially modified or reused incorrectly. You can even <code class="language-plaintext highlighter-rouge">delete</code> assignment operators to make replacement impossible — <a href="https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again">just remember the rule of five</a>.</p><p><a href="https://godbolt.org/z/nhb9nedvf">See the full example on Compiler Explorer.</a></p><h2 id="conclusion">Conclusion</h2><p>Deferred initialization is a tricky balance between expressiveness, safety, and practicality. If runtime constraints prevent you from initializing const data at construction time, there are still clean ways to express your intent:</p><ul><li>A <strong>private</strong> non-<code class="language-plaintext highlighter-rouge">const</code> member works but relies on discipline.<li>An <code class="language-plaintext highlighter-rouge">optional&lt;const T&gt;</code> clearly communicates immutability after initialization.<li>A dedicated <strong>registry or wrapper</strong> class adds even stronger guarantees and separation of concerns.</ul><p>In the end, the best solution depends on your context. But the key takeaway is this: <strong>even when constraints prevent you from using <code class="language-plaintext highlighter-rouge">const</code> directly, you can still design for immutability</strong>.</p><p>That mindset — of expressing intent through types - is one of the most powerful tools in modern C++.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/const/" class="post-tag no-text-decoration" >const</a> <a href="/tags/optional/" class="post-tag no-text-decoration" >optional</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Deferred member initialization - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Deferred member initialization - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Deferred member initialization - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Deferred member initialization - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/10/initializations-part-1"><div class="card-body"> <span class="timeago small" > Apr 10, 2024 <i class="unloaded">2024-04-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 1</h3><div class="text-muted small"><p> Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2026/02/04/clocks-part-10-conclusion" class="btn btn-outline-primary" prompt="Older"><p>Time in C++: Closing Thoughts</p></a> <span class="btn btn-outline-primary disabled" prompt="Newer"><p>-</p></span></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Deferred member initialization'; this.page.url = 'https://www.sandordargo.com/blog/2026/02/11/deferred-map-initialization'; this.page.identifier = '/blog/2026/02/11/deferred-map-initialization'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
