<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Time in C++: Closing Thoughts" /><meta property="og:locale" content="en_US" /><meta name="description" content="Time is time. We tend to think it’s simple to deal with it. But it’s more complex than it sounds. Both in programming and in real life. You want to measure how long something took, add a timestamp to a log entry, schedule a task for later, or display a date to a user in their local time. Each of these sounds straightforward — until clocks jump, time zones shift, or tests start failing randomly. This series started with the basics of &lt;chrono&gt;, but it was never just about learning an API. The goal was to build a mental model for time in C++: what the standard library gives us, what guarantees it makes, and where we still need to be careful. Modern C++ doesn’t try to hide the complexity of time. Instead, it makes it explicit. Clocks, time points, durations, calendars, and time zones all exist for a reason, and using them correctly starts with understanding how they fit together. In this final article, we’ll take a step back and briefly revisit the core building blocks, look at the clocks C++ provides and when to use each of them, touch on conversions and custom clocks, and close with a recap of time zones. The goal isn’t to repeat the series, but to leave you with a clear, practical map you can rely on when working with time in real-world C++ code. The Three Pillars Revisited In the first part of the series, we talked about three fundamental building blocks behind time handling in C++: time points, durations, and clocks. Almost everything in &lt;chrono&gt; is built on top of these, and most mistakes come from mixing up their roles. A time point answers a simple question: when did something happen? It represents a specific point on a timeline, but it only has meaning in the context of a clock. A time_point without knowing which clock it belongs to is incomplete — the same numeric value can represent entirely different moments depending on the clock behind it. A duration answers a different question: how long did something take? Durations are independent of clocks and epochs. They represent an amount of time, not a position on a timeline. This is why durations are usually the safest and most flexible part of &lt;chrono&gt;: they compose well, they make units explicit, and they are cheap to use. Finally, clocks define how time flows. A clock specifies an epoch, a tick rate, and the guarantees it provides — for example, whether it is steady or whether it can jump. When you choose a clock, you’re not just picking a way to read the current time, you’re choosing a set of assumptions about how that time behaves. Seen together, these three concepts form a simple but powerful model: Clocks define timelines Time points locate events on those timelines Durations measure distances between events Keeping these roles separate — and being explicit about which one you’re working with — is the foundation for writing correct, maintainable time-related code in C++. The Clock Landscape Most mistakes with time in C++ are really mistakes about which clock is being used. The standard library gives us several clocks, each with different guarantees. Knowing why they exist matters far more than memorizing their APIs. steady_clock is monotonic and never goes backwards. It is the default choice for measuring elapsed time, timeouts, and deadlines. system_clock represents wall-clock time. It can jump, but it is the right tool for timestamps, logging, and anything that needs to align with human time. high_resolution_clock is most often just an alias with no strong guarantees. In most cases, using steady_clock or system_clock directly makes intent clearer. utc_clock models UTC explicitly, including leap seconds. It exists for domains where leap-second correctness matters. tai_clock represents a continuous atomic time scale. You’ll rarely use it directly, but it underpins conversions between time scales. gps_clock represents GPS time, which is close to UTC but does not include leap seconds. It is mostly relevant in navigation, synchronization, and some embedded or scientific domains. file_clock is used for file timestamps. Its epoch and behavior are implementation-defined, which makes it suitable for filesystem operations but a poor choice for general-purpose time logic. Instead of relying on names or intuition, it helps to think in terms of use cases: Use case Recommended clock Measure elapsed time steady_clock Timeouts &amp; deadlines steady_clock Performance measurements steady_clock Logging &amp; timestamps system_clock Civil time &amp; calendars system_clock + calendar / time zones Leap-second–aware logic utc_clock File timestamps file_clock Simulations &amp; testing Custom clock Conversions: What You Can Convert — and Why Some Things Don’t Once you start working with multiple clocks, conversions become unavoidable — and &lt;chrono&gt; is deliberately conservative about what it allows. Durations are the simplest case. Converting between them is cheap, explicit, and safe, as long as you accept possible truncation. This is one of the strengths of &lt;chrono&gt;: units are part of the type system, and conversions are visible in the code. Time points are different. A time_point only makes sense in the context of its clock, and not all clocks share a common timeline. As a result, only a limited set of time-point conversions is supported, typically where there is a well-defined relationship between clocks. This is why some conversions that look “obvious” at first are not available. Preventing implicit or ambiguous conversions is a design choice, not a limitation. It forces you to acknowledge which timeline you are working on and what assumptions you are making. In practice, this means that conversions in &lt;chrono&gt; tend to be: explicit constrained and sometimes slightly verbose That verbosity is intentional. When time crosses clock boundaries, the code should make it obvious. Custom Clocks Standard clocks observe the real world. That’s fine in production, but it quickly becomes a problem in tests, simulations, or any code that needs deterministic behavior. Custom clocks let you control what “now” means and how time flows. Time can advance manually, stay frozen, or follow rules that match your domain instead of the system clock. This makes time-dependent code easier to test and reason about. More importantly, using a custom clock turns time into an explicit dependency. Instead of hiding calls to system_clock::now(), your design clearly communicates where and how time matters. Custom clocks aren’t exotic — they’re often the simplest and cleanest solution when real time gets in the way. Time Zones Time zones are where time handling usually becomes painful, and C++20 finally provides standard support for them. The goal here isn’t convenience, but correctness. The time-zone library is built around a clear separation of concerns. sys_time acts as the anchor, representing a point on the system clock’s timeline, while local_time and zoned_time handle civil time and time-zone rules. Conversions are explicit, and ambiguous situations — such as daylight saving transitions — are surfaced rather than silently guessed. This design can feel strict at first, especially compared to older APIs. But that strictness is intentional. It makes assumptions about civil time visible and forces code to deal with edge cases instead of ignoring them. In practice, time zones tend to live at the edges of a system: parsing input, displaying output, or communicating with users and external services. Keeping them there, and anchoring everything else to a well-defined clock, leads to simpler and more robust designs. Closing Thoughts Time is one of those topics that never quite stops being tricky. Clocks jump, calendars change, and even something as simple as “now” depends on more assumptions than it first appears. The goal of this series wasn’t to turn &lt;chrono&gt; into something simple, but to make it understandable. Modern C++ doesn’t hide the complexity of time — it exposes it in a structured way. Clocks, time points, durations, calendars, and time zones all exist to make different aspects of time explicit. If there’s one takeaway worth keeping, it’s this: be deliberate about time. Choose your clocks carefully, prefer durations for measurement, keep civil time and time zones at the edges, and don’t be afraid to introduce custom clocks when real time gets in the way. You don’t need to memorize every type in &lt;chrono&gt;. What matters is knowing which questions to ask and recognizing when time deserves a second thought. With that mindset, the standard library gives you the tools you need — without pretending that time is simpler than it really is. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Time is time. We tend to think it’s simple to deal with it. But it’s more complex than it sounds. Both in programming and in real life. You want to measure how long something took, add a timestamp to a log entry, schedule a task for later, or display a date to a user in their local time. Each of these sounds straightforward — until clocks jump, time zones shift, or tests start failing randomly. This series started with the basics of &lt;chrono&gt;, but it was never just about learning an API. The goal was to build a mental model for time in C++: what the standard library gives us, what guarantees it makes, and where we still need to be careful. Modern C++ doesn’t try to hide the complexity of time. Instead, it makes it explicit. Clocks, time points, durations, calendars, and time zones all exist for a reason, and using them correctly starts with understanding how they fit together. In this final article, we’ll take a step back and briefly revisit the core building blocks, look at the clocks C++ provides and when to use each of them, touch on conversions and custom clocks, and close with a recap of time zones. The goal isn’t to repeat the series, but to leave you with a clear, practical map you can rely on when working with time in real-world C++ code. The Three Pillars Revisited In the first part of the series, we talked about three fundamental building blocks behind time handling in C++: time points, durations, and clocks. Almost everything in &lt;chrono&gt; is built on top of these, and most mistakes come from mixing up their roles. A time point answers a simple question: when did something happen? It represents a specific point on a timeline, but it only has meaning in the context of a clock. A time_point without knowing which clock it belongs to is incomplete — the same numeric value can represent entirely different moments depending on the clock behind it. A duration answers a different question: how long did something take? Durations are independent of clocks and epochs. They represent an amount of time, not a position on a timeline. This is why durations are usually the safest and most flexible part of &lt;chrono&gt;: they compose well, they make units explicit, and they are cheap to use. Finally, clocks define how time flows. A clock specifies an epoch, a tick rate, and the guarantees it provides — for example, whether it is steady or whether it can jump. When you choose a clock, you’re not just picking a way to read the current time, you’re choosing a set of assumptions about how that time behaves. Seen together, these three concepts form a simple but powerful model: Clocks define timelines Time points locate events on those timelines Durations measure distances between events Keeping these roles separate — and being explicit about which one you’re working with — is the foundation for writing correct, maintainable time-related code in C++. The Clock Landscape Most mistakes with time in C++ are really mistakes about which clock is being used. The standard library gives us several clocks, each with different guarantees. Knowing why they exist matters far more than memorizing their APIs. steady_clock is monotonic and never goes backwards. It is the default choice for measuring elapsed time, timeouts, and deadlines. system_clock represents wall-clock time. It can jump, but it is the right tool for timestamps, logging, and anything that needs to align with human time. high_resolution_clock is most often just an alias with no strong guarantees. In most cases, using steady_clock or system_clock directly makes intent clearer. utc_clock models UTC explicitly, including leap seconds. It exists for domains where leap-second correctness matters. tai_clock represents a continuous atomic time scale. You’ll rarely use it directly, but it underpins conversions between time scales. gps_clock represents GPS time, which is close to UTC but does not include leap seconds. It is mostly relevant in navigation, synchronization, and some embedded or scientific domains. file_clock is used for file timestamps. Its epoch and behavior are implementation-defined, which makes it suitable for filesystem operations but a poor choice for general-purpose time logic. Instead of relying on names or intuition, it helps to think in terms of use cases: Use case Recommended clock Measure elapsed time steady_clock Timeouts &amp; deadlines steady_clock Performance measurements steady_clock Logging &amp; timestamps system_clock Civil time &amp; calendars system_clock + calendar / time zones Leap-second–aware logic utc_clock File timestamps file_clock Simulations &amp; testing Custom clock Conversions: What You Can Convert — and Why Some Things Don’t Once you start working with multiple clocks, conversions become unavoidable — and &lt;chrono&gt; is deliberately conservative about what it allows. Durations are the simplest case. Converting between them is cheap, explicit, and safe, as long as you accept possible truncation. This is one of the strengths of &lt;chrono&gt;: units are part of the type system, and conversions are visible in the code. Time points are different. A time_point only makes sense in the context of its clock, and not all clocks share a common timeline. As a result, only a limited set of time-point conversions is supported, typically where there is a well-defined relationship between clocks. This is why some conversions that look “obvious” at first are not available. Preventing implicit or ambiguous conversions is a design choice, not a limitation. It forces you to acknowledge which timeline you are working on and what assumptions you are making. In practice, this means that conversions in &lt;chrono&gt; tend to be: explicit constrained and sometimes slightly verbose That verbosity is intentional. When time crosses clock boundaries, the code should make it obvious. Custom Clocks Standard clocks observe the real world. That’s fine in production, but it quickly becomes a problem in tests, simulations, or any code that needs deterministic behavior. Custom clocks let you control what “now” means and how time flows. Time can advance manually, stay frozen, or follow rules that match your domain instead of the system clock. This makes time-dependent code easier to test and reason about. More importantly, using a custom clock turns time into an explicit dependency. Instead of hiding calls to system_clock::now(), your design clearly communicates where and how time matters. Custom clocks aren’t exotic — they’re often the simplest and cleanest solution when real time gets in the way. Time Zones Time zones are where time handling usually becomes painful, and C++20 finally provides standard support for them. The goal here isn’t convenience, but correctness. The time-zone library is built around a clear separation of concerns. sys_time acts as the anchor, representing a point on the system clock’s timeline, while local_time and zoned_time handle civil time and time-zone rules. Conversions are explicit, and ambiguous situations — such as daylight saving transitions — are surfaced rather than silently guessed. This design can feel strict at first, especially compared to older APIs. But that strictness is intentional. It makes assumptions about civil time visible and forces code to deal with edge cases instead of ignoring them. In practice, time zones tend to live at the edges of a system: parsing input, displaying output, or communicating with users and external services. Keeping them there, and anchoring everything else to a well-defined clock, leads to simpler and more robust designs. Closing Thoughts Time is one of those topics that never quite stops being tricky. Clocks jump, calendars change, and even something as simple as “now” depends on more assumptions than it first appears. The goal of this series wasn’t to turn &lt;chrono&gt; into something simple, but to make it understandable. Modern C++ doesn’t hide the complexity of time — it exposes it in a structured way. Clocks, time points, durations, calendars, and time zones all exist to make different aspects of time explicit. If there’s one takeaway worth keeping, it’s this: be deliberate about time. Choose your clocks carefully, prefer durations for measurement, keep civil time and time zones at the edges, and don’t be afraid to introduce custom clocks when real time gets in the way. You don’t need to memorize every type in &lt;chrono&gt;. What matters is knowing which questions to ask and recognizing when time deserves a second thought. With that mindset, the standard library gives you the tools you need — without pretending that time is simpler than it really is. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion" /><meta property="og:url" content="https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2026-02-04T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Time in C++: Closing Thoughts" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2026-02-04T00:00:00+01:00","datePublished":"2026-02-04T00:00:00+01:00","description":"Time is time. We tend to think it’s simple to deal with it. But it’s more complex than it sounds. Both in programming and in real life. You want to measure how long something took, add a timestamp to a log entry, schedule a task for later, or display a date to a user in their local time. Each of these sounds straightforward — until clocks jump, time zones shift, or tests start failing randomly. This series started with the basics of &lt;chrono&gt;, but it was never just about learning an API. The goal was to build a mental model for time in C++: what the standard library gives us, what guarantees it makes, and where we still need to be careful. Modern C++ doesn’t try to hide the complexity of time. Instead, it makes it explicit. Clocks, time points, durations, calendars, and time zones all exist for a reason, and using them correctly starts with understanding how they fit together. In this final article, we’ll take a step back and briefly revisit the core building blocks, look at the clocks C++ provides and when to use each of them, touch on conversions and custom clocks, and close with a recap of time zones. The goal isn’t to repeat the series, but to leave you with a clear, practical map you can rely on when working with time in real-world C++ code. The Three Pillars Revisited In the first part of the series, we talked about three fundamental building blocks behind time handling in C++: time points, durations, and clocks. Almost everything in &lt;chrono&gt; is built on top of these, and most mistakes come from mixing up their roles. A time point answers a simple question: when did something happen? It represents a specific point on a timeline, but it only has meaning in the context of a clock. A time_point without knowing which clock it belongs to is incomplete — the same numeric value can represent entirely different moments depending on the clock behind it. A duration answers a different question: how long did something take? Durations are independent of clocks and epochs. They represent an amount of time, not a position on a timeline. This is why durations are usually the safest and most flexible part of &lt;chrono&gt;: they compose well, they make units explicit, and they are cheap to use. Finally, clocks define how time flows. A clock specifies an epoch, a tick rate, and the guarantees it provides — for example, whether it is steady or whether it can jump. When you choose a clock, you’re not just picking a way to read the current time, you’re choosing a set of assumptions about how that time behaves. Seen together, these three concepts form a simple but powerful model: Clocks define timelines Time points locate events on those timelines Durations measure distances between events Keeping these roles separate — and being explicit about which one you’re working with — is the foundation for writing correct, maintainable time-related code in C++. The Clock Landscape Most mistakes with time in C++ are really mistakes about which clock is being used. The standard library gives us several clocks, each with different guarantees. Knowing why they exist matters far more than memorizing their APIs. steady_clock is monotonic and never goes backwards. It is the default choice for measuring elapsed time, timeouts, and deadlines. system_clock represents wall-clock time. It can jump, but it is the right tool for timestamps, logging, and anything that needs to align with human time. high_resolution_clock is most often just an alias with no strong guarantees. In most cases, using steady_clock or system_clock directly makes intent clearer. utc_clock models UTC explicitly, including leap seconds. It exists for domains where leap-second correctness matters. tai_clock represents a continuous atomic time scale. You’ll rarely use it directly, but it underpins conversions between time scales. gps_clock represents GPS time, which is close to UTC but does not include leap seconds. It is mostly relevant in navigation, synchronization, and some embedded or scientific domains. file_clock is used for file timestamps. Its epoch and behavior are implementation-defined, which makes it suitable for filesystem operations but a poor choice for general-purpose time logic. Instead of relying on names or intuition, it helps to think in terms of use cases: Use case Recommended clock Measure elapsed time steady_clock Timeouts &amp; deadlines steady_clock Performance measurements steady_clock Logging &amp; timestamps system_clock Civil time &amp; calendars system_clock + calendar / time zones Leap-second–aware logic utc_clock File timestamps file_clock Simulations &amp; testing Custom clock Conversions: What You Can Convert — and Why Some Things Don’t Once you start working with multiple clocks, conversions become unavoidable — and &lt;chrono&gt; is deliberately conservative about what it allows. Durations are the simplest case. Converting between them is cheap, explicit, and safe, as long as you accept possible truncation. This is one of the strengths of &lt;chrono&gt;: units are part of the type system, and conversions are visible in the code. Time points are different. A time_point only makes sense in the context of its clock, and not all clocks share a common timeline. As a result, only a limited set of time-point conversions is supported, typically where there is a well-defined relationship between clocks. This is why some conversions that look “obvious” at first are not available. Preventing implicit or ambiguous conversions is a design choice, not a limitation. It forces you to acknowledge which timeline you are working on and what assumptions you are making. In practice, this means that conversions in &lt;chrono&gt; tend to be: explicit constrained and sometimes slightly verbose That verbosity is intentional. When time crosses clock boundaries, the code should make it obvious. Custom Clocks Standard clocks observe the real world. That’s fine in production, but it quickly becomes a problem in tests, simulations, or any code that needs deterministic behavior. Custom clocks let you control what “now” means and how time flows. Time can advance manually, stay frozen, or follow rules that match your domain instead of the system clock. This makes time-dependent code easier to test and reason about. More importantly, using a custom clock turns time into an explicit dependency. Instead of hiding calls to system_clock::now(), your design clearly communicates where and how time matters. Custom clocks aren’t exotic — they’re often the simplest and cleanest solution when real time gets in the way. Time Zones Time zones are where time handling usually becomes painful, and C++20 finally provides standard support for them. The goal here isn’t convenience, but correctness. The time-zone library is built around a clear separation of concerns. sys_time acts as the anchor, representing a point on the system clock’s timeline, while local_time and zoned_time handle civil time and time-zone rules. Conversions are explicit, and ambiguous situations — such as daylight saving transitions — are surfaced rather than silently guessed. This design can feel strict at first, especially compared to older APIs. But that strictness is intentional. It makes assumptions about civil time visible and forces code to deal with edge cases instead of ignoring them. In practice, time zones tend to live at the edges of a system: parsing input, displaying output, or communicating with users and external services. Keeping them there, and anchoring everything else to a well-defined clock, leads to simpler and more robust designs. Closing Thoughts Time is one of those topics that never quite stops being tricky. Clocks jump, calendars change, and even something as simple as “now” depends on more assumptions than it first appears. The goal of this series wasn’t to turn &lt;chrono&gt; into something simple, but to make it understandable. Modern C++ doesn’t hide the complexity of time — it exposes it in a structured way. Clocks, time points, durations, calendars, and time zones all exist to make different aspects of time explicit. If there’s one takeaway worth keeping, it’s this: be deliberate about time. Choose your clocks carefully, prefer durations for measurement, keep civil time and time zones at the edges, and don’t be afraid to introduce custom clocks when real time gets in the way. You don’t need to memorize every type in &lt;chrono&gt;. What matters is knowing which questions to ask and recognizing when time deserves a second thought. With that mindset, the standard library gives you the tools you need — without pretending that time is simpler than it really is. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Time in C++: Closing Thoughts","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion"},"url":"https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion"}</script><title>Time in C++: Closing Thoughts | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2026"> 2026 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/04"> 04 </a> </span> <span>Time in C++: Closing Thoughts</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Time in C++: Closing Thoughts</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 4, 2026, 12:00 AM +0100" prep="on" > Feb 4 <i class="unloaded">2026-02-04T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1413 words">7 min</span></div></div><div class="post-content"><p>Time is time. We tend to think it’s simple to deal with it. But it’s more complex than it sounds. Both in programming and in real life.</p><p>You want to measure how long something took, add a timestamp to a log entry, schedule a task for later, or display a date to a user in their local time. Each of these sounds straightforward — until clocks jump, time zones shift, or tests start failing randomly.</p><p><a href="https://www.sandordargo.com/blog/2025/11/19/clocks-part-1-intro-to-chrono">This series started with the basics of <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code></a>, but it was never just about learning an API. The goal was to build a mental model for time in C++: what the standard library gives us, what guarantees it makes, and where we still need to be careful.</p><p>Modern C++ doesn’t try to hide the complexity of time. Instead, it makes it explicit. Clocks, time points, durations, calendars, and time zones all exist for a reason, and using them correctly starts with understanding how they fit together.</p><p>In this final article, we’ll take a step back and briefly revisit the core building blocks, look at the clocks C++ provides and when to use each of them, touch on conversions and custom clocks, and close with a recap of time zones. The goal isn’t to repeat the series, but to leave you with a clear, practical map you can rely on when working with time in real-world C++ code.</p><h2 id="the-three-pillars-revisited">The Three Pillars Revisited</h2><p><a href="https://www.sandordargo.com/blog/2025/11/19/clocks-part-1-intro-to-chrono">In the first part of the series</a>, we talked about three fundamental building blocks behind time handling in C++: <strong>time points</strong>, <strong>durations</strong>, and <strong>clocks</strong>. Almost everything in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> is built on top of these, and most mistakes come from mixing up their roles.</p><p>A <strong>time point</strong> answers a simple question: <em>when did something happen?</em> It represents a specific point on a timeline, but it only has meaning in the context of a clock. A <code class="language-plaintext highlighter-rouge">time_point</code> without knowing which clock it belongs to is incomplete — the same numeric value can represent entirely different moments depending on the clock behind it.</p><p>A <strong>duration</strong> answers a different question: <em>how long did something take?</em> Durations are independent of clocks and epochs. They represent an amount of time, not a position on a timeline. This is why durations are usually the safest and most flexible part of <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code>: they compose well, they make units explicit, and they are cheap to use.</p><p>Finally, <strong>clocks</strong> define how time flows. A clock specifies an epoch, a tick rate, and the guarantees it provides — for example, whether it is steady or whether it can jump. When you choose a clock, you’re not just picking a way to read the current time, you’re choosing a set of assumptions about how that time behaves.</p><p>Seen together, these three concepts form a simple but powerful model:</p><ul><li>Clocks define timelines<li>Time points locate events on those timelines<li>Durations measure distances between events</ul><p>Keeping these roles separate — and being explicit about which one you’re working with — is the foundation for writing correct, maintainable time-related code in C++.</p><h2 id="the-clock-landscape">The Clock Landscape</h2><p>Most mistakes with time in C++ are really mistakes about which clock is being used.</p><p>The standard library gives us several clocks, each with different guarantees. Knowing why they exist matters far more than memorizing their APIs.</p><ul><li><a href="https://www.sandordargo.com/blog/2025/12/03/clocks-part-3-steady_clock"><code class="language-plaintext highlighter-rouge">steady_clock</code> is monotonic and never goes backwards</a>. It is the default choice for measuring elapsed time, timeouts, and deadlines.<li><a href="https://www.sandordargo.com/blog/2025/11/26/clocks-part-2-system_clock"><code class="language-plaintext highlighter-rouge">system_clock</code> represents wall-clock time</a>. It can jump, but it is the right tool for timestamps, logging, and anything that needs to align with human time.<li><a href="https://www.sandordargo.com/blog/2025/12/10/clocks-part-4-high_resolution_clock"><code class="language-plaintext highlighter-rouge">high_resolution_clock</code> is most often just an alias with no strong guarantees</a>. In most cases, using <code class="language-plaintext highlighter-rouge">steady_clock</code> or <code class="language-plaintext highlighter-rouge">system_clock</code> directly makes intent clearer.<li><a href=""><code class="language-plaintext highlighter-rouge">utc_clock</code> models UTC explicitly</a>, including leap seconds. It exists for domains where leap-second correctness matters.<li><a href=""><code class="language-plaintext highlighter-rouge">tai_clock</code> represents a continuous atomic time scale</a>. You’ll rarely use it directly, but it underpins conversions between time scales.<li><a href=""><code class="language-plaintext highlighter-rouge">gps_clock</code> represents GPS time</a>, which is close to UTC but does not include leap seconds. It is mostly relevant in navigation, synchronization, and some embedded or scientific domains.<li><a href=""><code class="language-plaintext highlighter-rouge">file_clock</code> is used for file timestamps</a>. Its epoch and behavior are implementation-defined, which makes it suitable for filesystem operations but a poor choice for general-purpose time logic.</ul><p>Instead of relying on names or intuition, it helps to think in terms of use cases:</p><div class="table-wrapper"><table><thead><tr><th>Use case<th>Recommended clock<tbody><tr><td>Measure elapsed time<td><code class="language-plaintext highlighter-rouge">steady_clock</code><tr><td>Timeouts &amp; deadlines<td><code class="language-plaintext highlighter-rouge">steady_clock</code><tr><td>Performance measurements<td><code class="language-plaintext highlighter-rouge">steady_clock</code><tr><td>Logging &amp; timestamps<td><code class="language-plaintext highlighter-rouge">system_clock</code><tr><td>Civil time &amp; calendars<td><code class="language-plaintext highlighter-rouge">system_clock</code> + calendar / time zones<tr><td>Leap-second–aware logic<td><code class="language-plaintext highlighter-rouge">utc_clock</code><tr><td>File timestamps<td><code class="language-plaintext highlighter-rouge">file_clock</code><tr><td>Simulations &amp; testing<td>Custom clock</table></div><h2 id="conversions-what-you-can-convert--and-why-some-things-dont">Conversions: What You Can Convert — and Why Some Things Don’t</h2><p>Once you start working with multiple clocks, <a href="https://www.sandordargo.com/blog/2025/12/24/clocks-part-5-conversions">conversions become unavoidable — and <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> is deliberately conservative about what it allows</a>.</p><p>Durations are the simplest case. Converting between them is cheap, explicit, and safe, as long as you accept possible truncation. This is one of the strengths of<code class="language-plaintext highlighter-rouge"> &lt;chrono&gt;</code>: units are part of the type system, and conversions are visible in the code.</p><p>Time points are different. A <code class="language-plaintext highlighter-rouge">time_point</code> only makes sense in the context of its clock, and not all clocks share a common timeline. As a result, only a limited set of time-point conversions is supported, typically where there is a well-defined relationship between clocks.</p><p>This is why some conversions that look “obvious” at first are not available. Preventing implicit or ambiguous conversions is a design choice, not a limitation. It forces you to acknowledge which timeline you are working on and what assumptions you are making.</p><p>In practice, this means that conversions in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> tend to be:</p><ul><li>explicit<li>constrained<li>and sometimes slightly verbose</ul><p>That verbosity is intentional. When time crosses clock boundaries, the code should make it obvious.</p><h2 id="custom-clocks">Custom Clocks</h2><p>Standard clocks observe the real world. That’s fine in production, but it quickly becomes a problem in tests, simulations, or any code that needs deterministic behavior.</p><p><a href="">Custom clocks let you control what “now” means and how time flows</a>. Time can advance manually, stay frozen, or follow rules that match your domain instead of the system clock. This makes time-dependent code easier to test and reason about.</p><p>More importantly, using a custom clock turns time into an explicit dependency. Instead of hiding calls to <code class="language-plaintext highlighter-rouge">system_clock::now()</code>, your design clearly communicates where and how time matters.</p><p>Custom clocks aren’t exotic — they’re often the simplest and cleanest solution when real time gets in the way.</p><h2 id="time-zones">Time Zones</h2><p><a href="">Time zones are where time handling usually becomes painful, and C++20 finally provides standard support for them</a>. The goal here isn’t convenience, but correctness.</p><p>The time-zone library is built around a clear separation of concerns. <code class="language-plaintext highlighter-rouge">sys_time</code> acts as the anchor, representing a point on the system clock’s timeline, while <code class="language-plaintext highlighter-rouge">local_time</code> and <code class="language-plaintext highlighter-rouge">zoned_time</code> handle civil time and time-zone rules. Conversions are explicit, and ambiguous situations — such as daylight saving transitions — are surfaced rather than silently guessed.</p><p>This design can feel strict at first, especially compared to older APIs. But that strictness is intentional. It makes assumptions about civil time visible and forces code to deal with edge cases instead of ignoring them.</p><p>In practice, time zones tend to live at the edges of a system: parsing input, displaying output, or communicating with users and external services. Keeping them there, and anchoring everything else to a well-defined clock, leads to simpler and more robust designs.</p><h2 id="closing-thoughts">Closing Thoughts</h2><p>Time is one of those topics that never quite stops being tricky. Clocks jump, calendars change, and even something as simple as “now” depends on more assumptions than it first appears.</p><p>The goal of this series wasn’t to turn <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code> into something simple, but to make it understandable. Modern C++ doesn’t hide the complexity of time — it exposes it in a structured way. Clocks, time points, durations, calendars, and time zones all exist to make different aspects of time explicit.</p><p>If there’s one takeaway worth keeping, it’s this: be deliberate about time. Choose your clocks carefully, prefer durations for measurement, keep civil time and time zones at the edges, and don’t be afraid to introduce custom clocks when real time gets in the way.</p><p>You don’t need to memorize every type in <code class="language-plaintext highlighter-rouge">&lt;chrono&gt;</code>. What matters is knowing which questions to ask and recognizing when time deserves a second thought. With that mindset, the standard library gives you the tools you need — without pretending that time is simpler than it really is.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/clocks/" class="post-tag no-text-decoration" >clocks</a> <a href="/tags/time/" class="post-tag no-text-decoration" >time</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Time in C++: Closing Thoughts - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Time in C++: Closing Thoughts - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Time in C++: Closing Thoughts - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Time in C++: Closing Thoughts - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/12/10/clocks-part-4-high_resolution_clock"><div class="card-body"> <span class="timeago small" > Dec 10, 2025 <i class="unloaded">2025-12-10T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: std::chrono::high_resolution_clock — Myths and Realities</h3><div class="text-muted small"><p> If there’s one clock in &lt;chrono&gt; that causes the most confusion, it’s std::chrono::high_resolution_clock. The name sounds too tempting — who wouldn’t want “the highest resolution”? But like m...</p></div></div></a></div><div class="card"> <a href="/blog/2025/12/24/clocks-part-5-conversions"><div class="card-body"> <span class="timeago small" > Dec 24, 2025 <i class="unloaded">2025-12-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Inter-clock Conversions, Epochs, and Durations</h3><div class="text-muted small"><p> By now in this series, we’ve spent time looking at the major standard clocks and their behavior. We’ve talked about wall-clock time, monotonic clocks, and the myths around “high resolution”. Today,...</p></div></div></a></div><div class="card"> <a href="/blog/2026/01/07/clocks-part-6-cpp20"><div class="card-body"> <span class="timeago small" > Jan 7 <i class="unloaded">2026-01-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Time in C++: Additional clocks in C++20</h3><div class="text-muted small"><p> In this series, we’ve already talked about the main pillars behind &lt;chrono&gt;, the most widely used clocks, and even inter-clock conversions. Those clocks — system_clock, steady_clock, and hig...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2026/01/28/clocks-part-9-once-more-about-testing" class="btn btn-outline-primary" prompt="Older"><p>Time in C++: Once More About Testing</p></a> <a href="/blog/2026/02/11/deferred-map-initialization" class="btn btn-outline-primary" prompt="Newer"><p>Deferred member initialization</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Time in C++: Closing Thoughts'; this.page.url = 'https://www.sandordargo.com/blog/2026/02/04/clocks-part-10-conclusion'; this.page.identifier = '/blog/2026/02/04/clocks-part-10-conclusion'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
