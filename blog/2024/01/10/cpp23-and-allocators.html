<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: Allocator related changes" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this post, we are going to review two changes related to allocators in C++. One is about providing size information about the allocated memory and the other is about how CTAD should happen for containers with non-default allocators. Let’s get into them. Providing size feedback in the Allocator interface P0401R6 gives a new way to allocate memory on the heap to limit spurious reallocations. The new interface of std::allocator looks like this, but there is also a free function version of it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template&lt;class Pointer&gt; struct allocation_result { Pointer ptr; size_t count; }; // this class already exist: namespace std { template&lt;class T&gt; class allocator { public: // lots of existing things // ... // this is the old way to allocate [[nodiscard]] constexpr T* allocate(size_t n); // and this is the new way [[nodiscard]] constexpr allocation_result&lt;T*&gt; allocate_at_least(size_t n); // the interface for deallocation does not change constexpr void deallocate(T* p, size_t n); }; } As you can see, allocate_at_least takes a number and it should allocate enough memory for at least that many instances of T on the heap. While allocate returns a single pointer to the beginning of the allocated memory, allocate_at_least returns a new struct called allocation_result which has two members, the “usual” pointer to the beginning of the allocated memory (ptr) and the number of Ts memory got allocated for (count). count must be at least as large as the input parameter n, but it can also be more. allocate_at_least might throw two kinds of exceptions. If the memory cannot be obtained, it throws a bad_alloc exception. If n is larger than the maximum value of size_t divided by the size of T, it throws a bad_array_new_length exception. I don’t foresee that happening a lot. When you write custom allocators, this new interface can come in quite handy in order to limit the number of allocations and copies performed. Let’s take a vector for example. If you create a vector with 3 items, the chances are high that there will be more memory allocated. Then every time you push back, you either have to interact with the allocator or you have to perform some guesswork and handle if our guess is wrong. There were other alternatives considered - described in the paper - but somehow each of them introduces some extra work that is avoided if the function used for allocation returns the actual count. Non-deduction context for allocators in container deduction guides P1518R2 improves how Class Template Argument Deduction(CTAD) works for containers. The paper explains and fixes two different contexts, in one a deduction guideline is not used when it should be used, and in the other case, a deduction guide is used when it should not be used. Deduction guides were introduced in C++17. They simplify the usage of class templates by allowing the compiler to automatically deduce template arguments based on the types of constructor arguments. By providing a deduction guide alongside a class template, developers can create instances of the template without explicitly specifying template parameters. The guide specifies how to deduce the template arguments from the constructor arguments, enhancing code readability and reducing verbosity. This feature streamlines the syntax when working with class templates, promoting cleaner and more concise code. Please note, that these problems - in most cases - have been already fixed by the major compilers, so if you want to run the examples, you should use an older compiler. Luckily, with godbolt, that’s a piece of cake. With Clang, I had to go back to v14. Let’s start with the first problem. Overconstrained allocators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;memory_resource&gt; #include &lt;stack&gt; int main() { std::pmr::monotonic_buffer_resource mr; std::pmr::polymorphic_allocator&lt;int&gt; a = &amp;mr; std::pmr::vector&lt;int&gt; pv(a); auto noCtadStack = std::stack&lt;int, std::pmr::vector&lt;int&gt;&gt;(pv, &amp;mr); // #A auto ctadStack = std::stack(pv, &amp;mr); // #B } /* &lt;source&gt;:13:22: error: no viable constructor or deduction guide for deduction of template arguments of &#39;stack&#39; auto ctadStack = std::stack(pv, &amp;mr); // #B */ As you can see, the compiler complains that there is no viable deduction guide to create ctadStack at #B, whereas at line #A, we could create a stack with the very same arguments. The only relevant deduction guideline for std::stack is: 1 2 template&lt;class Container, class Allocator&gt; stack(Container, Allocator) -&gt; stack&lt;typename Container::value_type, Container&gt;; Yet, it’s not used due to &amp;mr. The problem is that according to the standard’s [container.adaptors.general] section, a deduction guide for a container adaptor shall not participate in overload resolution if it has an Allocator template parameter and a type that doesn’t qualify as an allocator is deduced for that parameter. Another restricting factor would be if the deduction guide had both a Container and an Allocator template parameter and uses_allocator_v&lt;Container, Allocator&gt; was false. uses_allocator_v&lt;std::pmr::vector&lt;int&gt;, std::pmr::monotonic_buffer_resource*&gt; is true, the problem is the first condition. A type A can be an allocator, if it has a nested-typedef A::value_type. Given that std::pmr::monotonic_buffer_resource lacks that typedef, it’s not considered an allocator. Different, conflicting deduction Let’s have a look at a very similar example. But we are going to use a vector, instead of a stack. But the problem we will see also occurs for other containers. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;memory_resource&gt; #include &lt;vector&gt; int main() { std::pmr::monotonic_buffer_resource mr; std::pmr::polymorphic_allocator&lt;int&gt; a = &amp;mr; std::pmr::vector&lt;int&gt; pv(a); auto noCtadVector = std::vector&lt;int, std::pmr::polymorphic_allocator&lt;int&gt;&gt;(pv, &amp;mr); auto ctadVector = std::vector(pv, &amp;mr); } As noCtadVector compiles, we know that the used parameters are good to initialize a std::vector. Let’s look at the relevant vector constructor: 1 2 3 4 5 6 7 8 9 namespace std { template&lt;class T, class Allocator&gt; class vector { vector(const vector&lt;T, Allocator&gt;&amp;, const Allocator&amp;); // ... }; } From the first constructor parameter, T is int and Allocator is std::pmr::polymorphic_allocator&lt;int&gt;. But from the second parameter Allocator is std::monotonic_buffer_resource*. Those two are conflicting, therefore the deduction fails. The second parameter shouldn’t participate in the deduction, because it doesn’t bring any new information and just prevents “natural and useful code from working as desired”. The solution To the first problem, to solution is to modify the wording of the standard for container adaptors deduction guides. As we saw earlier, according to the original state, a deduction guide for a container adaptor shouldn’t participate in the overload resolution if “it has an Allocator template and a type that does not qualify as an allocator is deduced for that parameter”. This is modified so that if it has a Container template parameter, then this rule doesn’t apply and the deduction guide should be part of the overload resolution (unless other rules apply). To solve the second problem, the constructors for most standard containers (for the full list, check P1518R2) are changing following the same logic. constexpr vector(const vector&amp;, const Allocator&amp;); becomes constexpr vector(const vector&amp;, const type_identity_t&lt;Allocator&gt;&amp;); and constexpr vector(vector&amp;&amp;, const Allocator&amp;); becomes constexpr vector(vector&amp;&amp;, const type_identity_t&lt;Allocator&gt;&amp;);. std::type_identity is a C++20 feature that “can be used to establish non-deduced contexts in template argument deduction.” That’s exactly why and how it is used here. Conclusion In this post, we saw two allocator-related changes in C++23. Thanks to the first change, the new interface of std::allocator gives a new way to allocate memory on the heap in order to limit spurious reallocations by returning size information about the allocated memory. The second discussed change fixes some CTAD issues that you can run into if you try to use std::pmr (or other custom allocators) with standard containers. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this post, we are going to review two changes related to allocators in C++. One is about providing size information about the allocated memory and the other is about how CTAD should happen for containers with non-default allocators. Let’s get into them. Providing size feedback in the Allocator interface P0401R6 gives a new way to allocate memory on the heap to limit spurious reallocations. The new interface of std::allocator looks like this, but there is also a free function version of it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template&lt;class Pointer&gt; struct allocation_result { Pointer ptr; size_t count; }; // this class already exist: namespace std { template&lt;class T&gt; class allocator { public: // lots of existing things // ... // this is the old way to allocate [[nodiscard]] constexpr T* allocate(size_t n); // and this is the new way [[nodiscard]] constexpr allocation_result&lt;T*&gt; allocate_at_least(size_t n); // the interface for deallocation does not change constexpr void deallocate(T* p, size_t n); }; } As you can see, allocate_at_least takes a number and it should allocate enough memory for at least that many instances of T on the heap. While allocate returns a single pointer to the beginning of the allocated memory, allocate_at_least returns a new struct called allocation_result which has two members, the “usual” pointer to the beginning of the allocated memory (ptr) and the number of Ts memory got allocated for (count). count must be at least as large as the input parameter n, but it can also be more. allocate_at_least might throw two kinds of exceptions. If the memory cannot be obtained, it throws a bad_alloc exception. If n is larger than the maximum value of size_t divided by the size of T, it throws a bad_array_new_length exception. I don’t foresee that happening a lot. When you write custom allocators, this new interface can come in quite handy in order to limit the number of allocations and copies performed. Let’s take a vector for example. If you create a vector with 3 items, the chances are high that there will be more memory allocated. Then every time you push back, you either have to interact with the allocator or you have to perform some guesswork and handle if our guess is wrong. There were other alternatives considered - described in the paper - but somehow each of them introduces some extra work that is avoided if the function used for allocation returns the actual count. Non-deduction context for allocators in container deduction guides P1518R2 improves how Class Template Argument Deduction(CTAD) works for containers. The paper explains and fixes two different contexts, in one a deduction guideline is not used when it should be used, and in the other case, a deduction guide is used when it should not be used. Deduction guides were introduced in C++17. They simplify the usage of class templates by allowing the compiler to automatically deduce template arguments based on the types of constructor arguments. By providing a deduction guide alongside a class template, developers can create instances of the template without explicitly specifying template parameters. The guide specifies how to deduce the template arguments from the constructor arguments, enhancing code readability and reducing verbosity. This feature streamlines the syntax when working with class templates, promoting cleaner and more concise code. Please note, that these problems - in most cases - have been already fixed by the major compilers, so if you want to run the examples, you should use an older compiler. Luckily, with godbolt, that’s a piece of cake. With Clang, I had to go back to v14. Let’s start with the first problem. Overconstrained allocators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;memory_resource&gt; #include &lt;stack&gt; int main() { std::pmr::monotonic_buffer_resource mr; std::pmr::polymorphic_allocator&lt;int&gt; a = &amp;mr; std::pmr::vector&lt;int&gt; pv(a); auto noCtadStack = std::stack&lt;int, std::pmr::vector&lt;int&gt;&gt;(pv, &amp;mr); // #A auto ctadStack = std::stack(pv, &amp;mr); // #B } /* &lt;source&gt;:13:22: error: no viable constructor or deduction guide for deduction of template arguments of &#39;stack&#39; auto ctadStack = std::stack(pv, &amp;mr); // #B */ As you can see, the compiler complains that there is no viable deduction guide to create ctadStack at #B, whereas at line #A, we could create a stack with the very same arguments. The only relevant deduction guideline for std::stack is: 1 2 template&lt;class Container, class Allocator&gt; stack(Container, Allocator) -&gt; stack&lt;typename Container::value_type, Container&gt;; Yet, it’s not used due to &amp;mr. The problem is that according to the standard’s [container.adaptors.general] section, a deduction guide for a container adaptor shall not participate in overload resolution if it has an Allocator template parameter and a type that doesn’t qualify as an allocator is deduced for that parameter. Another restricting factor would be if the deduction guide had both a Container and an Allocator template parameter and uses_allocator_v&lt;Container, Allocator&gt; was false. uses_allocator_v&lt;std::pmr::vector&lt;int&gt;, std::pmr::monotonic_buffer_resource*&gt; is true, the problem is the first condition. A type A can be an allocator, if it has a nested-typedef A::value_type. Given that std::pmr::monotonic_buffer_resource lacks that typedef, it’s not considered an allocator. Different, conflicting deduction Let’s have a look at a very similar example. But we are going to use a vector, instead of a stack. But the problem we will see also occurs for other containers. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;memory_resource&gt; #include &lt;vector&gt; int main() { std::pmr::monotonic_buffer_resource mr; std::pmr::polymorphic_allocator&lt;int&gt; a = &amp;mr; std::pmr::vector&lt;int&gt; pv(a); auto noCtadVector = std::vector&lt;int, std::pmr::polymorphic_allocator&lt;int&gt;&gt;(pv, &amp;mr); auto ctadVector = std::vector(pv, &amp;mr); } As noCtadVector compiles, we know that the used parameters are good to initialize a std::vector. Let’s look at the relevant vector constructor: 1 2 3 4 5 6 7 8 9 namespace std { template&lt;class T, class Allocator&gt; class vector { vector(const vector&lt;T, Allocator&gt;&amp;, const Allocator&amp;); // ... }; } From the first constructor parameter, T is int and Allocator is std::pmr::polymorphic_allocator&lt;int&gt;. But from the second parameter Allocator is std::monotonic_buffer_resource*. Those two are conflicting, therefore the deduction fails. The second parameter shouldn’t participate in the deduction, because it doesn’t bring any new information and just prevents “natural and useful code from working as desired”. The solution To the first problem, to solution is to modify the wording of the standard for container adaptors deduction guides. As we saw earlier, according to the original state, a deduction guide for a container adaptor shouldn’t participate in the overload resolution if “it has an Allocator template and a type that does not qualify as an allocator is deduced for that parameter”. This is modified so that if it has a Container template parameter, then this rule doesn’t apply and the deduction guide should be part of the overload resolution (unless other rules apply). To solve the second problem, the constructors for most standard containers (for the full list, check P1518R2) are changing following the same logic. constexpr vector(const vector&amp;, const Allocator&amp;); becomes constexpr vector(const vector&amp;, const type_identity_t&lt;Allocator&gt;&amp;); and constexpr vector(vector&amp;&amp;, const Allocator&amp;); becomes constexpr vector(vector&amp;&amp;, const type_identity_t&lt;Allocator&gt;&amp;);. std::type_identity is a C++20 feature that “can be used to establish non-deduced contexts in template argument deduction.” That’s exactly why and how it is used here. Conclusion In this post, we saw two allocator-related changes in C++23. Thanks to the first change, the new interface of std::allocator gives a new way to allocate memory on the heap in order to limit spurious reallocations by returning size information about the allocated memory. The second discussed change fixes some CTAD issues that you can run into if you try to use std::pmr (or other custom allocators) with standard containers. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-01-10T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: Allocator related changes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-01-10T00:00:00+01:00","datePublished":"2024-01-10T00:00:00+01:00","description":"In this post, we are going to review two changes related to allocators in C++. One is about providing size information about the allocated memory and the other is about how CTAD should happen for containers with non-default allocators. Let’s get into them. Providing size feedback in the Allocator interface P0401R6 gives a new way to allocate memory on the heap to limit spurious reallocations. The new interface of std::allocator looks like this, but there is also a free function version of it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 template&lt;class Pointer&gt; struct allocation_result { Pointer ptr; size_t count; }; // this class already exist: namespace std { template&lt;class T&gt; class allocator { public: // lots of existing things // ... // this is the old way to allocate [[nodiscard]] constexpr T* allocate(size_t n); // and this is the new way [[nodiscard]] constexpr allocation_result&lt;T*&gt; allocate_at_least(size_t n); // the interface for deallocation does not change constexpr void deallocate(T* p, size_t n); }; } As you can see, allocate_at_least takes a number and it should allocate enough memory for at least that many instances of T on the heap. While allocate returns a single pointer to the beginning of the allocated memory, allocate_at_least returns a new struct called allocation_result which has two members, the “usual” pointer to the beginning of the allocated memory (ptr) and the number of Ts memory got allocated for (count). count must be at least as large as the input parameter n, but it can also be more. allocate_at_least might throw two kinds of exceptions. If the memory cannot be obtained, it throws a bad_alloc exception. If n is larger than the maximum value of size_t divided by the size of T, it throws a bad_array_new_length exception. I don’t foresee that happening a lot. When you write custom allocators, this new interface can come in quite handy in order to limit the number of allocations and copies performed. Let’s take a vector for example. If you create a vector with 3 items, the chances are high that there will be more memory allocated. Then every time you push back, you either have to interact with the allocator or you have to perform some guesswork and handle if our guess is wrong. There were other alternatives considered - described in the paper - but somehow each of them introduces some extra work that is avoided if the function used for allocation returns the actual count. Non-deduction context for allocators in container deduction guides P1518R2 improves how Class Template Argument Deduction(CTAD) works for containers. The paper explains and fixes two different contexts, in one a deduction guideline is not used when it should be used, and in the other case, a deduction guide is used when it should not be used. Deduction guides were introduced in C++17. They simplify the usage of class templates by allowing the compiler to automatically deduce template arguments based on the types of constructor arguments. By providing a deduction guide alongside a class template, developers can create instances of the template without explicitly specifying template parameters. The guide specifies how to deduce the template arguments from the constructor arguments, enhancing code readability and reducing verbosity. This feature streamlines the syntax when working with class templates, promoting cleaner and more concise code. Please note, that these problems - in most cases - have been already fixed by the major compilers, so if you want to run the examples, you should use an older compiler. Luckily, with godbolt, that’s a piece of cake. With Clang, I had to go back to v14. Let’s start with the first problem. Overconstrained allocators 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;memory_resource&gt; #include &lt;stack&gt; int main() { std::pmr::monotonic_buffer_resource mr; std::pmr::polymorphic_allocator&lt;int&gt; a = &amp;mr; std::pmr::vector&lt;int&gt; pv(a); auto noCtadStack = std::stack&lt;int, std::pmr::vector&lt;int&gt;&gt;(pv, &amp;mr); // #A auto ctadStack = std::stack(pv, &amp;mr); // #B } /* &lt;source&gt;:13:22: error: no viable constructor or deduction guide for deduction of template arguments of &#39;stack&#39; auto ctadStack = std::stack(pv, &amp;mr); // #B */ As you can see, the compiler complains that there is no viable deduction guide to create ctadStack at #B, whereas at line #A, we could create a stack with the very same arguments. The only relevant deduction guideline for std::stack is: 1 2 template&lt;class Container, class Allocator&gt; stack(Container, Allocator) -&gt; stack&lt;typename Container::value_type, Container&gt;; Yet, it’s not used due to &amp;mr. The problem is that according to the standard’s [container.adaptors.general] section, a deduction guide for a container adaptor shall not participate in overload resolution if it has an Allocator template parameter and a type that doesn’t qualify as an allocator is deduced for that parameter. Another restricting factor would be if the deduction guide had both a Container and an Allocator template parameter and uses_allocator_v&lt;Container, Allocator&gt; was false. uses_allocator_v&lt;std::pmr::vector&lt;int&gt;, std::pmr::monotonic_buffer_resource*&gt; is true, the problem is the first condition. A type A can be an allocator, if it has a nested-typedef A::value_type. Given that std::pmr::monotonic_buffer_resource lacks that typedef, it’s not considered an allocator. Different, conflicting deduction Let’s have a look at a very similar example. But we are going to use a vector, instead of a stack. But the problem we will see also occurs for other containers. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;memory_resource&gt; #include &lt;vector&gt; int main() { std::pmr::monotonic_buffer_resource mr; std::pmr::polymorphic_allocator&lt;int&gt; a = &amp;mr; std::pmr::vector&lt;int&gt; pv(a); auto noCtadVector = std::vector&lt;int, std::pmr::polymorphic_allocator&lt;int&gt;&gt;(pv, &amp;mr); auto ctadVector = std::vector(pv, &amp;mr); } As noCtadVector compiles, we know that the used parameters are good to initialize a std::vector. Let’s look at the relevant vector constructor: 1 2 3 4 5 6 7 8 9 namespace std { template&lt;class T, class Allocator&gt; class vector { vector(const vector&lt;T, Allocator&gt;&amp;, const Allocator&amp;); // ... }; } From the first constructor parameter, T is int and Allocator is std::pmr::polymorphic_allocator&lt;int&gt;. But from the second parameter Allocator is std::monotonic_buffer_resource*. Those two are conflicting, therefore the deduction fails. The second parameter shouldn’t participate in the deduction, because it doesn’t bring any new information and just prevents “natural and useful code from working as desired”. The solution To the first problem, to solution is to modify the wording of the standard for container adaptors deduction guides. As we saw earlier, according to the original state, a deduction guide for a container adaptor shouldn’t participate in the overload resolution if “it has an Allocator template and a type that does not qualify as an allocator is deduced for that parameter”. This is modified so that if it has a Container template parameter, then this rule doesn’t apply and the deduction guide should be part of the overload resolution (unless other rules apply). To solve the second problem, the constructors for most standard containers (for the full list, check P1518R2) are changing following the same logic. constexpr vector(const vector&amp;, const Allocator&amp;); becomes constexpr vector(const vector&amp;, const type_identity_t&lt;Allocator&gt;&amp;); and constexpr vector(vector&amp;&amp;, const Allocator&amp;); becomes constexpr vector(vector&amp;&amp;, const type_identity_t&lt;Allocator&gt;&amp;);. std::type_identity is a C++20 feature that “can be used to establish non-deduced contexts in template argument deduction.” That’s exactly why and how it is used here. Conclusion In this post, we saw two allocator-related changes in C++23. Thanks to the first change, the new interface of std::allocator gives a new way to allocate memory on the heap in order to limit spurious reallocations by returning size information about the allocated memory. The second discussed change fixes some CTAD issues that you can run into if you try to use std::pmr (or other custom allocators) with standard containers. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: Allocator related changes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators"},"url":"https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators"}</script><title>C++23: Allocator related changes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/10"> 10 </a> </span> <span>C++23: Allocator related changes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: Allocator related changes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 10, 2024, 12:00 AM +0100" prep="on" > Jan 10, 2024 <i class="unloaded">2024-01-10T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1290 words">7 min</span></div></div><div class="post-content"><p>In this post, we are going to review two changes related to allocators in C++. One is about providing size information about the allocated memory and the other is about how CTAD should happen for containers with non-default allocators.</p><p>Let’s get into them.</p><h2 id="providing-size-feedback-in-the-allocator-interface">Providing size feedback in the Allocator interface</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0401r6.html">P0401R6</a> gives a new way to allocate memory on the heap to limit spurious reallocations.</p><p>The new interface of <code class="language-plaintext highlighter-rouge">std::allocator</code> looks like this, but there is also a free function version of it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Pointer</span><span class="p">&gt;</span>
  <span class="k">struct</span> <span class="nc">allocation_result</span> <span class="p">{</span>
    <span class="n">Pointer</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="kt">size_t</span> <span class="n">count</span><span class="p">;</span>
  <span class="p">};</span>

<span class="c1">// this class already exist:</span>
<span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">class</span> <span class="nc">allocator</span> <span class="p">{</span>
   <span class="nl">public:</span>
   <span class="c1">// lots of existing things</span>
   <span class="c1">// ...</span>
   <span class="c1">// this is the old way to allocate </span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">T</span><span class="o">*</span> <span class="n">allocate</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>

   <span class="c1">// and this is the new way</span>
   <span class="p">[[</span><span class="n">nodiscard</span><span class="p">]]</span> <span class="k">constexpr</span> <span class="n">allocation_result</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">allocate_at_least</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>

   <span class="c1">// the interface for deallocation does not change</span>
   <span class="k">constexpr</span> <span class="kt">void</span> <span class="n">deallocate</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, <code class="language-plaintext highlighter-rouge">allocate_at_least</code> takes a number and it should allocate enough memory for at least that many instances of <code class="language-plaintext highlighter-rouge">T</code> on the heap. While <code class="language-plaintext highlighter-rouge">allocate</code> returns a single pointer to the beginning of the allocated memory, <code class="language-plaintext highlighter-rouge">allocate_at_least</code> returns a new <code class="language-plaintext highlighter-rouge">struct</code> called <code class="language-plaintext highlighter-rouge">allocation_result</code> which has two members, the “usual” pointer to the beginning of the allocated memory (<code class="language-plaintext highlighter-rouge">ptr</code>) and the number of <code class="language-plaintext highlighter-rouge">T</code>s memory got allocated for (<code class="language-plaintext highlighter-rouge">count</code>). <code class="language-plaintext highlighter-rouge">count</code> must be at least as large as the input parameter <code class="language-plaintext highlighter-rouge">n</code>, but it can also be more.</p><p><code class="language-plaintext highlighter-rouge">allocate_at_least</code> might throw two kinds of exceptions. If the memory cannot be obtained, it throws a <code class="language-plaintext highlighter-rouge">bad_alloc</code> exception. If <code class="language-plaintext highlighter-rouge">n</code> is larger than the maximum value of <code class="language-plaintext highlighter-rouge">size_t</code> divided by the size of <code class="language-plaintext highlighter-rouge">T</code>, it throws a <code class="language-plaintext highlighter-rouge">bad_array_new_length</code> exception. I don’t foresee that happening a lot.</p><p>When you write custom allocators, this new interface can come in quite handy in order to limit the number of allocations and copies performed. Let’s take a vector for example. If you create a vector with 3 items, the chances are high that there will be more memory allocated. Then every time you push back, you either have to interact with the allocator or you have to perform some guesswork and handle if our guess is wrong.</p><p>There were other alternatives considered - <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0401r6.html">described in the paper</a> - but somehow each of them introduces some extra work that is avoided if the function used for allocation returns the actual <code class="language-plaintext highlighter-rouge">count</code>.</p><h2 id="non-deduction-context-for-allocators-in-container-deduction-guides">Non-deduction context for allocators in container deduction guides</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1518r2.html">P1518R2</a> improves how <em>Class Template Argument Deduction</em>(<a href="https://en.cppreference.com/w/cpp/language/class_template_argument_deduction">CTAD</a>) works for containers.</p><p>The paper explains and fixes two different contexts, in one a deduction guideline is not used when it should be used, and in the other case, a deduction guide is used when it should not be used.</p><blockquote><p>Deduction guides were introduced in C++17. They simplify the usage of class templates by allowing the compiler to automatically deduce template arguments based on the types of constructor arguments. By providing a deduction guide alongside a class template, developers can create instances of the template without explicitly specifying template parameters. The guide specifies how to deduce the template arguments from the constructor arguments, enhancing code readability and reducing verbosity. This feature streamlines the syntax when working with class templates, promoting cleaner and more concise code.</p></blockquote><p><em>Please note, that these problems - in most cases - have been already fixed by the major compilers, so if you want to run the examples, you should use an older compiler. Luckily, with <a href="https://godbolt.org/z/Gscj7ocYz">godbolt</a>, that’s a piece of cake. With Clang, I had to go back to v14.</em></p><p>Let’s start with the first problem.</p><h3 id="overconstrained-allocators">Overconstrained allocators</h3><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;stack&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">mr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pv</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>


    <span class="k">auto</span> <span class="n">noCtadStack</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mr</span><span class="p">);</span> <span class="c1">// #A</span>

    <span class="k">auto</span> <span class="n">ctadStack</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">stack</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mr</span><span class="p">);</span>  <span class="c1">// #B</span>
<span class="p">}</span>
<span class="cm">/*
&lt;source&gt;:13:22: error: no viable constructor or deduction guide for deduction of template arguments of 'stack'
    auto ctadStack = std::stack(pv, &amp;mr);  // #B
*/</span>
</pre></table></code></div></div><p>As you can see, the compiler complains that there is no viable deduction guide to create <code class="language-plaintext highlighter-rouge">ctadStack</code> at <em>#B</em>, whereas at line <em>#A</em>, we could create a stack with the very same arguments.</p><p>The only relevant deduction guideline for <code class="language-plaintext highlighter-rouge">std::stack</code> is:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">Container</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span><span class="p">&gt;</span>
<span class="n">stack</span><span class="p">(</span><span class="n">Container</span><span class="p">,</span> <span class="n">Allocator</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">stack</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">Container</span><span class="o">::</span><span class="n">value_type</span><span class="p">,</span> <span class="n">Container</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>Yet, it’s not used due to <code class="language-plaintext highlighter-rouge">&amp;mr</code>. The problem is that according to the standard’s <em>[container.adaptors.general]</em> section, a deduction guide for a container adaptor shall <strong>not</strong> participate in overload resolution if it has an <strong>Allocator</strong> template parameter and a type that doesn’t qualify as an allocator is deduced for that parameter. Another restricting factor would be if the deduction guide had both a Container and an Allocator template parameter and <code class="language-plaintext highlighter-rouge">uses_allocator_v&lt;Container, Allocator&gt;</code> was false.</p><p><code class="language-plaintext highlighter-rouge">uses_allocator_v&lt;std::pmr::vector&lt;int&gt;, std::pmr::monotonic_buffer_resource*&gt;</code> is <code class="language-plaintext highlighter-rouge">true</code>, the problem is the first condition. A type <code class="language-plaintext highlighter-rouge">A</code> can be an allocator, if it has a nested-typedef <code class="language-plaintext highlighter-rouge">A::value_type</code>. Given that <code class="language-plaintext highlighter-rouge">std::pmr::monotonic_buffer_resource</code> lacks that typedef, it’s not considered an allocator.</p><h3 id="different-conflicting-deduction">Different, conflicting deduction</h3><p>Let’s have a look at a very similar example. But we are going to use a <code class="language-plaintext highlighter-rouge">vector</code>, instead of a <code class="language-plaintext highlighter-rouge">stack</code>. But the problem we will see also occurs for other containers.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory_resource&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">monotonic_buffer_resource</span> <span class="n">mr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">a</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">mr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pv</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">noCtadVector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">pmr</span><span class="o">::</span><span class="n">polymorphic_allocator</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mr</span><span class="p">);</span>

    <span class="k">auto</span> <span class="n">ctadVector</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">(</span><span class="n">pv</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">mr</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As <code class="language-plaintext highlighter-rouge">noCtadVector</code> compiles, we know that the used parameters are good to initialize a <code class="language-plaintext highlighter-rouge">std::vector</code>.</p><p>Let’s look at the relevant <code class="language-plaintext highlighter-rouge">vector</code> constructor:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">namespace</span> <span class="n">std</span> <span class="p">{</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Allocator</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">vector</span> <span class="p">{</span>
    <span class="n">vector</span><span class="p">(</span><span class="k">const</span> <span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Allocator</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="p">}</span> 
</pre></table></code></div></div><p>From the first constructor parameter, <code class="language-plaintext highlighter-rouge">T</code> is <code class="language-plaintext highlighter-rouge">int</code> and <code class="language-plaintext highlighter-rouge">Allocator</code> is <code class="language-plaintext highlighter-rouge">std::pmr::polymorphic_allocator&lt;int&gt;</code>. But from the second parameter <code class="language-plaintext highlighter-rouge">Allocator</code> is <code class="language-plaintext highlighter-rouge">std::monotonic_buffer_resource*</code>. Those two are conflicting, therefore the deduction fails. The second parameter shouldn’t participate in the deduction, because it doesn’t bring any new information and just prevents “natural and useful code from working as desired”.</p><h3 id="the-solution">The solution</h3><p>To the first problem, to solution is to modify the wording of the standard for container adaptors deduction guides. As we saw earlier, according to the original state, a deduction guide for a container adaptor shouldn’t participate in the overload resolution if “it has an <code class="language-plaintext highlighter-rouge">Allocator</code> template and a type that does not qualify as an allocator is deduced for that parameter”. This is modified so that if it has a <code class="language-plaintext highlighter-rouge">Container</code> template parameter, then this rule doesn’t apply and the deduction guide should be part of the overload resolution (unless other rules apply).</p><p>To solve the second problem, the constructors for most standard containers (for the full list, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1518r2.html#wording">check P1518R2</a>) are changing following the same logic.</p><p><code class="language-plaintext highlighter-rouge">constexpr vector(const vector&amp;, const Allocator&amp;);</code> becomes <code class="language-plaintext highlighter-rouge">constexpr vector(const vector&amp;, const type_identity_t&lt;Allocator&gt;&amp;);</code> and <code class="language-plaintext highlighter-rouge">constexpr vector(vector&amp;&amp;, const Allocator&amp;);</code> becomes <code class="language-plaintext highlighter-rouge">constexpr vector(vector&amp;&amp;, const type_identity_t&lt;Allocator&gt;&amp;);</code>.</p><blockquote><p><code class="language-plaintext highlighter-rouge">std::type_identity</code> is a C++20 feature that “can be used to establish non-deduced contexts in template argument deduction.” That’s exactly why and how it is used here.</p></blockquote><h2 id="conclusion">Conclusion</h2><p>In this post, we saw two allocator-related changes in C++23. Thanks to the first change, the new interface of <code class="language-plaintext highlighter-rouge">std::allocator</code> gives a new way to allocate memory on the heap in order to limit spurious reallocations by returning size information about the allocated memory. The second discussed change fixes some CTAD issues that you can run into if you try to use <code class="language-plaintext highlighter-rouge">std::pmr</code> (or other custom allocators) with standard containers.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/allocators/" class="post-tag no-text-decoration" >allocators</a> <a href="/tags/ctad/" class="post-tag no-text-decoration" >ctad</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: Allocator related changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: Allocator related changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: Allocator related changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: Allocator related changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/01/06/wiring-the-winning-organization-by-gene-kim" class="btn btn-outline-primary" prompt="Older"><p>Wiring the Winning Organization by Gene Kim and Steven J. Spear</p></a> <a href="/blog/2024/01/17/cpp23-bitwise-operations" class="btn btn-outline-primary" prompt="Newer"><p>C++23: bitwise operations</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: Allocator related changes'; this.page.url = 'https://www.sandordargo.com/blog/2024/01/10/cpp23-and-allocators'; this.page.identifier = '/blog/2024/01/10/cpp23-and-allocators'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
