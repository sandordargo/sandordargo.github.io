<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23 likes to move it!" /><meta property="og:locale" content="en_US" /><meta name="description" content="C++23 is going to bring us a few changes regarding move operations. It mostly means extended support in the standard library, but there is also one change directly in the language. Let’s start with that. Simpler implicit move P2266R3 is a quite great proposal both in terms of its high-quality explanation and the amount of proposed changes in wording. I think if you’re interested in exploring a readable proposal, this might be the one. Let me try to summarize it briefly. Since the introduction of move semantics and rvalue references in C++11, we can return move-only types by value: 1 2 3 4 5 6 7 struct Widget { Widget(Widget&amp;&amp;); }; Widget one(Widget w) { return w; } C++14 extended this support so that even converting constructors accepting an rvalue type can be called to invoke an implicit move. 1 2 3 4 5 6 7 struct RRefTaker { RRefTaker(Widget&amp;&amp;); // here is the converting constructor }; RRefTaker two(Widget w) { return w; } As you can see, the two examples follow the same logic, in a sense they are quite symmetric. C++20 introduced some changes in copy elision and overload resolution. As a consequence two() would work even if w was taken as an rvalue (Widget&amp;&amp;). But because of a wording issue, if it had to take a Widget&amp;&amp; and return the same Widget&amp;&amp; we would get an error. The original wording is rather complex as it’s also claimed in the abstract of P2266R3. The proposal fixes the mentioned defect and also simplifies the specification by saying that a returned move-eligible id-expression is always an xvalue. In C++, an eXpiring value (xvalue in short) represents an expiring or about-to-expire value. It typically occurs in the context of a move operation or when the value is no longer needed in its current location. Examples include the result of std::move() and operator[] applied to an rvalue. GCC 13 and Clang 13 already support this! std::move_only_function P0288R9 addresses a request that has been opened in 2014. Nobody can say that this is a reckless change! std::move_only_function is like std::function, but for move-only types. It’s a wrapper for any constructible callable targets, such as functions, lambdas, function objects or bind expressions. The wrapper can only be moved as its copy assignment operator and copy constructor are deleted. It also supports cv/ref/noexcept qualifiers in function types. You (will) find this new utility in the &lt;functional&gt; wrapper. GCC 12 and MSVC 19.32 already support this! Given that this has been awaited for a long time and that std::function has a bad reputation, I plan to experiment with std::move_only_function in a few weeks and report back the results.. Adding move-only types support for comparison concepts C++20 introduced concepts and even though we have move semantics in C++ since C++11, many important concepts do not support move-only types, such as std::equality_comparable_with, totally_ordered_with or three_way_comparable_with. The reason is often that these concepts are implemented in a way that two const&amp; types have to be convertible to the non-reference std::common_reference_t which means that the two types have to be copyable. P2404R3 aims to relaxing this requriement by replacing common_reference_with&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt; with comparison-common-type-with &lt;T, U&gt; in std::three_way_comparable_with and in std::equality_comparable_with. It also relaxes the preconditions in std::totally_ordered_with so that it supports move-only types. comparison-common-type-with &lt;T, U&gt; is an exposition-only concept intended to determine that there exists a common supertype of T and U even if they are move-only types. Exposition-only means that they are not required by the standard, they just illustrate the intentions of the authors. An exposition-only definition is also a hint to the implementers about what the committee had in mind. MSVC 19.36 already supports this! Relaxing range adaptors to allow for move-only types Even though ranges were introduced to C++ many years later than move-semantics, still several range adaptors require that the types they store are copy-constructible. P2494R2 slightly modifies the views that currently use the exposition-only type copyable-box for user-provided predicates. That slight modification is that copyable-box is renamed to movable-box, but no constraints are modified for the changed views. It goes further though for transform-like views, where requirements on invocables are relaxed. Now their invocables don’t have to be copy-constructible anymore, move-constructability is enough. These views are: single_view, transform_view, zip_transform_view, and adjacent_transform_view. MSVC 19.34 already supports this! std::move_iterator should not always be input_iterator In order to understand the goals of this paper, let’s start with a bit of C++ history. In C++17, you could only subtract two iterators, if they were random access iterators. At the same time, there was no other way to get the size of a range. If you want a short reminder on what iterators are, read this article. C++20 improved this situation and even input iterators can be subtracted from their ranges’ “end” marked by a so-called sized_sentinel_for object and the standardized ranges can provide their size in a cheaper way than subtraction. Given that the range is a so-called sized range. On the other hand, if the range is unsized, there are some issues. If a range is unsized, you cannot construct a vector out of it by one single allocation, since we don’t know the size. Instead, the compiler has to loop over the range and keep pushing back to the vector. 1 some_unsized_forward_range | views::move | ranges::to&lt;vector&gt;() In C++20, move_iterator&lt;T*&gt; is an input_iterator which can be problematic. You can go through input_iterators normally multiple times without a problem, but you cannot do the same with move_iterator because if you do so, the second time you already pass through moved-from objects. Therefore library authors have to be very cautious and recognize if they deal with move_iterator. P2520R0 fixes this problem by not having move_iterator&lt;Iterator&gt;::interator_concept always input_iterator_tag. iterator_concept will be based on the actual Iterator. iterator_concept will only be input_iterator_tag if Iterator doesn’t model random_access_iterator, bidirectional_iterator or forward_iterator. If Iterator models one of those then the concept will be the corresponding tag (&lt;iterator concept&gt;_tag). As such, the above example can work fine with a single allocation, because if Iterator is a random access iterator (such as for T*), then the compiler can get the size without accessing any item, without passing through the range. Clang 17 and MSVC 19.34 already support this! Conclusion In this article, we reviewed how C++23 relaxes many requirements. More and more operations that required copy-constructible objects now will only require move-constructible ones. These are quite logical changes that are also good for performance. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="C++23 is going to bring us a few changes regarding move operations. It mostly means extended support in the standard library, but there is also one change directly in the language. Let’s start with that. Simpler implicit move P2266R3 is a quite great proposal both in terms of its high-quality explanation and the amount of proposed changes in wording. I think if you’re interested in exploring a readable proposal, this might be the one. Let me try to summarize it briefly. Since the introduction of move semantics and rvalue references in C++11, we can return move-only types by value: 1 2 3 4 5 6 7 struct Widget { Widget(Widget&amp;&amp;); }; Widget one(Widget w) { return w; } C++14 extended this support so that even converting constructors accepting an rvalue type can be called to invoke an implicit move. 1 2 3 4 5 6 7 struct RRefTaker { RRefTaker(Widget&amp;&amp;); // here is the converting constructor }; RRefTaker two(Widget w) { return w; } As you can see, the two examples follow the same logic, in a sense they are quite symmetric. C++20 introduced some changes in copy elision and overload resolution. As a consequence two() would work even if w was taken as an rvalue (Widget&amp;&amp;). But because of a wording issue, if it had to take a Widget&amp;&amp; and return the same Widget&amp;&amp; we would get an error. The original wording is rather complex as it’s also claimed in the abstract of P2266R3. The proposal fixes the mentioned defect and also simplifies the specification by saying that a returned move-eligible id-expression is always an xvalue. In C++, an eXpiring value (xvalue in short) represents an expiring or about-to-expire value. It typically occurs in the context of a move operation or when the value is no longer needed in its current location. Examples include the result of std::move() and operator[] applied to an rvalue. GCC 13 and Clang 13 already support this! std::move_only_function P0288R9 addresses a request that has been opened in 2014. Nobody can say that this is a reckless change! std::move_only_function is like std::function, but for move-only types. It’s a wrapper for any constructible callable targets, such as functions, lambdas, function objects or bind expressions. The wrapper can only be moved as its copy assignment operator and copy constructor are deleted. It also supports cv/ref/noexcept qualifiers in function types. You (will) find this new utility in the &lt;functional&gt; wrapper. GCC 12 and MSVC 19.32 already support this! Given that this has been awaited for a long time and that std::function has a bad reputation, I plan to experiment with std::move_only_function in a few weeks and report back the results.. Adding move-only types support for comparison concepts C++20 introduced concepts and even though we have move semantics in C++ since C++11, many important concepts do not support move-only types, such as std::equality_comparable_with, totally_ordered_with or three_way_comparable_with. The reason is often that these concepts are implemented in a way that two const&amp; types have to be convertible to the non-reference std::common_reference_t which means that the two types have to be copyable. P2404R3 aims to relaxing this requriement by replacing common_reference_with&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt; with comparison-common-type-with &lt;T, U&gt; in std::three_way_comparable_with and in std::equality_comparable_with. It also relaxes the preconditions in std::totally_ordered_with so that it supports move-only types. comparison-common-type-with &lt;T, U&gt; is an exposition-only concept intended to determine that there exists a common supertype of T and U even if they are move-only types. Exposition-only means that they are not required by the standard, they just illustrate the intentions of the authors. An exposition-only definition is also a hint to the implementers about what the committee had in mind. MSVC 19.36 already supports this! Relaxing range adaptors to allow for move-only types Even though ranges were introduced to C++ many years later than move-semantics, still several range adaptors require that the types they store are copy-constructible. P2494R2 slightly modifies the views that currently use the exposition-only type copyable-box for user-provided predicates. That slight modification is that copyable-box is renamed to movable-box, but no constraints are modified for the changed views. It goes further though for transform-like views, where requirements on invocables are relaxed. Now their invocables don’t have to be copy-constructible anymore, move-constructability is enough. These views are: single_view, transform_view, zip_transform_view, and adjacent_transform_view. MSVC 19.34 already supports this! std::move_iterator should not always be input_iterator In order to understand the goals of this paper, let’s start with a bit of C++ history. In C++17, you could only subtract two iterators, if they were random access iterators. At the same time, there was no other way to get the size of a range. If you want a short reminder on what iterators are, read this article. C++20 improved this situation and even input iterators can be subtracted from their ranges’ “end” marked by a so-called sized_sentinel_for object and the standardized ranges can provide their size in a cheaper way than subtraction. Given that the range is a so-called sized range. On the other hand, if the range is unsized, there are some issues. If a range is unsized, you cannot construct a vector out of it by one single allocation, since we don’t know the size. Instead, the compiler has to loop over the range and keep pushing back to the vector. 1 some_unsized_forward_range | views::move | ranges::to&lt;vector&gt;() In C++20, move_iterator&lt;T*&gt; is an input_iterator which can be problematic. You can go through input_iterators normally multiple times without a problem, but you cannot do the same with move_iterator because if you do so, the second time you already pass through moved-from objects. Therefore library authors have to be very cautious and recognize if they deal with move_iterator. P2520R0 fixes this problem by not having move_iterator&lt;Iterator&gt;::interator_concept always input_iterator_tag. iterator_concept will be based on the actual Iterator. iterator_concept will only be input_iterator_tag if Iterator doesn’t model random_access_iterator, bidirectional_iterator or forward_iterator. If Iterator models one of those then the concept will be the corresponding tag (&lt;iterator concept&gt;_tag). As such, the above example can work fine with a single allocation, because if Iterator is a random access iterator (such as for T*), then the compiler can get the size without accessing any item, without passing through the range. Clang 17 and MSVC 19.34 already support this! Conclusion In this article, we reviewed how C++23 relaxes many requirements. More and more operations that required copy-constructible objects now will only require move-constructible ones. These are quite logical changes that are also good for performance. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-01-31T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23 likes to move it!" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-02-02T19:51:13+01:00","datePublished":"2024-01-31T00:00:00+01:00","description":"C++23 is going to bring us a few changes regarding move operations. It mostly means extended support in the standard library, but there is also one change directly in the language. Let’s start with that. Simpler implicit move P2266R3 is a quite great proposal both in terms of its high-quality explanation and the amount of proposed changes in wording. I think if you’re interested in exploring a readable proposal, this might be the one. Let me try to summarize it briefly. Since the introduction of move semantics and rvalue references in C++11, we can return move-only types by value: 1 2 3 4 5 6 7 struct Widget { Widget(Widget&amp;&amp;); }; Widget one(Widget w) { return w; } C++14 extended this support so that even converting constructors accepting an rvalue type can be called to invoke an implicit move. 1 2 3 4 5 6 7 struct RRefTaker { RRefTaker(Widget&amp;&amp;); // here is the converting constructor }; RRefTaker two(Widget w) { return w; } As you can see, the two examples follow the same logic, in a sense they are quite symmetric. C++20 introduced some changes in copy elision and overload resolution. As a consequence two() would work even if w was taken as an rvalue (Widget&amp;&amp;). But because of a wording issue, if it had to take a Widget&amp;&amp; and return the same Widget&amp;&amp; we would get an error. The original wording is rather complex as it’s also claimed in the abstract of P2266R3. The proposal fixes the mentioned defect and also simplifies the specification by saying that a returned move-eligible id-expression is always an xvalue. In C++, an eXpiring value (xvalue in short) represents an expiring or about-to-expire value. It typically occurs in the context of a move operation or when the value is no longer needed in its current location. Examples include the result of std::move() and operator[] applied to an rvalue. GCC 13 and Clang 13 already support this! std::move_only_function P0288R9 addresses a request that has been opened in 2014. Nobody can say that this is a reckless change! std::move_only_function is like std::function, but for move-only types. It’s a wrapper for any constructible callable targets, such as functions, lambdas, function objects or bind expressions. The wrapper can only be moved as its copy assignment operator and copy constructor are deleted. It also supports cv/ref/noexcept qualifiers in function types. You (will) find this new utility in the &lt;functional&gt; wrapper. GCC 12 and MSVC 19.32 already support this! Given that this has been awaited for a long time and that std::function has a bad reputation, I plan to experiment with std::move_only_function in a few weeks and report back the results.. Adding move-only types support for comparison concepts C++20 introduced concepts and even though we have move semantics in C++ since C++11, many important concepts do not support move-only types, such as std::equality_comparable_with, totally_ordered_with or three_way_comparable_with. The reason is often that these concepts are implemented in a way that two const&amp; types have to be convertible to the non-reference std::common_reference_t which means that the two types have to be copyable. P2404R3 aims to relaxing this requriement by replacing common_reference_with&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt; with comparison-common-type-with &lt;T, U&gt; in std::three_way_comparable_with and in std::equality_comparable_with. It also relaxes the preconditions in std::totally_ordered_with so that it supports move-only types. comparison-common-type-with &lt;T, U&gt; is an exposition-only concept intended to determine that there exists a common supertype of T and U even if they are move-only types. Exposition-only means that they are not required by the standard, they just illustrate the intentions of the authors. An exposition-only definition is also a hint to the implementers about what the committee had in mind. MSVC 19.36 already supports this! Relaxing range adaptors to allow for move-only types Even though ranges were introduced to C++ many years later than move-semantics, still several range adaptors require that the types they store are copy-constructible. P2494R2 slightly modifies the views that currently use the exposition-only type copyable-box for user-provided predicates. That slight modification is that copyable-box is renamed to movable-box, but no constraints are modified for the changed views. It goes further though for transform-like views, where requirements on invocables are relaxed. Now their invocables don’t have to be copy-constructible anymore, move-constructability is enough. These views are: single_view, transform_view, zip_transform_view, and adjacent_transform_view. MSVC 19.34 already supports this! std::move_iterator should not always be input_iterator In order to understand the goals of this paper, let’s start with a bit of C++ history. In C++17, you could only subtract two iterators, if they were random access iterators. At the same time, there was no other way to get the size of a range. If you want a short reminder on what iterators are, read this article. C++20 improved this situation and even input iterators can be subtracted from their ranges’ “end” marked by a so-called sized_sentinel_for object and the standardized ranges can provide their size in a cheaper way than subtraction. Given that the range is a so-called sized range. On the other hand, if the range is unsized, there are some issues. If a range is unsized, you cannot construct a vector out of it by one single allocation, since we don’t know the size. Instead, the compiler has to loop over the range and keep pushing back to the vector. 1 some_unsized_forward_range | views::move | ranges::to&lt;vector&gt;() In C++20, move_iterator&lt;T*&gt; is an input_iterator which can be problematic. You can go through input_iterators normally multiple times without a problem, but you cannot do the same with move_iterator because if you do so, the second time you already pass through moved-from objects. Therefore library authors have to be very cautious and recognize if they deal with move_iterator. P2520R0 fixes this problem by not having move_iterator&lt;Iterator&gt;::interator_concept always input_iterator_tag. iterator_concept will be based on the actual Iterator. iterator_concept will only be input_iterator_tag if Iterator doesn’t model random_access_iterator, bidirectional_iterator or forward_iterator. If Iterator models one of those then the concept will be the corresponding tag (&lt;iterator concept&gt;_tag). As such, the above example can work fine with a single allocation, because if Iterator is a random access iterator (such as for T*), then the compiler can get the size without accessing any item, without passing through the range. Clang 17 and MSVC 19.34 already support this! Conclusion In this article, we reviewed how C++23 relaxes many requirements. More and more operations that required copy-constructible objects now will only require move-constructible ones. These are quite logical changes that are also good for performance. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23 likes to move it!","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it"},"url":"https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it"}</script><title>C++23 likes to move it! | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/31"> 31 </a> </span> <span>C++23 likes to move it!</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23 likes to move it!</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 31, 2024, 12:00 AM +0100" prep="on" > Jan 31, 2024 <i class="unloaded">2024-01-31T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Feb 2, 2024, 7:51 PM +0100" prefix="Updated " > Feb 2, 2024 <i class="unloaded">2024-02-02T19:51:13+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1094 words">6 min</span></div></div><div class="post-content"><p>C++23 is going to bring us a few changes regarding move operations. It mostly means extended support in the standard library, but there is also one change directly in the language. Let’s start with that.</p><h2 id="simpler-implicit-move">Simpler implicit move</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2266r3.html">P2266R3</a> is a quite great proposal both in terms of its high-quality explanation and the amount of proposed changes in wording. I think if you’re interested in exploring a readable proposal, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2266r3.html">this</a> might be the one.</p><p>Let me try to summarize it briefly.</p><p>Since the introduction of move semantics and rvalue references in C++11, we can return move-only types by value:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Widget</span> <span class="p">{</span>
    <span class="n">Widget</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="p">);</span>
<span class="p">};</span>

<span class="n">Widget</span> <span class="nf">one</span><span class="p">(</span><span class="n">Widget</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>C++14 extended this support so that even converting constructors accepting an rvalue type can be called to invoke an implicit move.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">RRefTaker</span> <span class="p">{</span>
    <span class="n">RRefTaker</span><span class="p">(</span><span class="n">Widget</span><span class="o">&amp;&amp;</span><span class="p">);</span> <span class="c1">// here is the converting constructor</span>
<span class="p">};</span>

<span class="n">RRefTaker</span> <span class="nf">two</span><span class="p">(</span><span class="n">Widget</span> <span class="n">w</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">w</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, the two examples follow the same logic, in a sense they are quite symmetric.</p><p>C++20 introduced some changes in copy elision and overload resolution. As a consequence <code class="language-plaintext highlighter-rouge">two()</code> would work even if <code class="language-plaintext highlighter-rouge">w</code> was taken as an rvalue (<code class="language-plaintext highlighter-rouge">Widget&amp;&amp;</code>). But because of a wording issue, if it had to take a <code class="language-plaintext highlighter-rouge">Widget&amp;&amp;</code> and return the same <code class="language-plaintext highlighter-rouge">Widget&amp;&amp;</code> we would get an error. The original wording is rather complex as it’s also claimed in the abstract of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2266r3.html">P2266R3</a>. The proposal fixes the mentioned defect and also simplifies the specification by saying that a returned move-eligible id-expression is always an xvalue.</p><blockquote><p>In C++, an eXpiring value (xvalue in short) represents an expiring or about-to-expire value. It typically occurs in the context of a move operation or when the value is no longer needed in its current location. Examples include the result of <code class="language-plaintext highlighter-rouge">std::move()</code> and <code class="language-plaintext highlighter-rouge">operator[]</code> applied to an rvalue.</p></blockquote><p>GCC 13 and Clang 13 already support this!</p><h2 id="stdmove_only_function">std::move_only_function</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0288r9.html">P0288R9</a> addresses a request that has been opened in 2014. Nobody can say that this is a reckless change!</p><p><code class="language-plaintext highlighter-rouge">std::move_only_function</code> is like <code class="language-plaintext highlighter-rouge">std::function</code>, but for move-only types. It’s a wrapper for any constructible callable targets, such as functions, lambdas, function objects or bind expressions. The wrapper can only be moved as its copy assignment operator and copy constructor are deleted. It also supports cv/ref/noexcept qualifiers in function types.</p><p>You (will) find this new utility in the <code class="language-plaintext highlighter-rouge">&lt;functional&gt;</code> wrapper.</p><p>GCC 12 and MSVC 19.32 already support this!</p><p><em>Given that this has been awaited for a long time and that <a href="https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates"><code class="language-plaintext highlighter-rouge">std::function</code> has a bad reputation</a>, I plan to experiment with <code class="language-plaintext highlighter-rouge">std::move_only_function</code> in a few weeks and report back the results.</em>.</p><h2 id="adding-move-only-types-support-for-comparison-concepts">Adding move-only types support for comparison concepts</h2><p>C++20 introduced <a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">concepts</a> and even though we have move semantics in C++ since C++11, many important concepts do not support move-only types, such as <code class="language-plaintext highlighter-rouge">std::equality_comparable_with</code>, <code class="language-plaintext highlighter-rouge">totally_ordered_with</code> or <code class="language-plaintext highlighter-rouge">three_way_comparable_with</code>.</p><p>The reason is often that these concepts are implemented in a way that two <code class="language-plaintext highlighter-rouge">const&amp;</code> types have to be convertible to the non-reference <code class="language-plaintext highlighter-rouge">std::common_reference_t</code> which means that the two types have to be copyable.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2404r3.pdf">P2404R3</a> aims to relaxing this requriement by replacing <code class="language-plaintext highlighter-rouge">common_reference_with&lt;const remove_reference_t&lt;T&gt;&amp;, const remove_reference_t&lt;U&gt;&amp;&gt;</code> with <code class="language-plaintext highlighter-rouge">comparison-common-type-with &lt;T, U&gt;</code> in <code class="language-plaintext highlighter-rouge">std::three_way_comparable_with</code> and in <code class="language-plaintext highlighter-rouge">std::equality_comparable_with</code>. It also relaxes the preconditions in <code class="language-plaintext highlighter-rouge">std::totally_ordered_with</code> so that it supports move-only types.</p><p><code class="language-plaintext highlighter-rouge">comparison-common-type-with &lt;T, U&gt;</code> is an exposition-only concept intended to determine that there exists a common supertype of <code class="language-plaintext highlighter-rouge">T</code> and <code class="language-plaintext highlighter-rouge">U</code> even if they are move-only types.</p><blockquote><p><a href="https://stackoverflow.com/a/34493177">Exposition-only means that they are not required by the standard, they just illustrate the intentions of the authors.</a> An exposition-only definition is also a hint to the implementers about what the committee had in mind.</p></blockquote><p>MSVC 19.36 already supports this!</p><h2 id="relaxing-range-adaptors-to-allow-for-move-only-types">Relaxing range adaptors to allow for move-only types</h2><p>Even though ranges were introduced to C++ many years later than move-semantics, still several range adaptors require that the types they store are copy-constructible.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2494r2.html">P2494R2</a> slightly modifies the views that currently use the exposition-only type <code class="language-plaintext highlighter-rouge">copyable-box</code> for user-provided predicates. That slight modification is that <code class="language-plaintext highlighter-rouge">copyable-box</code> is renamed to <code class="language-plaintext highlighter-rouge">movable-box</code>, but no constraints are modified for the changed views.</p><p>It goes further though for <code class="language-plaintext highlighter-rouge">transform</code>-like views, where requirements on invocables are relaxed. Now their invocables don’t have to be copy-constructible anymore, move-constructability is enough. These views are:</p><ul><li><code class="language-plaintext highlighter-rouge">single_view,</code><li><code class="language-plaintext highlighter-rouge">transform_view,</code><li><code class="language-plaintext highlighter-rouge">zip_transform_view</code>, and<li><code class="language-plaintext highlighter-rouge">adjacent_transform_view</code>.</ul><p>MSVC 19.34 already supports this!</p><h2 id="stdmove_iterator-should-not-always-be-input_iterator"><code class="language-plaintext highlighter-rouge">std::move_iterator</code> should not always be <code class="language-plaintext highlighter-rouge">input_iterator</code></h2><p>In order to understand the goals of this paper, let’s start with a bit of C++ history. In C++17, you could only subtract two iterators, if they were random access iterators. At the same time, there was no other way to get the size of a range.</p><blockquote><p>If you want a short reminder on what iterators are, <a href="https://www.sandordargo.com/blog/2022/03/16/iterators-vs-pointers#what-is-an-iterator">read this article</a>.</p></blockquote><p>C++20 improved this situation and even input iterators can be subtracted from their ranges’ “end” marked by a so-called <code class="language-plaintext highlighter-rouge">sized_sentinel_for</code> object and the standardized ranges can provide their size in a cheaper way than subtraction. Given that the range is a so-called sized range.</p><p>On the other hand, if the range is unsized, there are some issues. If a range is unsized, you cannot construct a <code class="language-plaintext highlighter-rouge">vector</code> out of it by one single allocation, since we don’t know the size. Instead, the compiler has to loop over the range and keep pushing back to the vector.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">some_unsized_forward_range</span> <span class="o">|</span> <span class="n">views</span><span class="o">::</span><span class="n">move</span> <span class="o">|</span> <span class="n">ranges</span><span class="o">::</span><span class="n">to</span><span class="o">&lt;</span><span class="n">vector</span><span class="o">&gt;</span><span class="p">()</span>
</pre></table></code></div></div><p>In C++20, <code class="language-plaintext highlighter-rouge">move_iterator&lt;T*&gt;</code> is an <code class="language-plaintext highlighter-rouge">input_iterator</code> which can be problematic. You can go through <code class="language-plaintext highlighter-rouge">input_iterator</code>s normally multiple times without a problem, but you cannot do the same with <code class="language-plaintext highlighter-rouge">move_iterator</code> because if you do so, the second time you already pass through moved-from objects. Therefore library authors have to be very cautious and recognize if they deal with move_iterator.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2520r0.html">P2520R0</a> fixes this problem by not having <code class="language-plaintext highlighter-rouge">move_iterator&lt;Iterator&gt;::interator_concept</code> always <code class="language-plaintext highlighter-rouge">input_iterator_tag</code>. <code class="language-plaintext highlighter-rouge">iterator_concept</code> will be based on the actual <code class="language-plaintext highlighter-rouge">Iterator</code>. <code class="language-plaintext highlighter-rouge">iterator_concept</code> will only be <code class="language-plaintext highlighter-rouge">input_iterator_tag</code> if <code class="language-plaintext highlighter-rouge">Iterator</code> doesn’t model <code class="language-plaintext highlighter-rouge">random_access_iterator</code>, <code class="language-plaintext highlighter-rouge">bidirectional_iterator</code> or <code class="language-plaintext highlighter-rouge">forward_iterator</code>. If <code class="language-plaintext highlighter-rouge">Iterator</code> models one of those then the concept will be the corresponding tag (<code class="language-plaintext highlighter-rouge">&lt;iterator concept&gt;_tag</code>).</p><p>As such, the above example can work fine with a single allocation, because if <code class="language-plaintext highlighter-rouge">Iterator</code> is a random access iterator (such as for <code class="language-plaintext highlighter-rouge">T*</code>), then the compiler can get the size without accessing any item, without passing through the range.</p><p>Clang 17 and MSVC 19.34 already support this!</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed how C++23 relaxes many requirements. More and more operations that required copy-constructible objects now will only require move-constructible ones. These are quite logical changes that are also good for performance.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/movesemantics/" class="post-tag no-text-decoration" >movesemantics</a> <a href="/tags/moveoperations/" class="post-tag no-text-decoration" >moveoperations</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23 likes to move it! - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23 likes to move it! - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23 likes to move it! - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23 likes to move it! - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/01/24/my-time-management-system" class="btn btn-outline-primary" prompt="Older"><p>My time management system in 2024</p></a> <a href="/blog/2024/02/07/cpp23-small-changes-2" class="btn btn-outline-primary" prompt="Newer"><p>C++23: More small changes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23 likes to move it!'; this.page.url = 'https://www.sandordargo.com/blog/2024/01/31/cpp23-likes-to-move-it'; this.page.identifier = '/blog/2024/01/31/cpp23-likes-to-move-it'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
