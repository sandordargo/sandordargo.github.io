<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="DR20 - The Equality Operator You Are Looking For" /><meta property="og:locale" content="en_US" /><meta name="description" content="When I see DR, I immediately think about Disaster Recovery. That’s due to my first corporate job where I worked as a Database Administrator and we had regular exercises to simulate events when datacenters would be unavailable. When you see DR in the title of a C++ proposal, it’s not about a disaster, it’s more about a bug. DR stands for defect report. But the paper itself is usually not about reporting that there is a problem - that has been already done -, but more about proposing a solution. What’s more important is that defect reports are not becoming part of the latest standard, they retrospectively change the one that introduced the defect. A defect of C++20’s equality operator P2468R2 is addressing a problem that was introduced by C++20. C++20 brought us the spaceship operator (operator&lt;=&gt;), but it further changed the logic of object comparisons. It changed the meaning of == and != and how overload resolution applies to them. C++20 introduced the concept of “rewrites” or “rewrite targets”. What this means is that if you implement a conforming operator==, the compiler will make sure that there is also operator!= available. If you use operator&lt;=&gt;, it will be used for rewrites. With “rewrites”, certain logical operators are implemented if certain others are available as they can be expressed with the help of the other. For example, if you have an operator== that checks whether two members are equal, the compiler can rewrite it and provide operator!=. operator!= will not check whether the members differ, but it will negate the result of operator==. As this is a new behaviour since C++20, you might run into some surprises, some unintended behaviour. Problems can arise when you migrate to C++20 and your operator== and operator!= are not matching. It might happen that the rewritten form of that operator is a better match and you have ambiguity errors or a silent change in the behaviour when migrating. How can those operators not match, you might ask? It can be intentional, but more probably it will be about a missing const qualifier on one of the operators. Take this example on C++ Insights, play with where you put the const and observe how the generated code changes from if(a.operator!=(b)) to if(!a.operator==(b)). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; class MyClass { public: int value; bool operator==(const MyClass&amp; other) const { return value == other.value; } bool operator!=(const MyClass&amp; other) const { return value != other.value; } }; int main() { MyClass a{42}; MyClass b{42}; if (a == b) { std::cout &lt;&lt; &quot;a is equal to b\n&quot;; } if (a != b) { std::cout &lt;&lt; &quot;a is not equal to b\n&quot;; } return 0; } Another reason for a surprise can be that you introduce operator== before the compiler sees the matching operator!= declaration. (C++ Insights) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; class MyClass { public: int value; bool operator==(const MyClass&amp; other) const { std::cout &lt;&lt; &quot;Using operator==\n&quot;; return value == other.value; } }; // This function is not visible before operator== is called bool operator!=(const MyClass&amp; a, const MyClass&amp; b) { std::cout &lt;&lt; &quot;Using operator!=\n&quot;; return !(a == b); } int main() { MyClass a{42}; MyClass b{42}; if (a == b) { std::cout &lt;&lt; &quot;a is equal to b\n&quot;; } if (a != b) { std::cout &lt;&lt; &quot;a is not equal to b\n&quot;; } return 0; } So in these cases, the compiler takes the operator== and if it cannot find the matching negation, it will create it by rewriting the operator== How do the rewritten versions rank against the ones that are provided - just probably provided not in the right form? As the economist would say, it depends. As the C++ developer would say, it depends on the compiler and the situation, but the answers can go from one range to another. You can check the paper for some concrete examples. The new clear programming model What’s more important for us is how to solve the situation. The authors of the paper considered different solutions, implemented them and ran the new rules against at least 59 open-source projects - by the end of their experiments, the number almost doubled - and checked how many of them would break. In the beginning, a third of the projects broke, but it was below 8% by the end. Based on these experiments that you can follow in the details in §1.3 of P2468R2, the proposed and accepted solution is the following. If you want the compiler to automatically reverse operator== and therefore generate operator!=, make sure that you write **only** an operator== that returns a bool. (Yes, it might return an int…) If you don’t want your operator== to be used for rewrites, make sure that you write a matching operator!=. No matter what, operator&lt;=&gt; will be used for rewrites, that’s an essential part of the feature. With all that considered, if you’re migrating from C++17 and you want to keep behaviour the same as it was, make sure that every operator== has a matching operator!=. And once you think that you’d like to benefit from rewrites, remove the operator!= and the compiler will provide that for you. Conclusion In this article, we very briefly reviewed what defect reports are in C++ and if a solution is proposed they become part of the standard version that introduced a defect. In this case, we saw how the equality operator’s behaviour changed with C++20 and that different compilers went with a different approach. In the end, we saw how the situation is fixed, what rules laid down by the authors of P2468R2. With this fix, it should be straightforward how to benefit form rewritten operator== and how to avoid it. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="When I see DR, I immediately think about Disaster Recovery. That’s due to my first corporate job where I worked as a Database Administrator and we had regular exercises to simulate events when datacenters would be unavailable. When you see DR in the title of a C++ proposal, it’s not about a disaster, it’s more about a bug. DR stands for defect report. But the paper itself is usually not about reporting that there is a problem - that has been already done -, but more about proposing a solution. What’s more important is that defect reports are not becoming part of the latest standard, they retrospectively change the one that introduced the defect. A defect of C++20’s equality operator P2468R2 is addressing a problem that was introduced by C++20. C++20 brought us the spaceship operator (operator&lt;=&gt;), but it further changed the logic of object comparisons. It changed the meaning of == and != and how overload resolution applies to them. C++20 introduced the concept of “rewrites” or “rewrite targets”. What this means is that if you implement a conforming operator==, the compiler will make sure that there is also operator!= available. If you use operator&lt;=&gt;, it will be used for rewrites. With “rewrites”, certain logical operators are implemented if certain others are available as they can be expressed with the help of the other. For example, if you have an operator== that checks whether two members are equal, the compiler can rewrite it and provide operator!=. operator!= will not check whether the members differ, but it will negate the result of operator==. As this is a new behaviour since C++20, you might run into some surprises, some unintended behaviour. Problems can arise when you migrate to C++20 and your operator== and operator!= are not matching. It might happen that the rewritten form of that operator is a better match and you have ambiguity errors or a silent change in the behaviour when migrating. How can those operators not match, you might ask? It can be intentional, but more probably it will be about a missing const qualifier on one of the operators. Take this example on C++ Insights, play with where you put the const and observe how the generated code changes from if(a.operator!=(b)) to if(!a.operator==(b)). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; class MyClass { public: int value; bool operator==(const MyClass&amp; other) const { return value == other.value; } bool operator!=(const MyClass&amp; other) const { return value != other.value; } }; int main() { MyClass a{42}; MyClass b{42}; if (a == b) { std::cout &lt;&lt; &quot;a is equal to b\n&quot;; } if (a != b) { std::cout &lt;&lt; &quot;a is not equal to b\n&quot;; } return 0; } Another reason for a surprise can be that you introduce operator== before the compiler sees the matching operator!= declaration. (C++ Insights) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; class MyClass { public: int value; bool operator==(const MyClass&amp; other) const { std::cout &lt;&lt; &quot;Using operator==\n&quot;; return value == other.value; } }; // This function is not visible before operator== is called bool operator!=(const MyClass&amp; a, const MyClass&amp; b) { std::cout &lt;&lt; &quot;Using operator!=\n&quot;; return !(a == b); } int main() { MyClass a{42}; MyClass b{42}; if (a == b) { std::cout &lt;&lt; &quot;a is equal to b\n&quot;; } if (a != b) { std::cout &lt;&lt; &quot;a is not equal to b\n&quot;; } return 0; } So in these cases, the compiler takes the operator== and if it cannot find the matching negation, it will create it by rewriting the operator== How do the rewritten versions rank against the ones that are provided - just probably provided not in the right form? As the economist would say, it depends. As the C++ developer would say, it depends on the compiler and the situation, but the answers can go from one range to another. You can check the paper for some concrete examples. The new clear programming model What’s more important for us is how to solve the situation. The authors of the paper considered different solutions, implemented them and ran the new rules against at least 59 open-source projects - by the end of their experiments, the number almost doubled - and checked how many of them would break. In the beginning, a third of the projects broke, but it was below 8% by the end. Based on these experiments that you can follow in the details in §1.3 of P2468R2, the proposed and accepted solution is the following. If you want the compiler to automatically reverse operator== and therefore generate operator!=, make sure that you write **only** an operator== that returns a bool. (Yes, it might return an int…) If you don’t want your operator== to be used for rewrites, make sure that you write a matching operator!=. No matter what, operator&lt;=&gt; will be used for rewrites, that’s an essential part of the feature. With all that considered, if you’re migrating from C++17 and you want to keep behaviour the same as it was, make sure that every operator== has a matching operator!=. And once you think that you’d like to benefit from rewrites, remove the operator!= and the compiler will provide that for you. Conclusion In this article, we very briefly reviewed what defect reports are in C++ and if a solution is proposed they become part of the standard version that introduced a defect. In this case, we saw how the equality operator’s behaviour changed with C++20 and that different compilers went with a different approach. In the end, we saw how the situation is fixed, what rules laid down by the authors of P2468R2. With this fix, it should be straightforward how to benefit form rewritten operator== and how to avoid it. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-01-03T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="DR20 - The Equality Operator You Are Looking For" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-01-07T22:07:01+01:00","datePublished":"2024-01-03T00:00:00+01:00","description":"When I see DR, I immediately think about Disaster Recovery. That’s due to my first corporate job where I worked as a Database Administrator and we had regular exercises to simulate events when datacenters would be unavailable. When you see DR in the title of a C++ proposal, it’s not about a disaster, it’s more about a bug. DR stands for defect report. But the paper itself is usually not about reporting that there is a problem - that has been already done -, but more about proposing a solution. What’s more important is that defect reports are not becoming part of the latest standard, they retrospectively change the one that introduced the defect. A defect of C++20’s equality operator P2468R2 is addressing a problem that was introduced by C++20. C++20 brought us the spaceship operator (operator&lt;=&gt;), but it further changed the logic of object comparisons. It changed the meaning of == and != and how overload resolution applies to them. C++20 introduced the concept of “rewrites” or “rewrite targets”. What this means is that if you implement a conforming operator==, the compiler will make sure that there is also operator!= available. If you use operator&lt;=&gt;, it will be used for rewrites. With “rewrites”, certain logical operators are implemented if certain others are available as they can be expressed with the help of the other. For example, if you have an operator== that checks whether two members are equal, the compiler can rewrite it and provide operator!=. operator!= will not check whether the members differ, but it will negate the result of operator==. As this is a new behaviour since C++20, you might run into some surprises, some unintended behaviour. Problems can arise when you migrate to C++20 and your operator== and operator!= are not matching. It might happen that the rewritten form of that operator is a better match and you have ambiguity errors or a silent change in the behaviour when migrating. How can those operators not match, you might ask? It can be intentional, but more probably it will be about a missing const qualifier on one of the operators. Take this example on C++ Insights, play with where you put the const and observe how the generated code changes from if(a.operator!=(b)) to if(!a.operator==(b)). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 #include &lt;iostream&gt; class MyClass { public: int value; bool operator==(const MyClass&amp; other) const { return value == other.value; } bool operator!=(const MyClass&amp; other) const { return value != other.value; } }; int main() { MyClass a{42}; MyClass b{42}; if (a == b) { std::cout &lt;&lt; &quot;a is equal to b\\n&quot;; } if (a != b) { std::cout &lt;&lt; &quot;a is not equal to b\\n&quot;; } return 0; } Another reason for a surprise can be that you introduce operator== before the compiler sees the matching operator!= declaration. (C++ Insights) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;iostream&gt; class MyClass { public: int value; bool operator==(const MyClass&amp; other) const { std::cout &lt;&lt; &quot;Using operator==\\n&quot;; return value == other.value; } }; // This function is not visible before operator== is called bool operator!=(const MyClass&amp; a, const MyClass&amp; b) { std::cout &lt;&lt; &quot;Using operator!=\\n&quot;; return !(a == b); } int main() { MyClass a{42}; MyClass b{42}; if (a == b) { std::cout &lt;&lt; &quot;a is equal to b\\n&quot;; } if (a != b) { std::cout &lt;&lt; &quot;a is not equal to b\\n&quot;; } return 0; } So in these cases, the compiler takes the operator== and if it cannot find the matching negation, it will create it by rewriting the operator== How do the rewritten versions rank against the ones that are provided - just probably provided not in the right form? As the economist would say, it depends. As the C++ developer would say, it depends on the compiler and the situation, but the answers can go from one range to another. You can check the paper for some concrete examples. The new clear programming model What’s more important for us is how to solve the situation. The authors of the paper considered different solutions, implemented them and ran the new rules against at least 59 open-source projects - by the end of their experiments, the number almost doubled - and checked how many of them would break. In the beginning, a third of the projects broke, but it was below 8% by the end. Based on these experiments that you can follow in the details in §1.3 of P2468R2, the proposed and accepted solution is the following. If you want the compiler to automatically reverse operator== and therefore generate operator!=, make sure that you write **only** an operator== that returns a bool. (Yes, it might return an int…) If you don’t want your operator== to be used for rewrites, make sure that you write a matching operator!=. No matter what, operator&lt;=&gt; will be used for rewrites, that’s an essential part of the feature. With all that considered, if you’re migrating from C++17 and you want to keep behaviour the same as it was, make sure that every operator== has a matching operator!=. And once you think that you’d like to benefit from rewrites, remove the operator!= and the compiler will provide that for you. Conclusion In this article, we very briefly reviewed what defect reports are in C++ and if a solution is proposed they become part of the standard version that introduced a defect. In this case, we saw how the equality operator’s behaviour changed with C++20 and that different compilers went with a different approach. In the end, we saw how the situation is fixed, what rules laid down by the authors of P2468R2. With this fix, it should be straightforward how to benefit form rewritten operator== and how to avoid it. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"DR20 - The Equality Operator You Are Looking For","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator"},"url":"https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator"}</script><title>DR20 - The Equality Operator You Are Looking For | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/03"> 03 </a> </span> <span>DR20 - The Equality Operator You Are Looking For</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>DR20 - The Equality Operator You Are Looking For</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 3, 2024, 12:00 AM +0100" prep="on" > Jan 3, 2024 <i class="unloaded">2024-01-03T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Jan 7, 2024, 10:07 PM +0100" prefix="Updated " > Jan 7, 2024 <i class="unloaded">2024-01-07T22:07:01+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1027 words">5 min</span></div></div><div class="post-content"><p>When I see <em>DR</em>, I immediately think about Disaster Recovery. That’s due to my first corporate job where I worked as a Database Administrator and we had regular exercises to simulate events when datacenters would be unavailable.</p><p>When you see DR in the title of a C++ proposal, it’s not about a disaster, it’s more about a bug. <em>DR</em> stands for defect report. But the paper itself is usually not about reporting that there is a problem - that has been already done -, but more about proposing a solution.</p><p>What’s more important is that defect reports are not becoming part of the latest standard, they retrospectively change the one that introduced the defect.</p><h2 id="a-defect-of-c20s-equality-operator">A defect of C++20’s equality operator</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2468r2.html">P2468R2</a> is addressing a problem that was introduced by C++20. C++20 brought us the spaceship operator (<code class="language-plaintext highlighter-rouge">operator&lt;=&gt;</code>), but it further changed the logic of object comparisons. It changed the meaning of <code class="language-plaintext highlighter-rouge">==</code> and <code class="language-plaintext highlighter-rouge">!=</code> and how overload resolution applies to them.</p><p>C++20 introduced the concept of “rewrites” or “rewrite targets”. What this means is that if you implement a conforming <code class="language-plaintext highlighter-rouge">operator==</code>, the compiler will make sure that there is also <code class="language-plaintext highlighter-rouge">operator!=</code> available. If you use <code class="language-plaintext highlighter-rouge">operator&lt;=&gt;</code>, it will be used for rewrites. With “rewrites”, certain logical operators are implemented if certain others are available as they can be expressed with the help of the other.</p><p>For example, if you have an <code class="language-plaintext highlighter-rouge">operator==</code> that checks whether two members are equal, the compiler can rewrite it and provide <code class="language-plaintext highlighter-rouge">operator!=</code>. <code class="language-plaintext highlighter-rouge">operator!=</code> will not check whether the members differ, but it will negate the result of <code class="language-plaintext highlighter-rouge">operator==</code>.</p><p>As this is a new behaviour since C++20, you might run into some surprises, some unintended behaviour.</p><p>Problems can arise when you migrate to C++20 and your <code class="language-plaintext highlighter-rouge">operator==</code> and <code class="language-plaintext highlighter-rouge">operator!=</code> are not matching. It might happen that the rewritten form of that operator is a better match and you have ambiguity errors or a silent change in the behaviour when migrating. How can those operators not match, you might ask? It can be intentional, but more probably it will be about a missing <code class="language-plaintext highlighter-rouge">const</code> qualifier on one of the operators.</p><p>Take this example on <a href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgoKY2xhc3MgTXlDbGFzcyB7CnB1YmxpYzoKICAgIGludCB2YWx1ZTsKCiAgICBib29sIG9wZXJhdG9yPT0oY29uc3QgTXlDbGFzcyYgb3RoZXIpIGNvbnN0IHsKICAgICAgICByZXR1cm4gdmFsdWUgPT0gb3RoZXIudmFsdWU7CiAgICB9CiAgCiAgCWJvb2wgb3BlcmF0b3IhPShjb25zdCBNeUNsYXNzJiBvdGhlcikgY29uc3QgewogICAgICAgIHJldHVybiB2YWx1ZSAhPSBvdGhlci52YWx1ZTsKICAgIH0KfTsKCmludCBtYWluKCkgewogICAgTXlDbGFzcyBhezQyfTsKICAgIE15Q2xhc3MgYns0Mn07CiAgICAKICAgIGlmIChhID09IGIpIHsKICAgICAgICBzdGQ6OmNvdXQgPDwgImEgaXMgZXF1YWwgdG8gYlxuIjsKICAgIH0KCiAgICBpZiAoYSAhPSBiKSB7CiAgICAgICAgc3RkOjpjb3V0IDw8ICJhIGlzIG5vdCBlcXVhbCB0byBiXG4iOwogICAgfQoKICAgIHJldHVybiAwOwp9&amp;insightsOptions=cpp20&amp;std=cpp20&amp;rev=1.0">C++ Insights</a>, play with where you put the <code class="language-plaintext highlighter-rouge">const</code> and observe how the generated code changes from <code class="language-plaintext highlighter-rouge">if(a.operator!=(b))</code> to <code class="language-plaintext highlighter-rouge">if(!a.operator==(b))</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
  
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">!=</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyClass</span> <span class="n">a</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">MyClass</span> <span class="n">b</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is equal to b</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is not equal to b</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Another reason for a surprise can be that you introduce <code class="language-plaintext highlighter-rouge">operator==</code> before the compiler sees the matching <code class="language-plaintext highlighter-rouge">operator!=</code> declaration. (<a href="https://cppinsights.io/lnk?code=I2luY2x1ZGUgPGlvc3RyZWFtPgoKY2xhc3MgTXlDbGFzcyB7CnB1YmxpYzoKICAgIGludCB2YWx1ZTsKCiAgICBib29sIG9wZXJhdG9yPT0oY29uc3QgTXlDbGFzcyYgb3RoZXIpIGNvbnN0IHsKICAgICAgICBzdGQ6OmNvdXQgPDwgIlVzaW5nIG9wZXJhdG9yPT1cbiI7CiAgICAgICAgcmV0dXJuIHZhbHVlID09IG90aGVyLnZhbHVlOwogICAgfQp9OwoKLy8gVGhpcyBmdW5jdGlvbiBpcyBub3QgdmlzaWJsZSBiZWZvcmUgb3BlcmF0b3I9PSBpcyBjYWxsZWQKYm9vbCBvcGVyYXRvciE9KGNvbnN0IE15Q2xhc3MmIGEsIGNvbnN0IE15Q2xhc3MmIGIpIHsKICAgIHN0ZDo6Y291dCA8PCAiVXNpbmcgb3BlcmF0b3IhPVxuIjsKICAgIHJldHVybiAhKGEgPT0gYik7Cn0KCmludCBtYWluKCkgewogICAgTXlDbGFzcyBhezQyfTsKICAgIE15Q2xhc3MgYns0Mn07CgogICAgaWYgKGEgPT0gYikgewogICAgICAgIHN0ZDo6Y291dCA8PCAiYSBpcyBlcXVhbCB0byBiXG4iOwogICAgfQoKICAgIGlmIChhICE9IGIpIHsKICAgICAgICBzdGQ6OmNvdXQgPDwgImEgaXMgbm90IGVxdWFsIHRvIGJcbiI7CiAgICB9CgogICAgcmV0dXJuIDA7Cn0=&amp;insightsOptions=cpp20&amp;std=cpp20&amp;rev=1.0">C++ Insights</a>)</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">value</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Using operator==</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">value</span> <span class="o">==</span> <span class="n">other</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// This function is not visible before operator== is called</span>
<span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">MyClass</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Using operator!=</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">MyClass</span> <span class="n">a</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">MyClass</span> <span class="n">b</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is equal to b</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">!=</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a is not equal to b</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>So in these cases, the compiler takes the <code class="language-plaintext highlighter-rouge">operator==</code> and if it cannot find the matching negation, it will create it by rewriting the <code class="language-plaintext highlighter-rouge">operator==</code></p><p>How do the rewritten versions rank against the ones that are provided - just probably provided not in the right form?</p><p>As the economist would say, it depends. As the C++ developer would say, it depends on the compiler and the situation, but the answers can go from one range to another. You can check the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2468r2.html">paper</a> for some concrete examples.</p><h2 id="the-new-clear-programming-model">The new clear programming model</h2><p>What’s more important for us is how to solve the situation.</p><p>The authors of the paper considered different solutions, implemented them and ran the new rules against at least 59 open-source projects - by the end of their experiments, the number almost doubled - and checked how many of them would break.</p><p>In the beginning, a third of the projects broke, but it was below 8% by the end.</p><p>Based on these experiments that you can follow in the details in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2468r2.html#existing-code-impact">§1.3 of P2468R2</a>, the proposed and accepted solution is the following.</p><p><strong>If you want the compiler to automatically reverse <code class="language-plaintext highlighter-rouge">operator==</code> and therefore generate <code class="language-plaintext highlighter-rouge">operator!=</code>, make sure that you write **only** an <code class="language-plaintext highlighter-rouge">operator==</code> that returns a <code class="language-plaintext highlighter-rouge">bool</code>. (Yes, it might return an <code class="language-plaintext highlighter-rouge">int</code>…)</strong></p><p><strong>If you don’t want your <code class="language-plaintext highlighter-rouge">operator==</code> to be used for rewrites, make sure that you write a matching <code class="language-plaintext highlighter-rouge">operator!=</code>.</strong></p><p>No matter what, <code class="language-plaintext highlighter-rouge">operator&lt;=&gt;</code> will be used for rewrites, that’s an essential part of the feature.</p><p>With all that considered, <strong>if you’re migrating from C++17 and you want to keep behaviour the same as it was, make sure that every <code class="language-plaintext highlighter-rouge">operator==</code> has a matching <code class="language-plaintext highlighter-rouge">operator!=</code></strong>. And once you think that you’d like to benefit from rewrites, remove the <code class="language-plaintext highlighter-rouge">operator!=</code> and the compiler will provide that for you.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we very briefly reviewed what defect reports are in C++ and if a solution is proposed they become part of the standard version that introduced a defect. In this case, we saw how the equality operator’s behaviour changed with C++20 and that different compilers went with a different approach. In the end, we saw how the situation is fixed, what rules laid down by the authors of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2468r2.html">P2468R2</a>. With this fix, it should be straightforward how to benefit form rewritten <code class="language-plaintext highlighter-rouge">operator==</code> and how to avoid it.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/dr/" class="post-tag no-text-decoration" >dr</a> <a href="/tags/equality/" class="post-tag no-text-decoration" >equality</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=DR20 - The Equality Operator You Are Looking For - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=DR20 - The Equality Operator You Are Looking For - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=DR20 - The Equality Operator You Are Looking For - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=DR20 - The Equality Operator You Are Looking For - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2021/04/03/cpp20-get-the-details-rainer-grimm"><div class="card-body"> <span class="timeago small" > Apr 3, 2021 <i class="unloaded">2021-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ 20: Get the details by Rainer Grimm</h3><div class="text-muted small"><p> I could say that I picked C++ 20: Get the details up because I wanted to learn about the latest version of C++. I wouldn’t lie if I said so, but truth be told I was already an avid reader of Modern...</p></div></div></a></div><div class="card"> <a href="/blog/2022/04/13/first-company-project-experience-with-cpp20"><div class="card-body"> <span class="timeago small" > Apr 13, 2022 <i class="unloaded">2022-04-13T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My first work experience with C++20</h3><div class="text-muted small"><p> I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in...</p></div></div></a></div><div class="card"> <a href="/blog/2024/11/06/std-span"><div class="card-body"> <span class="timeago small" > Nov 6, 2024 <i class="unloaded">2024-11-06T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Use std::span instead of C-style arrays</h3><div class="text-muted small"><p> While reading the awesome book C++ Brain Teasers by Anders Schau Knatten, I realized it might be worth writing about spans. std::span is a class template that was added to the standard library in ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/12/27/2023-in-review" class="btn btn-outline-primary" prompt="Older"><p>2023: What a tiring year!</p></a> <a href="/blog/2024/01/03/std-filesystem-part1-paths-and-operations" class="btn btn-outline-primary" prompt="Newer"><p>Late discovery of std::filesystem - Part I</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'DR20 - The Equality Operator You Are Looking For'; this.page.url = 'https://www.sandordargo.com/blog/2024/01/03/DR20-equality-operator'; this.page.identifier = '/blog/2024/01/03/DR20-equality-operator'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
