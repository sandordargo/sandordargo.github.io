<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Upgrading the compiler: undefined behaviour uncovered" /><meta property="og:locale" content="en_US" /><meta name="description" content="Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. I don’t think I’ll say a lot of new things, but I have fresh inspiration to write about this. So let’s start with the story. I recently upgraded the compiler I used to build a project from Clang 14 to Clang 17. It always feels better to compile with something newer, isn’t it? It all went fine, I applied the new compiler and I started to fix the compiler warnings one by one before merging my pull request when I found that a unit test broke. My first reaction was that it must be a flaky test. But it was not. My second reaction was that by fixing the compiler warnings, I must have changed something. But I did not. My third reaction was despair. Once I recovered from it, I tried to reproduce the error on my local. You might ask why I didn’t try to reproduce it before?! I changed so little when I fixed the warnings that it should have really stood out, that’s why. Sadly, I couldn’t reproduce it on my local. But I use a different compiler than the CI and it was working before on the CI as well, so I was not that much surprised. I extracted the failing piece of code and simplified it as much as it made sense and I had a look at it on Compiler Explorer. This seemed like a good idea because I could immediately try it with different compilers and compiler versions. Needless to say, I couldn’t reproduce the problem at all. Smells like Undefined Behaviour? Here is the piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include &lt;cstdint&gt; #include &lt;iostream&gt; #include &lt;optional&gt; enum SomeOption { kSomeOptionUnknown = -1, kSomeOptionNone, kSomeOptionA, kSomeOptionB, kSomeOptionLast }; using AnotherOption = uint32_t; enum { kAnotherOptionFoo = 1 &lt;&lt; 0, kAnotherOptionBar = 1 &lt;&lt; 1, kAnotherOptionFooBar = 1 &lt;&lt; 2, kAnotherOptionBaz = 1 &lt;&lt; 3, }; using SomeRules = uint32_t; enum { kSomeRulesA = 1 &lt;&lt; 0, kSomeRulesB = 1 &lt;&lt; 1, kSomeRulesC = 1 &lt;&lt; 2, kSomeRulesD = 1 &lt;&lt; 3, }; struct State { SomeOption some_option; AnotherOption another_option; SomeRules rules; bool playful; bool isOn() const noexcept; }; bool State::isOn() const noexcept { const bool forced = (rules &amp; kSomeRulesA) == 0; return !(forced || (some_option == kSomeOptionNone) || (some_option == kSomeOptionUnknown)); } bool hasStateChanged(const std::optional&lt;State&gt; &amp;old_state, const State &amp;new_state) { return old_state-&gt;some_option != new_state.some_option || old_state-&gt;isOn() != new_state.isOn() || ((old_state-&gt;another_option ^ new_state.another_option) &amp; kAnotherOptionBaz); } int main() { State old_state; old_state.some_option = kSomeOptionB; old_state.rules = kSomeRulesA; old_state.playful = false; State new_state = old_state; new_state.playful = true; if(!hasStateChanged(std::optional&lt;State&gt;{old_state}, new_state)) { std::cout &lt;&lt; &quot;test passed!\n&quot;; } else { std::cout &lt;&lt; &quot;test failed\n&quot;; } } I know that this example is a bit long, but it’s already simplified quite a bit. I let you ponder over it a bit. I even put here a nice image of Castell de Sant Ferran (Figueres) so that you don’t see the answer immediately. So the problem is that State::another_option is left uninitialized therefore the behaviour is undefined when its value is read in hasStateChanged(). Right after I gave it an initial value, the unit test didn’t fail anymore. Obviously, that’s not the long-term solution. We have to make sure that our code doesn’t read uninitialized regions of the memory. The best way to do that is to make sure that no variable is left uninitialized. For struct or class members, the easiest way is to provide a default value either through the default constructor or by in-line class member initialization. I would love to answer what exactly changed between Clang 14 and Clang 17 that provoked this breakdown of the test. But I have absolutely no idea about it. On the other hand, it’s worth noting two things: we can often observe that struct members have no default initialization (more often than class members) yet the code works as expected What can be the reason behind - apart from undefined behaviour in our favour? The answer is how fundamental variables are initialized. Let’s go through some basic rules. No matter if we talk about a local, namespace level or member variable, a class-type variable will be default-initialized. If a reference is not initialized, the program is ill-formed. For fundamental types, it’s more nuanced. Depending on how the enclosing object is initialized, fundamental members might be left in an indeterminate state and we have to face undefined behaviour if we read them, just like in the above case or they might be zero-initialized. In the above example, given that the declaration State old_state; has no initializer sequence, default-initialization is performed and that leaves State::another_option in an indeterminate state. If we add an initializer sequence (such as {}) to the mentioned declaration and we end up with State old_state{};, then we can talk about value-initialization which will zero-initialize State::another_option in the above struct. I find it more and more important to understand these nuances of C++, at the same time, I also understand more and more why many people think it’s too complex. I believe that a way to solve this - without moving to another language - is to write expressive and explicit code. If you want to say that a member’s default value is zero, then just write it down and don’t rely on initialization rules. At the same time, I know I would comment on code that initializes a std::string explicitly like std::string s{&quot;&quot;}. As a rule of thumb, I would suggest always explicitly initializing variables of fundamental types while not forgetting about enums. When it comes to class types and you want to invoke the default constructor, you can omit the explicit initialization. In my opinion, it’s reasonable to expect people to know that their default constructor will be invoked, but it’s unreasonable to expect people to know when fundamental types will be initialized and when they will be left with an undefined value. If you really want to stay consistent, just use the braces (std::string s{};). Conclusion In this article, I showed you what kind of undefined behaviour was uncovered thanks to a recent compiler upgrade I performed. Then we discussed when started to discuss when we can expect a fundamental data type to be initialized and when not. In the few articles, we are going to get deeper into that topic and we’ll discuss the many different kinds of initialization that exist in C++. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. I don’t think I’ll say a lot of new things, but I have fresh inspiration to write about this. So let’s start with the story. I recently upgraded the compiler I used to build a project from Clang 14 to Clang 17. It always feels better to compile with something newer, isn’t it? It all went fine, I applied the new compiler and I started to fix the compiler warnings one by one before merging my pull request when I found that a unit test broke. My first reaction was that it must be a flaky test. But it was not. My second reaction was that by fixing the compiler warnings, I must have changed something. But I did not. My third reaction was despair. Once I recovered from it, I tried to reproduce the error on my local. You might ask why I didn’t try to reproduce it before?! I changed so little when I fixed the warnings that it should have really stood out, that’s why. Sadly, I couldn’t reproduce it on my local. But I use a different compiler than the CI and it was working before on the CI as well, so I was not that much surprised. I extracted the failing piece of code and simplified it as much as it made sense and I had a look at it on Compiler Explorer. This seemed like a good idea because I could immediately try it with different compilers and compiler versions. Needless to say, I couldn’t reproduce the problem at all. Smells like Undefined Behaviour? Here is the piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include &lt;cstdint&gt; #include &lt;iostream&gt; #include &lt;optional&gt; enum SomeOption { kSomeOptionUnknown = -1, kSomeOptionNone, kSomeOptionA, kSomeOptionB, kSomeOptionLast }; using AnotherOption = uint32_t; enum { kAnotherOptionFoo = 1 &lt;&lt; 0, kAnotherOptionBar = 1 &lt;&lt; 1, kAnotherOptionFooBar = 1 &lt;&lt; 2, kAnotherOptionBaz = 1 &lt;&lt; 3, }; using SomeRules = uint32_t; enum { kSomeRulesA = 1 &lt;&lt; 0, kSomeRulesB = 1 &lt;&lt; 1, kSomeRulesC = 1 &lt;&lt; 2, kSomeRulesD = 1 &lt;&lt; 3, }; struct State { SomeOption some_option; AnotherOption another_option; SomeRules rules; bool playful; bool isOn() const noexcept; }; bool State::isOn() const noexcept { const bool forced = (rules &amp; kSomeRulesA) == 0; return !(forced || (some_option == kSomeOptionNone) || (some_option == kSomeOptionUnknown)); } bool hasStateChanged(const std::optional&lt;State&gt; &amp;old_state, const State &amp;new_state) { return old_state-&gt;some_option != new_state.some_option || old_state-&gt;isOn() != new_state.isOn() || ((old_state-&gt;another_option ^ new_state.another_option) &amp; kAnotherOptionBaz); } int main() { State old_state; old_state.some_option = kSomeOptionB; old_state.rules = kSomeRulesA; old_state.playful = false; State new_state = old_state; new_state.playful = true; if(!hasStateChanged(std::optional&lt;State&gt;{old_state}, new_state)) { std::cout &lt;&lt; &quot;test passed!\n&quot;; } else { std::cout &lt;&lt; &quot;test failed\n&quot;; } } I know that this example is a bit long, but it’s already simplified quite a bit. I let you ponder over it a bit. I even put here a nice image of Castell de Sant Ferran (Figueres) so that you don’t see the answer immediately. So the problem is that State::another_option is left uninitialized therefore the behaviour is undefined when its value is read in hasStateChanged(). Right after I gave it an initial value, the unit test didn’t fail anymore. Obviously, that’s not the long-term solution. We have to make sure that our code doesn’t read uninitialized regions of the memory. The best way to do that is to make sure that no variable is left uninitialized. For struct or class members, the easiest way is to provide a default value either through the default constructor or by in-line class member initialization. I would love to answer what exactly changed between Clang 14 and Clang 17 that provoked this breakdown of the test. But I have absolutely no idea about it. On the other hand, it’s worth noting two things: we can often observe that struct members have no default initialization (more often than class members) yet the code works as expected What can be the reason behind - apart from undefined behaviour in our favour? The answer is how fundamental variables are initialized. Let’s go through some basic rules. No matter if we talk about a local, namespace level or member variable, a class-type variable will be default-initialized. If a reference is not initialized, the program is ill-formed. For fundamental types, it’s more nuanced. Depending on how the enclosing object is initialized, fundamental members might be left in an indeterminate state and we have to face undefined behaviour if we read them, just like in the above case or they might be zero-initialized. In the above example, given that the declaration State old_state; has no initializer sequence, default-initialization is performed and that leaves State::another_option in an indeterminate state. If we add an initializer sequence (such as {}) to the mentioned declaration and we end up with State old_state{};, then we can talk about value-initialization which will zero-initialize State::another_option in the above struct. I find it more and more important to understand these nuances of C++, at the same time, I also understand more and more why many people think it’s too complex. I believe that a way to solve this - without moving to another language - is to write expressive and explicit code. If you want to say that a member’s default value is zero, then just write it down and don’t rely on initialization rules. At the same time, I know I would comment on code that initializes a std::string explicitly like std::string s{&quot;&quot;}. As a rule of thumb, I would suggest always explicitly initializing variables of fundamental types while not forgetting about enums. When it comes to class types and you want to invoke the default constructor, you can omit the explicit initialization. In my opinion, it’s reasonable to expect people to know that their default constructor will be invoked, but it’s unreasonable to expect people to know when fundamental types will be initialized and when they will be left with an undefined value. If you really want to stay consistent, just use the braces (std::string s{};). Conclusion In this article, I showed you what kind of undefined behaviour was uncovered thanks to a recent compiler upgrade I performed. Then we discussed when started to discuss when we can expect a fundamental data type to be initialized and when not. In the few articles, we are going to get deeper into that topic and we’ll discuss the many different kinds of initialization that exist in C++. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-03T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Upgrading the compiler: undefined behaviour uncovered" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-03T07:16:22+02:00","datePublished":"2024-04-03T00:00:00+02:00","description":"Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. I don’t think I’ll say a lot of new things, but I have fresh inspiration to write about this. So let’s start with the story. I recently upgraded the compiler I used to build a project from Clang 14 to Clang 17. It always feels better to compile with something newer, isn’t it? It all went fine, I applied the new compiler and I started to fix the compiler warnings one by one before merging my pull request when I found that a unit test broke. My first reaction was that it must be a flaky test. But it was not. My second reaction was that by fixing the compiler warnings, I must have changed something. But I did not. My third reaction was despair. Once I recovered from it, I tried to reproduce the error on my local. You might ask why I didn’t try to reproduce it before?! I changed so little when I fixed the warnings that it should have really stood out, that’s why. Sadly, I couldn’t reproduce it on my local. But I use a different compiler than the CI and it was working before on the CI as well, so I was not that much surprised. I extracted the failing piece of code and simplified it as much as it made sense and I had a look at it on Compiler Explorer. This seemed like a good idea because I could immediately try it with different compilers and compiler versions. Needless to say, I couldn’t reproduce the problem at all. Smells like Undefined Behaviour? Here is the piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 #include &lt;cstdint&gt; #include &lt;iostream&gt; #include &lt;optional&gt; enum SomeOption { kSomeOptionUnknown = -1, kSomeOptionNone, kSomeOptionA, kSomeOptionB, kSomeOptionLast }; using AnotherOption = uint32_t; enum { kAnotherOptionFoo = 1 &lt;&lt; 0, kAnotherOptionBar = 1 &lt;&lt; 1, kAnotherOptionFooBar = 1 &lt;&lt; 2, kAnotherOptionBaz = 1 &lt;&lt; 3, }; using SomeRules = uint32_t; enum { kSomeRulesA = 1 &lt;&lt; 0, kSomeRulesB = 1 &lt;&lt; 1, kSomeRulesC = 1 &lt;&lt; 2, kSomeRulesD = 1 &lt;&lt; 3, }; struct State { SomeOption some_option; AnotherOption another_option; SomeRules rules; bool playful; bool isOn() const noexcept; }; bool State::isOn() const noexcept { const bool forced = (rules &amp; kSomeRulesA) == 0; return !(forced || (some_option == kSomeOptionNone) || (some_option == kSomeOptionUnknown)); } bool hasStateChanged(const std::optional&lt;State&gt; &amp;old_state, const State &amp;new_state) { return old_state-&gt;some_option != new_state.some_option || old_state-&gt;isOn() != new_state.isOn() || ((old_state-&gt;another_option ^ new_state.another_option) &amp; kAnotherOptionBaz); } int main() { State old_state; old_state.some_option = kSomeOptionB; old_state.rules = kSomeRulesA; old_state.playful = false; State new_state = old_state; new_state.playful = true; if(!hasStateChanged(std::optional&lt;State&gt;{old_state}, new_state)) { std::cout &lt;&lt; &quot;test passed!\\n&quot;; } else { std::cout &lt;&lt; &quot;test failed\\n&quot;; } } I know that this example is a bit long, but it’s already simplified quite a bit. I let you ponder over it a bit. I even put here a nice image of Castell de Sant Ferran (Figueres) so that you don’t see the answer immediately. So the problem is that State::another_option is left uninitialized therefore the behaviour is undefined when its value is read in hasStateChanged(). Right after I gave it an initial value, the unit test didn’t fail anymore. Obviously, that’s not the long-term solution. We have to make sure that our code doesn’t read uninitialized regions of the memory. The best way to do that is to make sure that no variable is left uninitialized. For struct or class members, the easiest way is to provide a default value either through the default constructor or by in-line class member initialization. I would love to answer what exactly changed between Clang 14 and Clang 17 that provoked this breakdown of the test. But I have absolutely no idea about it. On the other hand, it’s worth noting two things: we can often observe that struct members have no default initialization (more often than class members) yet the code works as expected What can be the reason behind - apart from undefined behaviour in our favour? The answer is how fundamental variables are initialized. Let’s go through some basic rules. No matter if we talk about a local, namespace level or member variable, a class-type variable will be default-initialized. If a reference is not initialized, the program is ill-formed. For fundamental types, it’s more nuanced. Depending on how the enclosing object is initialized, fundamental members might be left in an indeterminate state and we have to face undefined behaviour if we read them, just like in the above case or they might be zero-initialized. In the above example, given that the declaration State old_state; has no initializer sequence, default-initialization is performed and that leaves State::another_option in an indeterminate state. If we add an initializer sequence (such as {}) to the mentioned declaration and we end up with State old_state{};, then we can talk about value-initialization which will zero-initialize State::another_option in the above struct. I find it more and more important to understand these nuances of C++, at the same time, I also understand more and more why many people think it’s too complex. I believe that a way to solve this - without moving to another language - is to write expressive and explicit code. If you want to say that a member’s default value is zero, then just write it down and don’t rely on initialization rules. At the same time, I know I would comment on code that initializes a std::string explicitly like std::string s{&quot;&quot;}. As a rule of thumb, I would suggest always explicitly initializing variables of fundamental types while not forgetting about enums. When it comes to class types and you want to invoke the default constructor, you can omit the explicit initialization. In my opinion, it’s reasonable to expect people to know that their default constructor will be invoked, but it’s unreasonable to expect people to know when fundamental types will be initialized and when they will be left with an undefined value. If you really want to stay consistent, just use the braces (std::string s{};). Conclusion In this article, I showed you what kind of undefined behaviour was uncovered thanks to a recent compiler upgrade I performed. Then we discussed when started to discuss when we can expect a fundamental data type to be initialized and when not. In the few articles, we are going to get deeper into that topic and we’ll discuss the many different kinds of initialization that exist in C++. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Upgrading the compiler: undefined behaviour uncovered","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"},"url":"https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"}</script><title>Upgrading the compiler: undefined behaviour uncovered | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/03"> 03 </a> </span> <span>Upgrading the compiler: undefined behaviour uncovered</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 3, 2024, 12:00 AM +0200" prep="on" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 3, 2024, 7:16 AM +0200" prefix="Updated " > Apr 3, 2024 <i class="unloaded">2024-04-03T07:16:22+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1180 words">6 min</span></div></div><div class="post-content"><p>Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, <a href="https://www.sandordargo.com/blog/2023/11/22/struct-initialization">Struct Initialization</a>.</p><p>In the coming weeks, I’m going to revisit the topic. I don’t think I’ll say a lot of new things, but I have fresh inspiration to write about this.</p><p>So let’s start with the story.</p><p>I recently upgraded the compiler I used to build a project from Clang 14 to Clang 17. It always feels better to compile with something newer, isn’t it?</p><p>It all went fine, I applied the new compiler and I started to fix the compiler warnings one by one before merging my pull request when I found that a unit test broke. My first reaction was that it must be a flaky test. But it was not. My second reaction was that by fixing the compiler warnings, I must have changed something. But I did not. My third reaction was despair.</p><p>Once I recovered from it, I tried to reproduce the error on my local. You might ask why I didn’t try to reproduce it before?! I changed so little when I fixed the warnings that it should have really stood out, that’s why. Sadly, I couldn’t reproduce it on my local. But I use a different compiler than the CI and it was working before on the CI as well, so I was not that much surprised.</p><p>I extracted the failing piece of code and simplified it as much as it made sense and I had a look at it on <a href="https://godbolt.org/z/38oj5j6df">Compiler Explorer</a>. This seemed like a good idea because I could immediately try it with different compilers and compiler versions. Needless to say, I couldn’t reproduce the problem at all.</p><p>Smells like Undefined Behaviour?</p><p>Here is the piece of code:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">SomeOption</span> <span class="p">{</span>
  <span class="n">kSomeOptionUnknown</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
  <span class="n">kSomeOptionNone</span><span class="p">,</span>
  <span class="n">kSomeOptionA</span><span class="p">,</span>
  <span class="n">kSomeOptionB</span><span class="p">,</span>

  <span class="n">kSomeOptionLast</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">AnotherOption</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="n">kAnotherOptionFoo</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">kAnotherOptionBar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">kAnotherOptionFooBar</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
  <span class="n">kAnotherOptionBaz</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">using</span> <span class="n">SomeRules</span> <span class="o">=</span> <span class="kt">uint32_t</span><span class="p">;</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="n">kSomeRulesA</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">0</span><span class="p">,</span>
  <span class="n">kSomeRulesB</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">,</span>
  <span class="n">kSomeRulesC</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">2</span><span class="p">,</span>
  <span class="n">kSomeRulesD</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">3</span><span class="p">,</span>
<span class="p">};</span>
  
  <span class="k">struct</span> <span class="nc">State</span> <span class="p">{</span>
    <span class="n">SomeOption</span> <span class="n">some_option</span><span class="p">;</span>
    <span class="n">AnotherOption</span> <span class="n">another_option</span><span class="p">;</span>
    <span class="n">SomeRules</span> <span class="n">rules</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">playful</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">isOn</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="kt">bool</span> <span class="n">State</span><span class="o">::</span><span class="n">isOn</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span> <span class="p">{</span>
  <span class="k">const</span> <span class="kt">bool</span> <span class="n">forced</span> <span class="o">=</span> <span class="p">(</span><span class="n">rules</span> <span class="o">&amp;</span> <span class="n">kSomeRulesA</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">!</span><span class="p">(</span><span class="n">forced</span> <span class="o">||</span> <span class="p">(</span><span class="n">some_option</span> <span class="o">==</span> <span class="n">kSomeOptionNone</span><span class="p">)</span> <span class="o">||</span>
           <span class="p">(</span><span class="n">some_option</span> <span class="o">==</span> <span class="n">kSomeOptionUnknown</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="nf">hasStateChanged</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">old_state</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">State</span> <span class="o">&amp;</span><span class="n">new_state</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">old_state</span><span class="o">-&gt;</span><span class="n">some_option</span> <span class="o">!=</span> <span class="n">new_state</span><span class="p">.</span><span class="n">some_option</span> <span class="o">||</span>
                       <span class="n">old_state</span><span class="o">-&gt;</span><span class="n">isOn</span><span class="p">()</span> <span class="o">!=</span> <span class="n">new_state</span><span class="p">.</span><span class="n">isOn</span><span class="p">()</span> <span class="o">||</span>
                       <span class="p">((</span><span class="n">old_state</span><span class="o">-&gt;</span><span class="n">another_option</span> <span class="o">^</span> <span class="n">new_state</span><span class="p">.</span><span class="n">another_option</span><span class="p">)</span> <span class="o">&amp;</span>
                        <span class="n">kAnotherOptionBaz</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">State</span> <span class="n">old_state</span><span class="p">;</span>
  <span class="n">old_state</span><span class="p">.</span><span class="n">some_option</span> <span class="o">=</span> <span class="n">kSomeOptionB</span><span class="p">;</span>
  <span class="n">old_state</span><span class="p">.</span><span class="n">rules</span> <span class="o">=</span> <span class="n">kSomeRulesA</span><span class="p">;</span>
  <span class="n">old_state</span><span class="p">.</span><span class="n">playful</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">State</span> <span class="n">new_state</span> <span class="o">=</span> <span class="n">old_state</span><span class="p">;</span>
  <span class="n">new_state</span><span class="p">.</span><span class="n">playful</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">hasStateChanged</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">State</span><span class="o">&gt;</span><span class="p">{</span><span class="n">old_state</span><span class="p">},</span> <span class="n">new_state</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test passed!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"test failed</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

<span class="p">}</span>
</pre></table></code></div></div><p>I know that this example is a bit long, but it’s already simplified quite a bit. I let you ponder over it a bit. I even put here a nice image of Castell de Sant Ferran (Figueres) so that you don’t see the answer immediately.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/light-tunnel.jpg" alt="Castell de Sant Ferran (Figueres)" /></p><p>So the problem is that <code class="language-plaintext highlighter-rouge">State::another_option</code> is left uninitialized therefore the behaviour is undefined when its value is read in <code class="language-plaintext highlighter-rouge">hasStateChanged()</code>. Right after I gave it an initial value, the unit test didn’t fail anymore.</p><p>Obviously, that’s not the long-term solution. We have to make sure that our code doesn’t read uninitialized regions of the memory. The best way to do that is to make sure that no variable is left uninitialized. For struct or class members, the easiest way is to provide a default value either through the default constructor or by in-line class member initialization.</p><p>I would love to answer what exactly changed between Clang 14 and Clang 17 that provoked this breakdown of the test. But I have absolutely no idea about it.</p><p>On the other hand, it’s worth noting two things:</p><ul><li>we can often observe that struct members have no default initialization (more often than class members)<li>yet the code works as expected</ul><p>What can be the reason behind - apart from undefined behaviour in our favour?</p><p>The answer is how fundamental variables are initialized.</p><p>Let’s go through some basic rules.</p><ul><li>No matter if we talk about a local, namespace level or member variable, a class-type variable will be default-initialized.<li>If a reference is not initialized, the program is ill-formed.<li>For fundamental types, it’s more nuanced.</ul><p>Depending on how the enclosing object is initialized, fundamental members might be left in an indeterminate state and we have to face undefined behaviour if we read them, just like in the above case or they might be zero-initialized.</p><p>In the above example, given that the declaration <code class="language-plaintext highlighter-rouge">State old_state;</code> has no initializer sequence, <em>default-initialization</em> is performed and that leaves <code class="language-plaintext highlighter-rouge">State::another_option</code> in an indeterminate state.</p><p>If we add an initializer sequence (such as <code class="language-plaintext highlighter-rouge">{}</code>) to the mentioned declaration and we end up with <code class="language-plaintext highlighter-rouge">State old_state{};</code>, then we can talk about <em>value-initialization</em> which will <em>zero-initialize</em> <code class="language-plaintext highlighter-rouge">State::another_option</code> in the above struct.</p><p>I find it more and more important to understand these nuances of C++, at the same time, I also understand more and more why many people think it’s too complex. I believe that a way to solve this - without moving to another language - is to write expressive and explicit code.</p><p>If you want to say that a member’s default value is zero, then just write it down and don’t rely on initialization rules. At the same time, I know I would comment on code that initializes a <code class="language-plaintext highlighter-rouge">std::string</code> explicitly like <code class="language-plaintext highlighter-rouge">std::string s{""}</code>.</p><p>As a rule of thumb, I would suggest always explicitly initializing variables of fundamental types while not forgetting about enums. When it comes to class types and you want to invoke the default constructor, you can omit the explicit initialization. In my opinion, it’s reasonable to expect people to know that their default constructor will be invoked, but it’s unreasonable to expect people to know when fundamental types will be initialized and when they will be left with an undefined value. If you really want to stay consistent, just use the braces (<code class="language-plaintext highlighter-rouge">std::string s{};</code>).</p><h2 id="conclusion">Conclusion</h2><p>In this article, I showed you what kind of undefined behaviour was uncovered thanks to a recent compiler upgrade I performed. Then we discussed when started to discuss when we can expect a fundamental data type to be initialized and when not.</p><p>In the few articles, we are going to get deeper into that topic and we’ll discuss the many different kinds of initialization that exist in C++. Stay tuned!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/fundamental/" class="post-tag no-text-decoration" >fundamental</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/undefinedbehaviour/" class="post-tag no-text-decoration" >undefinedbehaviour</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Upgrading the compiler: undefined behaviour uncovered - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Upgrading the compiler: undefined behaviour uncovered - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Upgrading the compiler: undefined behaviour uncovered - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Upgrading the compiler: undefined behaviour uncovered - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/24/initializations-part-3"><div class="card-body"> <span class="timeago small" > Apr 24, 2024 <i class="unloaded">2024-04-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 3</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I ma...</p></div></div></a></div><div class="card"> <a href="/blog/2024/05/01/initializations-part-4"><div class="card-body"> <span class="timeago small" > May 1, 2024 <i class="unloaded">2024-05-01T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 4</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. In part 1, we covered th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/03/27/move-from-funtamental" class="btn btn-outline-primary" prompt="Older"><p>Should we move from fundamental types?</p></a> <a href="/blog/2024/04/10/initializations-part-1" class="btn btn-outline-primary" prompt="Newer"><p>When and how variables are initialized? - Part 1</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Upgrading the compiler: undefined behaviour uncovered'; this.page.url = 'https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour'; this.page.identifier = '/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
