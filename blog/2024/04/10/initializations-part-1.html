<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="When and how variables are initialized? - Part 1" /><meta property="og:locale" content="en_US" /><meta name="description" content="Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the topic of initialization deserves a deeper look. Let’s look first at C++ Reference. It matters where you check, but you might even find 8 different types of initialization. I had a bit of a hard time understanding how all of them relate to each other. So I decided to go over each of them and just see if they mention/reference others. Here is what I found: Default-initialization: zero-initialization Zero-initialization: value-initialization, non-local initialization, constant-initialization Value-initialization: aggregate-initialization, list-initialization, default-initialization, zero-initialization, copy-initialization Aggregate-initialization: list-initialization, copy-initialization, direct-initialization List-initialization: direct-list-initialization, copy-list-initialization, aggregate-initialization, copy-initialization, direct-initialization Direct-initialization: list-initialization, aggregate-initialization, value-initialization, copy-initialization Copy-initialization: list-initialization, aggregate-initialization, direct-initialization Constant-initialization: default-initialization Reference initialization: list-initialization, copy-initialization, direct-initialization That’s plenty of connections. How can we categorize initializations? How can we start learning them? I had two ideas in mind, a top-down and a bottom-up approach. The top-down in this case would mean that we start with those that reference others and as we need more details, we get deeper. With the bottom-up approach, we’d start with the details and once we understand them, we use them to build up higher-level concepts. The problem is that the above list is full of cycles, only reference-initialization is not referenced by others. So let’s use another approach, which is based on C++ reference’s. 3 initialization syntaxes C++ reference lists 4 distinct syntaxes to perform initialization, but two forms use the same rules, the same list-initialization-syntax. The first listed syntax involves an = and an expression right after. That is the copy-initialization syntax and will invoke copy-initialization of the object on the left of the equation sign operator. E.g. T obj = foo(); The second syntax still involves braces. It doesn’t matter whether those braces follow an =, the syntax is called the list-initialization syntax and they will invoke the rules of list initialization. The pair of braces can be either empty, contain an initializer list or a designated initializer list. E.g. T obj = {.foo = 42, .bar = 13} There is another syntax where the variable name is followed by a pair of parentheses (()) with an initializer-list in between. This syntax is called direct-initialization syntax and therefore the object will be direct-initialized. E.g. T obj(&quot;foo&quot;, bar) In this article, we are going to cover the first one from that list, copy-initialization and during the next weeks, we’ll cover the rest. Copy-initialization Previously, we saw that copy-initialization is invoked by the copy-initialization syntax such as T obj = foo(). But copy initialization will also happen when you pass an argument by value to a function or when you return a variable by value from a function. Let’s not forget about throwing or catching an exception by value also uses copy-initialization! And we’ll also see copy-initialization later, as part of aggregate initialization. Let’s see the effects of copy-initialization. 1 2 3 4 5 6 7 8 class MyClass { /* */ }; MyClass foo() { return MyClass(); } // ... MyClass mc = foo(); In the above snippet, mc is copy-initialized from the return value of foo(). Since C++17 copy elision is guaranteed, so only one MyClass object is instantiated, there are no temporary objects created. 1 2 3 4 5 class MyClass { /* */ }; // ... MyClass mc; MyClass mc2 = mc; This is also a copy-initialization and it would still be called a copy initialization if mc was moved (MyClass mc2 = std::move(mc)). In these cases, the copy and move constructors are invoked. Otherwise, when there are the same types on both sides or on the left side there is a derived type of the type to be initialized, the compiler would examine all the non-explicit constructors of the type on the left to find the best match by overload resolution and call it. If the types are not the same on both sides, the left side is also not a derived type of the left side and at least one side is not a class type then the compiler will consider user-defined conversion sequences. A user-defined conversion consists of zero or one non-explicit single-argument converting constructor or non-explicit conversion function call. The above definition means that explicit constructors are not considered user-defined conversions. Let’s expand our MyClass to see the above in action. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;string&gt; class MyClass { public: MyClass() = default; explicit MyClass (const std::string&amp; s): m_s(s){} private: std::string m_s; }; int main() { // MyClass mc = &quot;not OK&quot;; using namespace std::string_literals;; // MyClass mc2 = &quot;also not OK&quot;s; MyClass mc = MyClass(&quot;OK&quot;); // just to keep the copy-initialization syntax, but normally you simply call MyClass mc(&quot;OK&quot;); } We can see that we must explicitly invoke an explicit constructor, otherwise, it’s not considered even if it wouldn’t require a conversion from const char* to std::string. On the other hand, when we invoke the constructor, an implicit conversion is performed for the parameter. If there are non-class types on both sides, the compiler will consider standard conversions if necessary. 1 2 int num = true; // OK num is 1 const float val = num; // OK val is 1.0 Conclusion Last week, piggybacking a bug caused by undefined behaviour, we discussed why knowing about the different types of initializations in C++ is important. This week, we started a discovery of the different types and syntaxes of initialization and we discovered the details of copy-initialization. Next week, we’ll continue with list- and direct-initialization. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the topic of initialization deserves a deeper look. Let’s look first at C++ Reference. It matters where you check, but you might even find 8 different types of initialization. I had a bit of a hard time understanding how all of them relate to each other. So I decided to go over each of them and just see if they mention/reference others. Here is what I found: Default-initialization: zero-initialization Zero-initialization: value-initialization, non-local initialization, constant-initialization Value-initialization: aggregate-initialization, list-initialization, default-initialization, zero-initialization, copy-initialization Aggregate-initialization: list-initialization, copy-initialization, direct-initialization List-initialization: direct-list-initialization, copy-list-initialization, aggregate-initialization, copy-initialization, direct-initialization Direct-initialization: list-initialization, aggregate-initialization, value-initialization, copy-initialization Copy-initialization: list-initialization, aggregate-initialization, direct-initialization Constant-initialization: default-initialization Reference initialization: list-initialization, copy-initialization, direct-initialization That’s plenty of connections. How can we categorize initializations? How can we start learning them? I had two ideas in mind, a top-down and a bottom-up approach. The top-down in this case would mean that we start with those that reference others and as we need more details, we get deeper. With the bottom-up approach, we’d start with the details and once we understand them, we use them to build up higher-level concepts. The problem is that the above list is full of cycles, only reference-initialization is not referenced by others. So let’s use another approach, which is based on C++ reference’s. 3 initialization syntaxes C++ reference lists 4 distinct syntaxes to perform initialization, but two forms use the same rules, the same list-initialization-syntax. The first listed syntax involves an = and an expression right after. That is the copy-initialization syntax and will invoke copy-initialization of the object on the left of the equation sign operator. E.g. T obj = foo(); The second syntax still involves braces. It doesn’t matter whether those braces follow an =, the syntax is called the list-initialization syntax and they will invoke the rules of list initialization. The pair of braces can be either empty, contain an initializer list or a designated initializer list. E.g. T obj = {.foo = 42, .bar = 13} There is another syntax where the variable name is followed by a pair of parentheses (()) with an initializer-list in between. This syntax is called direct-initialization syntax and therefore the object will be direct-initialized. E.g. T obj(&quot;foo&quot;, bar) In this article, we are going to cover the first one from that list, copy-initialization and during the next weeks, we’ll cover the rest. Copy-initialization Previously, we saw that copy-initialization is invoked by the copy-initialization syntax such as T obj = foo(). But copy initialization will also happen when you pass an argument by value to a function or when you return a variable by value from a function. Let’s not forget about throwing or catching an exception by value also uses copy-initialization! And we’ll also see copy-initialization later, as part of aggregate initialization. Let’s see the effects of copy-initialization. 1 2 3 4 5 6 7 8 class MyClass { /* */ }; MyClass foo() { return MyClass(); } // ... MyClass mc = foo(); In the above snippet, mc is copy-initialized from the return value of foo(). Since C++17 copy elision is guaranteed, so only one MyClass object is instantiated, there are no temporary objects created. 1 2 3 4 5 class MyClass { /* */ }; // ... MyClass mc; MyClass mc2 = mc; This is also a copy-initialization and it would still be called a copy initialization if mc was moved (MyClass mc2 = std::move(mc)). In these cases, the copy and move constructors are invoked. Otherwise, when there are the same types on both sides or on the left side there is a derived type of the type to be initialized, the compiler would examine all the non-explicit constructors of the type on the left to find the best match by overload resolution and call it. If the types are not the same on both sides, the left side is also not a derived type of the left side and at least one side is not a class type then the compiler will consider user-defined conversion sequences. A user-defined conversion consists of zero or one non-explicit single-argument converting constructor or non-explicit conversion function call. The above definition means that explicit constructors are not considered user-defined conversions. Let’s expand our MyClass to see the above in action. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;string&gt; class MyClass { public: MyClass() = default; explicit MyClass (const std::string&amp; s): m_s(s){} private: std::string m_s; }; int main() { // MyClass mc = &quot;not OK&quot;; using namespace std::string_literals;; // MyClass mc2 = &quot;also not OK&quot;s; MyClass mc = MyClass(&quot;OK&quot;); // just to keep the copy-initialization syntax, but normally you simply call MyClass mc(&quot;OK&quot;); } We can see that we must explicitly invoke an explicit constructor, otherwise, it’s not considered even if it wouldn’t require a conversion from const char* to std::string. On the other hand, when we invoke the constructor, an implicit conversion is performed for the parameter. If there are non-class types on both sides, the compiler will consider standard conversions if necessary. 1 2 int num = true; // OK num is 1 const float val = num; // OK val is 1.0 Conclusion Last week, piggybacking a bug caused by undefined behaviour, we discussed why knowing about the different types of initializations in C++ is important. This week, we started a discovery of the different types and syntaxes of initialization and we discovered the details of copy-initialization. Next week, we’ll continue with list- and direct-initialization. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/04/10/initializations-part-1" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/04/10/initializations-part-1" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-10T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="When and how variables are initialized? - Part 1" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-10T00:00:00+02:00","datePublished":"2024-04-10T00:00:00+02:00","description":"Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the topic of initialization deserves a deeper look. Let’s look first at C++ Reference. It matters where you check, but you might even find 8 different types of initialization. I had a bit of a hard time understanding how all of them relate to each other. So I decided to go over each of them and just see if they mention/reference others. Here is what I found: Default-initialization: zero-initialization Zero-initialization: value-initialization, non-local initialization, constant-initialization Value-initialization: aggregate-initialization, list-initialization, default-initialization, zero-initialization, copy-initialization Aggregate-initialization: list-initialization, copy-initialization, direct-initialization List-initialization: direct-list-initialization, copy-list-initialization, aggregate-initialization, copy-initialization, direct-initialization Direct-initialization: list-initialization, aggregate-initialization, value-initialization, copy-initialization Copy-initialization: list-initialization, aggregate-initialization, direct-initialization Constant-initialization: default-initialization Reference initialization: list-initialization, copy-initialization, direct-initialization That’s plenty of connections. How can we categorize initializations? How can we start learning them? I had two ideas in mind, a top-down and a bottom-up approach. The top-down in this case would mean that we start with those that reference others and as we need more details, we get deeper. With the bottom-up approach, we’d start with the details and once we understand them, we use them to build up higher-level concepts. The problem is that the above list is full of cycles, only reference-initialization is not referenced by others. So let’s use another approach, which is based on C++ reference’s. 3 initialization syntaxes C++ reference lists 4 distinct syntaxes to perform initialization, but two forms use the same rules, the same list-initialization-syntax. The first listed syntax involves an = and an expression right after. That is the copy-initialization syntax and will invoke copy-initialization of the object on the left of the equation sign operator. E.g. T obj = foo(); The second syntax still involves braces. It doesn’t matter whether those braces follow an =, the syntax is called the list-initialization syntax and they will invoke the rules of list initialization. The pair of braces can be either empty, contain an initializer list or a designated initializer list. E.g. T obj = {.foo = 42, .bar = 13} There is another syntax where the variable name is followed by a pair of parentheses (()) with an initializer-list in between. This syntax is called direct-initialization syntax and therefore the object will be direct-initialized. E.g. T obj(&quot;foo&quot;, bar) In this article, we are going to cover the first one from that list, copy-initialization and during the next weeks, we’ll cover the rest. Copy-initialization Previously, we saw that copy-initialization is invoked by the copy-initialization syntax such as T obj = foo(). But copy initialization will also happen when you pass an argument by value to a function or when you return a variable by value from a function. Let’s not forget about throwing or catching an exception by value also uses copy-initialization! And we’ll also see copy-initialization later, as part of aggregate initialization. Let’s see the effects of copy-initialization. 1 2 3 4 5 6 7 8 class MyClass { /* */ }; MyClass foo() { return MyClass(); } // ... MyClass mc = foo(); In the above snippet, mc is copy-initialized from the return value of foo(). Since C++17 copy elision is guaranteed, so only one MyClass object is instantiated, there are no temporary objects created. 1 2 3 4 5 class MyClass { /* */ }; // ... MyClass mc; MyClass mc2 = mc; This is also a copy-initialization and it would still be called a copy initialization if mc was moved (MyClass mc2 = std::move(mc)). In these cases, the copy and move constructors are invoked. Otherwise, when there are the same types on both sides or on the left side there is a derived type of the type to be initialized, the compiler would examine all the non-explicit constructors of the type on the left to find the best match by overload resolution and call it. If the types are not the same on both sides, the left side is also not a derived type of the left side and at least one side is not a class type then the compiler will consider user-defined conversion sequences. A user-defined conversion consists of zero or one non-explicit single-argument converting constructor or non-explicit conversion function call. The above definition means that explicit constructors are not considered user-defined conversions. Let’s expand our MyClass to see the above in action. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;string&gt; class MyClass { public: MyClass() = default; explicit MyClass (const std::string&amp; s): m_s(s){} private: std::string m_s; }; int main() { // MyClass mc = &quot;not OK&quot;; using namespace std::string_literals;; // MyClass mc2 = &quot;also not OK&quot;s; MyClass mc = MyClass(&quot;OK&quot;); // just to keep the copy-initialization syntax, but normally you simply call MyClass mc(&quot;OK&quot;); } We can see that we must explicitly invoke an explicit constructor, otherwise, it’s not considered even if it wouldn’t require a conversion from const char* to std::string. On the other hand, when we invoke the constructor, an implicit conversion is performed for the parameter. If there are non-class types on both sides, the compiler will consider standard conversions if necessary. 1 2 int num = true; // OK num is 1 const float val = num; // OK val is 1.0 Conclusion Last week, piggybacking a bug caused by undefined behaviour, we discussed why knowing about the different types of initializations in C++ is important. This week, we started a discovery of the different types and syntaxes of initialization and we discovered the details of copy-initialization. Next week, we’ll continue with list- and direct-initialization. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"When and how variables are initialized? - Part 1","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/04/10/initializations-part-1"},"url":"https://www.sandordargo.com/blog/2024/04/10/initializations-part-1"}</script><title>When and how variables are initialized? - Part 1 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/10"> 10 </a> </span> <span>When and how variables are initialized? - Part 1</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>When and how variables are initialized? - Part 1</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 10, 2024, 12:00 AM +0200" prep="on" > Apr 10, 2024 <i class="unloaded">2024-04-10T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="966 words">5 min</span></div></div><div class="post-content"><p>Recently, <a href="https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour">I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered</a>. There we briefly looked into why a member was left uninitialized, but the topic of initialization deserves a deeper look.</p><p>Let’s look first at C++ Reference. It matters where you check, but you might even find 8 different types of initialization.</p><p>I had a bit of a hard time understanding how all of them relate to each other. So I decided to go over each of them and just see if they mention/reference others. Here is what I found:</p><ul><li><em>Default-initialization</em>: zero-initialization<li><em>Zero-initialization</em>: value-initialization, non-local initialization, constant-initialization<li><em>Value-initialization</em>: aggregate-initialization, list-initialization, default-initialization, zero-initialization, copy-initialization<li><em>Aggregate-initialization</em>: list-initialization, copy-initialization, direct-initialization<li><em>List-initialization</em>: direct-list-initialization, copy-list-initialization, aggregate-initialization, copy-initialization, direct-initialization<li><em>Direct-initialization</em>: list-initialization, aggregate-initialization, value-initialization, copy-initialization<li><em>Copy-initialization</em>: list-initialization, aggregate-initialization, direct-initialization<li><em>Constant-initialization</em>: default-initialization<li><em>Reference initialization</em>: list-initialization, copy-initialization, direct-initialization</ul><p>That’s plenty of connections. How can we categorize initializations? How can we start learning them?</p><p>I had two ideas in mind, a top-down and a bottom-up approach. The top-down in this case would mean that we start with those that reference others and as we need more details, we get deeper. With the bottom-up approach, we’d start with the details and once we understand them, we use them to build up higher-level concepts.</p><p>The problem is that the above list is full of cycles, only reference-initialization is not referenced by others.</p><p>So let’s use another approach, which is based on C++ reference’s.</p><h2 id="3-initialization-syntaxes">3 initialization syntaxes</h2><p>C++ reference lists 4 distinct syntaxes to perform initialization, but two forms use the same rules, the same list-initialization-syntax.</p><p>The first listed syntax involves an <code class="language-plaintext highlighter-rouge">=</code> and an expression right after. That is the <em>copy-initialization</em> syntax and will invoke copy-initialization of the object on the left of the equation sign operator. <em>E.g. <code class="language-plaintext highlighter-rouge">T obj = foo();</code></em></p><p>The second syntax still involves braces. It doesn’t matter whether those braces follow an <code class="language-plaintext highlighter-rouge">=</code>, the syntax is called the list-initialization syntax and they will invoke the rules of list initialization. The pair of braces can be either empty, contain an initializer list or a designated initializer list. <em>E.g. <code class="language-plaintext highlighter-rouge">T obj = {.foo = 42, .bar = 13}</code></em></p><p>There is another syntax where the variable name is followed by a pair of parentheses (<code class="language-plaintext highlighter-rouge">()</code>) with an initializer-list in between. This syntax is called direct-initialization syntax and therefore the object will be direct-initialized. <em>E.g. <code class="language-plaintext highlighter-rouge">T obj("foo", bar)</code></em></p><p>In this article, we are going to cover the first one from that list, <em>copy-initialization</em> and during the next weeks, we’ll cover the rest.</p><h2 id="copy-initialization">Copy-initialization</h2><p>Previously, we saw that copy-initialization is invoked by the copy-initialization syntax such as <code class="language-plaintext highlighter-rouge">T obj = foo()</code>. But copy initialization will also happen when you pass an argument by value to a function or when you return a variable by value from a function. Let’s not forget about throwing or catching an exception by value also uses copy-initialization! And we’ll also see copy-initialization later, as part of aggregate initialization.</p><p>Let’s see the effects of copy-initialization.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">};</span>

<span class="n">MyClass</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">MyClass</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">// ...</span>
<span class="n">MyClass</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>
</pre></table></code></div></div><p>In the above snippet, <code class="language-plaintext highlighter-rouge">mc</code> is copy-initialized from the return value of <code class="language-plaintext highlighter-rouge">foo()</code>. Since C++17 copy elision is guaranteed, so only one <code class="language-plaintext highlighter-rouge">MyClass</code> object is instantiated, there are no temporary objects created.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span> <span class="cm">/* */</span> <span class="p">};</span>

<span class="c1">// ...</span>
<span class="n">MyClass</span> <span class="n">mc</span><span class="p">;</span>
<span class="n">MyClass</span> <span class="n">mc2</span> <span class="o">=</span> <span class="n">mc</span><span class="p">;</span> 
</pre></table></code></div></div><p>This is also a copy-initialization and it would still be called a copy initialization if <code class="language-plaintext highlighter-rouge">mc</code> was moved (<code class="language-plaintext highlighter-rouge">MyClass mc2 = std::move(mc)</code>). In these cases, the copy and move constructors are invoked. Otherwise, when there are the same types on both sides or on the left side there is a derived type of the type to be initialized, the compiler would examine all the non-explicit constructors of the type on the left to find the best match by overload resolution and call it.</p><p>If the types are not the same on both sides, the left side is also not a derived type of the left side and at least one side is not a class type then the compiler will consider user-defined conversion sequences.</p><blockquote><p>A user-defined conversion consists of zero or one non-explicit single-argument converting constructor or non-explicit conversion function call.</p></blockquote><p>The above definition means that explicit constructors are not considered user-defined conversions. Let’s expand our MyClass to see the above in action.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">MyClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">explicit</span> <span class="n">MyClass</span> <span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">)</span><span class="o">:</span> <span class="n">m_s</span><span class="p">(</span><span class="n">s</span><span class="p">){}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_s</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// MyClass mc = "not OK";</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="o">::</span><span class="n">string_literals</span><span class="p">;;</span>
    <span class="c1">// MyClass mc2 = "also not OK"s;</span>
    <span class="n">MyClass</span> <span class="n">mc</span> <span class="o">=</span> <span class="n">MyClass</span><span class="p">(</span><span class="s">"OK"</span><span class="p">);</span> <span class="c1">// just to keep the copy-initialization syntax, but normally you simply call MyClass mc("OK");</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We can see that we must explicitly invoke an explicit constructor, otherwise, it’s not considered even if it wouldn’t require a conversion from <code class="language-plaintext highlighter-rouge">const char*</code> to <code class="language-plaintext highlighter-rouge">std::string</code>. On the other hand, when we invoke the constructor, an implicit conversion is performed for the parameter.</p><p>If there are non-class types on both sides, the compiler will consider standard conversions if necessary.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// OK num is 1</span>
<span class="k">const</span> <span class="kt">float</span> <span class="n">val</span> <span class="o">=</span> <span class="n">num</span><span class="p">;</span> <span class="c1">// OK val is 1.0</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>Last week, piggybacking a bug caused by undefined behaviour, we discussed why knowing about the different types of initializations in C++ is important. This week, we started a discovery of the different types and syntaxes of initialization and we discovered the details of copy-initialization.</p><p>Next week, we’ll continue with list- and direct-initialization. Stay tuned.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/fundamental/" class="post-tag no-text-decoration" >fundamental</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/copyinitialization/" class="post-tag no-text-decoration" >copyinitialization</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=When and how variables are initialized? - Part 1 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/10/initializations-part-1" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=When and how variables are initialized? - Part 1 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/10/initializations-part-1" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=When and how variables are initialized? - Part 1 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/10/initializations-part-1" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=When and how variables are initialized? - Part 1 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/10/initializations-part-1" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/24/initializations-part-3"><div class="card-body"> <span class="timeago small" > Apr 24, 2024 <i class="unloaded">2024-04-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 3</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I ma...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour" class="btn btn-outline-primary" prompt="Older"><p>Upgrading the compiler: undefined behaviour uncovered</p></a> <a href="/blog/2024/04/17/initializations-part-2" class="btn btn-outline-primary" prompt="Newer"><p>When and how variables are initialized? - Part 2</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'When and how variables are initialized? - Part 1'; this.page.url = 'https://www.sandordargo.com/blog/2024/04/10/initializations-part-1'; this.page.identifier = '/blog/2024/04/10/initializations-part-1'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
