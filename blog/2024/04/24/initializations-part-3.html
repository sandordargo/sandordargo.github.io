<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="When and how variables are initialized? - Part 3" /><meta property="og:locale" content="en_US" /><meta name="description" content="For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I maintained. While I was looking for an answer to what happened, I realized that there are not only default and value initializations in C++ but many more different forms. Today, we are going to cover, default-, zero- and value-initialization. Default-initialization This is performed when an object is constructed with no initializer sequence. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s1; std::cout &lt;&lt; &quot;s1.m_num: &quot; &lt;&lt; s1.m_num &lt;&lt; &quot;, s1.m_text: &quot; &lt;&lt; s1.m_text &lt;&lt; &#39;\n&#39;; S* s2 = new S; std::cout &lt;&lt; &quot;s2-&gt;m_num: &quot; &lt;&lt; s2-&gt;m_num &lt;&lt; &quot;, s2-&gt;m_text: &quot; &lt;&lt; s2-&gt;m_text &lt;&lt; &#39;\n&#39;; } As you can see, the initializer can be omitted both for variables with automatic and even with dynamic storage duration, but it also works for static and thread-local variables. There is yet another possibility when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called. That might be a bit complex explanation, so let’s look at some examples. 1 2 3 4 struct S { S() {}; std::string m_text; }; In the above piece of code, a non-static data member (m_text) is not mentioned in a constructor initializer list. So when we construct an instance of S, m_text is default initialized. Now let’s cover the other possibility when the base class is not mentioned in the constructor initializer-list. 1 2 3 4 5 6 7 8 9 struct Base { std::string m_base_text; }; struct Derived : Base { Derived() {}; int m_num; std::string m_text; }; For class types, default-initialization means that their default constructor would be invoked. For non-class types, the meaning of default-initialization depends on their storage duration. If their storage duration is automatic or dynamic, the value would be undefined. But if their storage duration is static or thread-local, then the variable gets zero-initialized. We’ll discuss what zero-initialization means just in a bit. It’s worth noting that references and const scalar objects cannot be default-initialized. The following types are scalar: arithmetic, enumeration, pointer and pointer-to-member types and all their cv-qualified versions, as well as std::nullptr_t. Value-initialization Now let’s talk about value-initialization! First of all, let’s see the syntax that would invoke it! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() : m_num{}, m_text() {} int m_num; std::string m_text; }; int main() { S s1{}; std::cout &lt;&lt; &quot;s1.m_num: &quot; &lt;&lt; s1.m_num &lt;&lt; &quot;, s1.m_text: &quot; &lt;&lt; s1.m_text &lt;&lt; &#39;\n&#39;; S* s2 = new S(); std::cout &lt;&lt; &quot;s2-&gt;m_num: &quot; &lt;&lt; s2-&gt;m_num &lt;&lt; &quot;, s2-&gt;m_text: &quot; &lt;&lt; s2-&gt;m_text &lt;&lt; &#39;\n&#39;; } What we can see is that both local variables, s1 and s2 are now followed by an empty initializer sequence, either () or {} can invoke value-initialization. Value-initialization is also invoked for non-static members when they are initialized in the member initializer list with an empty pair of parentheses or braces. But what are the effects? As always, the answer is “it depends”. If it’s a class type and it has an implicitly defined or defaulted constructor, zero-initialization will happen. Unless the default constructor is non-trivial, then default-initialization will happen. If it’s a class type and there is no default constructor, or it’s user-provided or even deleted, then we are in the case of default initialization. If it’s an array type, then for each element we get into a recursive loop as they are value initialized. If it’s a non-class type, the object is zero-initialized. In all cases, if the empty pair of braces ({}) is used and T is an aggregate type, aggregate-initialization is performed instead of value-initialization. If T is a class type that has no default constructor but has a constructor taking std::initializer_list, list-initialization is performed just as we saw last week. Zero-intialization By now, we can clearly see that initialization is a complex topic in C++. If you’re not convinced, the next phrase will probably change that: zero-initialization does not have a dedicated syntax, but it might happen in certain situations. But first of all, what is zero-initialization? It depends on the type. If T is a union type then padding bits are initialized to zero bits and the first non-static named data member is zero-initialized. For arrays, each element is zero-initialized and for reference types, nothing is done. So far so good, but what does really happen? If T is a non-union class type, then padding bits are initialized to zero bits, all non-static members are zero-initialized, all non-virtual base class subobjects are zero-initialized just like each virtual base class subobjects, unless T is also a base class subobject itself. If T is scalar, then the object is initialized to the value obtained by explicitly converting the integer literal 0 to T. So bool b would be false, int i 0, double d 0.0 and a char c would contain the null character (\0). In the end, we are getting back to the fact that every type deep down is composed of built-in types and zero initialization will boil down to zero-initialize those. But when can it happen? For every named variable with static or thread-local storage duration that is not subject to constant initialization (another type of initialization!), before any other initialization. When an array of any character type is initialized with a string literal that is too short, the remainder of the array is zero-initialized. So the rest will contain \0 characters. As part of the value-initialization sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of aggregates for which no initializers are provided. This last one might need an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; struct S { int a, b, c; }; class C { public: int a, b, c; }; int main() { S a = S(); // the effect is same as: A a{}; or A a = {}; std::cout &lt;&lt; &quot;a = {&quot; &lt;&lt; a.a &lt;&lt; &#39; &#39; &lt;&lt; a.b &lt;&lt; &#39; &#39; &lt;&lt; a.c &lt;&lt; &quot;}\n&quot;; S b; // the effect is same as: A a{}; or A a = {}; std::cout &lt;&lt; &quot;b = {&quot; &lt;&lt; b.a &lt;&lt; &#39; &#39; &lt;&lt; b.b &lt;&lt; &#39; &#39; &lt;&lt; b.c &lt;&lt; &quot;}\n&quot;; C c; std::cout &lt;&lt; &quot;c = {&quot; &lt;&lt; c.a &lt;&lt; &#39; &#39; &lt;&lt; c.b &lt;&lt; &#39; &#39; &lt;&lt; c.c &lt;&lt; &quot;}\n&quot;; C d = C{}; std::cout &lt;&lt; &quot;d = {&quot; &lt;&lt; d.a &lt;&lt; &#39; &#39; &lt;&lt; d.b &lt;&lt; &#39; &#39; &lt;&lt; d.c &lt;&lt; &quot;}\n&quot;; } /* a = {0 0 0} b = {-11906462 32551 1651076199} c = {32551 0 0} d = {0 0 0} */ We can see that neither S nor C has a constructor (only the default generated one). Yet, for a and d we see zero-initialization happening, while for b and c what we observe is undefined behaviour and some garbage values. The difference is that zero-initialization might happen as part of value initialization, which is clearly the case for a and d due to the usage of initializer sequences. On the other hand, for b and d, no initializer sequence is used and as such we are in the case of default-initialization which leaves the uninitialized members in an undefined state. Conclusion This week, we’ve discussed default-, value- and zero- initializations of objects. It’s important to keep in mind that relying on default-initialization might leave data in an undefined state but with zero/value initialization that will never happen. Next week, we’ll put the final pieces together and talk about constant and reference initialization. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I maintained. While I was looking for an answer to what happened, I realized that there are not only default and value initializations in C++ but many more different forms. Today, we are going to cover, default-, zero- and value-initialization. Default-initialization This is performed when an object is constructed with no initializer sequence. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s1; std::cout &lt;&lt; &quot;s1.m_num: &quot; &lt;&lt; s1.m_num &lt;&lt; &quot;, s1.m_text: &quot; &lt;&lt; s1.m_text &lt;&lt; &#39;\n&#39;; S* s2 = new S; std::cout &lt;&lt; &quot;s2-&gt;m_num: &quot; &lt;&lt; s2-&gt;m_num &lt;&lt; &quot;, s2-&gt;m_text: &quot; &lt;&lt; s2-&gt;m_text &lt;&lt; &#39;\n&#39;; } As you can see, the initializer can be omitted both for variables with automatic and even with dynamic storage duration, but it also works for static and thread-local variables. There is yet another possibility when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called. That might be a bit complex explanation, so let’s look at some examples. 1 2 3 4 struct S { S() {}; std::string m_text; }; In the above piece of code, a non-static data member (m_text) is not mentioned in a constructor initializer list. So when we construct an instance of S, m_text is default initialized. Now let’s cover the other possibility when the base class is not mentioned in the constructor initializer-list. 1 2 3 4 5 6 7 8 9 struct Base { std::string m_base_text; }; struct Derived : Base { Derived() {}; int m_num; std::string m_text; }; For class types, default-initialization means that their default constructor would be invoked. For non-class types, the meaning of default-initialization depends on their storage duration. If their storage duration is automatic or dynamic, the value would be undefined. But if their storage duration is static or thread-local, then the variable gets zero-initialized. We’ll discuss what zero-initialization means just in a bit. It’s worth noting that references and const scalar objects cannot be default-initialized. The following types are scalar: arithmetic, enumeration, pointer and pointer-to-member types and all their cv-qualified versions, as well as std::nullptr_t. Value-initialization Now let’s talk about value-initialization! First of all, let’s see the syntax that would invoke it! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() : m_num{}, m_text() {} int m_num; std::string m_text; }; int main() { S s1{}; std::cout &lt;&lt; &quot;s1.m_num: &quot; &lt;&lt; s1.m_num &lt;&lt; &quot;, s1.m_text: &quot; &lt;&lt; s1.m_text &lt;&lt; &#39;\n&#39;; S* s2 = new S(); std::cout &lt;&lt; &quot;s2-&gt;m_num: &quot; &lt;&lt; s2-&gt;m_num &lt;&lt; &quot;, s2-&gt;m_text: &quot; &lt;&lt; s2-&gt;m_text &lt;&lt; &#39;\n&#39;; } What we can see is that both local variables, s1 and s2 are now followed by an empty initializer sequence, either () or {} can invoke value-initialization. Value-initialization is also invoked for non-static members when they are initialized in the member initializer list with an empty pair of parentheses or braces. But what are the effects? As always, the answer is “it depends”. If it’s a class type and it has an implicitly defined or defaulted constructor, zero-initialization will happen. Unless the default constructor is non-trivial, then default-initialization will happen. If it’s a class type and there is no default constructor, or it’s user-provided or even deleted, then we are in the case of default initialization. If it’s an array type, then for each element we get into a recursive loop as they are value initialized. If it’s a non-class type, the object is zero-initialized. In all cases, if the empty pair of braces ({}) is used and T is an aggregate type, aggregate-initialization is performed instead of value-initialization. If T is a class type that has no default constructor but has a constructor taking std::initializer_list, list-initialization is performed just as we saw last week. Zero-intialization By now, we can clearly see that initialization is a complex topic in C++. If you’re not convinced, the next phrase will probably change that: zero-initialization does not have a dedicated syntax, but it might happen in certain situations. But first of all, what is zero-initialization? It depends on the type. If T is a union type then padding bits are initialized to zero bits and the first non-static named data member is zero-initialized. For arrays, each element is zero-initialized and for reference types, nothing is done. So far so good, but what does really happen? If T is a non-union class type, then padding bits are initialized to zero bits, all non-static members are zero-initialized, all non-virtual base class subobjects are zero-initialized just like each virtual base class subobjects, unless T is also a base class subobject itself. If T is scalar, then the object is initialized to the value obtained by explicitly converting the integer literal 0 to T. So bool b would be false, int i 0, double d 0.0 and a char c would contain the null character (\0). In the end, we are getting back to the fact that every type deep down is composed of built-in types and zero initialization will boil down to zero-initialize those. But when can it happen? For every named variable with static or thread-local storage duration that is not subject to constant initialization (another type of initialization!), before any other initialization. When an array of any character type is initialized with a string literal that is too short, the remainder of the array is zero-initialized. So the rest will contain \0 characters. As part of the value-initialization sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of aggregates for which no initializers are provided. This last one might need an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; struct S { int a, b, c; }; class C { public: int a, b, c; }; int main() { S a = S(); // the effect is same as: A a{}; or A a = {}; std::cout &lt;&lt; &quot;a = {&quot; &lt;&lt; a.a &lt;&lt; &#39; &#39; &lt;&lt; a.b &lt;&lt; &#39; &#39; &lt;&lt; a.c &lt;&lt; &quot;}\n&quot;; S b; // the effect is same as: A a{}; or A a = {}; std::cout &lt;&lt; &quot;b = {&quot; &lt;&lt; b.a &lt;&lt; &#39; &#39; &lt;&lt; b.b &lt;&lt; &#39; &#39; &lt;&lt; b.c &lt;&lt; &quot;}\n&quot;; C c; std::cout &lt;&lt; &quot;c = {&quot; &lt;&lt; c.a &lt;&lt; &#39; &#39; &lt;&lt; c.b &lt;&lt; &#39; &#39; &lt;&lt; c.c &lt;&lt; &quot;}\n&quot;; C d = C{}; std::cout &lt;&lt; &quot;d = {&quot; &lt;&lt; d.a &lt;&lt; &#39; &#39; &lt;&lt; d.b &lt;&lt; &#39; &#39; &lt;&lt; d.c &lt;&lt; &quot;}\n&quot;; } /* a = {0 0 0} b = {-11906462 32551 1651076199} c = {32551 0 0} d = {0 0 0} */ We can see that neither S nor C has a constructor (only the default generated one). Yet, for a and d we see zero-initialization happening, while for b and c what we observe is undefined behaviour and some garbage values. The difference is that zero-initialization might happen as part of value initialization, which is clearly the case for a and d due to the usage of initializer sequences. On the other hand, for b and d, no initializer sequence is used and as such we are in the case of default-initialization which leaves the uninitialized members in an undefined state. Conclusion This week, we’ve discussed default-, value- and zero- initializations of objects. It’s important to keep in mind that relying on default-initialization might leave data in an undefined state but with zero/value initialization that will never happen. Next week, we’ll put the final pieces together and talk about constant and reference initialization. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/04/24/initializations-part-3" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/04/24/initializations-part-3" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-24T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="When and how variables are initialized? - Part 3" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-24T00:00:00+02:00","datePublished":"2024-04-24T00:00:00+02:00","description":"For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I maintained. While I was looking for an answer to what happened, I realized that there are not only default and value initializations in C++ but many more different forms. Today, we are going to cover, default-, zero- and value-initialization. Default-initialization This is performed when an object is constructed with no initializer sequence. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s1; std::cout &lt;&lt; &quot;s1.m_num: &quot; &lt;&lt; s1.m_num &lt;&lt; &quot;, s1.m_text: &quot; &lt;&lt; s1.m_text &lt;&lt; &#39;\\n&#39;; S* s2 = new S; std::cout &lt;&lt; &quot;s2-&gt;m_num: &quot; &lt;&lt; s2-&gt;m_num &lt;&lt; &quot;, s2-&gt;m_text: &quot; &lt;&lt; s2-&gt;m_text &lt;&lt; &#39;\\n&#39;; } As you can see, the initializer can be omitted both for variables with automatic and even with dynamic storage duration, but it also works for static and thread-local variables. There is yet another possibility when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called. That might be a bit complex explanation, so let’s look at some examples. 1 2 3 4 struct S { S() {}; std::string m_text; }; In the above piece of code, a non-static data member (m_text) is not mentioned in a constructor initializer list. So when we construct an instance of S, m_text is default initialized. Now let’s cover the other possibility when the base class is not mentioned in the constructor initializer-list. 1 2 3 4 5 6 7 8 9 struct Base { std::string m_base_text; }; struct Derived : Base { Derived() {}; int m_num; std::string m_text; }; For class types, default-initialization means that their default constructor would be invoked. For non-class types, the meaning of default-initialization depends on their storage duration. If their storage duration is automatic or dynamic, the value would be undefined. But if their storage duration is static or thread-local, then the variable gets zero-initialized. We’ll discuss what zero-initialization means just in a bit. It’s worth noting that references and const scalar objects cannot be default-initialized. The following types are scalar: arithmetic, enumeration, pointer and pointer-to-member types and all their cv-qualified versions, as well as std::nullptr_t. Value-initialization Now let’s talk about value-initialization! First of all, let’s see the syntax that would invoke it! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() : m_num{}, m_text() {} int m_num; std::string m_text; }; int main() { S s1{}; std::cout &lt;&lt; &quot;s1.m_num: &quot; &lt;&lt; s1.m_num &lt;&lt; &quot;, s1.m_text: &quot; &lt;&lt; s1.m_text &lt;&lt; &#39;\\n&#39;; S* s2 = new S(); std::cout &lt;&lt; &quot;s2-&gt;m_num: &quot; &lt;&lt; s2-&gt;m_num &lt;&lt; &quot;, s2-&gt;m_text: &quot; &lt;&lt; s2-&gt;m_text &lt;&lt; &#39;\\n&#39;; } What we can see is that both local variables, s1 and s2 are now followed by an empty initializer sequence, either () or {} can invoke value-initialization. Value-initialization is also invoked for non-static members when they are initialized in the member initializer list with an empty pair of parentheses or braces. But what are the effects? As always, the answer is “it depends”. If it’s a class type and it has an implicitly defined or defaulted constructor, zero-initialization will happen. Unless the default constructor is non-trivial, then default-initialization will happen. If it’s a class type and there is no default constructor, or it’s user-provided or even deleted, then we are in the case of default initialization. If it’s an array type, then for each element we get into a recursive loop as they are value initialized. If it’s a non-class type, the object is zero-initialized. In all cases, if the empty pair of braces ({}) is used and T is an aggregate type, aggregate-initialization is performed instead of value-initialization. If T is a class type that has no default constructor but has a constructor taking std::initializer_list, list-initialization is performed just as we saw last week. Zero-intialization By now, we can clearly see that initialization is a complex topic in C++. If you’re not convinced, the next phrase will probably change that: zero-initialization does not have a dedicated syntax, but it might happen in certain situations. But first of all, what is zero-initialization? It depends on the type. If T is a union type then padding bits are initialized to zero bits and the first non-static named data member is zero-initialized. For arrays, each element is zero-initialized and for reference types, nothing is done. So far so good, but what does really happen? If T is a non-union class type, then padding bits are initialized to zero bits, all non-static members are zero-initialized, all non-virtual base class subobjects are zero-initialized just like each virtual base class subobjects, unless T is also a base class subobject itself. If T is scalar, then the object is initialized to the value obtained by explicitly converting the integer literal 0 to T. So bool b would be false, int i 0, double d 0.0 and a char c would contain the null character (\\0). In the end, we are getting back to the fact that every type deep down is composed of built-in types and zero initialization will boil down to zero-initialize those. But when can it happen? For every named variable with static or thread-local storage duration that is not subject to constant initialization (another type of initialization!), before any other initialization. When an array of any character type is initialized with a string literal that is too short, the remainder of the array is zero-initialized. So the rest will contain \\0 characters. As part of the value-initialization sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of aggregates for which no initializers are provided. This last one might need an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; struct S { int a, b, c; }; class C { public: int a, b, c; }; int main() { S a = S(); // the effect is same as: A a{}; or A a = {}; std::cout &lt;&lt; &quot;a = {&quot; &lt;&lt; a.a &lt;&lt; &#39; &#39; &lt;&lt; a.b &lt;&lt; &#39; &#39; &lt;&lt; a.c &lt;&lt; &quot;}\\n&quot;; S b; // the effect is same as: A a{}; or A a = {}; std::cout &lt;&lt; &quot;b = {&quot; &lt;&lt; b.a &lt;&lt; &#39; &#39; &lt;&lt; b.b &lt;&lt; &#39; &#39; &lt;&lt; b.c &lt;&lt; &quot;}\\n&quot;; C c; std::cout &lt;&lt; &quot;c = {&quot; &lt;&lt; c.a &lt;&lt; &#39; &#39; &lt;&lt; c.b &lt;&lt; &#39; &#39; &lt;&lt; c.c &lt;&lt; &quot;}\\n&quot;; C d = C{}; std::cout &lt;&lt; &quot;d = {&quot; &lt;&lt; d.a &lt;&lt; &#39; &#39; &lt;&lt; d.b &lt;&lt; &#39; &#39; &lt;&lt; d.c &lt;&lt; &quot;}\\n&quot;; } /* a = {0 0 0} b = {-11906462 32551 1651076199} c = {32551 0 0} d = {0 0 0} */ We can see that neither S nor C has a constructor (only the default generated one). Yet, for a and d we see zero-initialization happening, while for b and c what we observe is undefined behaviour and some garbage values. The difference is that zero-initialization might happen as part of value initialization, which is clearly the case for a and d due to the usage of initializer sequences. On the other hand, for b and d, no initializer sequence is used and as such we are in the case of default-initialization which leaves the uninitialized members in an undefined state. Conclusion This week, we’ve discussed default-, value- and zero- initializations of objects. It’s important to keep in mind that relying on default-initialization might leave data in an undefined state but with zero/value initialization that will never happen. Next week, we’ll put the final pieces together and talk about constant and reference initialization. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"When and how variables are initialized? - Part 3","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/04/24/initializations-part-3"},"url":"https://www.sandordargo.com/blog/2024/04/24/initializations-part-3"}</script><title>When and how variables are initialized? - Part 3 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/24"> 24 </a> </span> <span>When and how variables are initialized? - Part 3</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>When and how variables are initialized? - Part 3</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 24, 2024, 12:00 AM +0200" prep="on" > Apr 24, 2024 <i class="unloaded">2024-04-24T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1363 words">7 min</span></div></div><div class="post-content"><p>For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by <a href="https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour">a bug I discovered after a compiler update</a> in a code base that I maintained. While I was looking for an answer to what happened, I realized that there are not only default and value initializations in C++ but many more different forms.</p><p>Today, we are going to cover, default-, zero- and value-initialization.</p><h2 id="default-initialization">Default-initialization</h2><p>This is performed when an object is constructed with no initializer sequence.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s1</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s1.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s1.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="n">S</span><span class="o">*</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s2-&gt;m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s2-&gt;m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, the initializer can be omitted both for variables with automatic and even with dynamic storage duration, but it also works for static and thread-local variables.</p><p>There is yet another possibility when a base class or a non-static data member is not mentioned in a constructor initializer list and that constructor is called. That might be a bit complex explanation, so let’s look at some examples.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In the above piece of code, a non-static data member (<code class="language-plaintext highlighter-rouge">m_text</code>) is not mentioned in a constructor initializer list. So when we construct an instance of <code class="language-plaintext highlighter-rouge">S</code>, <code class="language-plaintext highlighter-rouge">m_text</code> is default initialized.</p><p>Now let’s cover the other possibility when the base class is not mentioned in the constructor initializer-list.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_base_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="n">Derived</span><span class="p">()</span> <span class="p">{};</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>For class types, default-initialization means that their default constructor would be invoked.</p><p>For non-class types, the meaning of default-initialization depends on their storage duration. If their storage duration is automatic or dynamic, the value would be undefined. But if their storage duration is static or thread-local, then the variable gets zero-initialized. We’ll discuss what zero-initialization means just in a bit.</p><p>It’s worth noting that references and <code class="language-plaintext highlighter-rouge">const</code> scalar objects cannot be default-initialized.</p><blockquote><p>The following types are scalar: arithmetic, enumeration, pointer and pointer-to-member types and all their cv-qualified versions, as well as <code class="language-plaintext highlighter-rouge">std::nullptr_t</code>.</p></blockquote><h2 id="value-initialization">Value-initialization</h2><p>Now let’s talk about value-initialization! First of all, let’s see the syntax that would invoke it!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">:</span> <span class="n">m_num</span><span class="p">{},</span> <span class="n">m_text</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s1</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s1.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s1.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s1</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="n">S</span><span class="o">*</span> <span class="n">s2</span> <span class="o">=</span> <span class="k">new</span> <span class="nf">S</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s2-&gt;m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s2-&gt;m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s2</span><span class="o">-&gt;</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What we can see is that both local variables, <code class="language-plaintext highlighter-rouge">s1</code> and <code class="language-plaintext highlighter-rouge">s2</code> are now followed by an empty initializer sequence, either <code class="language-plaintext highlighter-rouge">()</code> or <code class="language-plaintext highlighter-rouge">{}</code> can invoke value-initialization.</p><p>Value-initialization is also invoked for non-static members when they are initialized in the member initializer list with an empty pair of parentheses or braces.</p><p>But what are the effects?</p><p>As always, the answer is <em>“it depends”</em>.</p><p>If it’s a class type and it has an implicitly defined or <code class="language-plaintext highlighter-rouge">default</code>ed constructor, zero-initialization will happen. Unless the default constructor is non-trivial, then default-initialization will happen.</p><p>If it’s a class type and there is no default constructor, or it’s user-provided or even deleted, then we are in the case of default initialization.</p><p>If it’s an array type, then for each element we get into a recursive loop as they are value initialized.</p><p>If it’s a non-class type, the object is zero-initialized.</p><p>In all cases, if the empty pair of braces (<code class="language-plaintext highlighter-rouge">{}</code>) is used and <code class="language-plaintext highlighter-rouge">T</code> is an aggregate type, aggregate-initialization is performed instead of value-initialization.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is a class type that has no default constructor but has a constructor taking <code class="language-plaintext highlighter-rouge">std::initializer_list</code>, list-initialization is performed just as we saw last week.</p><h2 id="zero-intialization">Zero-intialization</h2><p>By now, we can clearly see that initialization is a complex topic in C++. If you’re not convinced, the next phrase will probably change that: <em>zero-initialization does not have a dedicated syntax, but it might happen in certain situations</em>.</p><p>But first of all, what is zero-initialization?</p><p>It depends on the type.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is a union type then padding bits are initialized to zero bits and the first non-static named data member is zero-initialized.</p><p>For arrays, each element is zero-initialized and for reference types, nothing is done.</p><p>So far so good, but what does really happen?</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is a non-union class type, then padding bits are initialized to zero bits, all non-static members are zero-initialized, all non-virtual base class subobjects are zero-initialized just like each virtual base class subobjects, unless <code class="language-plaintext highlighter-rouge">T</code> is also a base class subobject itself.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is scalar, then the object is initialized to the value obtained by explicitly converting the integer literal <code class="language-plaintext highlighter-rouge">0</code> to <code class="language-plaintext highlighter-rouge">T</code>. So <code class="language-plaintext highlighter-rouge">bool b</code> would be false, <code class="language-plaintext highlighter-rouge">int i</code> 0, <code class="language-plaintext highlighter-rouge">double d</code> 0.0 and a <code class="language-plaintext highlighter-rouge">char c</code> would contain the null character (<code class="language-plaintext highlighter-rouge">\0</code>).</p><p>In the end, we are getting back to the fact that every type deep down is composed of built-in types and zero initialization will boil down to zero-initialize those.</p><p>But when can it happen?</p><ul><li>For every named variable with static or thread-local storage duration that is not subject to constant initialization (another type of initialization!), before any other initialization.<li>When an array of any character type is initialized with a string literal that is too short, the remainder of the array is zero-initialized. So the rest will contain <code class="language-plaintext highlighter-rouge">\0</code> characters.<li>As part of the value-initialization sequence for non-class types and for members of value-initialized class types that have no constructors, including value initialization of elements of aggregates for which no initializers are provided.</ul><p>This last one might need an example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">,</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">a</span> <span class="o">=</span> <span class="n">S</span><span class="p">();</span> <span class="c1">// the effect is same as: A a{}; or A a = {};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"a = {"</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">S</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// the effect is same as: A a{}; or A a = {};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"b = {"</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">b</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">C</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"c = {"</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>

    <span class="n">C</span> <span class="n">d</span> <span class="o">=</span> <span class="n">C</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"d = {"</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">"}</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
a = {0 0 0}
b = {-11906462 32551 1651076199}
c = {32551 0 0}
d = {0 0 0}
*/</span>
</pre></table></code></div></div><p>We can see that neither <code class="language-plaintext highlighter-rouge">S</code> nor <code class="language-plaintext highlighter-rouge">C</code> has a constructor (only the default generated one). Yet, for <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">d</code> we see zero-initialization happening, while for <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">c</code> what we observe is undefined behaviour and some garbage values.</p><p>The difference is that zero-initialization might happen as part of value initialization, which is clearly the case for <code class="language-plaintext highlighter-rouge">a</code> and <code class="language-plaintext highlighter-rouge">d</code> due to the usage of initializer sequences. On the other hand, for <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">d</code>, no initializer sequence is used and as such we are in the case of default-initialization which leaves the uninitialized members in an undefined state.</p><h2 id="conclusion">Conclusion</h2><p>This week, we’ve discussed default-, value- and zero- initializations of objects. It’s important to keep in mind that relying on default-initialization might leave data in an undefined state but with zero/value initialization that will never happen.</p><p>Next week, we’ll put the final pieces together and talk about constant and reference initialization.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/fundamental/" class="post-tag no-text-decoration" >fundamental</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/undefinedbehaviour/" class="post-tag no-text-decoration" >undefinedbehaviour</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=When and how variables are initialized? - Part 3 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/24/initializations-part-3" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=When and how variables are initialized? - Part 3 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/24/initializations-part-3" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=When and how variables are initialized? - Part 3 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/24/initializations-part-3" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=When and how variables are initialized? - Part 3 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/24/initializations-part-3" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div><div class="card"> <a href="/blog/2024/05/01/initializations-part-4"><div class="card-body"> <span class="timeago small" > May 1, 2024 <i class="unloaded">2024-05-01T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 4</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. In part 1, we covered th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/04/17/initializations-part-2" class="btn btn-outline-primary" prompt="Older"><p>When and how variables are initialized? - Part 2</p></a> <a href="/blog/2024/05/01/initializations-part-4" class="btn btn-outline-primary" prompt="Newer"><p>When and how variables are initialized? - Part 4</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'When and how variables are initialized? - Part 3'; this.page.url = 'https://www.sandordargo.com/blog/2024/04/24/initializations-part-3'; this.page.identifier = '/blog/2024/04/24/initializations-part-3'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
