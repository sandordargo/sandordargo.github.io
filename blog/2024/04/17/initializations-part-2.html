<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="When and how variables are initialized? - Part 2" /><meta property="og:locale" content="en_US" /><meta name="description" content="During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery with copy-initialization. This week, we continue this discovery with direct-, list- and aggregate-initialization. Direct-initalization Direct-initialization initializes an object from an explicit set of constructor arguments. Different syntaxes invoke direct initialization such as T object(&lt;at least one arg&gt;);, T(&lt;at least one arg&gt;); or new T(&lt;at least one arg&gt;); but it might also happen when you use curly braces (T object{oneArg};). Additional use cases are static casts, constructor initializer lists and values taken by value in lambda captures. While at first glance this might obvious there are some catches. Take this expression: T object{ arg };. In this case, object is directly initialized only if it’s a non-class type, otherwise, we talk about list-initialization. But if you use the parentheses syntax (T object(arg) then there is no such distinction between class and non-class types, in both cases, direct-initialization is performed. Also, T object{ arg1, arg2 }; would never be direct-initialized, that’s always an aggregate-initialization. In the expression [arg]() {}, the generated lambda members will not be copy-initialized, but they will be directly initialized. Another notable catch, or maybe better to say, a change introduced by C++17 is represented by the following snippet. Up until C++17, the following piece of code was ill-formed. 1 2 3 4 5 struct A { explicit A(int i = 0) {} }; A a[2](A(1)); But with C++20 it became valid and it initializes the first variable with A(1) and the second with A() - for elements without an initializer value-initialization is performed. With braces, it’s considered a list-initialization and it’s still invalid as it wouldn’t initialize all the array items. Direct initialization has quite a few small rules. What is worth noting is that since C++17 copy elision is guaranteed, there is no temporary object constructed when the initializer is a prvalue expression with the same type. The destination object is directly initialized. If the target is an aggregate class, it is initialized as it would happen with aggregate initialization except that it also accepts narrowing conversions and you cannot use designated initializers. Similarly to initializing an array, any elements without a value are value-initialized. For non-class types, all user-provided and standard conversion functions are examined and used if necessary. List-initialization First of all, list initialisation always involves braces. Not that we don’t have enough different kinds of initializations, we even have to separate two different kinds of list initializations. There is direct-list-initialization and copy-list-initialization. In general, we can talk about direct-list-initialization where there is no = between the object to be initialized and the opening brace (T object{arg1, arg2};) and copy-list-initialization when there is a = (T object = { arg1, arg2 };). Besides these cases, direct-list-initialization can happen when a possibly empty pair of braces follow T, new T or even member variables in the constructor-initializer-list. Further cases for copy-list-initialization involve also a possible empty pair of braces in function or constructor calls, return statements, subscript expressions ([{...}]) and the right side of assignments. There are a couple of different rules to consider if we want to understand what actually happens during a list-initialization. If T is an aggregate class, you don’t use designated initializers and there is one single parameter then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization. 1 2 3 4 5 6 7 8 9 10 struct Aggregate { int num; char c; }; int main() { Aggregate a{4, &#39;c&#39;}; // direct-list-initialization =&gt; direct-initialization Aggregate b = {4, &#39;c&#39;}; // copy-list-initialization =&gt; copy-initialization return 0; } Otherwise, if T is an aggregate type, aggregate-initialization is performed. If T is a char array and between the braces there is only a string literal the array will be initialization from the string literal. If the size of the array is not declared then the size of the literal + 1 for the \0 will be the size, otherwise, if the declared size is longer than the literal’s size + 1, the rest will be filled with \0 characters. If the literal is too long, the program is ill-formed. 1 2 3 4 5 6 7 int main() { char arr1[4] = {&quot;abc&quot;}; // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39; char arr2[5] = {&quot;abc&quot;}; // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39;, &#39;\0&#39; char arr3[] = {&quot;abc&quot;}; // arr3[4], &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39; // char arr4[3] = {&quot;abc&quot;}; // initializer is too long return 0; } If T is a class type and the braces are empty and T has a default constructor or T is non-class type, then value-initialization will be performed. If T is a specialization of std::ininitializer_list, then the brace-initializer-list is considered a std::initializer_list and each element will be copy-initialized from the list. If T has a constructor that takes only a std::initializer_list or it’s the first argument with others that have default values, those are considered first. If not, all other constructors are considered. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; #include &lt;vector&gt; class MyClass { public: MyClass(std::initializer_list&lt;int&gt; l): m_v(l) { std::cout &lt;&lt; &quot;MyClass::MyClass(std::initializer_list)\n&quot;; } MyClass(std::vector&lt;int&gt; l): m_v(l) { std::cout &lt;&lt; &quot;MyClass::MyClass(std::vector)\n&quot;; } private: std::vector&lt;int&gt; m_v; }; int main() { MyClass mc1{}; MyClass mc2{1, 2, 3}; MyClass mc3 = {1, 2, 3}; MyClass mc4 = std::vector{1, 2, 3}; MyClass mc5 {std::vector{1, 2, 3}}; return 0; } /* MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::vector) MyClass::MyClass(std::vector) */ If T is a non-class type and there is only one item between the braces then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization. It’s worth noting that narrowing conversion cannot happen with list-initialization. Aggregate-initialization Aggregate-initialization was mentioned several times while we discussed list-initialization, so let’s continue with that. It was introduced by C++11 as a form of list-initialization. It can happen only when braces are used as an initializer sequence. Since C++20, it might also include designated initializers. But what is aggregate? First of all, it might be an array type. Or it can also be a class type that adheres to a couple of requirements. An aggregate class cannot have any of the following (as of C++20): user-declared or inherited constructors private or protected direct non-static data members virtual base classes private or protected direct base classes virtual member functions If you use aggregate initialization, array elements will be initialized in subscript order and for classes, direct base classes and non-static data members will be initialized in declaration order. It’s worth noting that it’s possible to nest initializer lists, to initialize both an object and its member. Even though in many situations, the braces around the nested initializer list can be omitted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Foo { int i; int j; int a[3]; }; struct Bar { int x; Foo b; }; int main() { // These are the same initializations Bar s1 = {1, {2, 3, {4, 5, 6}}}; Bar s2 = {1, 2, 3, 4, 5, 6}; return 0; } When aggregate-initialisation is performed, you cannot pass more items than expected, it won’t compile. 1 2 3 4 5 6 7 8 9 10 11 struct Foo { int i; int j; int a[3]; }; int main() { // error: too many initializers for &#39;Foo&#39; Foo f = {1, 2, 3, 4, 5, 6}; return 0; } When aggregate initialization is performed of an object, on the items there will be either direct-, copy- or list-initialization performed. Conclusion After having discussed the importance of initializations two weeks ago and exploring the different initializer syntaxes and copy-initialization last week, we discussed 3 other kinds of initialization this week. We saw how direct initialization is used to initialize objets from its constructor arguments and then we deeped down into the world of brace initialization with list- and argument-initialization. TODO Next week, we are going to cover default-, value- and zero-initialization. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery with copy-initialization. This week, we continue this discovery with direct-, list- and aggregate-initialization. Direct-initalization Direct-initialization initializes an object from an explicit set of constructor arguments. Different syntaxes invoke direct initialization such as T object(&lt;at least one arg&gt;);, T(&lt;at least one arg&gt;); or new T(&lt;at least one arg&gt;); but it might also happen when you use curly braces (T object{oneArg};). Additional use cases are static casts, constructor initializer lists and values taken by value in lambda captures. While at first glance this might obvious there are some catches. Take this expression: T object{ arg };. In this case, object is directly initialized only if it’s a non-class type, otherwise, we talk about list-initialization. But if you use the parentheses syntax (T object(arg) then there is no such distinction between class and non-class types, in both cases, direct-initialization is performed. Also, T object{ arg1, arg2 }; would never be direct-initialized, that’s always an aggregate-initialization. In the expression [arg]() {}, the generated lambda members will not be copy-initialized, but they will be directly initialized. Another notable catch, or maybe better to say, a change introduced by C++17 is represented by the following snippet. Up until C++17, the following piece of code was ill-formed. 1 2 3 4 5 struct A { explicit A(int i = 0) {} }; A a[2](A(1)); But with C++20 it became valid and it initializes the first variable with A(1) and the second with A() - for elements without an initializer value-initialization is performed. With braces, it’s considered a list-initialization and it’s still invalid as it wouldn’t initialize all the array items. Direct initialization has quite a few small rules. What is worth noting is that since C++17 copy elision is guaranteed, there is no temporary object constructed when the initializer is a prvalue expression with the same type. The destination object is directly initialized. If the target is an aggregate class, it is initialized as it would happen with aggregate initialization except that it also accepts narrowing conversions and you cannot use designated initializers. Similarly to initializing an array, any elements without a value are value-initialized. For non-class types, all user-provided and standard conversion functions are examined and used if necessary. List-initialization First of all, list initialisation always involves braces. Not that we don’t have enough different kinds of initializations, we even have to separate two different kinds of list initializations. There is direct-list-initialization and copy-list-initialization. In general, we can talk about direct-list-initialization where there is no = between the object to be initialized and the opening brace (T object{arg1, arg2};) and copy-list-initialization when there is a = (T object = { arg1, arg2 };). Besides these cases, direct-list-initialization can happen when a possibly empty pair of braces follow T, new T or even member variables in the constructor-initializer-list. Further cases for copy-list-initialization involve also a possible empty pair of braces in function or constructor calls, return statements, subscript expressions ([{...}]) and the right side of assignments. There are a couple of different rules to consider if we want to understand what actually happens during a list-initialization. If T is an aggregate class, you don’t use designated initializers and there is one single parameter then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization. 1 2 3 4 5 6 7 8 9 10 struct Aggregate { int num; char c; }; int main() { Aggregate a{4, &#39;c&#39;}; // direct-list-initialization =&gt; direct-initialization Aggregate b = {4, &#39;c&#39;}; // copy-list-initialization =&gt; copy-initialization return 0; } Otherwise, if T is an aggregate type, aggregate-initialization is performed. If T is a char array and between the braces there is only a string literal the array will be initialization from the string literal. If the size of the array is not declared then the size of the literal + 1 for the \0 will be the size, otherwise, if the declared size is longer than the literal’s size + 1, the rest will be filled with \0 characters. If the literal is too long, the program is ill-formed. 1 2 3 4 5 6 7 int main() { char arr1[4] = {&quot;abc&quot;}; // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39; char arr2[5] = {&quot;abc&quot;}; // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39;, &#39;\0&#39; char arr3[] = {&quot;abc&quot;}; // arr3[4], &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\0&#39; // char arr4[3] = {&quot;abc&quot;}; // initializer is too long return 0; } If T is a class type and the braces are empty and T has a default constructor or T is non-class type, then value-initialization will be performed. If T is a specialization of std::ininitializer_list, then the brace-initializer-list is considered a std::initializer_list and each element will be copy-initialized from the list. If T has a constructor that takes only a std::initializer_list or it’s the first argument with others that have default values, those are considered first. If not, all other constructors are considered. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; #include &lt;vector&gt; class MyClass { public: MyClass(std::initializer_list&lt;int&gt; l): m_v(l) { std::cout &lt;&lt; &quot;MyClass::MyClass(std::initializer_list)\n&quot;; } MyClass(std::vector&lt;int&gt; l): m_v(l) { std::cout &lt;&lt; &quot;MyClass::MyClass(std::vector)\n&quot;; } private: std::vector&lt;int&gt; m_v; }; int main() { MyClass mc1{}; MyClass mc2{1, 2, 3}; MyClass mc3 = {1, 2, 3}; MyClass mc4 = std::vector{1, 2, 3}; MyClass mc5 {std::vector{1, 2, 3}}; return 0; } /* MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::vector) MyClass::MyClass(std::vector) */ If T is a non-class type and there is only one item between the braces then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization. It’s worth noting that narrowing conversion cannot happen with list-initialization. Aggregate-initialization Aggregate-initialization was mentioned several times while we discussed list-initialization, so let’s continue with that. It was introduced by C++11 as a form of list-initialization. It can happen only when braces are used as an initializer sequence. Since C++20, it might also include designated initializers. But what is aggregate? First of all, it might be an array type. Or it can also be a class type that adheres to a couple of requirements. An aggregate class cannot have any of the following (as of C++20): user-declared or inherited constructors private or protected direct non-static data members virtual base classes private or protected direct base classes virtual member functions If you use aggregate initialization, array elements will be initialized in subscript order and for classes, direct base classes and non-static data members will be initialized in declaration order. It’s worth noting that it’s possible to nest initializer lists, to initialize both an object and its member. Even though in many situations, the braces around the nested initializer list can be omitted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Foo { int i; int j; int a[3]; }; struct Bar { int x; Foo b; }; int main() { // These are the same initializations Bar s1 = {1, {2, 3, {4, 5, 6}}}; Bar s2 = {1, 2, 3, 4, 5, 6}; return 0; } When aggregate-initialisation is performed, you cannot pass more items than expected, it won’t compile. 1 2 3 4 5 6 7 8 9 10 11 struct Foo { int i; int j; int a[3]; }; int main() { // error: too many initializers for &#39;Foo&#39; Foo f = {1, 2, 3, 4, 5, 6}; return 0; } When aggregate initialization is performed of an object, on the items there will be either direct-, copy- or list-initialization performed. Conclusion After having discussed the importance of initializations two weeks ago and exploring the different initializer syntaxes and copy-initialization last week, we discussed 3 other kinds of initialization this week. We saw how direct initialization is used to initialize objets from its constructor arguments and then we deeped down into the world of brace initialization with list- and argument-initialization. TODO Next week, we are going to cover default-, value- and zero-initialization. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/04/17/initializations-part-2" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/04/17/initializations-part-2" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-04-17T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="When and how variables are initialized? - Part 2" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-17T00:00:00+02:00","datePublished":"2024-04-17T00:00:00+02:00","description":"During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery with copy-initialization. This week, we continue this discovery with direct-, list- and aggregate-initialization. Direct-initalization Direct-initialization initializes an object from an explicit set of constructor arguments. Different syntaxes invoke direct initialization such as T object(&lt;at least one arg&gt;);, T(&lt;at least one arg&gt;); or new T(&lt;at least one arg&gt;); but it might also happen when you use curly braces (T object{oneArg};). Additional use cases are static casts, constructor initializer lists and values taken by value in lambda captures. While at first glance this might obvious there are some catches. Take this expression: T object{ arg };. In this case, object is directly initialized only if it’s a non-class type, otherwise, we talk about list-initialization. But if you use the parentheses syntax (T object(arg) then there is no such distinction between class and non-class types, in both cases, direct-initialization is performed. Also, T object{ arg1, arg2 }; would never be direct-initialized, that’s always an aggregate-initialization. In the expression [arg]() {}, the generated lambda members will not be copy-initialized, but they will be directly initialized. Another notable catch, or maybe better to say, a change introduced by C++17 is represented by the following snippet. Up until C++17, the following piece of code was ill-formed. 1 2 3 4 5 struct A { explicit A(int i = 0) {} }; A a[2](A(1)); But with C++20 it became valid and it initializes the first variable with A(1) and the second with A() - for elements without an initializer value-initialization is performed. With braces, it’s considered a list-initialization and it’s still invalid as it wouldn’t initialize all the array items. Direct initialization has quite a few small rules. What is worth noting is that since C++17 copy elision is guaranteed, there is no temporary object constructed when the initializer is a prvalue expression with the same type. The destination object is directly initialized. If the target is an aggregate class, it is initialized as it would happen with aggregate initialization except that it also accepts narrowing conversions and you cannot use designated initializers. Similarly to initializing an array, any elements without a value are value-initialized. For non-class types, all user-provided and standard conversion functions are examined and used if necessary. List-initialization First of all, list initialisation always involves braces. Not that we don’t have enough different kinds of initializations, we even have to separate two different kinds of list initializations. There is direct-list-initialization and copy-list-initialization. In general, we can talk about direct-list-initialization where there is no = between the object to be initialized and the opening brace (T object{arg1, arg2};) and copy-list-initialization when there is a = (T object = { arg1, arg2 };). Besides these cases, direct-list-initialization can happen when a possibly empty pair of braces follow T, new T or even member variables in the constructor-initializer-list. Further cases for copy-list-initialization involve also a possible empty pair of braces in function or constructor calls, return statements, subscript expressions ([{...}]) and the right side of assignments. There are a couple of different rules to consider if we want to understand what actually happens during a list-initialization. If T is an aggregate class, you don’t use designated initializers and there is one single parameter then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization. 1 2 3 4 5 6 7 8 9 10 struct Aggregate { int num; char c; }; int main() { Aggregate a{4, &#39;c&#39;}; // direct-list-initialization =&gt; direct-initialization Aggregate b = {4, &#39;c&#39;}; // copy-list-initialization =&gt; copy-initialization return 0; } Otherwise, if T is an aggregate type, aggregate-initialization is performed. If T is a char array and between the braces there is only a string literal the array will be initialization from the string literal. If the size of the array is not declared then the size of the literal + 1 for the \\0 will be the size, otherwise, if the declared size is longer than the literal’s size + 1, the rest will be filled with \\0 characters. If the literal is too long, the program is ill-formed. 1 2 3 4 5 6 7 int main() { char arr1[4] = {&quot;abc&quot;}; // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\\0&#39; char arr2[5] = {&quot;abc&quot;}; // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\\0&#39;, &#39;\\0&#39; char arr3[] = {&quot;abc&quot;}; // arr3[4], &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;\\0&#39; // char arr4[3] = {&quot;abc&quot;}; // initializer is too long return 0; } If T is a class type and the braces are empty and T has a default constructor or T is non-class type, then value-initialization will be performed. If T is a specialization of std::ininitializer_list, then the brace-initializer-list is considered a std::initializer_list and each element will be copy-initialized from the list. If T has a constructor that takes only a std::initializer_list or it’s the first argument with others that have default values, those are considered first. If not, all other constructors are considered. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;iostream&gt; #include &lt;vector&gt; class MyClass { public: MyClass(std::initializer_list&lt;int&gt; l): m_v(l) { std::cout &lt;&lt; &quot;MyClass::MyClass(std::initializer_list)\\n&quot;; } MyClass(std::vector&lt;int&gt; l): m_v(l) { std::cout &lt;&lt; &quot;MyClass::MyClass(std::vector)\\n&quot;; } private: std::vector&lt;int&gt; m_v; }; int main() { MyClass mc1{}; MyClass mc2{1, 2, 3}; MyClass mc3 = {1, 2, 3}; MyClass mc4 = std::vector{1, 2, 3}; MyClass mc5 {std::vector{1, 2, 3}}; return 0; } /* MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::initializer_list) MyClass::MyClass(std::vector) MyClass::MyClass(std::vector) */ If T is a non-class type and there is only one item between the braces then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization. It’s worth noting that narrowing conversion cannot happen with list-initialization. Aggregate-initialization Aggregate-initialization was mentioned several times while we discussed list-initialization, so let’s continue with that. It was introduced by C++11 as a form of list-initialization. It can happen only when braces are used as an initializer sequence. Since C++20, it might also include designated initializers. But what is aggregate? First of all, it might be an array type. Or it can also be a class type that adheres to a couple of requirements. An aggregate class cannot have any of the following (as of C++20): user-declared or inherited constructors private or protected direct non-static data members virtual base classes private or protected direct base classes virtual member functions If you use aggregate initialization, array elements will be initialized in subscript order and for classes, direct base classes and non-static data members will be initialized in declaration order. It’s worth noting that it’s possible to nest initializer lists, to initialize both an object and its member. Even though in many situations, the braces around the nested initializer list can be omitted. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 struct Foo { int i; int j; int a[3]; }; struct Bar { int x; Foo b; }; int main() { // These are the same initializations Bar s1 = {1, {2, 3, {4, 5, 6}}}; Bar s2 = {1, 2, 3, 4, 5, 6}; return 0; } When aggregate-initialisation is performed, you cannot pass more items than expected, it won’t compile. 1 2 3 4 5 6 7 8 9 10 11 struct Foo { int i; int j; int a[3]; }; int main() { // error: too many initializers for &#39;Foo&#39; Foo f = {1, 2, 3, 4, 5, 6}; return 0; } When aggregate initialization is performed of an object, on the items there will be either direct-, copy- or list-initialization performed. Conclusion After having discussed the importance of initializations two weeks ago and exploring the different initializer syntaxes and copy-initialization last week, we discussed 3 other kinds of initialization this week. We saw how direct initialization is used to initialize objets from its constructor arguments and then we deeped down into the world of brace initialization with list- and argument-initialization. TODO Next week, we are going to cover default-, value- and zero-initialization. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"When and how variables are initialized? - Part 2","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/04/17/initializations-part-2"},"url":"https://www.sandordargo.com/blog/2024/04/17/initializations-part-2"}</script><title>When and how variables are initialized? - Part 2 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/17"> 17 </a> </span> <span>When and how variables are initialized? - Part 2</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>When and how variables are initialized? - Part 2</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 17, 2024, 12:00 AM +0200" prep="on" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1386 words">7 min</span></div></div><div class="post-content"><p>During the last two weeks, we saw <a href="https://www.sandordargo.com/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour">a bug related to uninitialized values and undefined behaviour</a>, <a href="https://www.sandordargo.com/blog/2024/04/10/initializations-part-1">we listed the different kinds of initializations in C++ and we started to more detailed discovery with copy-initialization</a>.</p><p>This week, we continue this discovery with direct-, list- and aggregate-initialization.</p><h2 id="direct-initalization">Direct-initalization</h2><p>Direct-initialization initializes an object from an explicit set of constructor arguments. Different syntaxes invoke direct initialization such as <code class="language-plaintext highlighter-rouge">T object(&lt;at least one arg&gt;);</code>, <code class="language-plaintext highlighter-rouge">T(&lt;at least one arg&gt;);</code> or <code class="language-plaintext highlighter-rouge">new T(&lt;at least one arg&gt;);</code> but it might also happen when you use curly braces (<code class="language-plaintext highlighter-rouge">T object{oneArg};</code>). Additional use cases are static casts, constructor initializer lists and values taken by value in lambda captures.</p><p>While at first glance this might obvious there are some catches.</p><p>Take this expression: <code class="language-plaintext highlighter-rouge">T object{ arg };</code>. In this case, <code class="language-plaintext highlighter-rouge">object</code> is directly initialized only if it’s a non-class type, otherwise, we talk about list-initialization. But if you use the parentheses syntax (<code class="language-plaintext highlighter-rouge">T object(arg)</code> then there is no such distinction between class and non-class types, in both cases, direct-initialization is performed. Also, <code class="language-plaintext highlighter-rouge">T object{ arg1, arg2 };</code> would never be direct-initialized, that’s always an aggregate-initialization.</p><p>In the expression <code class="language-plaintext highlighter-rouge">[arg]() {}</code>, the generated lambda members will not be copy-initialized, but they will be directly initialized.</p><p>Another notable catch, or maybe better to say, a change introduced by C++17 is represented by the following snippet. Up until C++17, the following piece of code was ill-formed.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">A</span> <span class="p">{</span>
    <span class="k">explicit</span> <span class="n">A</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="n">A</span> <span class="n">a</span><span class="p">[</span><span class="mi">2</span><span class="p">](</span><span class="n">A</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
</pre></table></code></div></div><p>But with C++20 it became valid and it initializes the first variable with <code class="language-plaintext highlighter-rouge">A(1)</code> and the second with <code class="language-plaintext highlighter-rouge">A()</code> - for elements without an initializer <em>value-initialization</em> is performed. With braces, it’s considered a list-initialization and it’s still invalid as it wouldn’t initialize all the array items.</p><p>Direct initialization has quite a few small rules. What is worth noting is that since C++17 copy elision is guaranteed, there is no temporary object constructed when the initializer is a <em>prvalue</em> expression with the same type. The destination object is directly initialized.</p><p>If the target is an aggregate class, it is initialized as it would happen with aggregate initialization except that it also accepts narrowing conversions and you cannot use designated initializers. Similarly to initializing an array, any elements without a value are value-initialized.</p><p>For non-class types, all user-provided and standard conversion functions are examined and used if necessary.</p><h2 id="list-initialization">List-initialization</h2><p>First of all, list initialisation always involves braces.</p><p>Not that we don’t have enough different kinds of initializations, we even have to separate two different kinds of list initializations. There is direct-list-initialization and copy-list-initialization.</p><p>In general, we can talk about direct-list-initialization where there is no <code class="language-plaintext highlighter-rouge">=</code> between the object to be initialized and the opening brace (<code class="language-plaintext highlighter-rouge">T object{arg1, arg2}</code>;) and copy-list-initialization when there is a <code class="language-plaintext highlighter-rouge">=</code> (<code class="language-plaintext highlighter-rouge">T object = { arg1, arg2 }</code>;).</p><p>Besides these cases, direct-list-initialization can happen when a possibly empty pair of braces follow <code class="language-plaintext highlighter-rouge">T</code>, <code class="language-plaintext highlighter-rouge">new T</code> or even member variables in the constructor-initializer-list.</p><p>Further cases for copy-list-initialization involve also a possible empty pair of braces in function or constructor calls, return statements, subscript expressions (<code class="language-plaintext highlighter-rouge">[{...}]</code>) and the right side of assignments.</p><p>There are a couple of different rules to consider if we want to understand what actually happens during a list-initialization.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is an aggregate class, you don’t use designated initializers and there is one single parameter then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Aggregate</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">num</span><span class="p">;</span>
    <span class="kt">char</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Aggregate</span> <span class="n">a</span><span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">};</span> <span class="c1">// direct-list-initialization =&gt; direct-initialization</span>
    <span class="n">Aggregate</span> <span class="n">b</span> <span class="o">=</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">};</span> <span class="c1">// copy-list-initialization =&gt; copy-initialization </span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Otherwise, if <code class="language-plaintext highlighter-rouge">T</code> is an aggregate type, aggregate-initialization is performed.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is a <code class="language-plaintext highlighter-rouge">char</code> array and between the braces there is only a string literal the array will be initialization from the string literal. If the size of the array is not declared then the size of the literal + 1 for the <code class="language-plaintext highlighter-rouge">\0</code> will be the size, otherwise, if the declared size is longer than the literal’s size + 1, the rest will be filled with <code class="language-plaintext highlighter-rouge">\0</code> characters. If the literal is too long, the program is ill-formed.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">arr1</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">};</span> <span class="c1">// 'a', 'b', 'c', '\0'</span>
    <span class="kt">char</span> <span class="n">arr2</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">};</span> <span class="c1">// 'a', 'b', 'c', '\0', '\0'</span>
    <span class="kt">char</span> <span class="n">arr3</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="s">"abc"</span><span class="p">};</span> <span class="c1">// arr3[4], 'a', 'b', 'c', '\0'</span>
    <span class="c1">// char arr4[3] = {"abc"}; // initializer is too long</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If <code class="language-plaintext highlighter-rouge">T</code> is a class type and the braces are empty and <code class="language-plaintext highlighter-rouge">T</code> has a default constructor or T is non-class type, then value-initialization will be performed.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> is a specialization of <code class="language-plaintext highlighter-rouge">std::ininitializer_list</code>, then the brace-initializer-list is considered a <code class="language-plaintext highlighter-rouge">std::initializer_list</code> and each element will be copy-initialized from the list.</p><p>If <code class="language-plaintext highlighter-rouge">T</code> has a constructor that takes only a <code class="language-plaintext highlighter-rouge">std::initializer_list</code> or it’s the first argument with others that have default values, those are considered first. If not, all other constructors are considered.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">MyClass</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">MyClass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span><span class="o">:</span> <span class="n">m_v</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass::MyClass(std::initializer_list)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">MyClass</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">l</span><span class="p">)</span><span class="o">:</span> <span class="n">m_v</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"MyClass::MyClass(std::vector)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">m_v</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MyClass</span> <span class="n">mc1</span><span class="p">{};</span>
  <span class="n">MyClass</span> <span class="n">mc2</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">MyClass</span> <span class="n">mc3</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">MyClass</span> <span class="n">mc4</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
  <span class="n">MyClass</span> <span class="n">mc5</span> <span class="p">{</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
MyClass::MyClass(std::initializer_list)
MyClass::MyClass(std::initializer_list)
MyClass::MyClass(std::initializer_list)
MyClass::MyClass(std::vector)
MyClass::MyClass(std::vector)
*/</span>
</pre></table></code></div></div><p>If <code class="language-plaintext highlighter-rouge">T</code> is a non-class type and there is only one item between the braces then either copy-initialization or direct-initialization will be performed depending on whether you’re in the case of copy-list-initialization or direct-list-initialization.</p><p>It’s worth noting that narrowing conversion cannot happen with list-initialization.</p><h2 id="aggregate-initialization">Aggregate-initialization</h2><p>Aggregate-initialization was mentioned several times while we discussed list-initialization, so let’s continue with that. It was introduced by C++11 as a form of list-initialization. It can happen only when braces are used as an initializer sequence. Since C++20, it might also include designated initializers.</p><p>But what is aggregate?</p><p>First of all, it might be an array type.</p><p>Or it can also be a class type that adheres to a couple of requirements. An aggregate class cannot have any of the following (as of C++20):</p><ul><li>user-declared or inherited constructors<li>private or protected direct non-static data members<li>virtual base classes<li>private or protected direct base classes<li>virtual member functions</ul><p>If you use aggregate initialization, array elements will be initialized in subscript order and for classes, direct base classes and non-static data members will be initialized in declaration order.</p><p>It’s worth noting that it’s possible to nest initializer lists, to initialize both an object and its member. Even though in many situations, the braces around the nested initializer list can be omitted.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>
<span class="k">struct</span> <span class="nc">Bar</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">Foo</span> <span class="n">b</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// These are the same initializations</span>
    <span class="n">Bar</span> <span class="n">s1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="p">{</span><span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}}};</span>
    <span class="n">Bar</span> <span class="n">s2</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>When aggregate-initialisation is performed, you cannot pass more items than expected, it won’t compile.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">];</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// error: too many initializers for 'Foo'</span>
    <span class="n">Foo</span> <span class="n">f</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">};</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>When aggregate initialization is performed of an object, on the items there will be either direct-, copy- or list-initialization performed.</p><h2 id="conclusion">Conclusion</h2><p>After having discussed the importance of initializations two weeks ago and exploring the different initializer syntaxes and copy-initialization last week, we discussed 3 other kinds of initialization this week.</p><p>We saw how direct initialization is used to initialize objets from its constructor arguments and then we deeped down into the world of brace initialization with list- and argument-initialization.</p><p>TODO Next week, we are going to cover default-, value- and zero-initialization.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/fundamental/" class="post-tag no-text-decoration" >fundamental</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/undefinedbehaviour/" class="post-tag no-text-decoration" >undefinedbehaviour</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=When and how variables are initialized? - Part 2 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/17/initializations-part-2" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=When and how variables are initialized? - Part 2 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/17/initializations-part-2" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=When and how variables are initialized? - Part 2 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/04/17/initializations-part-2" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=When and how variables are initialized? - Part 2 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/04/17/initializations-part-2" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/24/initializations-part-3"><div class="card-body"> <span class="timeago small" > Apr 24, 2024 <i class="unloaded">2024-04-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 3</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I ma...</p></div></div></a></div><div class="card"> <a href="/blog/2024/05/01/initializations-part-4"><div class="card-body"> <span class="timeago small" > May 1, 2024 <i class="unloaded">2024-05-01T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 4</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. In part 1, we covered th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/04/10/initializations-part-1" class="btn btn-outline-primary" prompt="Older"><p>When and how variables are initialized? - Part 1</p></a> <a href="/blog/2024/04/24/initializations-part-3" class="btn btn-outline-primary" prompt="Newer"><p>When and how variables are initialized? - Part 3</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'When and how variables are initialized? - Part 2'; this.page.url = 'https://www.sandordargo.com/blog/2024/04/17/initializations-part-2'; this.page.identifier = '/blog/2024/04/17/initializations-part-2'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
