<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="What is std::ref?" /><meta property="og:locale" content="en_US" /><meta name="description" content="Have you heard about std::ref and std::cref? The helper functions that generate objects of type std::reference_wrapper? The answer is probably yes. In that case, this article is probably not for you. But if you haven’t heard about them, or the only usage of std::reference_wrapper you faced was storing references in a vector, then probably it’s worth reading on. This article is inspired by some failing tests that needed me to use std::ref in order to pass them. What does reference_wrapper do? A reference of an object T (T&amp;) is not copy assignable. On the other hand, std::reference_wrapper&lt;T&gt; which emulates T&amp; it both copy-constructible and copy-assignable. It’s even trivially copyable, so copying can take place on a byte level which makes it very efficient. So when should we use such a wrapper? Store references in a container If you ever wanted to store references in a vector, you probably know that this wouldn’t compile. 1 2 // This doesn&#39;t compile std::vector&lt;std::string&amp;&gt; v; Originally, the root cause was that a reference is not assignable. Once a reference is initialized, it cannot be modified to refer to another object. (Pointers can do that.) Therefore you cannot store const objects either, as they are not reassignable either. 1 2 // This doesn&#39;t compile either std::vector&lt;const std::string&gt; v; While the above is still not possible, the rules changed a bit since C++11 and it’s not mainly about copy assignability, but it’s about (not) being erasable. Erasable means that the following expression is well formed: 1 allocator_traits&lt;A&gt;::destroy(m, p) Where A is the container’s allocator type, m is an allocator instance and p is a pointer of type *T. See here for Erasable definition. By default, std::allocator&lt;T&gt; is used as vector’s allocator. With the default allocator, the requirement is equivalent to the validity of p-&gt;~T() (Note that T is a reference type and p is pointer to a reference). However, a pointer to a reference is illegal, hence the expression is not well formed. On the other hand, a pointer to an instance of std::reference_wrapper is valid and we can store references in a container like this: 1 2 3 4 5 6 std::string s1{&quot;Hello&quot;}; std::string s2{&quot;,&quot;}; std::string s3{&quot;World!&quot;}; std::vector&lt;std::reference_wrapper&lt;std::string&gt;&gt; v { std::ref(s1), std::ref(s2), std::ref(s3) }; Pass references to some standard template functions But std::ref and std::cref doesn’t only come in handy with containers. They are also very useful when you need to pass a reference to std::bind, to the constructor of std::thread or to some standard helper functions such as std::make_pair. The common characteristic of them is that even if you pass references to them, they will remove those/decay those references and they will either move or copy what you passed in. Therefore if you really want to do as if you passed in a reference, use a reference wrapper! Let’s have a simple example of how std::ref/std::cref makes a difference in such scenarios! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;functional&gt; #include &lt;iostream&gt; void f(int&amp; p1, int&amp; p2, const int&amp; p3) { std::cout &lt;&lt; &quot;In function: &quot; &lt;&lt; p1 &lt;&lt; &#39; &#39; &lt;&lt; p2 &lt;&lt; &#39; &#39; &lt;&lt; p3 &lt;&lt; &#39;\n&#39;; ++p1; // increments the copy of n1 stored in the function object ++p2; // increments the main()&#39;s n2 // ++p3; // compile error } int main() { int n1 = 1, n2 = 2, n3 = 3; std::function&lt;void()&gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &lt;&lt; &quot;Before calling f() directly: &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; f(n1, n2, n3); std::cout &lt;&lt; &quot;After calling f() directly: &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;==================\n&quot;; std::cout &lt;&lt; &quot;Before calling bound_f(): &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; bound_f(); bound_f(); std::cout &lt;&lt; &quot;After calling bound_f(): &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; } In this example, f() takes all the integers by reference. The third one is also const. If we call f() directly, we get the desired behaviour, n1 and n2 are “permanently” modified. On the other hand, the behaviour is different when we invoke f() with the help of std::function. When we don’t use std::ref or std::cref to bind the arguments, they are simply copied. That’s why even though n1 is seemingly passed as a reference, in bound_f, p1 still has the value it had when the binding was made. Likewise, it doesn’t increase the value of n1. But if we call bound_f() the second time, we can see that p1’s value has changed. What that means is that std::function holds on a copy of n1 and that is updated between the calls. If we want p1 to be an actual reference of n1, we must pass it with the help of std::ref, just as we did it for n2/p2 and for n3/p3. Conclusion std::ref and std::cref are helper functions to std::reference_wrapper objects. With the help of these constructs, you can store references in standard containers. You can also pass references to templates and various helper functions such std::bind, std::thread or std::make_pair. Without using them, your code will seemingly work, but instead of taking references, copies might be made. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Have you heard about std::ref and std::cref? The helper functions that generate objects of type std::reference_wrapper? The answer is probably yes. In that case, this article is probably not for you. But if you haven’t heard about them, or the only usage of std::reference_wrapper you faced was storing references in a vector, then probably it’s worth reading on. This article is inspired by some failing tests that needed me to use std::ref in order to pass them. What does reference_wrapper do? A reference of an object T (T&amp;) is not copy assignable. On the other hand, std::reference_wrapper&lt;T&gt; which emulates T&amp; it both copy-constructible and copy-assignable. It’s even trivially copyable, so copying can take place on a byte level which makes it very efficient. So when should we use such a wrapper? Store references in a container If you ever wanted to store references in a vector, you probably know that this wouldn’t compile. 1 2 // This doesn&#39;t compile std::vector&lt;std::string&amp;&gt; v; Originally, the root cause was that a reference is not assignable. Once a reference is initialized, it cannot be modified to refer to another object. (Pointers can do that.) Therefore you cannot store const objects either, as they are not reassignable either. 1 2 // This doesn&#39;t compile either std::vector&lt;const std::string&gt; v; While the above is still not possible, the rules changed a bit since C++11 and it’s not mainly about copy assignability, but it’s about (not) being erasable. Erasable means that the following expression is well formed: 1 allocator_traits&lt;A&gt;::destroy(m, p) Where A is the container’s allocator type, m is an allocator instance and p is a pointer of type *T. See here for Erasable definition. By default, std::allocator&lt;T&gt; is used as vector’s allocator. With the default allocator, the requirement is equivalent to the validity of p-&gt;~T() (Note that T is a reference type and p is pointer to a reference). However, a pointer to a reference is illegal, hence the expression is not well formed. On the other hand, a pointer to an instance of std::reference_wrapper is valid and we can store references in a container like this: 1 2 3 4 5 6 std::string s1{&quot;Hello&quot;}; std::string s2{&quot;,&quot;}; std::string s3{&quot;World!&quot;}; std::vector&lt;std::reference_wrapper&lt;std::string&gt;&gt; v { std::ref(s1), std::ref(s2), std::ref(s3) }; Pass references to some standard template functions But std::ref and std::cref doesn’t only come in handy with containers. They are also very useful when you need to pass a reference to std::bind, to the constructor of std::thread or to some standard helper functions such as std::make_pair. The common characteristic of them is that even if you pass references to them, they will remove those/decay those references and they will either move or copy what you passed in. Therefore if you really want to do as if you passed in a reference, use a reference wrapper! Let’s have a simple example of how std::ref/std::cref makes a difference in such scenarios! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;functional&gt; #include &lt;iostream&gt; void f(int&amp; p1, int&amp; p2, const int&amp; p3) { std::cout &lt;&lt; &quot;In function: &quot; &lt;&lt; p1 &lt;&lt; &#39; &#39; &lt;&lt; p2 &lt;&lt; &#39; &#39; &lt;&lt; p3 &lt;&lt; &#39;\n&#39;; ++p1; // increments the copy of n1 stored in the function object ++p2; // increments the main()&#39;s n2 // ++p3; // compile error } int main() { int n1 = 1, n2 = 2, n3 = 3; std::function&lt;void()&gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &lt;&lt; &quot;Before calling f() directly: &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; f(n1, n2, n3); std::cout &lt;&lt; &quot;After calling f() directly: &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;==================\n&quot;; std::cout &lt;&lt; &quot;Before calling bound_f(): &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; bound_f(); bound_f(); std::cout &lt;&lt; &quot;After calling bound_f(): &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\n&#39;; } In this example, f() takes all the integers by reference. The third one is also const. If we call f() directly, we get the desired behaviour, n1 and n2 are “permanently” modified. On the other hand, the behaviour is different when we invoke f() with the help of std::function. When we don’t use std::ref or std::cref to bind the arguments, they are simply copied. That’s why even though n1 is seemingly passed as a reference, in bound_f, p1 still has the value it had when the binding was made. Likewise, it doesn’t increase the value of n1. But if we call bound_f() the second time, we can see that p1’s value has changed. What that means is that std::function holds on a copy of n1 and that is updated between the calls. If we want p1 to be an actual reference of n1, we must pass it with the help of std::ref, just as we did it for n2/p2 and for n3/p3. Conclusion std::ref and std::cref are helper functions to std::reference_wrapper objects. With the help of these constructs, you can store references in standard containers. You can also pass references to templates and various helper functions such std::bind, std::thread or std::make_pair. Without using them, your code will seemingly work, but instead of taking references, copies might be made. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/08/21/std-ref" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/08/21/std-ref" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-08-21T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="What is std::ref?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-08-21T00:00:00+02:00","datePublished":"2024-08-21T00:00:00+02:00","description":"Have you heard about std::ref and std::cref? The helper functions that generate objects of type std::reference_wrapper? The answer is probably yes. In that case, this article is probably not for you. But if you haven’t heard about them, or the only usage of std::reference_wrapper you faced was storing references in a vector, then probably it’s worth reading on. This article is inspired by some failing tests that needed me to use std::ref in order to pass them. What does reference_wrapper do? A reference of an object T (T&amp;) is not copy assignable. On the other hand, std::reference_wrapper&lt;T&gt; which emulates T&amp; it both copy-constructible and copy-assignable. It’s even trivially copyable, so copying can take place on a byte level which makes it very efficient. So when should we use such a wrapper? Store references in a container If you ever wanted to store references in a vector, you probably know that this wouldn’t compile. 1 2 // This doesn&#39;t compile std::vector&lt;std::string&amp;&gt; v; Originally, the root cause was that a reference is not assignable. Once a reference is initialized, it cannot be modified to refer to another object. (Pointers can do that.) Therefore you cannot store const objects either, as they are not reassignable either. 1 2 // This doesn&#39;t compile either std::vector&lt;const std::string&gt; v; While the above is still not possible, the rules changed a bit since C++11 and it’s not mainly about copy assignability, but it’s about (not) being erasable. Erasable means that the following expression is well formed: 1 allocator_traits&lt;A&gt;::destroy(m, p) Where A is the container’s allocator type, m is an allocator instance and p is a pointer of type *T. See here for Erasable definition. By default, std::allocator&lt;T&gt; is used as vector’s allocator. With the default allocator, the requirement is equivalent to the validity of p-&gt;~T() (Note that T is a reference type and p is pointer to a reference). However, a pointer to a reference is illegal, hence the expression is not well formed. On the other hand, a pointer to an instance of std::reference_wrapper is valid and we can store references in a container like this: 1 2 3 4 5 6 std::string s1{&quot;Hello&quot;}; std::string s2{&quot;,&quot;}; std::string s3{&quot;World!&quot;}; std::vector&lt;std::reference_wrapper&lt;std::string&gt;&gt; v { std::ref(s1), std::ref(s2), std::ref(s3) }; Pass references to some standard template functions But std::ref and std::cref doesn’t only come in handy with containers. They are also very useful when you need to pass a reference to std::bind, to the constructor of std::thread or to some standard helper functions such as std::make_pair. The common characteristic of them is that even if you pass references to them, they will remove those/decay those references and they will either move or copy what you passed in. Therefore if you really want to do as if you passed in a reference, use a reference wrapper! Let’s have a simple example of how std::ref/std::cref makes a difference in such scenarios! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;functional&gt; #include &lt;iostream&gt; void f(int&amp; p1, int&amp; p2, const int&amp; p3) { std::cout &lt;&lt; &quot;In function: &quot; &lt;&lt; p1 &lt;&lt; &#39; &#39; &lt;&lt; p2 &lt;&lt; &#39; &#39; &lt;&lt; p3 &lt;&lt; &#39;\\n&#39;; ++p1; // increments the copy of n1 stored in the function object ++p2; // increments the main()&#39;s n2 // ++p3; // compile error } int main() { int n1 = 1, n2 = 2, n3 = 3; std::function&lt;void()&gt; bound_f = std::bind(f, n1, std::ref(n2), std::cref(n3)); n1 = 10; n2 = 11; n3 = 12; std::cout &lt;&lt; &quot;Before calling f() directly: &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\\n&#39;; f(n1, n2, n3); std::cout &lt;&lt; &quot;After calling f() directly: &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;==================\\n&quot;; std::cout &lt;&lt; &quot;Before calling bound_f(): &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\\n&#39;; bound_f(); bound_f(); std::cout &lt;&lt; &quot;After calling bound_f(): &quot; &lt;&lt; n1 &lt;&lt; &#39; &#39; &lt;&lt; n2 &lt;&lt; &#39; &#39; &lt;&lt; n3 &lt;&lt; &#39;\\n&#39;; } In this example, f() takes all the integers by reference. The third one is also const. If we call f() directly, we get the desired behaviour, n1 and n2 are “permanently” modified. On the other hand, the behaviour is different when we invoke f() with the help of std::function. When we don’t use std::ref or std::cref to bind the arguments, they are simply copied. That’s why even though n1 is seemingly passed as a reference, in bound_f, p1 still has the value it had when the binding was made. Likewise, it doesn’t increase the value of n1. But if we call bound_f() the second time, we can see that p1’s value has changed. What that means is that std::function holds on a copy of n1 and that is updated between the calls. If we want p1 to be an actual reference of n1, we must pass it with the help of std::ref, just as we did it for n2/p2 and for n3/p3. Conclusion std::ref and std::cref are helper functions to std::reference_wrapper objects. With the help of these constructs, you can store references in standard containers. You can also pass references to templates and various helper functions such std::bind, std::thread or std::make_pair. Without using them, your code will seemingly work, but instead of taking references, copies might be made. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"What is std::ref?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/08/21/std-ref"},"url":"https://www.sandordargo.com/blog/2024/08/21/std-ref"}</script><title>What is std::ref? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/08"> 08 </a> </span> <span> <a href="/21"> 21 </a> </span> <span>What is std::ref?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>What is std::ref?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Aug 21, 2024, 12:00 AM +0200" prep="on" > Aug 21, 2024 <i class="unloaded">2024-08-21T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="919 words">5 min</span></div></div><div class="post-content"><p>Have you heard about <code class="language-plaintext highlighter-rouge">std::ref</code> and <code class="language-plaintext highlighter-rouge">std::cref</code>? The helper functions that generate objects of type <code class="language-plaintext highlighter-rouge">std::reference_wrapper</code>? The answer is probably yes. In that case, this article is probably not for you. But if you haven’t heard about them, or the only usage of <code class="language-plaintext highlighter-rouge">std::reference_wrapper</code> you faced was storing references in a vector, then probably it’s worth reading on.</p><p>This article is inspired by some failing tests that needed me to use <code class="language-plaintext highlighter-rouge">std::ref</code> in order to pass them.</p><p>What does <code class="language-plaintext highlighter-rouge">reference_wrapper</code> do?</p><p>A reference of an object <code class="language-plaintext highlighter-rouge">T</code> (<code class="language-plaintext highlighter-rouge">T&amp;</code>) is not copy assignable. On the other hand, <code class="language-plaintext highlighter-rouge">std::reference_wrapper&lt;T&gt;</code> which emulates <code class="language-plaintext highlighter-rouge">T&amp;</code> it both copy-constructible and copy-assignable. It’s even trivially copyable, so copying can take place on a byte level which makes it very efficient.</p><p>So when should we use such a wrapper?</p><h2 id="store-references-in-a-container">Store references in a container</h2><p>If you ever wanted to store references in a vector, you probably know that this wouldn’t compile.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// This doesn't compile</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;&gt;</span> <span class="n">v</span><span class="p">;</span>
</pre></table></code></div></div><p>Originally, the root cause was that a reference is not assignable. Once a reference is initialized, it cannot be modified to refer to another object. (Pointers can do that.) Therefore you cannot store <code class="language-plaintext highlighter-rouge">const</code> objects either, as they are not reassignable either.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// This doesn't compile either</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
</pre></table></code></div></div><p>While the above is still not possible, the rules changed a bit since C++11 and it’s not mainly about copy assignability, but it’s about (not) being erasable.</p><p><a href="https://stackoverflow.com/a/55301228">Erasable means</a> that the following expression is well formed:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">allocator_traits</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;::</span><span class="n">destroy</span><span class="p">(</span><span class="n">m</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
</pre></table></code></div></div><p>Where <code class="language-plaintext highlighter-rouge">A</code> is the container’s allocator type, <code class="language-plaintext highlighter-rouge">m</code> is an allocator instance and <code class="language-plaintext highlighter-rouge">p</code> is a pointer of type <code class="language-plaintext highlighter-rouge">*T</code>. <a href="https://eel.is/c++draft/container.requirements#def:Cpp17Erasable_from_X">See here</a> for <em>Erasable</em> definition.</p><p>By default, <code class="language-plaintext highlighter-rouge">std::allocator&lt;T&gt;</code> is used as <code class="language-plaintext highlighter-rouge">vector</code>’s allocator. With the default allocator, the requirement is equivalent to the validity of <code class="language-plaintext highlighter-rouge">p-&gt;~T()</code> (Note that <code class="language-plaintext highlighter-rouge">T</code> is a reference type and <code class="language-plaintext highlighter-rouge">p</code> is pointer to a reference). However, a pointer to a reference is illegal, hence the expression is not well formed.</p><p>On the other hand, a pointer to an instance of <code class="language-plaintext highlighter-rouge">std::reference_wrapper</code> is valid and we can store references in a container like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s1</span><span class="p">{</span><span class="s">"Hello"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s2</span><span class="p">{</span><span class="s">","</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s3</span><span class="p">{</span><span class="s">"World!"</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">reference_wrapper</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s1</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">s3</span><span class="p">)</span>
<span class="p">};</span>    
</pre></table></code></div></div><h2 id="pass-references-to-some-standard-template-functions">Pass references to some standard template functions</h2><p>But <code class="language-plaintext highlighter-rouge">std::ref</code> and <code class="language-plaintext highlighter-rouge">std::cref</code> doesn’t only come in handy with containers. They are also very useful when you need to pass a reference to <code class="language-plaintext highlighter-rouge">std::bind</code>, to the constructor of <code class="language-plaintext highlighter-rouge">std::thread</code> or to some standard helper functions such as <code class="language-plaintext highlighter-rouge">std::make_pair</code>.</p><p>The common characteristic of them is that even if you pass references to them, they will remove those/decay those references and they will either move or copy what you passed in. Therefore if you really want to do as if you passed in a reference, use a reference wrapper!</p><p>Let’s have a simple example of how <code class="language-plaintext highlighter-rouge">std::ref</code>/<code class="language-plaintext highlighter-rouge">std::cref</code> makes a difference in such scenarios!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span> 
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">p1</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">p2</span><span class="p">,</span> <span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">p3</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"In function: "</span> <span class="o">&lt;&lt;</span> <span class="n">p1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">p2</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">p3</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="o">++</span><span class="n">p1</span><span class="p">;</span> <span class="c1">// increments the copy of n1 stored in the function object</span>
    <span class="o">++</span><span class="n">p2</span><span class="p">;</span> <span class="c1">// increments the main()'s n2</span>
    <span class="c1">// ++p3; // compile error</span>
<span class="p">}</span>
 
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">n1</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">n2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">n3</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">void</span><span class="p">()</span><span class="o">&gt;</span> <span class="n">bound_f</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">bind</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">n1</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">ref</span><span class="p">(</span><span class="n">n2</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">cref</span><span class="p">(</span><span class="n">n3</span><span class="p">));</span>
    <span class="n">n1</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
    <span class="n">n2</span> <span class="o">=</span> <span class="mi">11</span><span class="p">;</span>
    <span class="n">n3</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Before calling f() directly: "</span> <span class="o">&lt;&lt;</span> <span class="n">n1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n2</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n3</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">n1</span><span class="p">,</span> <span class="n">n2</span><span class="p">,</span> <span class="n">n3</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After calling f() directly: "</span> <span class="o">&lt;&lt;</span> <span class="n">n1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n2</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n3</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"==================</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Before calling bound_f(): "</span> <span class="o">&lt;&lt;</span> <span class="n">n1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n2</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n3</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">bound_f</span><span class="p">();</span>
    <span class="n">bound_f</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"After calling bound_f(): "</span> <span class="o">&lt;&lt;</span> <span class="n">n1</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n2</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span> <span class="o">&lt;&lt;</span> <span class="n">n3</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In this example, <code class="language-plaintext highlighter-rouge">f()</code> takes all the integers by reference. The third one is also <code class="language-plaintext highlighter-rouge">const</code>. If we call <code class="language-plaintext highlighter-rouge">f()</code> directly, we get the desired behaviour, <code class="language-plaintext highlighter-rouge">n1</code> and <code class="language-plaintext highlighter-rouge">n2</code> are “permanently” modified.</p><p>On the other hand, the behaviour is different when we invoke <code class="language-plaintext highlighter-rouge">f()</code> with the help of <code class="language-plaintext highlighter-rouge">std::function</code>. When we don’t use <code class="language-plaintext highlighter-rouge">std::ref</code> or <code class="language-plaintext highlighter-rouge">std::cref</code> to bind the arguments, they are simply copied. That’s why even though <code class="language-plaintext highlighter-rouge">n1</code> is seemingly passed as a reference, in <code class="language-plaintext highlighter-rouge">bound_f</code>, <code class="language-plaintext highlighter-rouge">p1</code> still has the value it had when the binding was made. Likewise, it doesn’t increase the value of <code class="language-plaintext highlighter-rouge">n1</code>. But if we call <code class="language-plaintext highlighter-rouge">bound_f()</code> the second time, we can see that <code class="language-plaintext highlighter-rouge">p1</code>’s value has changed. What that means is that <code class="language-plaintext highlighter-rouge">std::function</code> holds on a copy of <code class="language-plaintext highlighter-rouge">n1</code> and that is updated between the calls.</p><p>If we want <code class="language-plaintext highlighter-rouge">p1</code> to be an actual reference of <code class="language-plaintext highlighter-rouge">n1</code>, we must pass it with the help of <code class="language-plaintext highlighter-rouge">std::ref</code>, just as we did it for <code class="language-plaintext highlighter-rouge">n2</code>/<code class="language-plaintext highlighter-rouge">p2</code> and for <code class="language-plaintext highlighter-rouge">n3</code>/<code class="language-plaintext highlighter-rouge">p3</code>.</p><h2 id="conclusion">Conclusion</h2><p><code class="language-plaintext highlighter-rouge">std::ref</code> and <code class="language-plaintext highlighter-rouge">std::cref</code> are helper functions to <code class="language-plaintext highlighter-rouge">std::reference_wrapper</code> objects. With the help of these constructs, you can store references in standard containers.</p><p>You can also pass references to templates and various helper functions such <code class="language-plaintext highlighter-rouge">std::bind</code>, <code class="language-plaintext highlighter-rouge">std::thread</code> or <code class="language-plaintext highlighter-rouge">std::make_pair</code>. Without using them, your code will seemingly work, but instead of taking references, copies might be made.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/move-only-function/" class="post-tag no-text-decoration" >move_only_function</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=What is std::ref? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/08/21/std-ref" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=What is std::ref? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/08/21/std-ref" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=What is std::ref? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/08/21/std-ref" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=What is std::ref? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/08/21/std-ref" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/07/31/rule-of-5-once-again"><div class="card-body"> <span class="timeago small" > Jul 31, 2024 <i class="unloaded">2024-07-31T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Once more about the rule of 5</h3><div class="text-muted small"><p> Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/07/rule-of-five-and-base-classes"><div class="card-body"> <span class="timeago small" > Aug 7, 2024 <i class="unloaded">2024-08-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The rule of 5 and inheritance</h3><div class="text-muted small"><p> Last week, we talked about the rule of five and we discovered what it means for move operations if we only declare a destructor and not the rest of the special member functions. In that case, move ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/08/14/learn-cpp-by-frances-buontempo" class="btn btn-outline-primary" prompt="Older"><p>Learn C++ by Example by Frances Buontempo</p></a> <a href="/blog/2024/08/28/wrapping-up-as-airbnb-host" class="btn btn-outline-primary" prompt="Newer"><p>Wrapping up our Airbnb host experience</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'What is std::ref?'; this.page.url = 'https://www.sandordargo.com/blog/2024/08/21/std-ref'; this.page.identifier = '/blog/2024/08/21/std-ref'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
