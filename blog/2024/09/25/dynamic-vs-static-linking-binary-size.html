<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Binary size: should we use static or dynamic linking?" /><meta property="og:locale" content="en_US" /><meta name="description" content="If at the end of a conference talk, I cannot answer a question and there is nobody to my rescue, I offer to reply later in the form of a blog post. At C++ on Sea, someone asked me about the implications of dynamic linking concerning binary size. I hope I remember the question well! Let me phrase it differently: assuming the same code, what if you deliver an executable where libraries are dynamically linked and what if they are statically linked? How much bigger the dynamic version will be overall? Or maybe the static version will be larger? Let’s take a small example. We’ll reuse one that we created for constexpr functions for smaller binary size. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // moduleA.h #pragma once int foo(int x); // moduleA.cpp #include &quot;moduleA.h&quot; #include &quot;utils.h&quot; int foo(int x) { return Fun(x) + 42; } // moduleB.h #pragma once int bar(int x); // moduleB.cpp #include &quot;moduleB.h&quot; #include &quot;utils.h&quot; int bar(int x) { return Fun(x) + 51; } // moduleC.h #pragma once int foobar(int x); // moduleC.cpp #include &quot;moduleC.h&quot; #include &quot;utils.h&quot; int foobar(int x) { return Fun(x) + 69; } // moduleD.h #pragma once int barfoo(int x); // moduleD.cpp #include &quot;moduleD.h&quot; #include &quot;utils.h&quot; int barfoo(int x) { return Fun(x) + 99; } // utils.h #pragma once constexpr auto Fun(int v); // utils.cpp #include &quot;utils.h&quot; constexpr auto Fun(int v); { return 42 / v; } // main.cpp #include &lt;iostream&gt; #include &quot;moduleA.h&quot; #include &quot;moduleB.h&quot; #include &quot;moduleC.h&quot; #include &quot;moduleD.h&quot; int main() { std::cout &lt;&lt; foo(2) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; bar(2) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foobar(2) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; barfoo(2) &lt;&lt; &#39;\n&#39;; } In our original example, we compiled this into 5 different shared libraries and linked them together. Here are the commands I used on MacOS: 1 2 3 4 5 6 7 clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include utils.h utils.cpp -o libutils.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleA.h moduleA.cpp -o libmoduleA.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleB.h moduleB.cpp -o libmoduleB.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleC.h moduleC.cpp -o libmoduleC.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleD.h moduleD.cpp -o libmoduleD.dylib clang++ -std=c++20 -stdlib=libc++ -L . -lutils -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main In order to calculate the full size of this example, we need to sum up the sizes of the shared objects and the main executable. Filename Binary size in bytes libutils.dylib 16,800 libmoduleA.dylib 33,392 libmoduleB.dylib 33,392 libmoduleC.dylib 33,392 libmoduleD.dylib 33,392 main 39,416 overall 189,784 To understand how much we lose with dynamic linking if we lose anything, we must try to link these libraries statically too. Let me first put here the commands I ran and then let’s review them together: 1 2 3 4 5 6 7 8 9 10 11 12 clang++ -std=c++20 -c -o libutils.o utils.cpp -include utils.h -fPIC ar r libutils.a libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -o libmoduleA.o -fPIC ar r libmoduleA.a libmoduleA.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleB.h moduleB.cpp -o libmoduleB.o -fPIC ar r libmoduleB.a libmoduleB.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleC.h moduleC.cpp -o libmoduleC.o -fPIC ar r libmoduleC.a libmoduleC.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleD.h moduleD.cpp -o libmoduleD.o -fPIC ar r libmoduleD.a libmoduleD.o clang++ -std=c++20 -stdlib=libc++ -L . -lutils -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main-static First, instead of compiling everything into a separate dynamic library, I compiled every translation unit (every .cpp file) into an object (.o) file. Then I used the ar command to create a different static library out of each object file. As a last step, I compiled main.cpp and specified each library with the -l option. It’s worth noting that both when I created static and dynamic libraries, the file’s name started with lib which I had to omit when I passed the library names. Now the size of the individual libraries doesn’t matter anymore in the sense that we don’t have to sum them up. Everything that is needed, will be part of our main-static executable file. But it’s still worth having a look at them just to see their sheer size. Filename Binary size in bytes libutils.a 720 libmoduleA.a 864 libmoduleB.a 864 libmoduleC.a 872 libmoduleD.a 872 They are two orders of magniture smaller. Filename Binary size in bytes main-static 39,448 As we can see, the size of the executable grew a tiny bit. But let’s not forget that with static linkage, we don’t have to keep the library files around, the executable works on its own! We can easily test this by deleting them and running the executables. The dynamically linked version will crash, while the static one will work fine. So in fact, we cut the size from 190 KB to 40 KB. We have some alternative ways to compile. If we looked at the example attentively, we might have noticed that libutils is not used by the main executable, but by all the other libraries. If we want, we can bundle the utils with each other library. With ar we cannot include a static library in another, but we can bundle the object files. Instead of uncompressing libutils.a and using its output, let’s directly use libutils.o. 1 2 3 4 5 6 7 8 9 10 11 clang++ -std=c++20 -c -o libutils.o utils.cpp -include utils.h -fPIC clang++ -c -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -o libmoduleA.o -fPIC ar r libmoduleA.a libmoduleA.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleB.h moduleB.cpp -o libmoduleB.o -fPIC ar r libmoduleB.a libmoduleB.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleC.h moduleC.cpp -o libmoduleC.o -fPIC ar r libmoduleC.a libmoduleC.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleD.h moduleD.cpp -o libmoduleD.o -fPIC ar r libmoduleD.a libmoduleD.o libutils.o clang++ -std=c++20 -stdlib=libc++ -L . -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main-static We can observe that while the size of the static libraries increased as they also include the object file created out of utils.cpp, the size of main didn’t change at all. Filename Binary size in bytes libmoduleA.a 1,480 libmoduleB.a 1,480 libmoduleC.a 1,496 libmoduleD.a 1,496 main 39,448 In a certain way, this is safer. Each library contains what it needs. It doesn’t depend on the final step to have its dependencies around. Besides, it doesn’t increase the size of the executable. Of course, you’ll need more space to store the static libraries and overall, packaging the libraries might take more time, but probably these won’t be your main concerns. As we are on a quest of decreasing binary sizes, let’s also see what if we compile everything together: 1 clang++ -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -include moduleB.h moduleB.cpp -include moduleC.h moduleC.cpp -include moduleD.h moduleD.cpp main.cpp -o main-static The size of the executable didn’t change, it’s still 39,448 bytes. It’s worth noting that we didn’t gain anything in terms of executable size. At the end of the day, what is better for binary size? Dynamic or static linking? As so often, the answer is: it depends. This was a small example and the size of the dynamically linked executable (without considering the shared libraries) was only a little bit smaller than the static one. Other times, the size difference will be more significant. Then the question is whether you run different executables on the same machine which could reuse the same shared libraries. If so, you might end up with a smaller overall size than with statically linked executables. On the other hand, if you have only one executable to run, it’s almost 100% sure that linking statically is what you’ll benefit from the most. (In this article we only care about binary size, there are of course other aspects as well.) The dynamic loader also has a size There is one more thing! On Windows and on MacOS this won’t matter as tooling is kind of given. But on Linux-based systems where you have a strong control over all the tooling, the question of the dynamic loader might matter. ld.so is used to load the dynamic libraries runtime. It also has a cache that help speed up search times. If on a system you don’t use anything that is dynamically linked, therefore you don’t need dynamic loading you might remove the dynamic loader. Strictly speaking, it’s not part of your executable size, but that is something that you need for dynamic loading. On systems with a very specific purpose, this might be worth considering. Conclusion With this article, I tried to answer one of the questions I was asked at C++ On Sea. How does dynamic linking influence binary size? The short answer is heavily. The longer answer is that dynamic linking has a big cost, it increases the overall size of your executable combined with the necessary libraries. It’s only worth paying if you share a library between several executables on the same device. If on one device you run only one executable and size is a concern for you for whatever reason, I’d go with static linking. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="If at the end of a conference talk, I cannot answer a question and there is nobody to my rescue, I offer to reply later in the form of a blog post. At C++ on Sea, someone asked me about the implications of dynamic linking concerning binary size. I hope I remember the question well! Let me phrase it differently: assuming the same code, what if you deliver an executable where libraries are dynamically linked and what if they are statically linked? How much bigger the dynamic version will be overall? Or maybe the static version will be larger? Let’s take a small example. We’ll reuse one that we created for constexpr functions for smaller binary size. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // moduleA.h #pragma once int foo(int x); // moduleA.cpp #include &quot;moduleA.h&quot; #include &quot;utils.h&quot; int foo(int x) { return Fun(x) + 42; } // moduleB.h #pragma once int bar(int x); // moduleB.cpp #include &quot;moduleB.h&quot; #include &quot;utils.h&quot; int bar(int x) { return Fun(x) + 51; } // moduleC.h #pragma once int foobar(int x); // moduleC.cpp #include &quot;moduleC.h&quot; #include &quot;utils.h&quot; int foobar(int x) { return Fun(x) + 69; } // moduleD.h #pragma once int barfoo(int x); // moduleD.cpp #include &quot;moduleD.h&quot; #include &quot;utils.h&quot; int barfoo(int x) { return Fun(x) + 99; } // utils.h #pragma once constexpr auto Fun(int v); // utils.cpp #include &quot;utils.h&quot; constexpr auto Fun(int v); { return 42 / v; } // main.cpp #include &lt;iostream&gt; #include &quot;moduleA.h&quot; #include &quot;moduleB.h&quot; #include &quot;moduleC.h&quot; #include &quot;moduleD.h&quot; int main() { std::cout &lt;&lt; foo(2) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; bar(2) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foobar(2) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; barfoo(2) &lt;&lt; &#39;\n&#39;; } In our original example, we compiled this into 5 different shared libraries and linked them together. Here are the commands I used on MacOS: 1 2 3 4 5 6 7 clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include utils.h utils.cpp -o libutils.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleA.h moduleA.cpp -o libmoduleA.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleB.h moduleB.cpp -o libmoduleB.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleC.h moduleC.cpp -o libmoduleC.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleD.h moduleD.cpp -o libmoduleD.dylib clang++ -std=c++20 -stdlib=libc++ -L . -lutils -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main In order to calculate the full size of this example, we need to sum up the sizes of the shared objects and the main executable. Filename Binary size in bytes libutils.dylib 16,800 libmoduleA.dylib 33,392 libmoduleB.dylib 33,392 libmoduleC.dylib 33,392 libmoduleD.dylib 33,392 main 39,416 overall 189,784 To understand how much we lose with dynamic linking if we lose anything, we must try to link these libraries statically too. Let me first put here the commands I ran and then let’s review them together: 1 2 3 4 5 6 7 8 9 10 11 12 clang++ -std=c++20 -c -o libutils.o utils.cpp -include utils.h -fPIC ar r libutils.a libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -o libmoduleA.o -fPIC ar r libmoduleA.a libmoduleA.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleB.h moduleB.cpp -o libmoduleB.o -fPIC ar r libmoduleB.a libmoduleB.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleC.h moduleC.cpp -o libmoduleC.o -fPIC ar r libmoduleC.a libmoduleC.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleD.h moduleD.cpp -o libmoduleD.o -fPIC ar r libmoduleD.a libmoduleD.o clang++ -std=c++20 -stdlib=libc++ -L . -lutils -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main-static First, instead of compiling everything into a separate dynamic library, I compiled every translation unit (every .cpp file) into an object (.o) file. Then I used the ar command to create a different static library out of each object file. As a last step, I compiled main.cpp and specified each library with the -l option. It’s worth noting that both when I created static and dynamic libraries, the file’s name started with lib which I had to omit when I passed the library names. Now the size of the individual libraries doesn’t matter anymore in the sense that we don’t have to sum them up. Everything that is needed, will be part of our main-static executable file. But it’s still worth having a look at them just to see their sheer size. Filename Binary size in bytes libutils.a 720 libmoduleA.a 864 libmoduleB.a 864 libmoduleC.a 872 libmoduleD.a 872 They are two orders of magniture smaller. Filename Binary size in bytes main-static 39,448 As we can see, the size of the executable grew a tiny bit. But let’s not forget that with static linkage, we don’t have to keep the library files around, the executable works on its own! We can easily test this by deleting them and running the executables. The dynamically linked version will crash, while the static one will work fine. So in fact, we cut the size from 190 KB to 40 KB. We have some alternative ways to compile. If we looked at the example attentively, we might have noticed that libutils is not used by the main executable, but by all the other libraries. If we want, we can bundle the utils with each other library. With ar we cannot include a static library in another, but we can bundle the object files. Instead of uncompressing libutils.a and using its output, let’s directly use libutils.o. 1 2 3 4 5 6 7 8 9 10 11 clang++ -std=c++20 -c -o libutils.o utils.cpp -include utils.h -fPIC clang++ -c -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -o libmoduleA.o -fPIC ar r libmoduleA.a libmoduleA.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleB.h moduleB.cpp -o libmoduleB.o -fPIC ar r libmoduleB.a libmoduleB.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleC.h moduleC.cpp -o libmoduleC.o -fPIC ar r libmoduleC.a libmoduleC.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleD.h moduleD.cpp -o libmoduleD.o -fPIC ar r libmoduleD.a libmoduleD.o libutils.o clang++ -std=c++20 -stdlib=libc++ -L . -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main-static We can observe that while the size of the static libraries increased as they also include the object file created out of utils.cpp, the size of main didn’t change at all. Filename Binary size in bytes libmoduleA.a 1,480 libmoduleB.a 1,480 libmoduleC.a 1,496 libmoduleD.a 1,496 main 39,448 In a certain way, this is safer. Each library contains what it needs. It doesn’t depend on the final step to have its dependencies around. Besides, it doesn’t increase the size of the executable. Of course, you’ll need more space to store the static libraries and overall, packaging the libraries might take more time, but probably these won’t be your main concerns. As we are on a quest of decreasing binary sizes, let’s also see what if we compile everything together: 1 clang++ -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -include moduleB.h moduleB.cpp -include moduleC.h moduleC.cpp -include moduleD.h moduleD.cpp main.cpp -o main-static The size of the executable didn’t change, it’s still 39,448 bytes. It’s worth noting that we didn’t gain anything in terms of executable size. At the end of the day, what is better for binary size? Dynamic or static linking? As so often, the answer is: it depends. This was a small example and the size of the dynamically linked executable (without considering the shared libraries) was only a little bit smaller than the static one. Other times, the size difference will be more significant. Then the question is whether you run different executables on the same machine which could reuse the same shared libraries. If so, you might end up with a smaller overall size than with statically linked executables. On the other hand, if you have only one executable to run, it’s almost 100% sure that linking statically is what you’ll benefit from the most. (In this article we only care about binary size, there are of course other aspects as well.) The dynamic loader also has a size There is one more thing! On Windows and on MacOS this won’t matter as tooling is kind of given. But on Linux-based systems where you have a strong control over all the tooling, the question of the dynamic loader might matter. ld.so is used to load the dynamic libraries runtime. It also has a cache that help speed up search times. If on a system you don’t use anything that is dynamically linked, therefore you don’t need dynamic loading you might remove the dynamic loader. Strictly speaking, it’s not part of your executable size, but that is something that you need for dynamic loading. On systems with a very specific purpose, this might be worth considering. Conclusion With this article, I tried to answer one of the questions I was asked at C++ On Sea. How does dynamic linking influence binary size? The short answer is heavily. The longer answer is that dynamic linking has a big cost, it increases the overall size of your executable combined with the necessary libraries. It’s only worth paying if you share a library between several executables on the same device. If on one device you run only one executable and size is a concern for you for whatever reason, I’d go with static linking. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-09-25T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Binary size: should we use static or dynamic linking?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-09-25T00:00:00+02:00","datePublished":"2024-09-25T00:00:00+02:00","description":"If at the end of a conference talk, I cannot answer a question and there is nobody to my rescue, I offer to reply later in the form of a blog post. At C++ on Sea, someone asked me about the implications of dynamic linking concerning binary size. I hope I remember the question well! Let me phrase it differently: assuming the same code, what if you deliver an executable where libraries are dynamically linked and what if they are statically linked? How much bigger the dynamic version will be overall? Or maybe the static version will be larger? Let’s take a small example. We’ll reuse one that we created for constexpr functions for smaller binary size. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 // moduleA.h #pragma once int foo(int x); // moduleA.cpp #include &quot;moduleA.h&quot; #include &quot;utils.h&quot; int foo(int x) { return Fun(x) + 42; } // moduleB.h #pragma once int bar(int x); // moduleB.cpp #include &quot;moduleB.h&quot; #include &quot;utils.h&quot; int bar(int x) { return Fun(x) + 51; } // moduleC.h #pragma once int foobar(int x); // moduleC.cpp #include &quot;moduleC.h&quot; #include &quot;utils.h&quot; int foobar(int x) { return Fun(x) + 69; } // moduleD.h #pragma once int barfoo(int x); // moduleD.cpp #include &quot;moduleD.h&quot; #include &quot;utils.h&quot; int barfoo(int x) { return Fun(x) + 99; } // utils.h #pragma once constexpr auto Fun(int v); // utils.cpp #include &quot;utils.h&quot; constexpr auto Fun(int v); { return 42 / v; } // main.cpp #include &lt;iostream&gt; #include &quot;moduleA.h&quot; #include &quot;moduleB.h&quot; #include &quot;moduleC.h&quot; #include &quot;moduleD.h&quot; int main() { std::cout &lt;&lt; foo(2) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; bar(2) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foobar(2) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; barfoo(2) &lt;&lt; &#39;\\n&#39;; } In our original example, we compiled this into 5 different shared libraries and linked them together. Here are the commands I used on MacOS: 1 2 3 4 5 6 7 clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include utils.h utils.cpp -o libutils.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleA.h moduleA.cpp -o libmoduleA.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleB.h moduleB.cpp -o libmoduleB.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleC.h moduleC.cpp -o libmoduleC.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include moduleD.h moduleD.cpp -o libmoduleD.dylib clang++ -std=c++20 -stdlib=libc++ -L . -lutils -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main In order to calculate the full size of this example, we need to sum up the sizes of the shared objects and the main executable. Filename Binary size in bytes libutils.dylib 16,800 libmoduleA.dylib 33,392 libmoduleB.dylib 33,392 libmoduleC.dylib 33,392 libmoduleD.dylib 33,392 main 39,416 overall 189,784 To understand how much we lose with dynamic linking if we lose anything, we must try to link these libraries statically too. Let me first put here the commands I ran and then let’s review them together: 1 2 3 4 5 6 7 8 9 10 11 12 clang++ -std=c++20 -c -o libutils.o utils.cpp -include utils.h -fPIC ar r libutils.a libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -o libmoduleA.o -fPIC ar r libmoduleA.a libmoduleA.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleB.h moduleB.cpp -o libmoduleB.o -fPIC ar r libmoduleB.a libmoduleB.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleC.h moduleC.cpp -o libmoduleC.o -fPIC ar r libmoduleC.a libmoduleC.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleD.h moduleD.cpp -o libmoduleD.o -fPIC ar r libmoduleD.a libmoduleD.o clang++ -std=c++20 -stdlib=libc++ -L . -lutils -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main-static First, instead of compiling everything into a separate dynamic library, I compiled every translation unit (every .cpp file) into an object (.o) file. Then I used the ar command to create a different static library out of each object file. As a last step, I compiled main.cpp and specified each library with the -l option. It’s worth noting that both when I created static and dynamic libraries, the file’s name started with lib which I had to omit when I passed the library names. Now the size of the individual libraries doesn’t matter anymore in the sense that we don’t have to sum them up. Everything that is needed, will be part of our main-static executable file. But it’s still worth having a look at them just to see their sheer size. Filename Binary size in bytes libutils.a 720 libmoduleA.a 864 libmoduleB.a 864 libmoduleC.a 872 libmoduleD.a 872 They are two orders of magniture smaller. Filename Binary size in bytes main-static 39,448 As we can see, the size of the executable grew a tiny bit. But let’s not forget that with static linkage, we don’t have to keep the library files around, the executable works on its own! We can easily test this by deleting them and running the executables. The dynamically linked version will crash, while the static one will work fine. So in fact, we cut the size from 190 KB to 40 KB. We have some alternative ways to compile. If we looked at the example attentively, we might have noticed that libutils is not used by the main executable, but by all the other libraries. If we want, we can bundle the utils with each other library. With ar we cannot include a static library in another, but we can bundle the object files. Instead of uncompressing libutils.a and using its output, let’s directly use libutils.o. 1 2 3 4 5 6 7 8 9 10 11 clang++ -std=c++20 -c -o libutils.o utils.cpp -include utils.h -fPIC clang++ -c -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -o libmoduleA.o -fPIC ar r libmoduleA.a libmoduleA.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleB.h moduleB.cpp -o libmoduleB.o -fPIC ar r libmoduleB.a libmoduleB.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleC.h moduleC.cpp -o libmoduleC.o -fPIC ar r libmoduleC.a libmoduleC.o libutils.o clang++ -c -std=c++20 -stdlib=libc++ -include moduleD.h moduleD.cpp -o libmoduleD.o -fPIC ar r libmoduleD.a libmoduleD.o libutils.o clang++ -std=c++20 -stdlib=libc++ -L . -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main-static We can observe that while the size of the static libraries increased as they also include the object file created out of utils.cpp, the size of main didn’t change at all. Filename Binary size in bytes libmoduleA.a 1,480 libmoduleB.a 1,480 libmoduleC.a 1,496 libmoduleD.a 1,496 main 39,448 In a certain way, this is safer. Each library contains what it needs. It doesn’t depend on the final step to have its dependencies around. Besides, it doesn’t increase the size of the executable. Of course, you’ll need more space to store the static libraries and overall, packaging the libraries might take more time, but probably these won’t be your main concerns. As we are on a quest of decreasing binary sizes, let’s also see what if we compile everything together: 1 clang++ -std=c++20 -stdlib=libc++ -include moduleA.h moduleA.cpp -include moduleB.h moduleB.cpp -include moduleC.h moduleC.cpp -include moduleD.h moduleD.cpp main.cpp -o main-static The size of the executable didn’t change, it’s still 39,448 bytes. It’s worth noting that we didn’t gain anything in terms of executable size. At the end of the day, what is better for binary size? Dynamic or static linking? As so often, the answer is: it depends. This was a small example and the size of the dynamically linked executable (without considering the shared libraries) was only a little bit smaller than the static one. Other times, the size difference will be more significant. Then the question is whether you run different executables on the same machine which could reuse the same shared libraries. If so, you might end up with a smaller overall size than with statically linked executables. On the other hand, if you have only one executable to run, it’s almost 100% sure that linking statically is what you’ll benefit from the most. (In this article we only care about binary size, there are of course other aspects as well.) The dynamic loader also has a size There is one more thing! On Windows and on MacOS this won’t matter as tooling is kind of given. But on Linux-based systems where you have a strong control over all the tooling, the question of the dynamic loader might matter. ld.so is used to load the dynamic libraries runtime. It also has a cache that help speed up search times. If on a system you don’t use anything that is dynamically linked, therefore you don’t need dynamic loading you might remove the dynamic loader. Strictly speaking, it’s not part of your executable size, but that is something that you need for dynamic loading. On systems with a very specific purpose, this might be worth considering. Conclusion With this article, I tried to answer one of the questions I was asked at C++ On Sea. How does dynamic linking influence binary size? The short answer is heavily. The longer answer is that dynamic linking has a big cost, it increases the overall size of your executable combined with the necessary libraries. It’s only worth paying if you share a library between several executables on the same device. If on one device you run only one executable and size is a concern for you for whatever reason, I’d go with static linking. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Binary size: should we use static or dynamic linking?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size"},"url":"https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size"}</script><title>Binary size: should we use static or dynamic linking? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/09"> 09 </a> </span> <span> <a href="/25"> 25 </a> </span> <span>Binary size: should we use static or dynamic linking?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Binary size: should we use static or dynamic linking?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 25, 2024, 12:00 AM +0200" prep="on" > Sep 25, 2024 <i class="unloaded">2024-09-25T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1562 words">8 min</span></div></div><div class="post-content"><p>If at the end of a conference talk, I cannot answer a question and there is nobody to my rescue, I offer to reply later in the form of a blog post.</p><p>At <a href="https://cpponsea.uk/">C++ on Sea</a>, someone asked me about the implications of dynamic linking concerning binary size. I hope I remember the question well! Let me phrase it differently: assuming the same code, what if you deliver an executable where libraries are dynamically linked and what if they are statically linked? How much bigger the dynamic version will be overall? Or maybe the static version will be larger?</p><p>Let’s take a small example. We’ll reuse one that we created for <a href="https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes"><code class="language-plaintext highlighter-rouge">constexpr</code> functions for smaller binary size</a>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
</pre><td class="rouge-code"><pre><span class="c1">// moduleA.h</span>
<span class="cp">#pragma once
</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// moduleA.cpp</span>
<span class="cp">#include</span> <span class="cpf">"moduleA.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">// moduleB.h</span>
<span class="cp">#pragma once
</span>
<span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// moduleB.cpp</span>
<span class="cp">#include</span> <span class="cpf">"moduleB.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">51</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">// moduleC.h</span>
<span class="cp">#pragma once
</span>
<span class="kt">int</span> <span class="nf">foobar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// moduleC.cpp</span>
<span class="cp">#include</span> <span class="cpf">"moduleC.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">foobar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">69</span><span class="p">;</span>
<span class="p">}</span> 

<span class="c1">// moduleD.h</span>
<span class="cp">#pragma once
</span>
<span class="kt">int</span> <span class="nf">barfoo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>

<span class="c1">// moduleD.cpp</span>
<span class="cp">#include</span> <span class="cpf">"moduleD.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">barfoo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">return</span> <span class="n">Fun</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="o">+</span> <span class="mi">99</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// utils.h</span>
<span class="cp">#pragma once
</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">);</span>

<span class="c1">// utils.cpp</span>

<span class="cp">#include</span> <span class="cpf">"utils.h"</span><span class="cp">
</span>
<span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">);</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">42</span> <span class="o">/</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">"moduleA.h"</span><span class="cp">
#include</span> <span class="cpf">"moduleB.h"</span><span class="cp">
#include</span> <span class="cpf">"moduleC.h"</span><span class="cp">
#include</span> <span class="cpf">"moduleD.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foobar</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">barfoo</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In our original example, we compiled this into 5 different shared libraries and linked them together. Here are the commands I used on MacOS:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre>clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-include</span> utils.h utils.cpp <span class="nt">-o</span> libutils.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-include</span> moduleA.h moduleA.cpp <span class="nt">-o</span> libmoduleA.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-include</span> moduleB.h moduleB.cpp <span class="nt">-o</span> libmoduleB.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-include</span> moduleC.h moduleC.cpp <span class="nt">-o</span> libmoduleC.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-include</span> moduleD.h moduleD.cpp <span class="nt">-o</span> libmoduleD.dylib

clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lutils</span> <span class="nt">-lmoduleA</span> <span class="nt">-lmoduleB</span> <span class="nt">-lmoduleC</span> <span class="nt">-lmoduleD</span> main.cpp <span class="nt">-o</span> main
</pre></table></code></div></div><p>In order to calculate the full size of this example, we need to sum up the sizes of the shared objects and the main executable.</p><div class="table-wrapper"><table><thead><tr><th>Filename<th>Binary size in bytes<tbody><tr><td>libutils.dylib<td>16,800<tr><td>libmoduleA.dylib<td>33,392<tr><td>libmoduleB.dylib<td>33,392<tr><td>libmoduleC.dylib<td>33,392<tr><td>libmoduleD.dylib<td>33,392<tr><td>main<td>39,416<tr><td>overall<td>189,784</table></div><p>To understand how much we lose with dynamic linking if we lose anything, we must try to link these libraries statically too.</p><p>Let me first put here the commands I ran and then let’s review them together:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre>clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-c</span> <span class="nt">-o</span> libutils.o utils.cpp <span class="nt">-include</span> utils.h <span class="nt">-fPIC</span>
ar r libutils.a libutils.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleA.h moduleA.cpp <span class="nt">-o</span> libmoduleA.o <span class="nt">-fPIC</span>
ar r libmoduleA.a libmoduleA.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleB.h moduleB.cpp <span class="nt">-o</span> libmoduleB.o <span class="nt">-fPIC</span>
ar r libmoduleB.a libmoduleB.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleC.h moduleC.cpp <span class="nt">-o</span> libmoduleC.o <span class="nt">-fPIC</span>
ar r libmoduleC.a libmoduleC.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleD.h moduleD.cpp <span class="nt">-o</span> libmoduleD.o <span class="nt">-fPIC</span> 
ar r libmoduleD.a libmoduleD.o

clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lutils</span> <span class="nt">-lmoduleA</span> <span class="nt">-lmoduleB</span> <span class="nt">-lmoduleC</span> <span class="nt">-lmoduleD</span> main.cpp <span class="nt">-o</span> main-static
</pre></table></code></div></div><p>First, instead of compiling everything into a separate dynamic library, I compiled every translation unit (every <code class="language-plaintext highlighter-rouge">.cpp</code> file) into an object (<code class="language-plaintext highlighter-rouge">.o</code>) file. Then I used the <code class="language-plaintext highlighter-rouge">ar</code> command to create a different static library out of each object file.</p><p>As a last step, I compiled <code class="language-plaintext highlighter-rouge">main.cpp</code> and specified each library with the <code class="language-plaintext highlighter-rouge">-l</code> option.</p><p>It’s worth noting that both when I created static and dynamic libraries, the file’s name started with <code class="language-plaintext highlighter-rouge">lib</code> which I had to omit when I passed the library names.</p><p>Now the size of the individual libraries doesn’t matter anymore in the sense that we don’t have to sum them up. Everything that is needed, will be part of our <code class="language-plaintext highlighter-rouge">main-static</code> executable file. But it’s still worth having a look at them just to see their sheer size.</p><div class="table-wrapper"><table><thead><tr><th>Filename<th>Binary size in bytes<tbody><tr><td>libutils.a<td>720<tr><td>libmoduleA.a<td>864<tr><td>libmoduleB.a<td>864<tr><td>libmoduleC.a<td>872<tr><td>libmoduleD.a<td>872</table></div><p>They are two orders of magniture smaller.</p><div class="table-wrapper"><table><thead><tr><th>Filename<th>Binary size in bytes<tbody><tr><td>main-static<td>39,448</table></div><p>As we can see, the size of the executable grew a tiny bit. But let’s not forget that with static linkage, we don’t have to keep the library files around, the executable works on its own! We can easily test this by deleting them and running the executables. The dynamically linked version will crash, while the static one will work fine.</p><p>So in fact, we cut the size from 190 KB to 40 KB.</p><p>We have some alternative ways to compile.</p><p>If we looked at the example attentively, we might have noticed that <code class="language-plaintext highlighter-rouge">libutils</code> is not used by the main executable, but by all the other libraries.</p><p>If we want, we can bundle the utils with each other library. With <code class="language-plaintext highlighter-rouge">ar</code> we cannot include a static library in another, but we can bundle the object files. Instead of uncompressing <code class="language-plaintext highlighter-rouge">libutils.a</code> and using its output, let’s directly use <code class="language-plaintext highlighter-rouge">libutils.o</code>.</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre>clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-c</span> <span class="nt">-o</span> libutils.o utils.cpp <span class="nt">-include</span> utils.h <span class="nt">-fPIC</span>
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleA.h moduleA.cpp <span class="nt">-o</span> libmoduleA.o <span class="nt">-fPIC</span>
ar r libmoduleA.a libmoduleA.o libutils.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleB.h moduleB.cpp <span class="nt">-o</span> libmoduleB.o <span class="nt">-fPIC</span>
ar r libmoduleB.a libmoduleB.o libutils.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleC.h moduleC.cpp <span class="nt">-o</span> libmoduleC.o <span class="nt">-fPIC</span>
ar r libmoduleC.a libmoduleC.o libutils.o
clang++ <span class="nt">-c</span> <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleD.h moduleD.cpp <span class="nt">-o</span> libmoduleD.o <span class="nt">-fPIC</span> 
ar r libmoduleD.a libmoduleD.o libutils.o

clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lmoduleA</span> <span class="nt">-lmoduleB</span> <span class="nt">-lmoduleC</span> <span class="nt">-lmoduleD</span> main.cpp <span class="nt">-o</span> main-static
</pre></table></code></div></div><p>We can observe that while the size of the static libraries increased as they also include the object file created out of <code class="language-plaintext highlighter-rouge">utils.cpp</code>, the size of <code class="language-plaintext highlighter-rouge">main</code> didn’t change at all.</p><div class="table-wrapper"><table><thead><tr><th>Filename<th>Binary size in bytes<tbody><tr><td>libmoduleA.a<td>1,480<tr><td>libmoduleB.a<td>1,480<tr><td>libmoduleC.a<td>1,496<tr><td>libmoduleD.a<td>1,496<tr><td>main<td>39,448</table></div><p>In a certain way, this is safer. Each library contains what it needs. It doesn’t depend on the final step to have its dependencies around. Besides, it doesn’t increase the size of the executable. Of course, you’ll need more space to store the static libraries and overall, packaging the libraries might take more time, but probably these won’t be your main concerns.</p><p>As we are on a quest of decreasing binary sizes, let’s also see what if we compile everything together:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-include</span> moduleA.h moduleA.cpp <span class="nt">-include</span> moduleB.h moduleB.cpp <span class="nt">-include</span> moduleC.h moduleC.cpp <span class="nt">-include</span> moduleD.h moduleD.cpp main.cpp <span class="nt">-o</span> main-static
</pre></table></code></div></div><p>The size of the executable didn’t change, it’s still <code class="language-plaintext highlighter-rouge">39,448</code> bytes.</p><p>It’s worth noting that we didn’t gain anything in terms of executable size.</p><p>At the end of the day, what is better for binary size? Dynamic or static linking?</p><p>As so often, the answer is: it depends.</p><p>This was a small example and the size of the dynamically linked executable (without considering the shared libraries) was only a little bit smaller than the static one. Other times, the size difference will be more significant. Then the question is whether you run different executables on the same machine which could reuse the same shared libraries. If so, you might end up with a smaller overall size than with statically linked executables. On the other hand, if you have only one executable to run, it’s almost 100% sure that linking statically is what you’ll benefit from the most. (<em>In this article we only care about binary size, there are of course other aspects as well.</em>)</p><h2 id="the-dynamic-loader-also-has-a-size">The dynamic loader also has a size</h2><p>There is one more thing! On Windows and on MacOS this won’t matter as tooling is kind of given. But on Linux-based systems where you have a strong control over all the tooling, the question of the dynamic loader might matter.</p><p><code class="language-plaintext highlighter-rouge">ld.so</code> is used to load the dynamic libraries runtime. It also has a cache that help speed up search times.</p><p>If on a system you don’t use anything that is dynamically linked, therefore you don’t need dynamic loading you might remove the dynamic loader. Strictly speaking, it’s not part of your executable size, but that is something that you need for dynamic loading.</p><p>On systems with a very specific purpose, this might be worth considering.</p><h2 id="conclusion">Conclusion</h2><p>With this article, I tried to answer one of the questions I was asked at C++ On Sea. How does dynamic linking influence binary size? The short answer is <em>heavily</em>. The longer answer is that dynamic linking has a big cost, it increases the overall size of your executable combined with the necessary libraries. It’s only worth paying if you share a library between several executables on the same device. If on one device you run only one executable and size is a concern for you for whatever reason, I’d go with static linking.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/staticlinking/" class="post-tag no-text-decoration" >staticlinking</a> <a href="/tags/dynamiclinking/" class="post-tag no-text-decoration" >dynamiclinking</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Binary size: should we use static or dynamic linking? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Binary size: should we use static or dynamic linking? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Binary size: should we use static or dynamic linking? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Binary size: should we use static or dynamic linking? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/10/02/dynamic-vs-static-linking"><div class="card-body"> <span class="timeago small" > Oct 2, 2024 <i class="unloaded">2024-10-02T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>So shall we use static or dynamic linking?</h3><div class="text-muted small"><p> Last week, we were talking about static vs dynamic linking from a binary size point of view. Around the end of the article, I wrote that I omitted other aspects. Now let’s talk briefly about some ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/11/13/implicit-string-conversion-to-bool"><div class="card-body"> <span class="timeago small" > Nov 13, 2024 <i class="unloaded">2024-11-13T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Implicit string conversions to booleans</h3><div class="text-muted small"><p> From C++ Brain Teasers by Anders Schau Knatten, I learned about a compiler warning offered by Clang, called -Wstring-conversion. It emits a warning when a string literal is implicitly converted int...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/09/18/alignment-trap" class="btn btn-outline-primary" prompt="Older"><p>Do it right or do the right thing: The Alignment Trap</p></a> <a href="/blog/2024/10/02/dynamic-vs-static-linking" class="btn btn-outline-primary" prompt="Newer"><p>So shall we use static or dynamic linking?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Binary size: should we use static or dynamic linking?'; this.page.url = 'https://www.sandordargo.com/blog/2024/09/25/dynamic-vs-static-linking-binary-size'; this.page.identifier = '/blog/2024/09/25/dynamic-vs-static-linking-binary-size'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
