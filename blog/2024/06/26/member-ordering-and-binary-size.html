<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Member ordering and binary sizes" /><meta property="og:locale" content="en_US" /><meta name="description" content="While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a performance tuning workshop that the order of member variables can significantly impact the memory layout and size of objects. Considering this factor, you can make your class more cache-friendly to increase runtime performance. This matters mostly when you plan to store a class in big numbers in a container. But what about binary sizes? Before that, let’s first discuss what padding means. Padding and alignment When it comes to the memory layout of data structures, padding refers to the extra bytes inserted between member variables of a data structure to satisfy alignment requirements. These requirements depend on your platform. On most systems, 4-byte integers must start at a memory address that is a multiple of 4. Similarly, 8-byte doubles have to start at addresses that are a multiple of 8. That’s what we call alignment. Padding is the extra space between the variables that helps satisfy the alignment requirements. Alignment is important for optimizing access speed. Let’s take the following example. 1 2 3 4 5 6 7 struct UnoptimalOrder { int i1; // 4 bytes double d1; // 8 bytes int i2; // 4 bytes }; static_assert(sizeof(UnoptimalOrder) == 24); The assertion is true. Even though we have two ints of 4 bytes and one double of 8 bytes, the size of UnoptimalOrder is not the sum. It’s not 16 bytes, but 24. The reason is what I explained just earlier: 8-byte doubles have to start at addresses that are a multiple of 8. Therefore i1 goes to address 0, then it’s followed by 4 bytes of padding so that d1 can be placed on an address that is the multiple of 8. At the end, i2 follows along and some padding so that the size of the whole struct is a multiple of 8. If it would contain types that are 4 bytes large at maximum, it could also be a multiple of 4 bytes. Order elements by size to reduce padding To potentially gain some space in terms of binary size, you have to reduce the size of padding bytes. The easiest and best rule of thumb to follow is to order the members by decreasing size. If we consider the above example, we should start with the biggest member of type double, followed by the two integers. As such we can eliminate all the padding and decrease the size to 16 bytes. Let’s also rename the class to OptimalOrder. 1 2 3 4 5 6 7 struct OptimalOrder { double d1; // 8 bytes int i1; // 4 bytes int i2; // 4 bytes }; static_assert(sizeof(OptimalOrder) == 16); It won’t always reduce binary size If you remember back to the article on object initialization, we saw that often the compiler is smart enough to optimize things and simply use .zerofill to reserve a big enough space. Even if you create an array of 10k objects with static storage duration, the order will not change the size of your binary if everything is default initialized. On the other hand, if one of the members has a value other than (something implicitly convertible to) 0, ordering will matter. The below two examples are both compiled to a binary of 16,888 bytes on my machine. With good ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;array&gt; class Example { public: double a;// = 4.2; // 8 bytes int b;// = 1; // 4 bytes float c; // 4 bytes char d; // 1 byte bool e; // 1 byte bool f; // 1 byte // Assuming typical alignment, &#39;a&#39; (8 bytes) should be first, // followed by &#39;b&#39; and &#39;c&#39; (both 4 bytes), and then &#39;d&#39; and &#39;e&#39; (1 byte each). }; std::array&lt;Example, 10&#39;000&gt; arr {}; static_assert(sizeof(Example) == 24); int main() { return 0; } With bad ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;array&gt; struct Example { int b;//=1; // 4 bytes char d; // 1 byte float c; // 4 bytes bool e; // 1 byte double a;// = 4.2; // 8 bytes bool f; }; std::array&lt;Example, 10&#39;000&gt; arr{}; static_assert(sizeof(Example) == 32); int main() { return 0; } We can observe that the size of Example is 24 bytes in one case, but 32 in the other. Yet the binary size is the same. But as soon as we add some initial values to the members, for example, 1 to b and 4.2 to a, there is a significant size difference. With the good ordering, the size is 264k while with the bad ordering it’s 347k. That’s a big diff! But not as big as the difference between the version with 0 initial values and some others. Conclusion Today we discussed member ordering. We saw that in order to minimize padding, we should order members in a decreasing order of their size. At the same time, even an unoptimal ordering will not change the binary size, if you zero initialize members. So the best thing you can do for binary size is to use default values for members which are implicitly convertible to zero. The second best thing to do is pay attention to member ordering. But that’s something to pay attention to anyway for cache friendliness. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a performance tuning workshop that the order of member variables can significantly impact the memory layout and size of objects. Considering this factor, you can make your class more cache-friendly to increase runtime performance. This matters mostly when you plan to store a class in big numbers in a container. But what about binary sizes? Before that, let’s first discuss what padding means. Padding and alignment When it comes to the memory layout of data structures, padding refers to the extra bytes inserted between member variables of a data structure to satisfy alignment requirements. These requirements depend on your platform. On most systems, 4-byte integers must start at a memory address that is a multiple of 4. Similarly, 8-byte doubles have to start at addresses that are a multiple of 8. That’s what we call alignment. Padding is the extra space between the variables that helps satisfy the alignment requirements. Alignment is important for optimizing access speed. Let’s take the following example. 1 2 3 4 5 6 7 struct UnoptimalOrder { int i1; // 4 bytes double d1; // 8 bytes int i2; // 4 bytes }; static_assert(sizeof(UnoptimalOrder) == 24); The assertion is true. Even though we have two ints of 4 bytes and one double of 8 bytes, the size of UnoptimalOrder is not the sum. It’s not 16 bytes, but 24. The reason is what I explained just earlier: 8-byte doubles have to start at addresses that are a multiple of 8. Therefore i1 goes to address 0, then it’s followed by 4 bytes of padding so that d1 can be placed on an address that is the multiple of 8. At the end, i2 follows along and some padding so that the size of the whole struct is a multiple of 8. If it would contain types that are 4 bytes large at maximum, it could also be a multiple of 4 bytes. Order elements by size to reduce padding To potentially gain some space in terms of binary size, you have to reduce the size of padding bytes. The easiest and best rule of thumb to follow is to order the members by decreasing size. If we consider the above example, we should start with the biggest member of type double, followed by the two integers. As such we can eliminate all the padding and decrease the size to 16 bytes. Let’s also rename the class to OptimalOrder. 1 2 3 4 5 6 7 struct OptimalOrder { double d1; // 8 bytes int i1; // 4 bytes int i2; // 4 bytes }; static_assert(sizeof(OptimalOrder) == 16); It won’t always reduce binary size If you remember back to the article on object initialization, we saw that often the compiler is smart enough to optimize things and simply use .zerofill to reserve a big enough space. Even if you create an array of 10k objects with static storage duration, the order will not change the size of your binary if everything is default initialized. On the other hand, if one of the members has a value other than (something implicitly convertible to) 0, ordering will matter. The below two examples are both compiled to a binary of 16,888 bytes on my machine. With good ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;array&gt; class Example { public: double a;// = 4.2; // 8 bytes int b;// = 1; // 4 bytes float c; // 4 bytes char d; // 1 byte bool e; // 1 byte bool f; // 1 byte // Assuming typical alignment, &#39;a&#39; (8 bytes) should be first, // followed by &#39;b&#39; and &#39;c&#39; (both 4 bytes), and then &#39;d&#39; and &#39;e&#39; (1 byte each). }; std::array&lt;Example, 10&#39;000&gt; arr {}; static_assert(sizeof(Example) == 24); int main() { return 0; } With bad ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;array&gt; struct Example { int b;//=1; // 4 bytes char d; // 1 byte float c; // 4 bytes bool e; // 1 byte double a;// = 4.2; // 8 bytes bool f; }; std::array&lt;Example, 10&#39;000&gt; arr{}; static_assert(sizeof(Example) == 32); int main() { return 0; } We can observe that the size of Example is 24 bytes in one case, but 32 in the other. Yet the binary size is the same. But as soon as we add some initial values to the members, for example, 1 to b and 4.2 to a, there is a significant size difference. With the good ordering, the size is 264k while with the bad ordering it’s 347k. That’s a big diff! But not as big as the difference between the version with 0 initial values and some others. Conclusion Today we discussed member ordering. We saw that in order to minimize padding, we should order members in a decreasing order of their size. At the same time, even an unoptimal ordering will not change the binary size, if you zero initialize members. So the best thing you can do for binary size is to use default values for members which are implicitly convertible to zero. The second best thing to do is pay attention to member ordering. But that’s something to pay attention to anyway for cache friendliness. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-06-26T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Member ordering and binary sizes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-19T06:35:16+02:00","datePublished":"2024-06-26T00:00:00+02:00","description":"While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a performance tuning workshop that the order of member variables can significantly impact the memory layout and size of objects. Considering this factor, you can make your class more cache-friendly to increase runtime performance. This matters mostly when you plan to store a class in big numbers in a container. But what about binary sizes? Before that, let’s first discuss what padding means. Padding and alignment When it comes to the memory layout of data structures, padding refers to the extra bytes inserted between member variables of a data structure to satisfy alignment requirements. These requirements depend on your platform. On most systems, 4-byte integers must start at a memory address that is a multiple of 4. Similarly, 8-byte doubles have to start at addresses that are a multiple of 8. That’s what we call alignment. Padding is the extra space between the variables that helps satisfy the alignment requirements. Alignment is important for optimizing access speed. Let’s take the following example. 1 2 3 4 5 6 7 struct UnoptimalOrder { int i1; // 4 bytes double d1; // 8 bytes int i2; // 4 bytes }; static_assert(sizeof(UnoptimalOrder) == 24); The assertion is true. Even though we have two ints of 4 bytes and one double of 8 bytes, the size of UnoptimalOrder is not the sum. It’s not 16 bytes, but 24. The reason is what I explained just earlier: 8-byte doubles have to start at addresses that are a multiple of 8. Therefore i1 goes to address 0, then it’s followed by 4 bytes of padding so that d1 can be placed on an address that is the multiple of 8. At the end, i2 follows along and some padding so that the size of the whole struct is a multiple of 8. If it would contain types that are 4 bytes large at maximum, it could also be a multiple of 4 bytes. Order elements by size to reduce padding To potentially gain some space in terms of binary size, you have to reduce the size of padding bytes. The easiest and best rule of thumb to follow is to order the members by decreasing size. If we consider the above example, we should start with the biggest member of type double, followed by the two integers. As such we can eliminate all the padding and decrease the size to 16 bytes. Let’s also rename the class to OptimalOrder. 1 2 3 4 5 6 7 struct OptimalOrder { double d1; // 8 bytes int i1; // 4 bytes int i2; // 4 bytes }; static_assert(sizeof(OptimalOrder) == 16); It won’t always reduce binary size If you remember back to the article on object initialization, we saw that often the compiler is smart enough to optimize things and simply use .zerofill to reserve a big enough space. Even if you create an array of 10k objects with static storage duration, the order will not change the size of your binary if everything is default initialized. On the other hand, if one of the members has a value other than (something implicitly convertible to) 0, ordering will matter. The below two examples are both compiled to a binary of 16,888 bytes on my machine. With good ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;array&gt; class Example { public: double a;// = 4.2; // 8 bytes int b;// = 1; // 4 bytes float c; // 4 bytes char d; // 1 byte bool e; // 1 byte bool f; // 1 byte // Assuming typical alignment, &#39;a&#39; (8 bytes) should be first, // followed by &#39;b&#39; and &#39;c&#39; (both 4 bytes), and then &#39;d&#39; and &#39;e&#39; (1 byte each). }; std::array&lt;Example, 10&#39;000&gt; arr {}; static_assert(sizeof(Example) == 24); int main() { return 0; } With bad ordering: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;array&gt; struct Example { int b;//=1; // 4 bytes char d; // 1 byte float c; // 4 bytes bool e; // 1 byte double a;// = 4.2; // 8 bytes bool f; }; std::array&lt;Example, 10&#39;000&gt; arr{}; static_assert(sizeof(Example) == 32); int main() { return 0; } We can observe that the size of Example is 24 bytes in one case, but 32 in the other. Yet the binary size is the same. But as soon as we add some initial values to the members, for example, 1 to b and 4.2 to a, there is a significant size difference. With the good ordering, the size is 264k while with the bad ordering it’s 347k. That’s a big diff! But not as big as the difference between the version with 0 initial values and some others. Conclusion Today we discussed member ordering. We saw that in order to minimize padding, we should order members in a decreasing order of their size. At the same time, even an unoptimal ordering will not change the binary size, if you zero initialize members. So the best thing you can do for binary size is to use default values for members which are implicitly convertible to zero. The second best thing to do is pay attention to member ordering. But that’s something to pay attention to anyway for cache friendliness. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Member ordering and binary sizes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size"},"url":"https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size"}</script><title>Member ordering and binary sizes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/06"> 06 </a> </span> <span> <a href="/26"> 26 </a> </span> <span>Member ordering and binary sizes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Member ordering and binary sizes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jun 26, 2024, 12:00 AM +0200" prep="on" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Jun 19, 2025, 6:35 AM +0200" prefix="Updated " > Jun 19 <i class="unloaded">2025-06-19T06:35:16+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="942 words">5 min</span></div></div><div class="post-content"><p>While I have been preparing my presentation for <a href="https://cpponsea.uk/">C++ On Sea</a>, I realized that something is missing from <a href="https://cpponsea.uk/2024/session/how-to-keep-your-binaries-small">How to keep your binaries small</a>. The importance of member ordering!</p><p>I remember learning at a performance tuning workshop that the order of member variables can significantly impact the memory layout and size of objects. Considering this factor, you can make your class more cache-friendly to increase runtime performance. This matters mostly when you plan to store a class in big numbers in a container.</p><p>But what about binary sizes?</p><p>Before that, let’s first discuss what padding means.</p><h2 id="padding-and-alignment">Padding and alignment</h2><p>When it comes to the memory layout of data structures, padding refers to the extra bytes inserted between member variables of a data structure to satisfy alignment requirements. These requirements depend on your platform.</p><p>On most systems, 4-byte integers must start at a memory address that is a multiple of 4. Similarly, 8-byte <code class="language-plaintext highlighter-rouge">double</code>s have to start at addresses that are a multiple of 8. That’s what we call alignment.</p><p>Padding is the extra space between the variables that helps satisfy the alignment requirements. Alignment is important for optimizing access speed.</p><p>Let’s take the following example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">UnoptimalOrder</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">;</span>     <span class="c1">// 4 bytes</span>
    <span class="kt">double</span> <span class="n">d1</span><span class="p">;</span>  <span class="c1">// 8 bytes</span>
    <span class="kt">int</span> <span class="n">i2</span><span class="p">;</span>     <span class="c1">// 4 bytes</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">UnoptimalOrder</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">);</span>
</pre></table></code></div></div><p>The assertion is true. Even though we have two <code class="language-plaintext highlighter-rouge">int</code>s of 4 bytes and one <code class="language-plaintext highlighter-rouge">double</code> of 8 bytes, the size of <code class="language-plaintext highlighter-rouge">UnoptimalOrder</code> is not the sum. It’s not 16 bytes, but 24. The reason is what I explained just earlier: 8-byte <code class="language-plaintext highlighter-rouge">double</code>s have to start at addresses that are a multiple of 8. Therefore <code class="language-plaintext highlighter-rouge">i1</code> goes to address 0, then it’s followed by 4 bytes of padding so that <code class="language-plaintext highlighter-rouge">d1</code> can be placed on an address that is the multiple of 8. At the end, <code class="language-plaintext highlighter-rouge">i2</code> follows along and some padding so that the size of the whole struct is a multiple of 8.</p><p>If it would contain types that are 4 bytes large at maximum, it could also be a multiple of 4 bytes.</p><h2 id="order-elements-by-size-to-reduce-padding">Order elements by size to reduce padding</h2><p>To potentially gain some space in terms of binary size, you have to reduce the size of padding bytes.</p><p>The easiest and best rule of thumb to follow is to order the members by decreasing size. If we consider the above example, we should start with the biggest member of type <code class="language-plaintext highlighter-rouge">double</code>, followed by the two integers.</p><p>As such we can eliminate all the padding and decrease the size to 16 bytes. Let’s also rename the class to <code class="language-plaintext highlighter-rouge">OptimalOrder</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">OptimalOrder</span> <span class="p">{</span>
    <span class="kt">double</span> <span class="n">d1</span><span class="p">;</span>  <span class="c1">// 8 bytes</span>
    <span class="kt">int</span> <span class="n">i1</span><span class="p">;</span>     <span class="c1">// 4 bytes</span>
    <span class="kt">int</span> <span class="n">i2</span><span class="p">;</span>     <span class="c1">// 4 bytes</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">OptimalOrder</span><span class="p">)</span> <span class="o">==</span> <span class="mi">16</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="it-wont-always-reduce-binary-size">It won’t always reduce binary size</h2><p>If you remember back to the article on object initialization, we saw that often the compiler is smart enough to optimize things and simply use <code class="language-plaintext highlighter-rouge">.zerofill</code> to reserve a big enough space. Even if you create an array of 10k objects with static storage duration, the order will not change the size of your binary if everything is default initialized.</p><p>On the other hand, if one of the members has a value other than (something implicitly convertible to) 0, ordering will matter.</p><p>The below two examples are both compiled to a binary of 16,888 bytes on my machine.</p><p>With good ordering:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Example</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="kt">double</span> <span class="n">a</span><span class="p">;</span><span class="c1">// = 4.2;   // 8 bytes</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span><span class="c1">// = 1;      // 4 bytes</span>
    <span class="kt">float</span> <span class="n">c</span><span class="p">;</span>    <span class="c1">// 4 bytes</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// 1 byte</span>
    <span class="kt">bool</span> <span class="n">e</span><span class="p">;</span>     <span class="c1">// 1 byte</span>
    <span class="kt">bool</span> <span class="n">f</span><span class="p">;</span>     <span class="c1">// 1 byte</span>
    <span class="c1">// Assuming typical alignment, 'a' (8 bytes) should be first,</span>
    <span class="c1">// followed by 'b' and 'c' (both 4 bytes), and then 'd' and 'e' (1 byte each).</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Example</span><span class="p">,</span> <span class="mi">10'000</span><span class="o">&gt;</span> <span class="n">arr</span> <span class="p">{};</span>
<span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Example</span><span class="p">)</span> <span class="o">==</span> <span class="mi">24</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>With bad ordering:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Example</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">b</span><span class="p">;</span><span class="c1">//=1;      // 4 bytes</span>
    <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>     <span class="c1">// 1 byte</span>
    <span class="kt">float</span> <span class="n">c</span><span class="p">;</span>    <span class="c1">// 4 bytes</span>
    <span class="kt">bool</span> <span class="n">e</span><span class="p">;</span>     <span class="c1">// 1 byte</span>
    <span class="kt">double</span> <span class="n">a</span><span class="p">;</span><span class="c1">// = 4.2;   // 8 bytes</span>
    <span class="kt">bool</span> <span class="n">f</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">Example</span><span class="p">,</span> <span class="mi">10'000</span><span class="o">&gt;</span> <span class="n">arr</span><span class="p">{};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Example</span><span class="p">)</span> <span class="o">==</span> <span class="mi">32</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We can observe that the size of <code class="language-plaintext highlighter-rouge">Example</code> is 24 bytes in one case, but 32 in the other. Yet the binary size is the same.</p><p>But as soon as we add some initial values to the members, for example, <code class="language-plaintext highlighter-rouge">1</code> to <code class="language-plaintext highlighter-rouge">b</code> and <code class="language-plaintext highlighter-rouge">4.2</code> to a, there is a significant size difference. With the good ordering, the size is 264k while with the bad ordering it’s 347k.</p><p>That’s a big diff! But not as big as the difference between the version with 0 initial values and some others.</p><h2 id="conclusion">Conclusion</h2><p>Today we discussed member ordering. We saw that in order to minimize padding, we should order members in a decreasing order of their size.</p><p>At the same time, even an unoptimal ordering will not change the binary size, if you zero initialize members. So the best thing you can do for binary size is to use default values for members which are implicitly convertible to zero. The second best thing to do is pay attention to member ordering. But that’s something to pay attention to anyway for cache friendliness.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Member ordering and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Member ordering and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Member ordering and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Member ordering and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/07/31/rule-of-5-once-again"><div class="card-body"> <span class="timeago small" > Jul 31, 2024 <i class="unloaded">2024-07-31T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Once more about the rule of 5</h3><div class="text-muted small"><p> Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/07/rule-of-five-and-base-classes"><div class="card-body"> <span class="timeago small" > Aug 7, 2024 <i class="unloaded">2024-08-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The rule of 5 and inheritance</h3><div class="text-muted small"><p> Last week, we talked about the rule of five and we discovered what it means for move operations if we only declare a destructor and not the rest of the special member functions. In that case, move ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/21/std-ref"><div class="card-body"> <span class="timeago small" > Aug 21, 2024 <i class="unloaded">2024-08-21T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What is std::ref?</h3><div class="text-muted small"><p> Have you heard about std::ref and std::cref? The helper functions that generate objects of type std::reference_wrapper? The answer is probably yes. In that case, this article is probably not for yo...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/06/19/did-you-do-what-i-asked-for" class="btn btn-outline-primary" prompt="Older"><p>Did you do what I asked for or not?</p></a> <a href="/blog/2024/07/03/cpp23-further-small-changes" class="btn btn-outline-primary" prompt="Newer"><p>C++23: further small changes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Member ordering and binary sizes'; this.page.url = 'https://www.sandordargo.com/blog/2024/06/26/member-ordering-and-binary-size'; this.page.identifier = '/blog/2024/06/26/member-ordering-and-binary-size'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
