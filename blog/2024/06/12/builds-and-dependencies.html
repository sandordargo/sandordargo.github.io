<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Limit the number of library dependencies" /><meta property="og:locale" content="en_US" /><meta name="description" content="First, let’s discuss what a dependency is. When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about dependency injection and therefore they think about dependencies of their interfaces. A dependency is an object that the dependee depends on and to break this dependency, the dependee can expect the dependency to be passed through the interface. 1 2 3 4 5 6 7 8 9 10 11 12 void withoutInjection(/* various params*/) { // some code Dependency d; d.doStuff(/* some params*/) // some more code } void withInjection(const Dependency&amp; d, /* various params */) { // some code d.doStuff(/* some params*/) // some more code } But that’s not the kind of dependency that we talk about today. Library dependencies Let’s assume that you have this interface: 1 2 3 4 5 6 7 8 9 10 11 12 // foo.h #include &lt;bar/bar.h&gt; class Foo { public: Foo(Bar b) : m_b(b) {} // ... private: Bar m_b; }; The question is where is Bar defined? Is it part of the same library? Does it come from somewhere else? Let’s assume that Bar is part of a different library. Now Foo’s library (foo) depends on Bar’s library (bar). What does that mean compile-wise? Whether bar is shared or dynamic, at one point we need access to the header file bar/bar.h, so the include statement can be replaced with the contents of the header file. It doesn’t need access to the cpp files though. It doesn’t need the definitions of the symbols. On the other hand, those undefined symbols must be resolved at link time. If bar is a static library, the compiled code will be copied over to your executable. If you use a dynamic library, the compiled code won’t be copied over, but the linker will only add information that is needed during runtime to load the library into memory. Now let’s talk about the situation when your library depends on other libraries, but some other libraries also depend on your library and all links are dynamic. But first, let’s define two terms. The direction of dependencies a downstream dependency of your library is another library that yours depends on an upstream dependency of your library is another library that depends on yours Your library has to be rebuilt every time your downstream dependencies change in a binary-incompatible way. As long as a library changes in a binary-compatible way, its upstream dependencies don’t have to be rebuilt. Without going through the do’s and don’ts of binary compatibility, in a very simplified way, this means that as long as you don’t change the virtual interface of a class or you don’t modify the existing public non-virtual functions, you’re binaries will stay compatible. Now let’s get back to dependencies and their publicness. In the CMake world, a dependency should be declared public (marked as LINK_PUBLIC) if it’s used in your publicly shared header files. If a public header file includes a header from a library, then you depend publicly on that library. If the library you depend on has a binary incompatible change, your library will have to be rebuilt. That change, that need for rebuilt will propagate to your upstream dependencies. Therefore it is also called a transient dependency. That’s why it’s important to limit your public dependencies. You want to avoid forcing your clients to rebuild more frequently than absolutely necessary. What to do to limit your dependencies? This means that we have very good reasons to limit our publicly linked dependencies or even if we don’t live in the CMake world and we do not distinguish between public and non-public links, we should strive to limit the number of header files we include in our publicly-exposed header files. Our build times and library sizes will go down if we follow these efforts. But what can we do in order to limit our dependencies and the number of rebuilds? First of all, we should make sure that we only include in our headers what is absolutely necessary. In other words, delete what you don’t use and delete a bit more. Use forward declarations when you don’t need the full definitions of a type and include the header only in the .cpp file. Also, if many people depend on your library, try to stabilize your API as soon as possible! With that, people don’t have to update their code forcing them to perform some manual work. At the same time, they don’t have to rebuild just if they upgrade the version of your library. They will be thankful. If you’re really serious about these efforts, you might think about separating a library into two different parts. One will be a rarely-changing API and the other an implementation. The API will only contain data structures used in your public interface. They shouldn’t contain any business logic and they should have only minimal dependencies on any other libraries. Besides, this component will only contain abstract interfaces. The other library will depend on the API component and it will contain all the implementations of the abstract interfaces. Many of your users will only have to link against your API component as they won’t be required to instantiate the direct types on their own. Think about users who get your types as return values of other libraries and they will only have to manipulate those returned values but don’t have to construct their own instances. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // somewhere in lib barapi class Storage { public: virtual ~Storage() = default; //... virtual bool addItem(Item) = 0; }; // somewhere in lib foo void baz(std::unique_ptr&lt;Storage&gt; s) { // You don&#39;t need the implementation of Storage::addItem here auto res = s-&gt;addItem(Item{&quot;whatnot&quot;, 42}); // .. } The clients will have to depend on a much smaller library with hopefully fewer dependencies. Make sure that even in your implementation library you limit the number of exposed headers and the number of exposed dependencies. In other words, you don’t have to publish all the header files of your library. If you create some classes in separate .h/.cpp files that are only used within your library and they only exist for better readability, don’t publish them. Even though, if the implementation libraries are only used in leaf components, meaning that they are not used by any other component, it does not matter that much how many of the dependencies are exposed. Still, it’s better to be consistent and follow good habits all the time. Conclusion In this article, we discussed why it’s important to limit the number of dependencies your APIs have. The more libraries you link, the more time it will take. But also the more libraries you link, the more events can force you to recompile, which in general we want to avoid. Limiting the number of dependencies can happen in different ways. You have to be very mindful in terms of what you include in your headers and whenever you can, you should rely on forward declaration. But you should go beyond and if build times matter a lot - because you have a big system that is often changed - make sure that dependencies are limited by design design. A great way to achieve that is by splitting a library into a separate API and an implementation library. The API which will be used by most users will only have a small amount of dependencies and the other one can do the heavy lifting. What are your best practices to limit the number of dependencies your library has or exposes? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="First, let’s discuss what a dependency is. When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about dependency injection and therefore they think about dependencies of their interfaces. A dependency is an object that the dependee depends on and to break this dependency, the dependee can expect the dependency to be passed through the interface. 1 2 3 4 5 6 7 8 9 10 11 12 void withoutInjection(/* various params*/) { // some code Dependency d; d.doStuff(/* some params*/) // some more code } void withInjection(const Dependency&amp; d, /* various params */) { // some code d.doStuff(/* some params*/) // some more code } But that’s not the kind of dependency that we talk about today. Library dependencies Let’s assume that you have this interface: 1 2 3 4 5 6 7 8 9 10 11 12 // foo.h #include &lt;bar/bar.h&gt; class Foo { public: Foo(Bar b) : m_b(b) {} // ... private: Bar m_b; }; The question is where is Bar defined? Is it part of the same library? Does it come from somewhere else? Let’s assume that Bar is part of a different library. Now Foo’s library (foo) depends on Bar’s library (bar). What does that mean compile-wise? Whether bar is shared or dynamic, at one point we need access to the header file bar/bar.h, so the include statement can be replaced with the contents of the header file. It doesn’t need access to the cpp files though. It doesn’t need the definitions of the symbols. On the other hand, those undefined symbols must be resolved at link time. If bar is a static library, the compiled code will be copied over to your executable. If you use a dynamic library, the compiled code won’t be copied over, but the linker will only add information that is needed during runtime to load the library into memory. Now let’s talk about the situation when your library depends on other libraries, but some other libraries also depend on your library and all links are dynamic. But first, let’s define two terms. The direction of dependencies a downstream dependency of your library is another library that yours depends on an upstream dependency of your library is another library that depends on yours Your library has to be rebuilt every time your downstream dependencies change in a binary-incompatible way. As long as a library changes in a binary-compatible way, its upstream dependencies don’t have to be rebuilt. Without going through the do’s and don’ts of binary compatibility, in a very simplified way, this means that as long as you don’t change the virtual interface of a class or you don’t modify the existing public non-virtual functions, you’re binaries will stay compatible. Now let’s get back to dependencies and their publicness. In the CMake world, a dependency should be declared public (marked as LINK_PUBLIC) if it’s used in your publicly shared header files. If a public header file includes a header from a library, then you depend publicly on that library. If the library you depend on has a binary incompatible change, your library will have to be rebuilt. That change, that need for rebuilt will propagate to your upstream dependencies. Therefore it is also called a transient dependency. That’s why it’s important to limit your public dependencies. You want to avoid forcing your clients to rebuild more frequently than absolutely necessary. What to do to limit your dependencies? This means that we have very good reasons to limit our publicly linked dependencies or even if we don’t live in the CMake world and we do not distinguish between public and non-public links, we should strive to limit the number of header files we include in our publicly-exposed header files. Our build times and library sizes will go down if we follow these efforts. But what can we do in order to limit our dependencies and the number of rebuilds? First of all, we should make sure that we only include in our headers what is absolutely necessary. In other words, delete what you don’t use and delete a bit more. Use forward declarations when you don’t need the full definitions of a type and include the header only in the .cpp file. Also, if many people depend on your library, try to stabilize your API as soon as possible! With that, people don’t have to update their code forcing them to perform some manual work. At the same time, they don’t have to rebuild just if they upgrade the version of your library. They will be thankful. If you’re really serious about these efforts, you might think about separating a library into two different parts. One will be a rarely-changing API and the other an implementation. The API will only contain data structures used in your public interface. They shouldn’t contain any business logic and they should have only minimal dependencies on any other libraries. Besides, this component will only contain abstract interfaces. The other library will depend on the API component and it will contain all the implementations of the abstract interfaces. Many of your users will only have to link against your API component as they won’t be required to instantiate the direct types on their own. Think about users who get your types as return values of other libraries and they will only have to manipulate those returned values but don’t have to construct their own instances. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // somewhere in lib barapi class Storage { public: virtual ~Storage() = default; //... virtual bool addItem(Item) = 0; }; // somewhere in lib foo void baz(std::unique_ptr&lt;Storage&gt; s) { // You don&#39;t need the implementation of Storage::addItem here auto res = s-&gt;addItem(Item{&quot;whatnot&quot;, 42}); // .. } The clients will have to depend on a much smaller library with hopefully fewer dependencies. Make sure that even in your implementation library you limit the number of exposed headers and the number of exposed dependencies. In other words, you don’t have to publish all the header files of your library. If you create some classes in separate .h/.cpp files that are only used within your library and they only exist for better readability, don’t publish them. Even though, if the implementation libraries are only used in leaf components, meaning that they are not used by any other component, it does not matter that much how many of the dependencies are exposed. Still, it’s better to be consistent and follow good habits all the time. Conclusion In this article, we discussed why it’s important to limit the number of dependencies your APIs have. The more libraries you link, the more time it will take. But also the more libraries you link, the more events can force you to recompile, which in general we want to avoid. Limiting the number of dependencies can happen in different ways. You have to be very mindful in terms of what you include in your headers and whenever you can, you should rely on forward declaration. But you should go beyond and if build times matter a lot - because you have a big system that is often changed - make sure that dependencies are limited by design design. A great way to achieve that is by splitting a library into a separate API and an implementation library. The API which will be used by most users will only have a small amount of dependencies and the other one can do the heavy lifting. What are your best practices to limit the number of dependencies your library has or exposes? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-06-12T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Limit the number of library dependencies" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-06-12T00:00:00+02:00","datePublished":"2024-06-12T00:00:00+02:00","description":"First, let’s discuss what a dependency is. When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about dependency injection and therefore they think about dependencies of their interfaces. A dependency is an object that the dependee depends on and to break this dependency, the dependee can expect the dependency to be passed through the interface. 1 2 3 4 5 6 7 8 9 10 11 12 void withoutInjection(/* various params*/) { // some code Dependency d; d.doStuff(/* some params*/) // some more code } void withInjection(const Dependency&amp; d, /* various params */) { // some code d.doStuff(/* some params*/) // some more code } But that’s not the kind of dependency that we talk about today. Library dependencies Let’s assume that you have this interface: 1 2 3 4 5 6 7 8 9 10 11 12 // foo.h #include &lt;bar/bar.h&gt; class Foo { public: Foo(Bar b) : m_b(b) {} // ... private: Bar m_b; }; The question is where is Bar defined? Is it part of the same library? Does it come from somewhere else? Let’s assume that Bar is part of a different library. Now Foo’s library (foo) depends on Bar’s library (bar). What does that mean compile-wise? Whether bar is shared or dynamic, at one point we need access to the header file bar/bar.h, so the include statement can be replaced with the contents of the header file. It doesn’t need access to the cpp files though. It doesn’t need the definitions of the symbols. On the other hand, those undefined symbols must be resolved at link time. If bar is a static library, the compiled code will be copied over to your executable. If you use a dynamic library, the compiled code won’t be copied over, but the linker will only add information that is needed during runtime to load the library into memory. Now let’s talk about the situation when your library depends on other libraries, but some other libraries also depend on your library and all links are dynamic. But first, let’s define two terms. The direction of dependencies a downstream dependency of your library is another library that yours depends on an upstream dependency of your library is another library that depends on yours Your library has to be rebuilt every time your downstream dependencies change in a binary-incompatible way. As long as a library changes in a binary-compatible way, its upstream dependencies don’t have to be rebuilt. Without going through the do’s and don’ts of binary compatibility, in a very simplified way, this means that as long as you don’t change the virtual interface of a class or you don’t modify the existing public non-virtual functions, you’re binaries will stay compatible. Now let’s get back to dependencies and their publicness. In the CMake world, a dependency should be declared public (marked as LINK_PUBLIC) if it’s used in your publicly shared header files. If a public header file includes a header from a library, then you depend publicly on that library. If the library you depend on has a binary incompatible change, your library will have to be rebuilt. That change, that need for rebuilt will propagate to your upstream dependencies. Therefore it is also called a transient dependency. That’s why it’s important to limit your public dependencies. You want to avoid forcing your clients to rebuild more frequently than absolutely necessary. What to do to limit your dependencies? This means that we have very good reasons to limit our publicly linked dependencies or even if we don’t live in the CMake world and we do not distinguish between public and non-public links, we should strive to limit the number of header files we include in our publicly-exposed header files. Our build times and library sizes will go down if we follow these efforts. But what can we do in order to limit our dependencies and the number of rebuilds? First of all, we should make sure that we only include in our headers what is absolutely necessary. In other words, delete what you don’t use and delete a bit more. Use forward declarations when you don’t need the full definitions of a type and include the header only in the .cpp file. Also, if many people depend on your library, try to stabilize your API as soon as possible! With that, people don’t have to update their code forcing them to perform some manual work. At the same time, they don’t have to rebuild just if they upgrade the version of your library. They will be thankful. If you’re really serious about these efforts, you might think about separating a library into two different parts. One will be a rarely-changing API and the other an implementation. The API will only contain data structures used in your public interface. They shouldn’t contain any business logic and they should have only minimal dependencies on any other libraries. Besides, this component will only contain abstract interfaces. The other library will depend on the API component and it will contain all the implementations of the abstract interfaces. Many of your users will only have to link against your API component as they won’t be required to instantiate the direct types on their own. Think about users who get your types as return values of other libraries and they will only have to manipulate those returned values but don’t have to construct their own instances. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // somewhere in lib barapi class Storage { public: virtual ~Storage() = default; //... virtual bool addItem(Item) = 0; }; // somewhere in lib foo void baz(std::unique_ptr&lt;Storage&gt; s) { // You don&#39;t need the implementation of Storage::addItem here auto res = s-&gt;addItem(Item{&quot;whatnot&quot;, 42}); // .. } The clients will have to depend on a much smaller library with hopefully fewer dependencies. Make sure that even in your implementation library you limit the number of exposed headers and the number of exposed dependencies. In other words, you don’t have to publish all the header files of your library. If you create some classes in separate .h/.cpp files that are only used within your library and they only exist for better readability, don’t publish them. Even though, if the implementation libraries are only used in leaf components, meaning that they are not used by any other component, it does not matter that much how many of the dependencies are exposed. Still, it’s better to be consistent and follow good habits all the time. Conclusion In this article, we discussed why it’s important to limit the number of dependencies your APIs have. The more libraries you link, the more time it will take. But also the more libraries you link, the more events can force you to recompile, which in general we want to avoid. Limiting the number of dependencies can happen in different ways. You have to be very mindful in terms of what you include in your headers and whenever you can, you should rely on forward declaration. But you should go beyond and if build times matter a lot - because you have a big system that is often changed - make sure that dependencies are limited by design design. A great way to achieve that is by splitting a library into a separate API and an implementation library. The API which will be used by most users will only have a small amount of dependencies and the other one can do the heavy lifting. What are your best practices to limit the number of dependencies your library has or exposes? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Limit the number of library dependencies","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies"},"url":"https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies"}</script><title>Limit the number of library dependencies | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/06"> 06 </a> </span> <span> <a href="/12"> 12 </a> </span> <span>Limit the number of library dependencies</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Limit the number of library dependencies</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jun 12, 2024, 12:00 AM +0200" prep="on" > Jun 12, 2024 <i class="unloaded">2024-06-12T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1299 words">7 min</span></div></div><div class="post-content"><p>First, let’s discuss what a dependency is.</p><p>When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about <a href="https://en.wikipedia.org/wiki/Dependency_injection">dependency injection</a> and therefore they think about dependencies of their interfaces. A dependency is an object that the dependee depends on and to break this dependency, the dependee can expect the dependency to be passed through the interface.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">withoutInjection</span><span class="p">(</span><span class="cm">/* various params*/</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// some code</span>
	<span class="n">Dependency</span> <span class="n">d</span><span class="p">;</span>
	<span class="n">d</span><span class="p">.</span><span class="n">doStuff</span><span class="p">(</span><span class="cm">/* some params*/</span><span class="p">)</span>
	<span class="c1">// some more code</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">withInjection</span><span class="p">(</span><span class="k">const</span> <span class="n">Dependency</span><span class="o">&amp;</span> <span class="n">d</span><span class="p">,</span> <span class="cm">/* various params */</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// some code</span>
	<span class="n">d</span><span class="p">.</span><span class="n">doStuff</span><span class="p">(</span><span class="cm">/* some params*/</span><span class="p">)</span>
	<span class="c1">// some more code</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But that’s not the kind of dependency that we talk about today.</p><h2 id="library-dependencies">Library dependencies</h2><p>Let’s assume that you have this interface:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="c1">// foo.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;bar/bar.h&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Foo</span><span class="p">(</span><span class="n">Bar</span> <span class="n">b</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_b</span><span class="p">(</span><span class="n">b</span><span class="p">)</span> <span class="p">{}</span>

	<span class="c1">// ...</span>

<span class="k">private</span><span class="o">:</span>
	<span class="n">Bar</span> <span class="n">m_b</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>The question is where is <code class="language-plaintext highlighter-rouge">Bar</code> defined? Is it part of the same library? Does it come from somewhere else?</p><p>Let’s assume that <code class="language-plaintext highlighter-rouge">Bar</code> is part of a different library. Now <code class="language-plaintext highlighter-rouge">Foo</code>’s library (<code class="language-plaintext highlighter-rouge">foo</code>) depends on <code class="language-plaintext highlighter-rouge">Bar</code>’s library (<code class="language-plaintext highlighter-rouge">bar</code>). What does that mean compile-wise?</p><p>Whether <code class="language-plaintext highlighter-rouge">bar</code> is shared or dynamic, at one point we need access to the header file <code class="language-plaintext highlighter-rouge">bar/bar.h</code>, so the include statement can be replaced with the contents of the header file. It doesn’t need access to the <code class="language-plaintext highlighter-rouge">cpp</code> files though. It doesn’t need the definitions of the symbols.</p><p>On the other hand, those undefined symbols must be resolved at link time. If <code class="language-plaintext highlighter-rouge">bar</code> is a <em>static library</em>, the compiled code will be copied over to your executable. If you use a <em>dynamic library</em>, the compiled code won’t be copied over, but the linker will only add information that is needed during runtime to load the library into memory.</p><p>Now let’s talk about the situation when your library depends on other libraries, but some other libraries also depend on your library and all links are dynamic.</p><p>But first, let’s define two terms.</p><h2 id="the-direction-of-dependencies">The direction of dependencies</h2><ul><li>a <strong>downstream dependency</strong> of your library is another library that yours depends on<li>an <strong>upstream dependency</strong> of your library is another library that depends on yours</ul><p>Your library has to be rebuilt every time your downstream dependencies change in a binary-incompatible way. As long as a library changes in a <a href="https://community.kde.org/Policies/Binary_Compatibility_Issues_With_C%2B%2B">binary-compatible way</a>, its upstream dependencies don’t have to be rebuilt.</p><p>Without going through the do’s and don’ts of binary compatibility, in a very simplified way, this means that as long as you don’t change the <code class="language-plaintext highlighter-rouge">virtual</code> interface of a class or you don’t modify the existing public non-<code class="language-plaintext highlighter-rouge">virtual</code> functions, you’re binaries will stay compatible.</p><p>Now let’s get back to dependencies and their publicness. In the CMake world, a dependency should be declared public (marked as <code class="language-plaintext highlighter-rouge">LINK_PUBLIC</code>) if it’s used in your publicly shared header files. If a public header file includes a header from a library, then you depend publicly on that library. If the library you depend on has a binary incompatible change, your library will have to be rebuilt. That change, that need for rebuilt will propagate to your upstream dependencies. Therefore it is also called a transient dependency.</p><p>That’s why it’s important to limit your public dependencies. You want to avoid forcing your clients to rebuild more frequently than absolutely necessary.</p><h2 id="what-to-do-to-limit-your-dependencies">What to do to limit your dependencies?</h2><p>This means that we have very good reasons to limit our publicly linked dependencies or even if we don’t live in the CMake world and we do not distinguish between public and non-public links, we should strive to limit the number of header files we include in our publicly-exposed header files. Our build times and library sizes will go down if we follow these efforts.</p><p>But what can we do in order to limit our dependencies and the number of rebuilds?</p><p>First of all, we should make sure that we only include in our headers what is absolutely necessary. In other words, delete what you don’t use and delete a bit more. Use <a href="https://www.learncpp.com/cpp-tutorial/forward-declarations/">forward declarations</a> when you don’t need the full definitions of a type and include the header only in the <code class="language-plaintext highlighter-rouge">.cpp</code> file.</p><p>Also, if many people depend on your library, try to stabilize your API as soon as possible! With that, people don’t have to update their code forcing them to perform some manual work. At the same time, they don’t have to rebuild just if they upgrade the version of your library. They will be thankful.</p><p>If you’re really serious about these efforts, you might think about separating a library into two different parts. One will be a rarely-changing API and the other an implementation. The API will only contain data structures used in your public interface. They shouldn’t contain any business logic and they should have only minimal dependencies on any other libraries. Besides, this component will only contain abstract interfaces.</p><p>The other library will depend on the API component and it will contain all the implementations of the abstract interfaces. Many of your users will only have to link against your API component as they won’t be required to instantiate the direct types on their own. Think about users who get your types as return values of other libraries and they will only have to manipulate those returned values but don’t have to construct their own instances.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="c1">// somewhere in lib barapi</span>

<span class="k">class</span> <span class="nc">Storage</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="o">~</span><span class="n">Storage</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="c1">//...</span>
	<span class="k">virtual</span> <span class="kt">bool</span> <span class="n">addItem</span><span class="p">(</span><span class="n">Item</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// somewhere in lib foo</span>

<span class="kt">void</span> <span class="nf">baz</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Storage</span><span class="o">&gt;</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span>
	<span class="c1">// You don't need the implementation of Storage::addItem here </span>
	<span class="k">auto</span> <span class="n">res</span> <span class="o">=</span> <span class="n">s</span><span class="o">-&gt;</span><span class="n">addItem</span><span class="p">(</span><span class="n">Item</span><span class="p">{</span><span class="s">"whatnot"</span><span class="p">,</span> <span class="mi">42</span><span class="p">});</span>
	<span class="c1">// ..</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The clients will have to depend on a much smaller library with hopefully fewer dependencies. Make sure that even in your implementation library you limit the number of exposed headers and the number of exposed dependencies. In other words, you don’t have to publish all the header files of your library. If you create some classes in separate <code class="language-plaintext highlighter-rouge">.h</code>/<code class="language-plaintext highlighter-rouge">.cpp</code> files that are only used within your library and they <em>only</em> exist for better readability, don’t publish them.</p><p>Even though, if the implementation libraries are only used in leaf components, meaning that they are not used by any other component, it does not matter that much how many of the dependencies are exposed. Still, it’s better to be consistent and follow good habits all the time.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we discussed why it’s important to limit the number of dependencies your APIs have. The more libraries you link, the more time it will take. But also the more libraries you link, the more events can force you to recompile, which in general we want to avoid.</p><p>Limiting the number of dependencies can happen in different ways. You have to be very mindful in terms of what you include in your headers and whenever you can, you should rely on forward declaration. But you should go beyond and if build times matter a lot - because you have a big system that is often changed - make sure that dependencies are limited by design design. A great way to achieve that is by splitting a library into a separate API and an implementation library. The API which will be used by most users will only have a small amount of dependencies and the other one can do the heavy lifting.</p><p>What are your best practices to limit the number of dependencies your library has or exposes?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/builds/" class="post-tag no-text-decoration" >builds</a> <a href="/tags/dependencies/" class="post-tag no-text-decoration" >dependencies</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Limit the number of library dependencies - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Limit the number of library dependencies - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Limit the number of library dependencies - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Limit the number of library dependencies - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/07/17/what-should-be-a-default-value"><div class="card-body"> <span class="timeago small" > Jul 17, 2024 <i class="unloaded">2024-07-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What to do if you don't want a default constructor?</h3><div class="text-muted small"><p> Do we need a default constructor? What does it mean to have a default constructor? What happens if we don’t have one? Those are the questions we are going after in this article. A default construc...</p></div></div></a></div><div class="card"> <a href="/blog/2022/07/23/hands-on-design-patterns-by-fedor-pikus"><div class="card-body"> <span class="timeago small" > Jul 23, 2022 <i class="unloaded">2022-07-23T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hands-On Design Patterns with C++ by Fedor Pikus</h3><div class="text-muted small"><p> In Hands-On Design Patterns with C++, the author Fedor Pikus shares the most common design patterns used in modern C++. In fact, not only design patterns but also some best practices and idioms. He...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/17/cpp-software-design-by-klaus-iglberger"><div class="card-body"> <span class="timeago small" > Dec 17, 2022 <i class="unloaded">2022-12-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ Software Design by Klaus Iglberger</h3><div class="text-muted small"><p> The first time I - virtually - met Klaus was at C++ On Sea, I think in 2020. He held a workshop about modern software design which I managed to partially attend. He spoke in a slow and friendly man...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/06/05/the-limits-of-maybe-unused" class="btn btn-outline-primary" prompt="Older"><p>The limits of `[[maybe_unused]]`</p></a> <a href="/blog/2024/06/19/did-you-do-what-i-asked-for" class="btn btn-outline-primary" prompt="Newer"><p>Did you do what I asked for or not?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Limit the number of library dependencies'; this.page.url = 'https://www.sandordargo.com/blog/2024/06/12/builds-and-dependencies'; this.page.identifier = '/blog/2024/06/12/builds-and-dependencies'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
