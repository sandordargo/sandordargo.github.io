<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: further small changes" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this article, let’s get back to exploring C++23. We are going to have a look at some unrelated small changes in the standard, including the rarest species of changes. Deprecations! Printing volatile pointers P1147R1 has pointed out and fixed an interesting behaviour of std::cout with pointers. Let’s assume that we have p0 and p1 pointers pointing at the same address (0xdeadbeef), but their type is different. p0 is int* while p1 is volatile int*. If you happen to print those addresses with cout, the output will be different for the two pointers. While printing p0 used to output the actual address, p1 on the other hand used to print 1. The reason behind is that for the two pointers, different overloads of std::cout matched. int* was implicitly converted to const void*, but volatile int* was converted to bool. Thanks to P1147R1, a new overload const volatile void* has been introduced which const_casts away volatile and calls const void*. As a result, printing the values of int* and volatile int* is the same now. Clarifying the status of the “C headers” P2340R1 is actually both a good read and a meaningful update to the standard. You’re probably aware of so-called C headers in C++. Most ISO C headers are available in C++ in two forms. For one, you have the C-style headers following the &lt;name.h&gt; conventions and also the C++ version of them following the &lt;cname&gt; convention with the same names declared in it but within the std namespace. For example, there is &lt;stdint.h&gt; with all the fixed width integer types declared in it in the global namespace, such as int8_t, int16_t, etc; and there is the C++ version called &lt;cstdint&gt; with std::int8_t, std::int16_t, etc. Since the beginning of the C++ standard, the C headers (&lt;name.h&gt;) have been deprecated, in other words, subject to future removal, whereas everyone knew that they wouldn’t go anywhere due to reasons of interoperability with C. The usage of C headers is needed when code must be valid C++ and valid C code. Otherwise, in pure C++ code, we should use the C++ versions. At the same time, the need for the C headers is not going away. This proposal makes C headers no longer deprecated, but assigns them a state called “for foreign-language interoperability only.” std::unreachable() P0627R6 is introducing a new standard library function in the &lt;utility&gt; header, std::unreachable(). std::unreachable() serves to mark locations in code that are known to the compiler to be unreachable. Let’s take an example where we have a function foo taking an int n which can only have the values 0, 1, 2 or 3. The function contains a switch statement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int n) { switch (n) { case 0: case 2: handle_0_or_2(); break; case 1: handle_1(); break; case 3: handle_3(); break; } } The compiler will not know that n cannot be smaller than 0 or bigger than 3, so it might generate some extra instructions to skip the whole switch statement if the value is different. One option would be to use an enum in these cases, but it might not always be possible and we could find other usages for std::unreachable(). So another way to omit such extra code is to mark other cases unreachable. It’s already possible with some compiler- and/or platform-specific functions such as __builtin_reachable() or __assume(false), but with C++23 we also get the standard way to this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void foo(int n) { switch (n) { case 0: case 2: handle_0_or_2(); break; case 1: handle_1(); break; case 3: handle_3(); break; default: std::unreachable(); } } If std::unreachable() is still reached, the behaviour is undefined. For an interesting read on design decisions and comparison with contract-based programming, check out P0627R6. Deprecate std::aligned_storage and std::aligned_union We often say that one of the superpowers of C++ is backward compatibility. Very few things get deprecated even less removed. We discussed already that the support for garbage collection has been removed from C++. Today we finish this article, with a couple of deprecations. Let’s start with P1413R3 which deprecates std::aligned_storage and std::aligned_union. These functions are niche, they are mainly used for containers by utility libraries, such as Abseil, Boost or Folly. The reason behind removing these functions is their poor, unsafe and sometimes even misleading APIs. They require extensive usage of reinterpret_cast and as such they are prone to invoke undefined behaviour. They fail to provide upper-bound guarantees on the size of the resulting type and some of the default template arguments are misleading and lead to errors. If you want to learn about the details of these issues, read the “On the API” section of P1413R3. If you happen to use these aligned_* functions, most probably you’re aware of this and the suggested replacement which is using std::byte in combination with the alignas attribute. 1 2 - std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; t_buff; + alignas(T) std::byte t_buff[sizeof(T)]; Deprecate std::numeric_limits::has_denorm and std::numeric_limits::has_denorm_loss This change goes hand in hand with a change in C where _HAS_SUBNORM macros are getting obsoleted. Most probably you never used these functions. Even the author of P2614R2 claims that no code relies on these. Why this paper is interesting and we refer back once again to that superpower of backwards-compatibility because the author explicitly says that these functions are not helpful and can be even misleading, yet they cannot be removed. They should be deprecated, so marked as not to be used, but without the intent of actual removal! The reason: that would be a major compatibility break. I’m not in the position to judge this approach, but it’s definitely a reason why the standard is ever-growing and why certain people think that the language is getting more and more complex. Conclusion In this article, we reviewed some small changes in the standard. We’ve how printing volatile pointers is getting fixed, we’ve seen that marking unreachable parts of code is getting standardized and we’ve also had a look at the deprecation of some niche or not even used functions from the standard library. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this article, let’s get back to exploring C++23. We are going to have a look at some unrelated small changes in the standard, including the rarest species of changes. Deprecations! Printing volatile pointers P1147R1 has pointed out and fixed an interesting behaviour of std::cout with pointers. Let’s assume that we have p0 and p1 pointers pointing at the same address (0xdeadbeef), but their type is different. p0 is int* while p1 is volatile int*. If you happen to print those addresses with cout, the output will be different for the two pointers. While printing p0 used to output the actual address, p1 on the other hand used to print 1. The reason behind is that for the two pointers, different overloads of std::cout matched. int* was implicitly converted to const void*, but volatile int* was converted to bool. Thanks to P1147R1, a new overload const volatile void* has been introduced which const_casts away volatile and calls const void*. As a result, printing the values of int* and volatile int* is the same now. Clarifying the status of the “C headers” P2340R1 is actually both a good read and a meaningful update to the standard. You’re probably aware of so-called C headers in C++. Most ISO C headers are available in C++ in two forms. For one, you have the C-style headers following the &lt;name.h&gt; conventions and also the C++ version of them following the &lt;cname&gt; convention with the same names declared in it but within the std namespace. For example, there is &lt;stdint.h&gt; with all the fixed width integer types declared in it in the global namespace, such as int8_t, int16_t, etc; and there is the C++ version called &lt;cstdint&gt; with std::int8_t, std::int16_t, etc. Since the beginning of the C++ standard, the C headers (&lt;name.h&gt;) have been deprecated, in other words, subject to future removal, whereas everyone knew that they wouldn’t go anywhere due to reasons of interoperability with C. The usage of C headers is needed when code must be valid C++ and valid C code. Otherwise, in pure C++ code, we should use the C++ versions. At the same time, the need for the C headers is not going away. This proposal makes C headers no longer deprecated, but assigns them a state called “for foreign-language interoperability only.” std::unreachable() P0627R6 is introducing a new standard library function in the &lt;utility&gt; header, std::unreachable(). std::unreachable() serves to mark locations in code that are known to the compiler to be unreachable. Let’s take an example where we have a function foo taking an int n which can only have the values 0, 1, 2 or 3. The function contains a switch statement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int n) { switch (n) { case 0: case 2: handle_0_or_2(); break; case 1: handle_1(); break; case 3: handle_3(); break; } } The compiler will not know that n cannot be smaller than 0 or bigger than 3, so it might generate some extra instructions to skip the whole switch statement if the value is different. One option would be to use an enum in these cases, but it might not always be possible and we could find other usages for std::unreachable(). So another way to omit such extra code is to mark other cases unreachable. It’s already possible with some compiler- and/or platform-specific functions such as __builtin_reachable() or __assume(false), but with C++23 we also get the standard way to this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void foo(int n) { switch (n) { case 0: case 2: handle_0_or_2(); break; case 1: handle_1(); break; case 3: handle_3(); break; default: std::unreachable(); } } If std::unreachable() is still reached, the behaviour is undefined. For an interesting read on design decisions and comparison with contract-based programming, check out P0627R6. Deprecate std::aligned_storage and std::aligned_union We often say that one of the superpowers of C++ is backward compatibility. Very few things get deprecated even less removed. We discussed already that the support for garbage collection has been removed from C++. Today we finish this article, with a couple of deprecations. Let’s start with P1413R3 which deprecates std::aligned_storage and std::aligned_union. These functions are niche, they are mainly used for containers by utility libraries, such as Abseil, Boost or Folly. The reason behind removing these functions is their poor, unsafe and sometimes even misleading APIs. They require extensive usage of reinterpret_cast and as such they are prone to invoke undefined behaviour. They fail to provide upper-bound guarantees on the size of the resulting type and some of the default template arguments are misleading and lead to errors. If you want to learn about the details of these issues, read the “On the API” section of P1413R3. If you happen to use these aligned_* functions, most probably you’re aware of this and the suggested replacement which is using std::byte in combination with the alignas attribute. 1 2 - std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; t_buff; + alignas(T) std::byte t_buff[sizeof(T)]; Deprecate std::numeric_limits::has_denorm and std::numeric_limits::has_denorm_loss This change goes hand in hand with a change in C where _HAS_SUBNORM macros are getting obsoleted. Most probably you never used these functions. Even the author of P2614R2 claims that no code relies on these. Why this paper is interesting and we refer back once again to that superpower of backwards-compatibility because the author explicitly says that these functions are not helpful and can be even misleading, yet they cannot be removed. They should be deprecated, so marked as not to be used, but without the intent of actual removal! The reason: that would be a major compatibility break. I’m not in the position to judge this approach, but it’s definitely a reason why the standard is ever-growing and why certain people think that the language is getting more and more complex. Conclusion In this article, we reviewed some small changes in the standard. We’ve how printing volatile pointers is getting fixed, we’ve seen that marking unreachable parts of code is getting standardized and we’ve also had a look at the deprecation of some niche or not even used functions from the standard library. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-03T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: further small changes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-03T00:00:00+02:00","datePublished":"2024-07-03T00:00:00+02:00","description":"In this article, let’s get back to exploring C++23. We are going to have a look at some unrelated small changes in the standard, including the rarest species of changes. Deprecations! Printing volatile pointers P1147R1 has pointed out and fixed an interesting behaviour of std::cout with pointers. Let’s assume that we have p0 and p1 pointers pointing at the same address (0xdeadbeef), but their type is different. p0 is int* while p1 is volatile int*. If you happen to print those addresses with cout, the output will be different for the two pointers. While printing p0 used to output the actual address, p1 on the other hand used to print 1. The reason behind is that for the two pointers, different overloads of std::cout matched. int* was implicitly converted to const void*, but volatile int* was converted to bool. Thanks to P1147R1, a new overload const volatile void* has been introduced which const_casts away volatile and calls const void*. As a result, printing the values of int* and volatile int* is the same now. Clarifying the status of the “C headers” P2340R1 is actually both a good read and a meaningful update to the standard. You’re probably aware of so-called C headers in C++. Most ISO C headers are available in C++ in two forms. For one, you have the C-style headers following the &lt;name.h&gt; conventions and also the C++ version of them following the &lt;cname&gt; convention with the same names declared in it but within the std namespace. For example, there is &lt;stdint.h&gt; with all the fixed width integer types declared in it in the global namespace, such as int8_t, int16_t, etc; and there is the C++ version called &lt;cstdint&gt; with std::int8_t, std::int16_t, etc. Since the beginning of the C++ standard, the C headers (&lt;name.h&gt;) have been deprecated, in other words, subject to future removal, whereas everyone knew that they wouldn’t go anywhere due to reasons of interoperability with C. The usage of C headers is needed when code must be valid C++ and valid C code. Otherwise, in pure C++ code, we should use the C++ versions. At the same time, the need for the C headers is not going away. This proposal makes C headers no longer deprecated, but assigns them a state called “for foreign-language interoperability only.” std::unreachable() P0627R6 is introducing a new standard library function in the &lt;utility&gt; header, std::unreachable(). std::unreachable() serves to mark locations in code that are known to the compiler to be unreachable. Let’s take an example where we have a function foo taking an int n which can only have the values 0, 1, 2 or 3. The function contains a switch statement. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 void foo(int n) { switch (n) { case 0: case 2: handle_0_or_2(); break; case 1: handle_1(); break; case 3: handle_3(); break; } } The compiler will not know that n cannot be smaller than 0 or bigger than 3, so it might generate some extra instructions to skip the whole switch statement if the value is different. One option would be to use an enum in these cases, but it might not always be possible and we could find other usages for std::unreachable(). So another way to omit such extra code is to mark other cases unreachable. It’s already possible with some compiler- and/or platform-specific functions such as __builtin_reachable() or __assume(false), but with C++23 we also get the standard way to this. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 void foo(int n) { switch (n) { case 0: case 2: handle_0_or_2(); break; case 1: handle_1(); break; case 3: handle_3(); break; default: std::unreachable(); } } If std::unreachable() is still reached, the behaviour is undefined. For an interesting read on design decisions and comparison with contract-based programming, check out P0627R6. Deprecate std::aligned_storage and std::aligned_union We often say that one of the superpowers of C++ is backward compatibility. Very few things get deprecated even less removed. We discussed already that the support for garbage collection has been removed from C++. Today we finish this article, with a couple of deprecations. Let’s start with P1413R3 which deprecates std::aligned_storage and std::aligned_union. These functions are niche, they are mainly used for containers by utility libraries, such as Abseil, Boost or Folly. The reason behind removing these functions is their poor, unsafe and sometimes even misleading APIs. They require extensive usage of reinterpret_cast and as such they are prone to invoke undefined behaviour. They fail to provide upper-bound guarantees on the size of the resulting type and some of the default template arguments are misleading and lead to errors. If you want to learn about the details of these issues, read the “On the API” section of P1413R3. If you happen to use these aligned_* functions, most probably you’re aware of this and the suggested replacement which is using std::byte in combination with the alignas attribute. 1 2 - std::aligned_storage_t&lt;sizeof(T), alignof(T)&gt; t_buff; + alignas(T) std::byte t_buff[sizeof(T)]; Deprecate std::numeric_limits::has_denorm and std::numeric_limits::has_denorm_loss This change goes hand in hand with a change in C where _HAS_SUBNORM macros are getting obsoleted. Most probably you never used these functions. Even the author of P2614R2 claims that no code relies on these. Why this paper is interesting and we refer back once again to that superpower of backwards-compatibility because the author explicitly says that these functions are not helpful and can be even misleading, yet they cannot be removed. They should be deprecated, so marked as not to be used, but without the intent of actual removal! The reason: that would be a major compatibility break. I’m not in the position to judge this approach, but it’s definitely a reason why the standard is ever-growing and why certain people think that the language is getting more and more complex. Conclusion In this article, we reviewed some small changes in the standard. We’ve how printing volatile pointers is getting fixed, we’ve seen that marking unreachable parts of code is getting standardized and we’ve also had a look at the deprecation of some niche or not even used functions from the standard library. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: further small changes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes"},"url":"https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes"}</script><title>C++23: further small changes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/03"> 03 </a> </span> <span>C++23: further small changes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: further small changes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 3, 2024, 12:00 AM +0200" prep="on" > Jul 3, 2024 <i class="unloaded">2024-07-03T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1045 words">5 min</span></div></div><div class="post-content"><p>In this article, let’s get back to exploring C++23. We are going to have a look at some unrelated small changes in the standard, including the rarest species of changes. Deprecations!</p><h2 id="printing-volatile-pointers">Printing volatile pointers</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html">P1147R1</a> has pointed out and fixed an interesting behaviour of <code class="language-plaintext highlighter-rouge">std::cout</code> with pointers.</p><p>Let’s assume that we have <code class="language-plaintext highlighter-rouge">p0</code> and <code class="language-plaintext highlighter-rouge">p1</code> pointers pointing at the same address (<code class="language-plaintext highlighter-rouge">0xdeadbeef</code>), but their type is different. <code class="language-plaintext highlighter-rouge">p0</code> is <code class="language-plaintext highlighter-rouge">int*</code> while <code class="language-plaintext highlighter-rouge">p1</code> is <code class="language-plaintext highlighter-rouge">volatile int*</code>. If you happen to print those addresses with <code class="language-plaintext highlighter-rouge">cout</code>, the output will be different for the two pointers. While printing <code class="language-plaintext highlighter-rouge">p0</code> used to output the actual address, <code class="language-plaintext highlighter-rouge">p1</code> on the other hand used to print <code class="language-plaintext highlighter-rouge">1</code>.</p><p>The reason behind is that for the two pointers, different overloads of <code class="language-plaintext highlighter-rouge">std::cout</code> matched. <code class="language-plaintext highlighter-rouge">int*</code> was implicitly converted to <code class="language-plaintext highlighter-rouge">const void*</code>, but <code class="language-plaintext highlighter-rouge">volatile int*</code> was converted to <code class="language-plaintext highlighter-rouge">bool</code>. Thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1147r1.html">P1147R1</a>, a new overload <code class="language-plaintext highlighter-rouge">const volatile void*</code> has been introduced which <code class="language-plaintext highlighter-rouge">const_cast</code>s away <code class="language-plaintext highlighter-rouge">volatile</code> and calls <code class="language-plaintext highlighter-rouge">const void*</code>. As a result, printing the values of <code class="language-plaintext highlighter-rouge">int*</code> and <code class="language-plaintext highlighter-rouge">volatile int*</code> is the same now.</p><h2 id="clarifying-the-status-of-the-c-headers">Clarifying the status of the “C headers”</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2340r1.html">P2340R1</a> is actually both a good read and a meaningful update to the standard. You’re probably aware of so-called C headers in C++.</p><p>Most ISO C headers are available in C++ in two forms. For one, you have the C-style headers following the <code class="language-plaintext highlighter-rouge">&lt;name.h&gt;</code> conventions and also the C++ version of them following the <code class="language-plaintext highlighter-rouge">&lt;cname&gt;</code> convention with the same names declared in it but within the <code class="language-plaintext highlighter-rouge">std</code> namespace.</p><p>For example, there is <code class="language-plaintext highlighter-rouge">&lt;stdint.h&gt;</code> with all the fixed width integer types declared in it in the global namespace, such as <code class="language-plaintext highlighter-rouge">int8_t</code>, <code class="language-plaintext highlighter-rouge">int16_t</code>, etc; and there is the C++ version called <code class="language-plaintext highlighter-rouge">&lt;cstdint&gt;</code> with <code class="language-plaintext highlighter-rouge">std::int8_t</code>, <code class="language-plaintext highlighter-rouge">std::int16_t</code>, etc.</p><p>Since the beginning of the C++ standard, the C headers (<code class="language-plaintext highlighter-rouge">&lt;name.h&gt;</code>) have been deprecated, in other words, subject to future removal, whereas everyone knew that they wouldn’t go anywhere due to reasons of interoperability with C. The usage of C headers is needed when code must be valid C++ and valid C code. Otherwise, in pure C++ code, we should use the C++ versions. At the same time, the need for the C headers is not going away.</p><p>This proposal makes C headers no longer deprecated, but assigns them a state called “for foreign-language interoperability only.”</p><h2 id="stdunreachable"><code class="language-plaintext highlighter-rouge">std::unreachable()</code></h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0627r6.pdf">P0627R6</a> is introducing a new standard library function in the <code class="language-plaintext highlighter-rouge">&lt;utility&gt;</code> header, <code class="language-plaintext highlighter-rouge">std::unreachable()</code>.</p><p><code class="language-plaintext highlighter-rouge">std::unreachable()</code> serves to mark locations in code that are known to the compiler to be unreachable.</p><p>Let’s take an example where we have a function <code class="language-plaintext highlighter-rouge">foo</code> taking an <code class="language-plaintext highlighter-rouge">int n</code> which can only have the values 0, 1, 2 or 3. The function contains a switch statement.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="n">handle_0_or_2</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">handle_1</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
		<span class="n">handle_3</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The compiler will not know that <code class="language-plaintext highlighter-rouge">n</code> cannot be smaller than 0 or bigger than 3, so it might generate some extra instructions to skip the whole switch statement if the value is different.</p><p>One option would be to use an enum in these cases, but it might not always be possible and we could find other usages for <code class="language-plaintext highlighter-rouge">std::unreachable()</code>. So another way to omit such extra code is to mark other cases unreachable. It’s already possible with some compiler- and/or platform-specific functions such as <code class="language-plaintext highlighter-rouge">__builtin_reachable()</code> or <code class="language-plaintext highlighter-rouge">__assume(false)</code>, but with C++23 we also get the standard way to this.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
<span class="k">switch</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span> <span class="p">{</span>
	<span class="k">case</span> <span class="mi">0</span><span class="p">:</span>
	<span class="k">case</span> <span class="mi">2</span><span class="p">:</span>
		<span class="n">handle_0_or_2</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">1</span><span class="p">:</span>
		<span class="n">handle_1</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="k">case</span> <span class="mi">3</span><span class="p">:</span>
		<span class="n">handle_3</span><span class="p">();</span>
		<span class="k">break</span><span class="p">;</span>
	<span class="nl">default:</span>
		<span class="n">std</span><span class="o">::</span><span class="n">unreachable</span><span class="p">();</span>
	<span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If <code class="language-plaintext highlighter-rouge">std::unreachable()</code> is still reached, the behaviour is undefined.</p><p>For an interesting read on design decisions and comparison with contract-based programming, check out <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0627r6.pdf">P0627R6</a>.</p><h2 id="deprecate-stdaligned_storage-and-stdaligned_union">Deprecate <code class="language-plaintext highlighter-rouge">std::aligned_storage</code> and <code class="language-plaintext highlighter-rouge">std::aligned_union</code></h2><p>We often say that one of the superpowers of C++ is backward compatibility. Very few things get deprecated even less removed. We discussed already that <a href="">the support for garbage collection has been removed from C++</a>. Today we finish this article, with a couple of deprecations.</p><p>Let’s start with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1413r3.pdf">P1413R3</a> which deprecates <code class="language-plaintext highlighter-rouge">std::aligned_storage</code> and <code class="language-plaintext highlighter-rouge">std::aligned_union</code>. These functions are niche, they are mainly used for containers by utility libraries, such as <em>Abseil</em>, <em>Boost</em> or <em>Folly</em>.</p><p>The reason behind removing these functions is their poor, unsafe and sometimes even misleading APIs. They require extensive usage of <code class="language-plaintext highlighter-rouge">reinterpret_cast</code> and as such they are prone to invoke undefined behaviour. They fail to provide upper-bound guarantees on the size of the resulting type and some of the default template arguments are misleading and lead to errors.</p><p>If you want to learn about the details of these issues, read the “On the API” section of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1413r3.pdf">P1413R3</a>.</p><p>If you happen to use these <code class="language-plaintext highlighter-rouge">aligned_*</code> functions, most probably you’re aware of this and the suggested replacement which is using <code class="language-plaintext highlighter-rouge">std::byte</code> in combination with the <code class="language-plaintext highlighter-rouge">alignas</code> attribute.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="o">-</span> <span class="n">std</span><span class="o">::</span><span class="n">aligned_storage_t</span><span class="o">&lt;</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">),</span> <span class="k">alignof</span><span class="p">(</span><span class="n">T</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">t_buff</span><span class="p">;</span>
<span class="o">+</span> <span class="k">alignas</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">byte</span> <span class="n">t_buff</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="n">T</span><span class="p">)];</span>
</pre></table></code></div></div><h2 id="deprecate-stdnumeric_limitshas_denorm-and-stdnumeric_limitshas_denorm_loss">Deprecate <code class="language-plaintext highlighter-rouge">std::numeric_limits::has_denorm</code> and <code class="language-plaintext highlighter-rouge">std::numeric_limits::has_denorm_loss</code></h2><p>This change goes hand in hand with a change in <code class="language-plaintext highlighter-rouge">C</code> where <code class="language-plaintext highlighter-rouge">_HAS_SUBNORM</code> macros are getting obsoleted.</p><p>Most probably you never used these functions. Even the author of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2614r2.pdf">P2614R2</a> claims that no code relies on these. Why this paper is interesting and we refer back once again to that superpower of backwards-compatibility because the author explicitly says that these functions are not helpful and can be even misleading, yet they cannot be removed. They should be deprecated, so marked as not to be used, but without the intent of actual removal! The reason: that would be a major compatibility break.</p><p>I’m not in the position to judge this approach, but it’s definitely a reason why the standard is ever-growing and why certain people think that the language is getting more and more complex.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed some small changes in the standard. We’ve how printing volatile pointers is getting fixed, we’ve seen that marking unreachable parts of code is getting standardized and we’ve also had a look at the deprecation of some niche or not even used functions from the standard library.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/unreachable/" class="post-tag no-text-decoration" >unreachable</a> <a href="/tags/deprecation/" class="post-tag no-text-decoration" >deprecation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: further small changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: further small changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: further small changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: further small changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/06/26/member-ordering-and-binary-size" class="btn btn-outline-primary" prompt="Older"><p>Member ordering and binary sizes</p></a> <a href="/blog/2024/07/10/cpponsea2024-trip-report" class="btn btn-outline-primary" prompt="Newer"><p>Trip report: C++ On Sea 2024</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: further small changes'; this.page.url = 'https://www.sandordargo.com/blog/2024/07/03/cpp23-further-small-changes'; this.page.identifier = '/blog/2024/07/03/cpp23-further-small-changes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
