<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="What to do if you don’t want a default constructor?" /><meta property="og:locale" content="en_US" /><meta name="description" content="Do we need a default constructor? What does it mean to have a default constructor? What happens if we don’t have one? Those are the questions we are going after in this article. A default constructor is a constructor that takes no arguments and initializes - hopefully - all the members with some default values. If you define no constructors at all, it’ll even be generated for you. Do we need default constructors? It really depends. Let’s first approach this question from a design point of view. Does it make sense to represent an object where the members are default initialized? If you represent a tachograph, it probably makes sense to have such a default state where all the counters are initialized to zero. The tachograph is the device that records driving times and rest periods as well as periods of other work and availability taken by the driver of a heavy vehicle. On the other hand, if you represent a person or a task identifier - which inspired me to write this article - it doesn’t. A person with an empty name or a task ID with an empty ID doesn’t make much sense. Well, that’s the case from a design point of view. What about the technical aspects? What happens if we don’t have a default constructor? You’ll have a harder time using some standard library types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; void serialize(std::string &amp;out_buffer) const { out_buffer.resize(sizeof(TaskID)); memcpy(out_buffer.data(), reinterpret_cast&lt;const char *&gt;(this), sizeof(TaskID)); } private: std::string m_uuid; }; void foo(const TaskID&amp; taskID) { // ... taskID.serialize(); } int main() { std::vector&lt;TaskID&gt; tasks; // cannot compile, resize() needs a default constructor // tasks.resize(10); // this doesn&#39;t work as there is no default constructor // std::vector&lt;TaskID&gt; moreTasks(10); std::map&lt;TaskID, std::string&gt; tasksMap{ {TaskID{&quot;ab12&quot;}, &quot;dummy&quot;} }; tasksMap[TaskID{&quot;ab13&quot;}] = &quot;other dummy&quot;; std::map&lt;int, TaskID&gt; tasksMap242}; // cannot use operator[], needs default constructor for the value type // tasksMap2[4] = TaskID{&quot;ab13&quot;}; foo(tasksMap.at(42)); } Just to show you two examples, you’ll have difficulties to use std::vector or std::map up to their full extents. At the same time, these limitations are not necessarily blocking. On the other hand, there is another limitation that is harder to swallow. Let’s say that you have another class Widget that would hold TaskID by value. That’s possible, sure, but that class cannot have an auto-generated default constructor because it would require that TaskID has a default constructor. Let’s assume that at the moment of construction, we cannot have the meaningful value TaskID, because we only can or want to figure that out later. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; private: std::string m_uuid; }; class Widget { public: // ... TaskID getTaskID() const { return taskId; } private: TaskID taskId; }; void foo(const TaskID&amp; taskID) { // ... taskID.serialize(); } int main() { // error: call to implicitly-deleted default constructor of &#39;Widget&#39; Widget widget; foo(widget.getTaskID()); } We can still provide a default constructor for that Widget, but how would you instantiate a default TaskID? Or any class that doesn’t have a meaningful empty state? Still use a default constructor We could assign some dummy values for members. For integers, we can often see that -1 is used as a number to represent an invalid state. For strings that could be just an empty value. Let’s be honest, most often people don’t really think about these questions, they just let an object be created with the default values of the members. If they see that the code doesn’t compile, because the default constructor is missing for a class, they just add it. If they are more careful, they probably define a member function like isValid() to check the validity of an object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TaskID { public: TaskID() = default; TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; bool isValid() const { return !m_uuid.empty(); } private: std::string m_uuid; }; void foo(const TaskID&amp; taskID) { if (!taskID.isValid()) { return; } // ... taskID.serialize(); } But what other options do we have if we care about not creating objects with meaningless default values? Wrap your object with std::optional To avoid having a default constructor, but still be able to use it as a class member or to use it with the different standard containers, we can wrap TaskID with std::optional. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;map&gt; #include &lt;optional&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; private: std::string m_uuid; }; void foo(std::optional&lt;TaskID&gt; taskID) { if (!taskID) { return; } // ... taskID.serialize(); } int main() { std::vector&lt;std::optional&lt;TaskID&gt;&gt; tasks; tasks.resize(10); std::vector&lt;std::optional&lt;TaskID&gt;&gt; moreTasks(10); std::map&lt;TaskID, std::string&gt; tasksMap{ {TaskID{&quot;ab12&quot;}, &quot;dummy&quot;} }; tasksMap[TaskID{&quot;ab13&quot;}] = &quot;other dummy&quot;; std::map&lt;int, std::optional&lt;TaskID&gt;&gt; tasksMap242}; tasksMap2[4] = TaskID{&quot;ab13&quot;}; foo(tasksMap2[42]); } What does that mean for us? From a practical point of view, we have to validate if a TaskID is present to avoid segmentation faults or bad_optional_access. In other words, we have an extra layer. That can be cumbersome. From a semantic point of view, this means that a TaskID is either present or not. It’s optionally present. I’d argue that it’s only partially what we want to communicate. What we want to say in most cases is that the TaskID is not yet available or it’s already there. At the same time, std::optional’s communication capabilities stop here. Let’s look into another option with more communication capabilities. Use std::variant std::variant&lt;Ts...&gt; is a bit like std::optional&lt;T&gt; but on steroids. Instead of std::nullopt or T, it can hold practically any kind and number of different types. Therefore, instead of std::nullopt, we might say that it can hold a TaskID, InvalidTaskID, UninitialziedTaskID, etc. It’s enough to define those other options as empty structs. 1 2 3 4 5 class TaskID { /* as before*/ }; struct InvalidTaskID{}; struct UninitialziedTaskID {}; std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID; I put UninitialziedTaskID in the first place in the template argument list because by default variables will be initialized to that. Compared to std::optional its usage is not painfully complicated, though probably you’ll need to use quite a few std::holds_alternative&lt;T&gt; and std::get&lt;T&gt; in your code which can hinder its readability. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void foo(std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID) { if (!std::holds_alternative&lt;TaskID&gt;(taskID)) { return; } // ... taskID.serialize(); } void bar(std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID) { try { std::get&lt;TaskID&gt;(taskId).serialize() } catch (std::bad_variant_access const&amp; ex) { std::cout &lt;&lt; ex.what() &lt;&lt; &quot;: taskID didn&#39;t contain TaskID\n&quot;; } } Use std::variant combined with an enum There is an interesting option we haven’t experimented with yet. We could use std::variant with only two types, TaskID in the second place and an enum in the first place which can hold the different invalid states. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include &lt;string&gt; #include &lt;variant&gt; #include &lt;vector&gt; enum class InvalidTaskIDStates { InvalidTaskID, UninitialziedTaskID, }; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; private: std::string m_uuid; }; void foo(std::variant&lt;InvalidTaskIDStates, TaskID&gt; taskID) { if (std::holds_alternative&lt;InvalidTaskIDStates&gt;(taskID)) { return; } // ... taskID.serialize(); } void bar(std::variant&lt;InvalidTaskIDStates, TaskID&gt; taskID) { if (std::holds_alternative&lt;InvalidTaskIDStates&gt;(taskID)) { switch (std::get&lt;InvalidTaskIDStates&gt;(taskID)) { case InvalidTaskIDStates::InvalidTaskID: std::cout &lt;&lt; &quot;InvalidTaskID\n&quot;; return; case InvalidTaskIDStates::UninitialziedTaskID: std::cout &lt;&lt; &quot;UninitialziedTaskID\n&quot;; return; } } // ... taskID.serialize(); } int main() { std::variant&lt;InvalidTaskIDStates, TaskID&gt; myvar; std::vector&lt;std::variant&lt;InvalidTaskIDStates, TaskID&gt;&gt; tasks; tasks.resize(10); tasks.push_back(TaskID{&quot;ab12&quot;}); foo(tasks.back()); bar(tasks.front()); } On the positive side, we can say that if we are interested in invalid states, we only have one variant to check. On the other hand, if we are interested in which invalid state a variable holds, we’ll need to mix two kinds of grammar. We need to use the API of std::variant and the syntax related to enums as well. Conclusion Today, we discussed what options we have if we don’t want our type to have a default constructor because it doesn’t make sense. We’ve seen that even in those cases having a default constructor might make sense, initializing the object to a kind of an invalid state. Even though it’s really not a best practice. Types without a default constructor are sometimes hard to use with containers. Our options are also limited when we need to compose other types that are default constructible, but one of the members have no default constructor. In such cases, we can wrap these types into std::optional or std::variant based on our needs. Of course, we could use (smart) pointers as well, but that’s not an option we discussed, because dynamic memory allocation is clearly not something we need to solve the original problem. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Do we need a default constructor? What does it mean to have a default constructor? What happens if we don’t have one? Those are the questions we are going after in this article. A default constructor is a constructor that takes no arguments and initializes - hopefully - all the members with some default values. If you define no constructors at all, it’ll even be generated for you. Do we need default constructors? It really depends. Let’s first approach this question from a design point of view. Does it make sense to represent an object where the members are default initialized? If you represent a tachograph, it probably makes sense to have such a default state where all the counters are initialized to zero. The tachograph is the device that records driving times and rest periods as well as periods of other work and availability taken by the driver of a heavy vehicle. On the other hand, if you represent a person or a task identifier - which inspired me to write this article - it doesn’t. A person with an empty name or a task ID with an empty ID doesn’t make much sense. Well, that’s the case from a design point of view. What about the technical aspects? What happens if we don’t have a default constructor? You’ll have a harder time using some standard library types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; void serialize(std::string &amp;out_buffer) const { out_buffer.resize(sizeof(TaskID)); memcpy(out_buffer.data(), reinterpret_cast&lt;const char *&gt;(this), sizeof(TaskID)); } private: std::string m_uuid; }; void foo(const TaskID&amp; taskID) { // ... taskID.serialize(); } int main() { std::vector&lt;TaskID&gt; tasks; // cannot compile, resize() needs a default constructor // tasks.resize(10); // this doesn&#39;t work as there is no default constructor // std::vector&lt;TaskID&gt; moreTasks(10); std::map&lt;TaskID, std::string&gt; tasksMap{ {TaskID{&quot;ab12&quot;}, &quot;dummy&quot;} }; tasksMap[TaskID{&quot;ab13&quot;}] = &quot;other dummy&quot;; std::map&lt;int, TaskID&gt; tasksMap242}; // cannot use operator[], needs default constructor for the value type // tasksMap2[4] = TaskID{&quot;ab13&quot;}; foo(tasksMap.at(42)); } Just to show you two examples, you’ll have difficulties to use std::vector or std::map up to their full extents. At the same time, these limitations are not necessarily blocking. On the other hand, there is another limitation that is harder to swallow. Let’s say that you have another class Widget that would hold TaskID by value. That’s possible, sure, but that class cannot have an auto-generated default constructor because it would require that TaskID has a default constructor. Let’s assume that at the moment of construction, we cannot have the meaningful value TaskID, because we only can or want to figure that out later. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; private: std::string m_uuid; }; class Widget { public: // ... TaskID getTaskID() const { return taskId; } private: TaskID taskId; }; void foo(const TaskID&amp; taskID) { // ... taskID.serialize(); } int main() { // error: call to implicitly-deleted default constructor of &#39;Widget&#39; Widget widget; foo(widget.getTaskID()); } We can still provide a default constructor for that Widget, but how would you instantiate a default TaskID? Or any class that doesn’t have a meaningful empty state? Still use a default constructor We could assign some dummy values for members. For integers, we can often see that -1 is used as a number to represent an invalid state. For strings that could be just an empty value. Let’s be honest, most often people don’t really think about these questions, they just let an object be created with the default values of the members. If they see that the code doesn’t compile, because the default constructor is missing for a class, they just add it. If they are more careful, they probably define a member function like isValid() to check the validity of an object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TaskID { public: TaskID() = default; TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; bool isValid() const { return !m_uuid.empty(); } private: std::string m_uuid; }; void foo(const TaskID&amp; taskID) { if (!taskID.isValid()) { return; } // ... taskID.serialize(); } But what other options do we have if we care about not creating objects with meaningless default values? Wrap your object with std::optional To avoid having a default constructor, but still be able to use it as a class member or to use it with the different standard containers, we can wrap TaskID with std::optional. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;map&gt; #include &lt;optional&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; private: std::string m_uuid; }; void foo(std::optional&lt;TaskID&gt; taskID) { if (!taskID) { return; } // ... taskID.serialize(); } int main() { std::vector&lt;std::optional&lt;TaskID&gt;&gt; tasks; tasks.resize(10); std::vector&lt;std::optional&lt;TaskID&gt;&gt; moreTasks(10); std::map&lt;TaskID, std::string&gt; tasksMap{ {TaskID{&quot;ab12&quot;}, &quot;dummy&quot;} }; tasksMap[TaskID{&quot;ab13&quot;}] = &quot;other dummy&quot;; std::map&lt;int, std::optional&lt;TaskID&gt;&gt; tasksMap242}; tasksMap2[4] = TaskID{&quot;ab13&quot;}; foo(tasksMap2[42]); } What does that mean for us? From a practical point of view, we have to validate if a TaskID is present to avoid segmentation faults or bad_optional_access. In other words, we have an extra layer. That can be cumbersome. From a semantic point of view, this means that a TaskID is either present or not. It’s optionally present. I’d argue that it’s only partially what we want to communicate. What we want to say in most cases is that the TaskID is not yet available or it’s already there. At the same time, std::optional’s communication capabilities stop here. Let’s look into another option with more communication capabilities. Use std::variant std::variant&lt;Ts...&gt; is a bit like std::optional&lt;T&gt; but on steroids. Instead of std::nullopt or T, it can hold practically any kind and number of different types. Therefore, instead of std::nullopt, we might say that it can hold a TaskID, InvalidTaskID, UninitialziedTaskID, etc. It’s enough to define those other options as empty structs. 1 2 3 4 5 class TaskID { /* as before*/ }; struct InvalidTaskID{}; struct UninitialziedTaskID {}; std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID; I put UninitialziedTaskID in the first place in the template argument list because by default variables will be initialized to that. Compared to std::optional its usage is not painfully complicated, though probably you’ll need to use quite a few std::holds_alternative&lt;T&gt; and std::get&lt;T&gt; in your code which can hinder its readability. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void foo(std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID) { if (!std::holds_alternative&lt;TaskID&gt;(taskID)) { return; } // ... taskID.serialize(); } void bar(std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID) { try { std::get&lt;TaskID&gt;(taskId).serialize() } catch (std::bad_variant_access const&amp; ex) { std::cout &lt;&lt; ex.what() &lt;&lt; &quot;: taskID didn&#39;t contain TaskID\n&quot;; } } Use std::variant combined with an enum There is an interesting option we haven’t experimented with yet. We could use std::variant with only two types, TaskID in the second place and an enum in the first place which can hold the different invalid states. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include &lt;string&gt; #include &lt;variant&gt; #include &lt;vector&gt; enum class InvalidTaskIDStates { InvalidTaskID, UninitialziedTaskID, }; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; private: std::string m_uuid; }; void foo(std::variant&lt;InvalidTaskIDStates, TaskID&gt; taskID) { if (std::holds_alternative&lt;InvalidTaskIDStates&gt;(taskID)) { return; } // ... taskID.serialize(); } void bar(std::variant&lt;InvalidTaskIDStates, TaskID&gt; taskID) { if (std::holds_alternative&lt;InvalidTaskIDStates&gt;(taskID)) { switch (std::get&lt;InvalidTaskIDStates&gt;(taskID)) { case InvalidTaskIDStates::InvalidTaskID: std::cout &lt;&lt; &quot;InvalidTaskID\n&quot;; return; case InvalidTaskIDStates::UninitialziedTaskID: std::cout &lt;&lt; &quot;UninitialziedTaskID\n&quot;; return; } } // ... taskID.serialize(); } int main() { std::variant&lt;InvalidTaskIDStates, TaskID&gt; myvar; std::vector&lt;std::variant&lt;InvalidTaskIDStates, TaskID&gt;&gt; tasks; tasks.resize(10); tasks.push_back(TaskID{&quot;ab12&quot;}); foo(tasks.back()); bar(tasks.front()); } On the positive side, we can say that if we are interested in invalid states, we only have one variant to check. On the other hand, if we are interested in which invalid state a variable holds, we’ll need to mix two kinds of grammar. We need to use the API of std::variant and the syntax related to enums as well. Conclusion Today, we discussed what options we have if we don’t want our type to have a default constructor because it doesn’t make sense. We’ve seen that even in those cases having a default constructor might make sense, initializing the object to a kind of an invalid state. Even though it’s really not a best practice. Types without a default constructor are sometimes hard to use with containers. Our options are also limited when we need to compose other types that are default constructible, but one of the members have no default constructor. In such cases, we can wrap these types into std::optional or std::variant based on our needs. Of course, we could use (smart) pointers as well, but that’s not an option we discussed, because dynamic memory allocation is clearly not something we need to solve the original problem. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-17T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="What to do if you don’t want a default constructor?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-17T00:00:00+02:00","datePublished":"2024-07-17T00:00:00+02:00","description":"Do we need a default constructor? What does it mean to have a default constructor? What happens if we don’t have one? Those are the questions we are going after in this article. A default constructor is a constructor that takes no arguments and initializes - hopefully - all the members with some default values. If you define no constructors at all, it’ll even be generated for you. Do we need default constructors? It really depends. Let’s first approach this question from a design point of view. Does it make sense to represent an object where the members are default initialized? If you represent a tachograph, it probably makes sense to have such a default state where all the counters are initialized to zero. The tachograph is the device that records driving times and rest periods as well as periods of other work and availability taken by the driver of a heavy vehicle. On the other hand, if you represent a person or a task identifier - which inspired me to write this article - it doesn’t. A person with an empty name or a task ID with an empty ID doesn’t make much sense. Well, that’s the case from a design point of view. What about the technical aspects? What happens if we don’t have a default constructor? You’ll have a harder time using some standard library types. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; void serialize(std::string &amp;out_buffer) const { out_buffer.resize(sizeof(TaskID)); memcpy(out_buffer.data(), reinterpret_cast&lt;const char *&gt;(this), sizeof(TaskID)); } private: std::string m_uuid; }; void foo(const TaskID&amp; taskID) { // ... taskID.serialize(); } int main() { std::vector&lt;TaskID&gt; tasks; // cannot compile, resize() needs a default constructor // tasks.resize(10); // this doesn&#39;t work as there is no default constructor // std::vector&lt;TaskID&gt; moreTasks(10); std::map&lt;TaskID, std::string&gt; tasksMap{ {TaskID{&quot;ab12&quot;}, &quot;dummy&quot;} }; tasksMap[TaskID{&quot;ab13&quot;}] = &quot;other dummy&quot;; std::map&lt;int, TaskID&gt; tasksMap242}; // cannot use operator[], needs default constructor for the value type // tasksMap2[4] = TaskID{&quot;ab13&quot;}; foo(tasksMap.at(42)); } Just to show you two examples, you’ll have difficulties to use std::vector or std::map up to their full extents. At the same time, these limitations are not necessarily blocking. On the other hand, there is another limitation that is harder to swallow. Let’s say that you have another class Widget that would hold TaskID by value. That’s possible, sure, but that class cannot have an auto-generated default constructor because it would require that TaskID has a default constructor. Let’s assume that at the moment of construction, we cannot have the meaningful value TaskID, because we only can or want to figure that out later. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 #include &lt;map&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; private: std::string m_uuid; }; class Widget { public: // ... TaskID getTaskID() const { return taskId; } private: TaskID taskId; }; void foo(const TaskID&amp; taskID) { // ... taskID.serialize(); } int main() { // error: call to implicitly-deleted default constructor of &#39;Widget&#39; Widget widget; foo(widget.getTaskID()); } We can still provide a default constructor for that Widget, but how would you instantiate a default TaskID? Or any class that doesn’t have a meaningful empty state? Still use a default constructor We could assign some dummy values for members. For integers, we can often see that -1 is used as a number to represent an invalid state. For strings that could be just an empty value. Let’s be honest, most often people don’t really think about these questions, they just let an object be created with the default values of the members. If they see that the code doesn’t compile, because the default constructor is missing for a class, they just add it. If they are more careful, they probably define a member function like isValid() to check the validity of an object. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class TaskID { public: TaskID() = default; TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; bool isValid() const { return !m_uuid.empty(); } private: std::string m_uuid; }; void foo(const TaskID&amp; taskID) { if (!taskID.isValid()) { return; } // ... taskID.serialize(); } But what other options do we have if we care about not creating objects with meaningless default values? Wrap your object with std::optional To avoid having a default constructor, but still be able to use it as a class member or to use it with the different standard containers, we can wrap TaskID with std::optional. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;map&gt; #include &lt;optional&gt; #include &lt;string&gt; #include &lt;vector&gt; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; auto operator&lt;=&gt;(const TaskID&amp;) const = default; private: std::string m_uuid; }; void foo(std::optional&lt;TaskID&gt; taskID) { if (!taskID) { return; } // ... taskID.serialize(); } int main() { std::vector&lt;std::optional&lt;TaskID&gt;&gt; tasks; tasks.resize(10); std::vector&lt;std::optional&lt;TaskID&gt;&gt; moreTasks(10); std::map&lt;TaskID, std::string&gt; tasksMap{ {TaskID{&quot;ab12&quot;}, &quot;dummy&quot;} }; tasksMap[TaskID{&quot;ab13&quot;}] = &quot;other dummy&quot;; std::map&lt;int, std::optional&lt;TaskID&gt;&gt; tasksMap242}; tasksMap2[4] = TaskID{&quot;ab13&quot;}; foo(tasksMap2[42]); } What does that mean for us? From a practical point of view, we have to validate if a TaskID is present to avoid segmentation faults or bad_optional_access. In other words, we have an extra layer. That can be cumbersome. From a semantic point of view, this means that a TaskID is either present or not. It’s optionally present. I’d argue that it’s only partially what we want to communicate. What we want to say in most cases is that the TaskID is not yet available or it’s already there. At the same time, std::optional’s communication capabilities stop here. Let’s look into another option with more communication capabilities. Use std::variant std::variant&lt;Ts...&gt; is a bit like std::optional&lt;T&gt; but on steroids. Instead of std::nullopt or T, it can hold practically any kind and number of different types. Therefore, instead of std::nullopt, we might say that it can hold a TaskID, InvalidTaskID, UninitialziedTaskID, etc. It’s enough to define those other options as empty structs. 1 2 3 4 5 class TaskID { /* as before*/ }; struct InvalidTaskID{}; struct UninitialziedTaskID {}; std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID; I put UninitialziedTaskID in the first place in the template argument list because by default variables will be initialized to that. Compared to std::optional its usage is not painfully complicated, though probably you’ll need to use quite a few std::holds_alternative&lt;T&gt; and std::get&lt;T&gt; in your code which can hinder its readability. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 void foo(std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID) { if (!std::holds_alternative&lt;TaskID&gt;(taskID)) { return; } // ... taskID.serialize(); } void bar(std::variant&lt;UninitialziedTaskID, InvalidTaskID, TaskID&gt; taskID) { try { std::get&lt;TaskID&gt;(taskId).serialize() } catch (std::bad_variant_access const&amp; ex) { std::cout &lt;&lt; ex.what() &lt;&lt; &quot;: taskID didn&#39;t contain TaskID\\n&quot;; } } Use std::variant combined with an enum There is an interesting option we haven’t experimented with yet. We could use std::variant with only two types, TaskID in the second place and an enum in the first place which can hold the different invalid states. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 #include &lt;string&gt; #include &lt;variant&gt; #include &lt;vector&gt; enum class InvalidTaskIDStates { InvalidTaskID, UninitialziedTaskID, }; class TaskID { public: TaskID(std::string uuid): m_uuid(uuid){}; private: std::string m_uuid; }; void foo(std::variant&lt;InvalidTaskIDStates, TaskID&gt; taskID) { if (std::holds_alternative&lt;InvalidTaskIDStates&gt;(taskID)) { return; } // ... taskID.serialize(); } void bar(std::variant&lt;InvalidTaskIDStates, TaskID&gt; taskID) { if (std::holds_alternative&lt;InvalidTaskIDStates&gt;(taskID)) { switch (std::get&lt;InvalidTaskIDStates&gt;(taskID)) { case InvalidTaskIDStates::InvalidTaskID: std::cout &lt;&lt; &quot;InvalidTaskID\\n&quot;; return; case InvalidTaskIDStates::UninitialziedTaskID: std::cout &lt;&lt; &quot;UninitialziedTaskID\\n&quot;; return; } } // ... taskID.serialize(); } int main() { std::variant&lt;InvalidTaskIDStates, TaskID&gt; myvar; std::vector&lt;std::variant&lt;InvalidTaskIDStates, TaskID&gt;&gt; tasks; tasks.resize(10); tasks.push_back(TaskID{&quot;ab12&quot;}); foo(tasks.back()); bar(tasks.front()); } On the positive side, we can say that if we are interested in invalid states, we only have one variant to check. On the other hand, if we are interested in which invalid state a variable holds, we’ll need to mix two kinds of grammar. We need to use the API of std::variant and the syntax related to enums as well. Conclusion Today, we discussed what options we have if we don’t want our type to have a default constructor because it doesn’t make sense. We’ve seen that even in those cases having a default constructor might make sense, initializing the object to a kind of an invalid state. Even though it’s really not a best practice. Types without a default constructor are sometimes hard to use with containers. Our options are also limited when we need to compose other types that are default constructible, but one of the members have no default constructor. In such cases, we can wrap these types into std::optional or std::variant based on our needs. Of course, we could use (smart) pointers as well, but that’s not an option we discussed, because dynamic memory allocation is clearly not something we need to solve the original problem. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"What to do if you don’t want a default constructor?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value"},"url":"https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value"}</script><title>What to do if you don't want a default constructor? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/17"> 17 </a> </span> <span>What to do if you don't want a default constructor?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>What to do if you don't want a default constructor?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 17, 2024, 12:00 AM +0200" prep="on" > Jul 17, 2024 <i class="unloaded">2024-07-17T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1611 words">8 min</span></div></div><div class="post-content"><p>Do we need a default constructor? What does it mean to have a default constructor? What happens if we don’t have one? Those are the questions we are going after in this article.</p><p>A default constructor is a constructor that takes no arguments and initializes - hopefully - all the members with some default values. If you define no constructors at all, it’ll even be generated for you.</p><h2 id="do-we-need-default-constructors">Do we need default constructors?</h2><p>It really depends. Let’s first approach this question from a design point of view. Does it make sense to represent an object where the members are default initialized?</p><p>If you represent a tachograph, it probably makes sense to have such a default state where all the counters are initialized to zero.</p><blockquote><p><em>The tachograph is the device that records driving times and rest periods as well as periods of other work and availability taken by the driver of a heavy vehicle.</em></p></blockquote><p>On the other hand, if you represent a person or a task identifier - which inspired me to write this article - it doesn’t. A person with an empty name or a task ID with an empty ID doesn’t make much sense.</p><p>Well, that’s the case from a design point of view. What about the technical aspects? What happens if we don’t have a default constructor?</p><p>You’ll have a harder time using some standard library types.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">TaskID</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">TaskID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uuid</span><span class="p">)</span><span class="o">:</span> <span class="n">m_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">){};</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">out_buffer</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
        <span class="n">out_buffer</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">TaskID</span><span class="p">));</span>
        <span class="n">memcpy</span><span class="p">(</span><span class="n">out_buffer</span><span class="p">.</span><span class="n">data</span><span class="p">(),</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*&gt;</span><span class="p">(</span><span class="k">this</span><span class="p">),</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">TaskID</span><span class="p">));</span>
    <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_uuid</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">tasks</span><span class="p">;</span>
    
    <span class="c1">// cannot compile, resize() needs a default constructor</span>
    <span class="c1">// tasks.resize(10);</span>

    <span class="c1">// this doesn't work as there is no default constructor</span>
    <span class="c1">// std::vector&lt;TaskID&gt; moreTasks(10);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tasksMap</span><span class="p">{</span> <span class="p">{</span><span class="n">TaskID</span><span class="p">{</span><span class="s">"ab12"</span><span class="p">},</span> <span class="s">"dummy"</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">tasksMap</span><span class="p">[</span><span class="n">TaskID</span><span class="p">{</span><span class="s">"ab13"</span><span class="p">}]</span> <span class="o">=</span> <span class="s">"other dummy"</span><span class="p">;</span>


    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">tasksMap242</span><span class="p">};</span>
    <span class="c1">// cannot use operator[], needs default constructor for the value type </span>
    <span class="c1">// tasksMap2[4] = TaskID{"ab13"};</span>

    <span class="n">foo</span><span class="p">(</span><span class="n">tasksMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="mi">42</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Just to show you two examples, you’ll have difficulties to use <code class="language-plaintext highlighter-rouge">std::vector</code> or <code class="language-plaintext highlighter-rouge">std::map</code> up to their full extents. At the same time, these limitations are not necessarily blocking.</p><p>On the other hand, there is another limitation that is harder to swallow.</p><p>Let’s say that you have another class <code class="language-plaintext highlighter-rouge">Widget</code> that would hold <code class="language-plaintext highlighter-rouge">TaskID</code> by value. That’s possible, sure, but that class cannot have an auto-generated default constructor because it would require that <code class="language-plaintext highlighter-rouge">TaskID</code> has a default constructor.</p><p>Let’s assume that at the moment of construction, we cannot have the meaningful value <code class="language-plaintext highlighter-rouge">TaskID</code>, because we only can or want to figure that out later.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">TaskID</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">TaskID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uuid</span><span class="p">)</span><span class="o">:</span> <span class="n">m_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">){};</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_uuid</span><span class="p">;</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="c1">// ...</span>
    <span class="n">TaskID</span> <span class="n">getTaskID</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">taskId</span><span class="p">;</span> <span class="p">}</span> 

<span class="k">private</span><span class="o">:</span>
    <span class="n">TaskID</span> <span class="n">taskId</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="c1">// error: call to implicitly-deleted default constructor of 'Widget'</span>
    <span class="n">Widget</span> <span class="n">widget</span><span class="p">;</span>

    <span class="n">foo</span><span class="p">(</span><span class="n">widget</span><span class="p">.</span><span class="n">getTaskID</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We can still provide a default constructor for that <code class="language-plaintext highlighter-rouge">Widget</code>, but how would you instantiate a default <code class="language-plaintext highlighter-rouge">TaskID</code>? Or any class that doesn’t have a meaningful empty state?</p><h2 id="still-use-a-default-constructor">Still use a default constructor</h2><p>We could assign some dummy values for members. For integers, we can often see that <code class="language-plaintext highlighter-rouge">-1</code> is used as a number to represent an invalid state. For strings that could be just an empty value. Let’s be honest, most often people don’t really think about these questions, they just let an object be created with the default values of the members.</p><p>If they see that the code doesn’t compile, because the default constructor is missing for a class, they just add it.</p><p>If they are more careful, they probably define a member function like <code class="language-plaintext highlighter-rouge">isValid()</code> to check the validity of an object.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TaskID</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">TaskID</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">TaskID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uuid</span><span class="p">)</span><span class="o">:</span> <span class="n">m_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">){};</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="nf">isValid</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">!</span><span class="n">m_uuid</span><span class="p">.</span><span class="n">empty</span><span class="p">();</span>
    <span class="p">}</span>
 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_uuid</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">taskID</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But what other options do we have if we care about not creating objects with meaningless default values?</p><h2 id="wrap-your-object-with-stdoptional">Wrap your object with <code class="language-plaintext highlighter-rouge">std::optional</code></h2><p>To avoid having a default constructor, but still be able to use it as a class member or to use it with the different standard containers, we can wrap <code class="language-plaintext highlighter-rouge">TaskID</code> with <code class="language-plaintext highlighter-rouge">std::optional</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;map&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">TaskID</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">TaskID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uuid</span><span class="p">)</span><span class="o">:</span> <span class="n">m_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">){};</span>

    <span class="k">auto</span> <span class="k">operator</span><span class="o">&lt;=&gt;</span><span class="p">(</span><span class="k">const</span> <span class="n">TaskID</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_uuid</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;&gt;</span> <span class="n">tasks</span><span class="p">;</span>
 
    <span class="n">tasks</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;&gt;</span> <span class="n">moreTasks</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">tasksMap</span><span class="p">{</span> <span class="p">{</span><span class="n">TaskID</span><span class="p">{</span><span class="s">"ab12"</span><span class="p">},</span> <span class="s">"dummy"</span><span class="p">}</span> <span class="p">};</span>
    <span class="n">tasksMap</span><span class="p">[</span><span class="n">TaskID</span><span class="p">{</span><span class="s">"ab13"</span><span class="p">}]</span> <span class="o">=</span> <span class="s">"other dummy"</span><span class="p">;</span>


    <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;&gt;</span> <span class="n">tasksMap242</span><span class="p">};</span>
    <span class="n">tasksMap2</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="n">TaskID</span><span class="p">{</span><span class="s">"ab13"</span><span class="p">};</span>

    <span class="n">foo</span><span class="p">(</span><span class="n">tasksMap2</span><span class="p">[</span><span class="mi">42</span><span class="p">]);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What does that mean for us?</p><p>From a practical point of view, we have to validate if a <code class="language-plaintext highlighter-rouge">TaskID</code> is present to avoid segmentation faults or <code class="language-plaintext highlighter-rouge">bad_optional_access</code>. In other words, we have an extra layer. That can be cumbersome.</p><p>From a semantic point of view, this means that a <code class="language-plaintext highlighter-rouge">TaskID</code> is either present or not. It’s optionally present. I’d argue that it’s only partially what we want to communicate. What we want to say in most cases is that the <code class="language-plaintext highlighter-rouge">TaskID</code> is not yet available or it’s already there. At the same time, <code class="language-plaintext highlighter-rouge">std::optional</code>’s communication capabilities stop here.</p><p>Let’s look into another option with more communication capabilities.</p><h2 id="use-stdvariant">Use <code class="language-plaintext highlighter-rouge">std::variant</code></h2><p><code class="language-plaintext highlighter-rouge">std::variant&lt;Ts...&gt;</code> is a bit like <code class="language-plaintext highlighter-rouge">std::optional&lt;T&gt;</code> but on steroids. Instead of <code class="language-plaintext highlighter-rouge">std::nullopt</code> or <code class="language-plaintext highlighter-rouge">T</code>, it can hold practically any kind and number of different types. Therefore, instead of <code class="language-plaintext highlighter-rouge">std::nullopt</code>, we might say that it can hold a <code class="language-plaintext highlighter-rouge">TaskID</code>, <code class="language-plaintext highlighter-rouge">InvalidTaskID</code>, <code class="language-plaintext highlighter-rouge">UninitialziedTaskID</code>, etc. It’s enough to define those other options as empty <code class="language-plaintext highlighter-rouge">struct</code>s.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">TaskID</span> <span class="p">{</span> <span class="cm">/* as before*/</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">InvalidTaskID</span><span class="p">{};</span>
<span class="k">struct</span> <span class="nc">UninitialziedTaskID</span> <span class="p">{};</span>

<span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">UninitialziedTaskID</span><span class="p">,</span> <span class="n">InvalidTaskID</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">taskID</span><span class="p">;</span>
</pre></table></code></div></div><p>I put <code class="language-plaintext highlighter-rouge">UninitialziedTaskID</code> in the first place in the template argument list because by default variables will be initialized to that.</p><p>Compared to <code class="language-plaintext highlighter-rouge">std::optional</code> its usage is not painfully complicated, though probably you’ll need to use quite a few <code class="language-plaintext highlighter-rouge">std::holds_alternative&lt;T&gt;</code> and <code class="language-plaintext highlighter-rouge">std::get&lt;T&gt;</code> in your code which can hinder its readability.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">UninitialziedTaskID</span><span class="p">,</span> <span class="n">InvalidTaskID</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">holds_alternative</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span><span class="p">(</span><span class="n">taskID</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">UninitialziedTaskID</span><span class="p">,</span> <span class="n">InvalidTaskID</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">try</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">TaskID</span><span class="o">&gt;</span><span class="p">(</span><span class="n">taskId</span><span class="p">).</span><span class="n">serialize</span><span class="p">()</span>
   <span class="p">}</span> <span class="k">catch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">bad_variant_access</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">ex</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">ex</span><span class="p">.</span><span class="n">what</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">": taskID didn't contain TaskID</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="use-stdvariant-combined-with-an-enum">Use <code class="language-plaintext highlighter-rouge">std::variant</code> combined with an <code class="language-plaintext highlighter-rouge">enum</code></h2><p>There is an interesting option we haven’t experimented with yet. We could use <code class="language-plaintext highlighter-rouge">std::variant</code> with only two types, <code class="language-plaintext highlighter-rouge">TaskID</code> in the second place and an enum in the first place which can hold the different invalid states.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;variant&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">InvalidTaskIDStates</span> <span class="p">{</span>
<span class="n">InvalidTaskID</span><span class="p">,</span>
<span class="n">UninitialziedTaskID</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">TaskID</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">TaskID</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">uuid</span><span class="p">)</span><span class="o">:</span> <span class="n">m_uuid</span><span class="p">(</span><span class="n">uuid</span><span class="p">){};</span>
 <span class="k">private</span><span class="o">:</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_uuid</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">holds_alternative</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="o">&gt;</span><span class="p">(</span><span class="n">taskID</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">return</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">taskID</span><span class="p">)</span> <span class="p">{</span>
   <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">holds_alternative</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="o">&gt;</span><span class="p">(</span><span class="n">taskID</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">switch</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="o">&gt;</span><span class="p">(</span><span class="n">taskID</span><span class="p">))</span> <span class="p">{</span>
         <span class="k">case</span> <span class="n">InvalidTaskIDStates</span><span class="o">::</span><span class="n">InvalidTaskID</span><span class="p">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"InvalidTaskID</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
         <span class="k">case</span> <span class="n">InvalidTaskIDStates</span><span class="o">::</span><span class="n">UninitialziedTaskID</span><span class="p">:</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"UninitialziedTaskID</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
            <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
   <span class="p">}</span>
   <span class="c1">// ...</span>
   <span class="n">taskID</span><span class="p">.</span><span class="n">serialize</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;</span> <span class="n">myvar</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">InvalidTaskIDStates</span><span class="p">,</span> <span class="n">TaskID</span><span class="o">&gt;&gt;</span> <span class="n">tasks</span><span class="p">;</span>
    <span class="n">tasks</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">tasks</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">TaskID</span><span class="p">{</span><span class="s">"ab12"</span><span class="p">});</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">tasks</span><span class="p">.</span><span class="n">front</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>On the positive side, we can say that if we are interested in invalid states, we only have one variant to check. On the other hand, if we are interested in which invalid state a variable holds, we’ll need to mix two kinds of grammar. We need to use the API of <code class="language-plaintext highlighter-rouge">std::variant</code> and the syntax related to <code class="language-plaintext highlighter-rouge">enum</code>s as well.</p><h2 id="conclusion">Conclusion</h2><p>Today, we discussed what options we have if we don’t want our type to have a default constructor because it doesn’t make sense. We’ve seen that even in those cases having a default constructor might make sense, initializing the object to a kind of an invalid state. Even though it’s really not a best practice.</p><p>Types without a default constructor are sometimes hard to use with containers. Our options are also limited when we need to compose other types that are default constructible, but one of the members have no default constructor. In such cases, we can wrap these types into <code class="language-plaintext highlighter-rouge">std::optional</code> or <code class="language-plaintext highlighter-rouge">std::variant</code> based on our needs.</p><p>Of course, we could use (smart) pointers as well, but that’s not an option we discussed, because dynamic memory allocation is clearly not something we need to solve the original problem.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/builds/" class="post-tag no-text-decoration" >builds</a> <a href="/tags/dependencies/" class="post-tag no-text-decoration" >dependencies</a> <a href="/tags/architecture/" class="post-tag no-text-decoration" >architecture</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=What to do if you don't want a default constructor? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=What to do if you don't want a default constructor? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=What to do if you don't want a default constructor? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=What to do if you don't want a default constructor? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/06/12/builds-and-dependencies"><div class="card-body"> <span class="timeago small" > Jun 12, 2024 <i class="unloaded">2024-06-12T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Limit the number of library dependencies</h3><div class="text-muted small"><p> First, let’s discuss what a dependency is. When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about dependency inj...</p></div></div></a></div><div class="card"> <a href="/blog/2022/07/23/hands-on-design-patterns-by-fedor-pikus"><div class="card-body"> <span class="timeago small" > Jul 23, 2022 <i class="unloaded">2022-07-23T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Hands-On Design Patterns with C++ by Fedor Pikus</h3><div class="text-muted small"><p> In Hands-On Design Patterns with C++, the author Fedor Pikus shares the most common design patterns used in modern C++. In fact, not only design patterns but also some best practices and idioms. He...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/17/cpp-software-design-by-klaus-iglberger"><div class="card-body"> <span class="timeago small" > Dec 17, 2022 <i class="unloaded">2022-12-17T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ Software Design by Klaus Iglberger</h3><div class="text-muted small"><p> The first time I - virtually - met Klaus was at C++ On Sea, I think in 2020. He held a workshop about modern software design which I managed to partially attend. He spoke in a slow and friendly man...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/07/10/cpponsea2024-trip-report" class="btn btn-outline-primary" prompt="Older"><p>Trip report: C++ On Sea 2024</p></a> <a href="/blog/2024/07/24/5-reasons-not-to-talk-about-politics-at-work" class="btn btn-outline-primary" prompt="Newer"><p>5 reasons why politics will ruin your career hopes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'What to do if you don't want a default constructor?'; this.page.url = 'https://www.sandordargo.com/blog/2024/07/17/what-should-be-a-default-value'; this.page.identifier = '/blog/2024/07/17/what-should-be-a-default-value'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
