<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Once more about the rule of 5" /><meta property="og:locale" content="en_US" /><meta name="description" content="Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule of Five tells us that if we need to define any of a copy constructor, copy assignment operator, move constructor, move assignment operator or destructor then we usually need to define all five. Fair enough. Have you ever seen classes where the default constructor and destructor are explicitly defaulted? Like this? 1 2 3 4 5 6 7 8 9 class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; First of all, that’s not the best idea. You can simply remove them. But let’s assume that you cannot remove the user-provided destructor for some reason. Maybe it’s not defaulted and it does something. What does the famous Hinnant table tell us? The Hinnant table (source: https://howardhinnant.github.io/) It says that when the user declares a destructor, the move operations are not declared. Hmmm… What does that mean? Does it support move operations or not? If you’re not familiar with the details, but you got the idea to test class properties at compile-time, you might add some static assertions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;type_traits&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { return 0; } They all pass! Does it mean that we have what we wanted? Does it mean that SomeClass really supports move operations? Well… Either we overlooked something or the rule of five and the above Hinnant-table is not totally correct. Considering those options, of course, we overlooked something. If you watch a few minutes of this talk by Howard Hinnant from 18:20, the picture will be clearer. First of all, if something is mentioned as not declared, it will not be part of the overload resolution. Second, and probably this is more important, for move operations this means that they are not available, but there will be an automatic fallback to copy operations. Otherwise, way too many classes would have been broken by C++11. So in the above case, the two static assertions about move operations only mean that code would compile if move operations were requested. Not that actual move operations would happen. That’s too bad. How can we still be sure about what is going on? We can have an indirect proof with the help of C++Insights. Let’s include the &lt;utility&gt; header and add some explicit move operations to our code first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;type_traits&gt; #include &lt;utility&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { SomeClass s1; SomeClass s2 = std::move(s1); return 0; } And now let’s run it in C++ Insights. “C++ Insights is a clang-based tool which does a source to source transformation. Its goal is to make things visible, which normally and intentionally happen behind the scenes. It’s about the magic the compiler does for us to make things work. Or looking through the classes of a compiler.” The above class definition is expanded as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class SomeClass { public: inline constexpr SomeClass() noexcept = default; inline ~SomeClass() noexcept = default; void foo(); private: int m_num; public: // inline constexpr SomeClass(const SomeClass &amp;) noexcept = default; }; We can observe some inline and noexcept specifiers being added to the constructor and destructor, and the constructor is even constexpr. What is more important though is the commented out line. It’s a copy constructor… It’s sad because we expected a move right? But the Hinnant-table already hinted to us that there would be no move operations declared if we declare our own destructor. Let’s see what happens if we remove the user-provided destructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 class SomeClass { public: inline constexpr SomeClass() noexcept = default; void foo(); private: int m_num; public: // inline constexpr SomeClass(SomeClass &amp;&amp;) noexcept = default; }; Not surprisingly, the destructor disappeared from the expanded C++ Insight version. We can also observe that the commented out line now doesn’t specify a copy, but rather a move constructor. In other words, by providing a destructor, we lost the ability to use move semantics. Let’s see what Compiler Explorer says! But before, I added another member, a std::string so that optimizations aren’t so easy to perform. This is the new example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;string&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; std::string m_text; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { SomeClass s1; SomeClass s2 = std::move(s1); return 0; } Now the assembly for the line SomeClass s2 = std::move(s1); is a call to the copy constructor! call SomeClass::SomeClass(SomeClass const&amp;) [base object constructor] If we remove the user-declared destructor, it becomes a call to the move constructor: call SomeClass::SomeClass(SomeClass&amp;&amp;) [base object constructor] Conclusion Both C++ Insights and Compiler Explorer confirmed the same. By providing a destructor while not following the rule of five, our classes lose the ability to support move semantics. Yet, due to backward compatibility, they don’t fail to compile, they silently fall back to copy semantics. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule of Five tells us that if we need to define any of a copy constructor, copy assignment operator, move constructor, move assignment operator or destructor then we usually need to define all five. Fair enough. Have you ever seen classes where the default constructor and destructor are explicitly defaulted? Like this? 1 2 3 4 5 6 7 8 9 class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; First of all, that’s not the best idea. You can simply remove them. But let’s assume that you cannot remove the user-provided destructor for some reason. Maybe it’s not defaulted and it does something. What does the famous Hinnant table tell us? The Hinnant table (source: https://howardhinnant.github.io/) It says that when the user declares a destructor, the move operations are not declared. Hmmm… What does that mean? Does it support move operations or not? If you’re not familiar with the details, but you got the idea to test class properties at compile-time, you might add some static assertions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;type_traits&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { return 0; } They all pass! Does it mean that we have what we wanted? Does it mean that SomeClass really supports move operations? Well… Either we overlooked something or the rule of five and the above Hinnant-table is not totally correct. Considering those options, of course, we overlooked something. If you watch a few minutes of this talk by Howard Hinnant from 18:20, the picture will be clearer. First of all, if something is mentioned as not declared, it will not be part of the overload resolution. Second, and probably this is more important, for move operations this means that they are not available, but there will be an automatic fallback to copy operations. Otherwise, way too many classes would have been broken by C++11. So in the above case, the two static assertions about move operations only mean that code would compile if move operations were requested. Not that actual move operations would happen. That’s too bad. How can we still be sure about what is going on? We can have an indirect proof with the help of C++Insights. Let’s include the &lt;utility&gt; header and add some explicit move operations to our code first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;type_traits&gt; #include &lt;utility&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { SomeClass s1; SomeClass s2 = std::move(s1); return 0; } And now let’s run it in C++ Insights. “C++ Insights is a clang-based tool which does a source to source transformation. Its goal is to make things visible, which normally and intentionally happen behind the scenes. It’s about the magic the compiler does for us to make things work. Or looking through the classes of a compiler.” The above class definition is expanded as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class SomeClass { public: inline constexpr SomeClass() noexcept = default; inline ~SomeClass() noexcept = default; void foo(); private: int m_num; public: // inline constexpr SomeClass(const SomeClass &amp;) noexcept = default; }; We can observe some inline and noexcept specifiers being added to the constructor and destructor, and the constructor is even constexpr. What is more important though is the commented out line. It’s a copy constructor… It’s sad because we expected a move right? But the Hinnant-table already hinted to us that there would be no move operations declared if we declare our own destructor. Let’s see what happens if we remove the user-provided destructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 class SomeClass { public: inline constexpr SomeClass() noexcept = default; void foo(); private: int m_num; public: // inline constexpr SomeClass(SomeClass &amp;&amp;) noexcept = default; }; Not surprisingly, the destructor disappeared from the expanded C++ Insight version. We can also observe that the commented out line now doesn’t specify a copy, but rather a move constructor. In other words, by providing a destructor, we lost the ability to use move semantics. Let’s see what Compiler Explorer says! But before, I added another member, a std::string so that optimizations aren’t so easy to perform. This is the new example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;string&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; std::string m_text; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { SomeClass s1; SomeClass s2 = std::move(s1); return 0; } Now the assembly for the line SomeClass s2 = std::move(s1); is a call to the copy constructor! call SomeClass::SomeClass(SomeClass const&amp;) [base object constructor] If we remove the user-declared destructor, it becomes a call to the move constructor: call SomeClass::SomeClass(SomeClass&amp;&amp;) [base object constructor] Conclusion Both C++ Insights and Compiler Explorer confirmed the same. By providing a destructor while not following the rule of five, our classes lose the ability to support move semantics. Yet, due to backward compatibility, they don’t fail to compile, they silently fall back to copy semantics. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-07-31T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Once more about the rule of 5" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-07-31T00:00:00+02:00","datePublished":"2024-07-31T00:00:00+02:00","description":"Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule of Five tells us that if we need to define any of a copy constructor, copy assignment operator, move constructor, move assignment operator or destructor then we usually need to define all five. Fair enough. Have you ever seen classes where the default constructor and destructor are explicitly defaulted? Like this? 1 2 3 4 5 6 7 8 9 class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; First of all, that’s not the best idea. You can simply remove them. But let’s assume that you cannot remove the user-provided destructor for some reason. Maybe it’s not defaulted and it does something. What does the famous Hinnant table tell us? The Hinnant table (source: https://howardhinnant.github.io/) It says that when the user declares a destructor, the move operations are not declared. Hmmm… What does that mean? Does it support move operations or not? If you’re not familiar with the details, but you got the idea to test class properties at compile-time, you might add some static assertions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;type_traits&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { return 0; } They all pass! Does it mean that we have what we wanted? Does it mean that SomeClass really supports move operations? Well… Either we overlooked something or the rule of five and the above Hinnant-table is not totally correct. Considering those options, of course, we overlooked something. If you watch a few minutes of this talk by Howard Hinnant from 18:20, the picture will be clearer. First of all, if something is mentioned as not declared, it will not be part of the overload resolution. Second, and probably this is more important, for move operations this means that they are not available, but there will be an automatic fallback to copy operations. Otherwise, way too many classes would have been broken by C++11. So in the above case, the two static assertions about move operations only mean that code would compile if move operations were requested. Not that actual move operations would happen. That’s too bad. How can we still be sure about what is going on? We can have an indirect proof with the help of C++Insights. Let’s include the &lt;utility&gt; header and add some explicit move operations to our code first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 #include &lt;type_traits&gt; #include &lt;utility&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { SomeClass s1; SomeClass s2 = std::move(s1); return 0; } And now let’s run it in C++ Insights. “C++ Insights is a clang-based tool which does a source to source transformation. Its goal is to make things visible, which normally and intentionally happen behind the scenes. It’s about the magic the compiler does for us to make things work. Or looking through the classes of a compiler.” The above class definition is expanded as below: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class SomeClass { public: inline constexpr SomeClass() noexcept = default; inline ~SomeClass() noexcept = default; void foo(); private: int m_num; public: // inline constexpr SomeClass(const SomeClass &amp;) noexcept = default; }; We can observe some inline and noexcept specifiers being added to the constructor and destructor, and the constructor is even constexpr. What is more important though is the commented out line. It’s a copy constructor… It’s sad because we expected a move right? But the Hinnant-table already hinted to us that there would be no move operations declared if we declare our own destructor. Let’s see what happens if we remove the user-provided destructor. 1 2 3 4 5 6 7 8 9 10 11 12 13 class SomeClass { public: inline constexpr SomeClass() noexcept = default; void foo(); private: int m_num; public: // inline constexpr SomeClass(SomeClass &amp;&amp;) noexcept = default; }; Not surprisingly, the destructor disappeared from the expanded C++ Insight version. We can also observe that the commented out line now doesn’t specify a copy, but rather a move constructor. In other words, by providing a destructor, we lost the ability to use move semantics. Let’s see what Compiler Explorer says! But before, I added another member, a std::string so that optimizations aren’t so easy to perform. This is the new example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;type_traits&gt; #include &lt;utility&gt; #include &lt;string&gt; class SomeClass { public: SomeClass() = default; ~SomeClass() = default; void foo(); private: int m_num{42}; std::string m_text; }; static_assert(std::is_default_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_constructible_v&lt;SomeClass&gt;); static_assert(std::is_copy_assignable_v&lt;SomeClass&gt;); static_assert(std::is_move_constructible_v&lt;SomeClass&gt;); static_assert(std::is_move_assignable_v&lt;SomeClass&gt;); int main() { SomeClass s1; SomeClass s2 = std::move(s1); return 0; } Now the assembly for the line SomeClass s2 = std::move(s1); is a call to the copy constructor! call SomeClass::SomeClass(SomeClass const&amp;) [base object constructor] If we remove the user-declared destructor, it becomes a call to the move constructor: call SomeClass::SomeClass(SomeClass&amp;&amp;) [base object constructor] Conclusion Both C++ Insights and Compiler Explorer confirmed the same. By providing a destructor while not following the rule of five, our classes lose the ability to support move semantics. Yet, due to backward compatibility, they don’t fail to compile, they silently fall back to copy semantics. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Once more about the rule of 5","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again"},"url":"https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again"}</script><title>Once more about the rule of 5 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/07"> 07 </a> </span> <span> <a href="/31"> 31 </a> </span> <span>Once more about the rule of 5</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Once more about the rule of 5</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 31, 2024, 12:00 AM +0200" prep="on" > Jul 31, 2024 <i class="unloaded">2024-07-31T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="986 words">5 min</span></div></div><div class="post-content"><p><a href="https://www.sandordargo.com/blog/2024/07/10/cpponsea2024-trip-report#my-favourite-talks">Arne Mertz talked about misused guidelines at C++OnSea</a>. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen.</p><p>Let’s first repeat what the rule of 5 says.</p><blockquote><p>The Rule of Five tells us that if we need to define any of a copy constructor, copy assignment operator, move constructor, move assignment operator or destructor then we usually need to define all five.</p></blockquote><p>Fair enough.</p><p>Have you ever seen classes where the default constructor and destructor are explicitly defaulted? Like this?</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="p">};</span>
</pre></table></code></div></div><p>First of all, that’s not the best idea. You can simply remove them. But let’s assume that you cannot remove the user-provided destructor for some reason. Maybe it’s not defaulted and it does something.</p><p>What does the famous Hinnant table tell us?</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/hinnant-table.jpg" alt="The Hinnant table" title="The Hinnant table" /> <em>The Hinnant table (source: https://howardhinnant.github.io/)</em></p><p>It says that when the user declares a destructor, the move operations are not declared. Hmmm… What does that mean?</p><p>Does it support move operations or not?</p><p>If you’re not familiar with the details, but you got the idea to test class properties at compile-time, you might add some static assertions.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_assignable_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_assignable_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>They all pass!</p><p>Does it mean that we have what we wanted? Does it mean that <code class="language-plaintext highlighter-rouge">SomeClass</code> really supports move operations?</p><p>Well… Either we overlooked something or the rule of five and the above Hinnant-table is not totally correct.</p><p>Considering those options, of course, we overlooked something.</p><p>If you watch a few minutes of <a href="https://youtu.be/vLinb2fgkHk?si=42VB8-4QEpBNt4CP&amp;t=1100">this talk by Howard Hinnant from 18:20</a>, the picture will be clearer. First of all, if something is mentioned as not declared, it will not be part of the overload resolution. Second, and probably this is more important, for move operations this means that they are not available, but there will be an automatic fallback to copy operations. Otherwise, way too many classes would have been broken by C++11.</p><p>So in the above case, the two static assertions about move operations only mean that code would compile if move operations were requested. Not that actual move operations would happen.</p><p>That’s too bad. How can we still be sure about what is going on?</p><p>We can have an indirect proof with the help of C++Insights. Let’s include the <code class="language-plaintext highlighter-rouge">&lt;utility&gt;</code> header and add some explicit move operations to our code first.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_assignable_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_assignable_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">SomeClass</span> <span class="n">s1</span><span class="p">;</span>
    <span class="n">SomeClass</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And now let’s run it in <a href="https://cppinsights.io/about.html">C++ Insights</a>.</p><blockquote><p><em>“C++ Insights is a clang-based tool which does a source to source transformation. Its goal is to make things visible, which normally and intentionally happen behind the scenes. It’s about the magic the compiler does for us to make things work. Or looking through the classes of a compiler.”</em></p></blockquote><p>The above class definition is expanded as below:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">SomeClass</span>
<span class="p">{</span>
  
  <span class="nl">public:</span> 
  <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">SomeClass</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="kr">inline</span> <span class="o">~</span><span class="n">SomeClass</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
  
  
  <span class="nl">private:</span> 
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
  <span class="nl">public:</span> 
  <span class="c1">// inline constexpr SomeClass(const SomeClass &amp;) noexcept = default;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>We can observe some <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">noexcept</code> specifiers being added to the constructor and destructor, and the constructor is even <code class="language-plaintext highlighter-rouge">constexpr</code>. What is more important though is the commented out line. It’s a copy constructor…</p><p>It’s sad because we expected a move right? But the Hinnant-table already hinted to us that there would be no move operations declared if we declare our own destructor. Let’s see what happens if we remove the user-provided destructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">SomeClass</span>
<span class="p">{</span>
  
  <span class="nl">public:</span> 
  <span class="kr">inline</span> <span class="k">constexpr</span> <span class="n">SomeClass</span><span class="p">()</span> <span class="k">noexcept</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
  
  
  <span class="nl">private:</span> 
  <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
  <span class="nl">public:</span> 
  <span class="c1">// inline constexpr SomeClass(SomeClass &amp;&amp;) noexcept = default;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>Not surprisingly, the destructor disappeared from the expanded C++ Insight version. We can also observe that the commented out line now doesn’t specify a copy, but rather a move constructor.</p><p>In other words, by providing a destructor, we lost the ability to use move semantics.</p><p>Let’s see what Compiler Explorer says! But before, I added another member, a <code class="language-plaintext highlighter-rouge">std::string</code> so that optimizations aren’t so easy to perform.</p><p>This is the new example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="o">~</span><span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>
<span class="nl">private:</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_assignable_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_assignable_v</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">SomeClass</span> <span class="n">s1</span><span class="p">;</span>
    <span class="n">SomeClass</span> <span class="n">s2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">s1</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now the assembly for the line <code class="language-plaintext highlighter-rouge">SomeClass s2 = std::move(s1);</code> is a call to the copy constructor!</p><pre><code class="language-asm">call    SomeClass::SomeClass(SomeClass const&amp;) [base object constructor]
</code></pre><p>If we remove the user-declared destructor, it becomes a call to the move constructor:</p><pre><code class="language-asm">call    SomeClass::SomeClass(SomeClass&amp;&amp;) [base object constructor]
</code></pre><h2 id="conclusion">Conclusion</h2><p>Both C++ Insights and Compiler Explorer confirmed the same. By providing a destructor while not following the rule of five, our classes lose the ability to support move semantics. Yet, due to backward compatibility, they don’t fail to compile, they silently fall back to copy semantics.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/move-only-function/" class="post-tag no-text-decoration" >move_only_function</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Once more about the rule of 5 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Once more about the rule of 5 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Once more about the rule of 5 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Once more about the rule of 5 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/08/07/rule-of-five-and-base-classes"><div class="card-body"> <span class="timeago small" > Aug 7, 2024 <i class="unloaded">2024-08-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The rule of 5 and inheritance</h3><div class="text-muted small"><p> Last week, we talked about the rule of five and we discovered what it means for move operations if we only declare a destructor and not the rest of the special member functions. In that case, move ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/21/std-ref"><div class="card-body"> <span class="timeago small" > Aug 21, 2024 <i class="unloaded">2024-08-21T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What is std::ref?</h3><div class="text-muted small"><p> Have you heard about std::ref and std::cref? The helper functions that generate objects of type std::reference_wrapper? The answer is probably yes. In that case, this article is probably not for yo...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/07/24/5-reasons-not-to-talk-about-politics-at-work" class="btn btn-outline-primary" prompt="Older"><p>5 reasons why politics will ruin your career hopes</p></a> <a href="/blog/2024/08/07/rule-of-five-and-base-classes" class="btn btn-outline-primary" prompt="Newer"><p>The rule of 5 and inheritance</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Once more about the rule of 5'; this.page.url = 'https://www.sandordargo.com/blog/2024/07/31/rule-of-5-once-again'; this.page.identifier = '/blog/2024/07/31/rule-of-5-once-again'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
