<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Use std::span instead of C-style arrays" /><meta property="og:locale" content="en_US" /><meta name="description" content="While reading the awesome book C++ Brain Teasers by Anders Schau Knatten, I realized it might be worth writing about spans. std::span is a class template that was added to the standard library in C++20 and you’ll find it in the &lt;span&gt; header. A span is a non-owning object that refers to a contiguous sequence of objects with the first sequence element at position zero. In its goal, a span is quite similar to a string_view. While a string_view is a non-owning view of string-like objects, a span is also a non-owning view for array-like objects where the stored elements occupy contiguous places in memory. While it’s possible to use spans with vectors and arrays, most frequently it will be used with C-style arrays because a span gives you safe access to its elements and also to the size of the view, something that you don’t get with C-style arrays. When and why does it come in handy? Let me steal an example from C++ Brain Teasers, but we’ll go with another solution compared to the one in the book. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; void serialize(char characters[]) { std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; } int main() { char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\n&quot;; serialize(characters); } In the above piece of code, serialize takes an array of characters. When we define the array of characters in main(), we can use sizeof to print the size of the array. Well, we actually print how many bytes the characters[] array occupies. Let me demonstrate. 1 2 3 4 5 char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; /* 3 */ When we try to print the size of a char array all seems fine. We expect 3 and the output is three. But use another type, like an int and we see there is a problem: 1 2 3 4 5 int ints[] = {1, 2, 3}; std::cout &lt;&lt; sizeof(ints) &lt;&lt; &quot;\n&quot;; /* 12 */ The output is 12, because we printed the memory size the array needs and that’s 3 times the size of an int in this case. As an int on my system is 4 bytes, the output is 3 * 4 bytes, that is 12. As the size of a char is 1 byte the memory size of the array and the number of elements in it are the same. If you want to know how many elements are there in a C-style array of any type, you have to use this good old verbose and cumbersome pattern: 1 2 3 4 5 6 std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(ints) / sizeof(ints[0]) &lt;&lt; &quot;\n&quot;; /* 3 3 */ Dividing the size of the array with the size of the first item will always work. Well, not always. In the above examples, we had the arrays declared in the same scope - or at least we assumed that they were declared there. But if the array is a function parameter, our assumptions break down. Let’s have a look at the following example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;span&gt; void serialize(char characters[]) { std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\n&quot;; } void serialize(int ints[]) { std::cout &lt;&lt; sizeof(ints) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(ints) / sizeof(ints[0]) &lt;&lt; &quot;\n&quot;; } int main() { int ints[] = {1, 2, 3}; char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; serialize(characters); serialize(ints); } /* 8 8 2 2 */ The outputs are broken both the size of the arrays and the number of items in them. The reason is that when a function takes a C-style array as an argument, the array is implicitly converted into a pointer. This is also called array decay. From a usage perspective, it still means that we can access individual elements, but we lost any means to compute the array size because the size of the parameter is not the size of the array anymore, simply the size of a pointer point to the first element of the array. That’s why we can often observe in C-style APIs that along an array its size is also passed. With std::span we don’t need that anymore. As a std::span is a proper (non-owning) object, it doesn’t decay to a pointer. On the other hand, a C-style array can be implicitly converted into a span. A span gives you access to the number of elements in it (without having to do a verbose and error-prone calculation), it gives you an easy way to access the items in the span and it’s also iterable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;span&gt; void serialize(std::span&lt;char&gt; characters) { std::cout &lt;&lt; characters.size() &lt;&lt; &quot;\n&quot;; for(size_t i = 0; i &lt; characters.size(); ++i) { std::cout &lt;&lt; characters[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39;; for (const auto c: characters) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39;; } int main() { char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; serialize(characters); } As a general rule of thumb, I’d recommend not using C-style arrays, but if you have no choice, use spans as function parameters to make it easier and safer to work with them. Conclusion C-style arrays are still used, mostly when you have to deal with C-libraries. They come with significant limitations, particularly when passed to functions where array decay occurs, leading to the loss of size information. std::span, introduced in C++20, solves this issue by providing a safe, non-owning view of contiguous data, retaining the size and offering easy access to elements. It simplifies working with arrays in functions without needing additional parameters for size, making code safer and more concise. Whenever possible, it’s advisable to replace C-style arrays with spans for more robust and maintainable code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="While reading the awesome book C++ Brain Teasers by Anders Schau Knatten, I realized it might be worth writing about spans. std::span is a class template that was added to the standard library in C++20 and you’ll find it in the &lt;span&gt; header. A span is a non-owning object that refers to a contiguous sequence of objects with the first sequence element at position zero. In its goal, a span is quite similar to a string_view. While a string_view is a non-owning view of string-like objects, a span is also a non-owning view for array-like objects where the stored elements occupy contiguous places in memory. While it’s possible to use spans with vectors and arrays, most frequently it will be used with C-style arrays because a span gives you safe access to its elements and also to the size of the view, something that you don’t get with C-style arrays. When and why does it come in handy? Let me steal an example from C++ Brain Teasers, but we’ll go with another solution compared to the one in the book. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; void serialize(char characters[]) { std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; } int main() { char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\n&quot;; serialize(characters); } In the above piece of code, serialize takes an array of characters. When we define the array of characters in main(), we can use sizeof to print the size of the array. Well, we actually print how many bytes the characters[] array occupies. Let me demonstrate. 1 2 3 4 5 char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; /* 3 */ When we try to print the size of a char array all seems fine. We expect 3 and the output is three. But use another type, like an int and we see there is a problem: 1 2 3 4 5 int ints[] = {1, 2, 3}; std::cout &lt;&lt; sizeof(ints) &lt;&lt; &quot;\n&quot;; /* 12 */ The output is 12, because we printed the memory size the array needs and that’s 3 times the size of an int in this case. As an int on my system is 4 bytes, the output is 3 * 4 bytes, that is 12. As the size of a char is 1 byte the memory size of the array and the number of elements in it are the same. If you want to know how many elements are there in a C-style array of any type, you have to use this good old verbose and cumbersome pattern: 1 2 3 4 5 6 std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(ints) / sizeof(ints[0]) &lt;&lt; &quot;\n&quot;; /* 3 3 */ Dividing the size of the array with the size of the first item will always work. Well, not always. In the above examples, we had the arrays declared in the same scope - or at least we assumed that they were declared there. But if the array is a function parameter, our assumptions break down. Let’s have a look at the following example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;span&gt; void serialize(char characters[]) { std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\n&quot;; } void serialize(int ints[]) { std::cout &lt;&lt; sizeof(ints) &lt;&lt; &quot;\n&quot;; std::cout &lt;&lt; sizeof(ints) / sizeof(ints[0]) &lt;&lt; &quot;\n&quot;; } int main() { int ints[] = {1, 2, 3}; char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; serialize(characters); serialize(ints); } /* 8 8 2 2 */ The outputs are broken both the size of the arrays and the number of items in them. The reason is that when a function takes a C-style array as an argument, the array is implicitly converted into a pointer. This is also called array decay. From a usage perspective, it still means that we can access individual elements, but we lost any means to compute the array size because the size of the parameter is not the size of the array anymore, simply the size of a pointer point to the first element of the array. That’s why we can often observe in C-style APIs that along an array its size is also passed. With std::span we don’t need that anymore. As a std::span is a proper (non-owning) object, it doesn’t decay to a pointer. On the other hand, a C-style array can be implicitly converted into a span. A span gives you access to the number of elements in it (without having to do a verbose and error-prone calculation), it gives you an easy way to access the items in the span and it’s also iterable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;span&gt; void serialize(std::span&lt;char&gt; characters) { std::cout &lt;&lt; characters.size() &lt;&lt; &quot;\n&quot;; for(size_t i = 0; i &lt; characters.size(); ++i) { std::cout &lt;&lt; characters[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39;; for (const auto c: characters) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39;; } int main() { char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; serialize(characters); } As a general rule of thumb, I’d recommend not using C-style arrays, but if you have no choice, use spans as function parameters to make it easier and safer to work with them. Conclusion C-style arrays are still used, mostly when you have to deal with C-libraries. They come with significant limitations, particularly when passed to functions where array decay occurs, leading to the loss of size information. std::span, introduced in C++20, solves this issue by providing a safe, non-owning view of contiguous data, retaining the size and offering easy access to elements. It simplifies working with arrays in functions without needing additional parameters for size, making code safer and more concise. Whenever possible, it’s advisable to replace C-style arrays with spans for more robust and maintainable code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/11/06/std-span" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/11/06/std-span" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-06T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Use std::span instead of C-style arrays" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-06T00:00:00+01:00","datePublished":"2024-11-06T00:00:00+01:00","description":"While reading the awesome book C++ Brain Teasers by Anders Schau Knatten, I realized it might be worth writing about spans. std::span is a class template that was added to the standard library in C++20 and you’ll find it in the &lt;span&gt; header. A span is a non-owning object that refers to a contiguous sequence of objects with the first sequence element at position zero. In its goal, a span is quite similar to a string_view. While a string_view is a non-owning view of string-like objects, a span is also a non-owning view for array-like objects where the stored elements occupy contiguous places in memory. While it’s possible to use spans with vectors and arrays, most frequently it will be used with C-style arrays because a span gives you safe access to its elements and also to the size of the view, something that you don’t get with C-style arrays. When and why does it come in handy? Let me steal an example from C++ Brain Teasers, but we’ll go with another solution compared to the one in the book. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; void serialize(char characters[]) { std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\\n&quot;; } int main() { char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\\n&quot;; serialize(characters); } In the above piece of code, serialize takes an array of characters. When we define the array of characters in main(), we can use sizeof to print the size of the array. Well, we actually print how many bytes the characters[] array occupies. Let me demonstrate. 1 2 3 4 5 char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\\n&quot;; /* 3 */ When we try to print the size of a char array all seems fine. We expect 3 and the output is three. But use another type, like an int and we see there is a problem: 1 2 3 4 5 int ints[] = {1, 2, 3}; std::cout &lt;&lt; sizeof(ints) &lt;&lt; &quot;\\n&quot;; /* 12 */ The output is 12, because we printed the memory size the array needs and that’s 3 times the size of an int in this case. As an int on my system is 4 bytes, the output is 3 * 4 bytes, that is 12. As the size of a char is 1 byte the memory size of the array and the number of elements in it are the same. If you want to know how many elements are there in a C-style array of any type, you have to use this good old verbose and cumbersome pattern: 1 2 3 4 5 6 std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; sizeof(ints) / sizeof(ints[0]) &lt;&lt; &quot;\\n&quot;; /* 3 3 */ Dividing the size of the array with the size of the first item will always work. Well, not always. In the above examples, we had the arrays declared in the same scope - or at least we assumed that they were declared there. But if the array is a function parameter, our assumptions break down. Let’s have a look at the following example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;span&gt; void serialize(char characters[]) { std::cout &lt;&lt; sizeof(characters) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; sizeof(characters) / sizeof(characters[0]) &lt;&lt; &quot;\\n&quot;; } void serialize(int ints[]) { std::cout &lt;&lt; sizeof(ints) &lt;&lt; &quot;\\n&quot;; std::cout &lt;&lt; sizeof(ints) / sizeof(ints[0]) &lt;&lt; &quot;\\n&quot;; } int main() { int ints[] = {1, 2, 3}; char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; serialize(characters); serialize(ints); } /* 8 8 2 2 */ The outputs are broken both the size of the arrays and the number of items in them. The reason is that when a function takes a C-style array as an argument, the array is implicitly converted into a pointer. This is also called array decay. From a usage perspective, it still means that we can access individual elements, but we lost any means to compute the array size because the size of the parameter is not the size of the array anymore, simply the size of a pointer point to the first element of the array. That’s why we can often observe in C-style APIs that along an array its size is also passed. With std::span we don’t need that anymore. As a std::span is a proper (non-owning) object, it doesn’t decay to a pointer. On the other hand, a C-style array can be implicitly converted into a span. A span gives you access to the number of elements in it (without having to do a verbose and error-prone calculation), it gives you an easy way to access the items in the span and it’s also iterable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;span&gt; void serialize(std::span&lt;char&gt; characters) { std::cout &lt;&lt; characters.size() &lt;&lt; &quot;\\n&quot;; for(size_t i = 0; i &lt; characters.size(); ++i) { std::cout &lt;&lt; characters[i] &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\\n&#39;; for (const auto c: characters) { std::cout &lt;&lt; c &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\\n&#39;; } int main() { char characters[] = {&#39;a&#39;, &#39;b&#39;, &#39;c&#39;}; serialize(characters); } As a general rule of thumb, I’d recommend not using C-style arrays, but if you have no choice, use spans as function parameters to make it easier and safer to work with them. Conclusion C-style arrays are still used, mostly when you have to deal with C-libraries. They come with significant limitations, particularly when passed to functions where array decay occurs, leading to the loss of size information. std::span, introduced in C++20, solves this issue by providing a safe, non-owning view of contiguous data, retaining the size and offering easy access to elements. It simplifies working with arrays in functions without needing additional parameters for size, making code safer and more concise. Whenever possible, it’s advisable to replace C-style arrays with spans for more robust and maintainable code. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Use std::span instead of C-style arrays","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/11/06/std-span"},"url":"https://www.sandordargo.com/blog/2024/11/06/std-span"}</script><title>Use std::span instead of C-style arrays | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/06"> 06 </a> </span> <span>Use std::span instead of C-style arrays</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Use std::span instead of C-style arrays</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 6, 2024, 12:00 AM +0100" prep="on" > Nov 6, 2024 <i class="unloaded">2024-11-06T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1034 words">5 min</span></div></div><div class="post-content"><p>While reading the awesome book <a href="https://www.sandordargo.com/blog/2024/10/16/cpp-brain-teasers">C++ Brain Teasers by Anders Schau Knatten</a>, I realized it might be worth writing about spans.</p><p><code class="language-plaintext highlighter-rouge">std::span</code> is a class template that was added to the standard library in C++20 and you’ll find it in the <code class="language-plaintext highlighter-rouge">&lt;span&gt;</code> header. A <code class="language-plaintext highlighter-rouge">span</code> is a non-owning object that refers to a contiguous sequence of objects with the first sequence element at position zero.</p><p>In its goal, a <code class="language-plaintext highlighter-rouge">span</code> is quite similar to a <code class="language-plaintext highlighter-rouge">string_view</code>. While a <code class="language-plaintext highlighter-rouge">string_view</code> is a non-owning view of string-like objects, a <code class="language-plaintext highlighter-rouge">span</code> is also a non-owning view for array-like objects where the stored elements occupy contiguous places in memory.</p><p>While it’s possible to use <code class="language-plaintext highlighter-rouge">span</code>s with <code class="language-plaintext highlighter-rouge">vector</code>s and <code class="language-plaintext highlighter-rouge">array</code>s, most frequently it will be used with C-style arrays because a span gives you safe access to its elements and also to the size of the view, something that you don’t get with C-style arrays.</p><p>When and why does it come in handy?</p><p>Let me steal an example from C++ Brain Teasers, but we’ll go with another solution compared to the one in the book.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="kt">char</span> <span class="n">characters</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">characters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">serialize</span><span class="p">(</span><span class="n">characters</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the above piece of code, <code class="language-plaintext highlighter-rouge">serialize</code> takes an array of characters. When we define the array of characters in <code class="language-plaintext highlighter-rouge">main()</code>, we can use <code class="language-plaintext highlighter-rouge">sizeof</code> to print the size of the array. Well, we actually print how many bytes the <code class="language-plaintext highlighter-rouge">characters[]</code> array occupies. Let me demonstrate.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="n">characters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="cm">/*
3
*/</span>
</pre></table></code></div></div><p>When we try to print the size of a <code class="language-plaintext highlighter-rouge">char</code> array all seems fine. We expect 3 and the output is three. But use another type, like an <code class="language-plaintext highlighter-rouge">int</code> and we see there is a problem:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="n">ints</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="cm">/*
12
*/</span>
</pre></table></code></div></div><p>The output is 12, because we printed the memory size the array needs and that’s 3 times the size of an <code class="language-plaintext highlighter-rouge">int</code> in this case. As an <code class="language-plaintext highlighter-rouge">int</code> on my system is 4 bytes, the output is 3 * 4 bytes, that is 12. As the size of a <code class="language-plaintext highlighter-rouge">char</code> is 1 byte the memory size of the array and the number of elements in it are the same.</p><p>If you want to know how many elements are there in a C-style array of any type, you have to use this good old verbose and cumbersome pattern:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="cm">/*
3
3
*/</span>
</pre></table></code></div></div><p>Dividing the size of the array with the size of the first item will always work.</p><p>Well, not always.</p><p>In the above examples, we had the arrays declared in the same scope - or at least we assumed that they were declared there.</p><p>But if the array is a function parameter, our assumptions break down. Let’s have a look at the following example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;span&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="kt">char</span> <span class="n">characters</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">characters</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="kt">int</span> <span class="n">ints</span><span class="p">[])</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span> <span class="o">/</span> <span class="k">sizeof</span><span class="p">(</span><span class="n">ints</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">ints</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="kt">char</span> <span class="n">characters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">};</span>
    <span class="n">serialize</span><span class="p">(</span><span class="n">characters</span><span class="p">);</span>
    <span class="n">serialize</span><span class="p">(</span><span class="n">ints</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
8
8
2
2
*/</span>
</pre></table></code></div></div><p>The outputs are broken both the size of the arrays and the number of items in them. The reason is that when a function takes a C-style array as an argument, the array is implicitly converted into a pointer. This is also called array decay.</p><p>From a usage perspective, it still means that we can access individual elements, but we lost any means to compute the array size because the size of the parameter is not the size of the array anymore, simply the size of a pointer point to the first element of the array.</p><p>That’s why we can often observe in C-style APIs that along an array its size is also passed.</p><p>With <code class="language-plaintext highlighter-rouge">std::span</code> we don’t need that anymore.</p><p>As a <code class="language-plaintext highlighter-rouge">std::span</code> is a proper (non-owning) object, it doesn’t decay to a pointer. On the other hand, a C-style array can be implicitly converted into a <code class="language-plaintext highlighter-rouge">span</code>. A span gives you access to the number of elements in it (without having to do a verbose and error-prone calculation), it gives you an easy way to access the items in the span and it’s also iterable.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;span&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">serialize</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">characters</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">characters</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">characters</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">characters</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">c</span><span class="o">:</span> <span class="n">characters</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">c</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">char</span> <span class="n">characters</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">'a'</span><span class="p">,</span> <span class="sc">'b'</span><span class="p">,</span> <span class="sc">'c'</span><span class="p">};</span>
    <span class="n">serialize</span><span class="p">(</span><span class="n">characters</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As a general rule of thumb, I’d recommend not using C-style arrays, but if you have no choice, use spans as function parameters to make it easier and safer to work with them.</p><h2 id="conclusion">Conclusion</h2><p>C-style arrays are still used, mostly when you have to deal with C-libraries. They come with significant limitations, particularly when passed to functions where array decay occurs, leading to the loss of size information.</p><p><code class="language-plaintext highlighter-rouge">std::span</code>, introduced in C++20, solves this issue by providing a safe, non-owning view of contiguous data, retaining the size and offering easy access to elements. It simplifies working with arrays in functions without needing additional parameters for size, making code safer and more concise.</p><p>Whenever possible, it’s advisable to replace C-style arrays with spans for more robust and maintainable code.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/span/" class="post-tag no-text-decoration" >span</a> <a href="/tags/stl/" class="post-tag no-text-decoration" >stl</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Use std::span instead of C-style arrays - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/11/06/std-span" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Use std::span instead of C-style arrays - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/11/06/std-span" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Use std::span instead of C-style arrays - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/11/06/std-span" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Use std::span instead of C-style arrays - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/11/06/std-span" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2020/08/26/effective-stl"><div class="card-body"> <span class="timeago small" > Aug 26, 2020 <i class="unloaded">2020-08-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Effective STL: 50 Specific Ways to Improve Your Use of the Standard Template Library by Scott Meyers</h3><div class="text-muted small"><p> I have learned, written and spoken a lot about the Standard Template Library during the course of the last years. My sources have been mostly websites such as cppreference.com, cplusplus.com, blogs...</p></div></div></a></div><div class="card"> <a href="/blog/2021/04/03/cpp20-get-the-details-rainer-grimm"><div class="card-body"> <span class="timeago small" > Apr 3, 2021 <i class="unloaded">2021-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ 20: Get the details by Rainer Grimm</h3><div class="text-muted small"><p> I could say that I picked C++ 20: Get the details up because I wanted to learn about the latest version of C++. I wouldn’t lie if I said so, but truth be told I was already an avid reader of Modern...</p></div></div></a></div><div class="card"> <a href="/blog/2022/04/13/first-company-project-experience-with-cpp20"><div class="card-body"> <span class="timeago small" > Apr 13, 2022 <i class="unloaded">2022-04-13T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My first work experience with C++20</h3><div class="text-muted small"><p> I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/10/30/when-perf-was-about-algorithmic-complexity" class="btn btn-outline-primary" prompt="Older"><p>(When) performance is not about algorithmic complexity</p></a> <a href="/blog/2024/11/13/implicit-string-conversion-to-bool" class="btn btn-outline-primary" prompt="Newer"><p>Implicit string conversions to booleans</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Use std::span instead of C-style arrays'; this.page.url = 'https://www.sandordargo.com/blog/2024/11/06/std-span'; this.page.identifier = '/blog/2024/11/06/std-span'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
