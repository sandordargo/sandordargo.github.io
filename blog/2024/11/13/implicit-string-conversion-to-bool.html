<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Implicit string conversions to booleans" /><meta property="og:locale" content="en_US" /><meta name="description" content="From C++ Brain Teasers by Anders Schau Knatten, I learned about a compiler warning offered by Clang, called -Wstring-conversion. It emits a warning when a string literal is implicitly converted into a boolean. You might even be surprised that it is even possible. And why would anyone do that? Let’s start with the first part by explaining why such an implicit conversion is possible. A string literal is an array of const chars. Arrays can be converted into pointers, something we talked about last week when we discussed why spans are so useful. This is also called decay. Furthermore, pointers can be converted into booleans. That is how a string literal can be converted into a bool. 1 2 static_assert(!!&quot;&quot; == true); static_assert(static_cast&lt;bool&gt;(&quot;&quot;) == true); What might be surprising though is that even an empty string literal is converted into true. The reason is that only a nullptr would be converted into false, but an empty string literal is an array of a size of one so it’s not a nullptr. As a result, &quot;&quot; converted to true. The possible confusion is that the one character in that array of one is the \0 terminator. But this shouldn’t really matter. You shouldn’t use such shady implicit conversions. We could end this article right here. But life is not ideal and I tried to turn on -Wstring-conversion in a production codebase where I found a few different cases of string literals conversions. Fail with a message The most frequent usage of these conversions was tied to constantly failing assertions. 1 assert(!&quot;Invalid argument&quot;) Considering that a string literal can be converted into true, the above assertion will always fail and the literal &quot;Invalid argument&quot; will appear in the logs. The problem with the above assertion is that if you don’t know about such implicit conversions, it’s hard to understand this line of code. We can replace it in a very simple way. 1 assert(false &amp;&amp; &quot;Invalid argument&quot;) With the expanded version, the false &amp;&amp; communicates even to non-C++ developers that the assertion will always fail and it’s easier the deduce that the second part is just an error message. Fail conditionally with a message The second case is very similar to the previous one, just a bit more complicated. Before the negated literal, there is another condition combined with an OR. 1 assert((arg != 42) || !&quot;Invalid argument&quot;); This combination means that if the condition fails, then the assertion will fire. Otherwise, if the condition is true, then the whole expression is true and we can move on. To make it more readable, we should make the same breakdown in code that we just did in words. We should extract the condition and invert it, then we can make the same transformation on the negated literal that we did previously. 1 2 3 if (arg == 42) { assert(false &amp;&amp; &quot;Invalid argument&quot;); } We end up with slightly more code, but it raises way less questions. Our code becomes more readable. Remember, when we write production code, we don’t write it to win in a code golf where every character counts. We simply want to make the future maintainers’ lives easier while doing the right thing. Now, let’s have a look at a third case. Allow additional implicit conversions The last case is plain horror. Let’s have a look at it first: 1 2 3 4 5 6 7 8 9 10 void foo(long l) { } void bar(const char* arg) { foo(arg); // this fails to compile } void baz(const char* arg) { foo(!!arg); } We have a function called foo that takes a long, but it can take any other integer-like parameter that we want to call with an argument of const char*. A const char* can be implicitly converted to a bool which can be implicitly converted to a long. But the compiler cannot invoke both on its own. But if we force an implicit conversion to a bool with a negation, the compiler will take care of the other. Of course, due to the negation, we wouldn’t get the value we wanted, so we have to negate the negated value. It will always be the same result, unless arg is nullptr. But let’s say, we don’t want to eliminate this argument, we want to keep it. How should we do it without relying on the implicit conversion to bool? Instead of a double negation, let’s use a static_cast which is longer, but it’s very clear on its intent 1 2 3 void bar(const char* arg) { foo(static_cast&lt;bool&gt;(arg)); } We still rely on an implicit conversion from bool to long, but that’s obviously not reported by -Wstring-conversion. If it really bothered us, we could use another static_cast. Though I guess nobody really wants that. Conclusion In this article, we learned about -Wstring-conversion, something I learned from C++ Brain Teasers by Anders Schau Knatten](https://www.sandordargo.com/blog/2024/10/16/cpp-brain-teasers). Clang offers this compiler warning which fires on implicit conversions from C-strings to bools. I presented you with three different scenarios where I saw that developers relied on this kind of implicit conversion in production codebases. Two of them are related to assertions and one is about a chain of conversions, ultimately to integral numbers. None of them are difficult to get rid of. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="From C++ Brain Teasers by Anders Schau Knatten, I learned about a compiler warning offered by Clang, called -Wstring-conversion. It emits a warning when a string literal is implicitly converted into a boolean. You might even be surprised that it is even possible. And why would anyone do that? Let’s start with the first part by explaining why such an implicit conversion is possible. A string literal is an array of const chars. Arrays can be converted into pointers, something we talked about last week when we discussed why spans are so useful. This is also called decay. Furthermore, pointers can be converted into booleans. That is how a string literal can be converted into a bool. 1 2 static_assert(!!&quot;&quot; == true); static_assert(static_cast&lt;bool&gt;(&quot;&quot;) == true); What might be surprising though is that even an empty string literal is converted into true. The reason is that only a nullptr would be converted into false, but an empty string literal is an array of a size of one so it’s not a nullptr. As a result, &quot;&quot; converted to true. The possible confusion is that the one character in that array of one is the \0 terminator. But this shouldn’t really matter. You shouldn’t use such shady implicit conversions. We could end this article right here. But life is not ideal and I tried to turn on -Wstring-conversion in a production codebase where I found a few different cases of string literals conversions. Fail with a message The most frequent usage of these conversions was tied to constantly failing assertions. 1 assert(!&quot;Invalid argument&quot;) Considering that a string literal can be converted into true, the above assertion will always fail and the literal &quot;Invalid argument&quot; will appear in the logs. The problem with the above assertion is that if you don’t know about such implicit conversions, it’s hard to understand this line of code. We can replace it in a very simple way. 1 assert(false &amp;&amp; &quot;Invalid argument&quot;) With the expanded version, the false &amp;&amp; communicates even to non-C++ developers that the assertion will always fail and it’s easier the deduce that the second part is just an error message. Fail conditionally with a message The second case is very similar to the previous one, just a bit more complicated. Before the negated literal, there is another condition combined with an OR. 1 assert((arg != 42) || !&quot;Invalid argument&quot;); This combination means that if the condition fails, then the assertion will fire. Otherwise, if the condition is true, then the whole expression is true and we can move on. To make it more readable, we should make the same breakdown in code that we just did in words. We should extract the condition and invert it, then we can make the same transformation on the negated literal that we did previously. 1 2 3 if (arg == 42) { assert(false &amp;&amp; &quot;Invalid argument&quot;); } We end up with slightly more code, but it raises way less questions. Our code becomes more readable. Remember, when we write production code, we don’t write it to win in a code golf where every character counts. We simply want to make the future maintainers’ lives easier while doing the right thing. Now, let’s have a look at a third case. Allow additional implicit conversions The last case is plain horror. Let’s have a look at it first: 1 2 3 4 5 6 7 8 9 10 void foo(long l) { } void bar(const char* arg) { foo(arg); // this fails to compile } void baz(const char* arg) { foo(!!arg); } We have a function called foo that takes a long, but it can take any other integer-like parameter that we want to call with an argument of const char*. A const char* can be implicitly converted to a bool which can be implicitly converted to a long. But the compiler cannot invoke both on its own. But if we force an implicit conversion to a bool with a negation, the compiler will take care of the other. Of course, due to the negation, we wouldn’t get the value we wanted, so we have to negate the negated value. It will always be the same result, unless arg is nullptr. But let’s say, we don’t want to eliminate this argument, we want to keep it. How should we do it without relying on the implicit conversion to bool? Instead of a double negation, let’s use a static_cast which is longer, but it’s very clear on its intent 1 2 3 void bar(const char* arg) { foo(static_cast&lt;bool&gt;(arg)); } We still rely on an implicit conversion from bool to long, but that’s obviously not reported by -Wstring-conversion. If it really bothered us, we could use another static_cast. Though I guess nobody really wants that. Conclusion In this article, we learned about -Wstring-conversion, something I learned from C++ Brain Teasers by Anders Schau Knatten](https://www.sandordargo.com/blog/2024/10/16/cpp-brain-teasers). Clang offers this compiler warning which fires on implicit conversions from C-strings to bools. I presented you with three different scenarios where I saw that developers relied on this kind of implicit conversion in production codebases. Two of them are related to assertions and one is about a chain of conversions, ultimately to integral numbers. None of them are difficult to get rid of. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-13T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Implicit string conversions to booleans" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-13T00:00:00+01:00","datePublished":"2024-11-13T00:00:00+01:00","description":"From C++ Brain Teasers by Anders Schau Knatten, I learned about a compiler warning offered by Clang, called -Wstring-conversion. It emits a warning when a string literal is implicitly converted into a boolean. You might even be surprised that it is even possible. And why would anyone do that? Let’s start with the first part by explaining why such an implicit conversion is possible. A string literal is an array of const chars. Arrays can be converted into pointers, something we talked about last week when we discussed why spans are so useful. This is also called decay. Furthermore, pointers can be converted into booleans. That is how a string literal can be converted into a bool. 1 2 static_assert(!!&quot;&quot; == true); static_assert(static_cast&lt;bool&gt;(&quot;&quot;) == true); What might be surprising though is that even an empty string literal is converted into true. The reason is that only a nullptr would be converted into false, but an empty string literal is an array of a size of one so it’s not a nullptr. As a result, &quot;&quot; converted to true. The possible confusion is that the one character in that array of one is the \\0 terminator. But this shouldn’t really matter. You shouldn’t use such shady implicit conversions. We could end this article right here. But life is not ideal and I tried to turn on -Wstring-conversion in a production codebase where I found a few different cases of string literals conversions. Fail with a message The most frequent usage of these conversions was tied to constantly failing assertions. 1 assert(!&quot;Invalid argument&quot;) Considering that a string literal can be converted into true, the above assertion will always fail and the literal &quot;Invalid argument&quot; will appear in the logs. The problem with the above assertion is that if you don’t know about such implicit conversions, it’s hard to understand this line of code. We can replace it in a very simple way. 1 assert(false &amp;&amp; &quot;Invalid argument&quot;) With the expanded version, the false &amp;&amp; communicates even to non-C++ developers that the assertion will always fail and it’s easier the deduce that the second part is just an error message. Fail conditionally with a message The second case is very similar to the previous one, just a bit more complicated. Before the negated literal, there is another condition combined with an OR. 1 assert((arg != 42) || !&quot;Invalid argument&quot;); This combination means that if the condition fails, then the assertion will fire. Otherwise, if the condition is true, then the whole expression is true and we can move on. To make it more readable, we should make the same breakdown in code that we just did in words. We should extract the condition and invert it, then we can make the same transformation on the negated literal that we did previously. 1 2 3 if (arg == 42) { assert(false &amp;&amp; &quot;Invalid argument&quot;); } We end up with slightly more code, but it raises way less questions. Our code becomes more readable. Remember, when we write production code, we don’t write it to win in a code golf where every character counts. We simply want to make the future maintainers’ lives easier while doing the right thing. Now, let’s have a look at a third case. Allow additional implicit conversions The last case is plain horror. Let’s have a look at it first: 1 2 3 4 5 6 7 8 9 10 void foo(long l) { } void bar(const char* arg) { foo(arg); // this fails to compile } void baz(const char* arg) { foo(!!arg); } We have a function called foo that takes a long, but it can take any other integer-like parameter that we want to call with an argument of const char*. A const char* can be implicitly converted to a bool which can be implicitly converted to a long. But the compiler cannot invoke both on its own. But if we force an implicit conversion to a bool with a negation, the compiler will take care of the other. Of course, due to the negation, we wouldn’t get the value we wanted, so we have to negate the negated value. It will always be the same result, unless arg is nullptr. But let’s say, we don’t want to eliminate this argument, we want to keep it. How should we do it without relying on the implicit conversion to bool? Instead of a double negation, let’s use a static_cast which is longer, but it’s very clear on its intent 1 2 3 void bar(const char* arg) { foo(static_cast&lt;bool&gt;(arg)); } We still rely on an implicit conversion from bool to long, but that’s obviously not reported by -Wstring-conversion. If it really bothered us, we could use another static_cast. Though I guess nobody really wants that. Conclusion In this article, we learned about -Wstring-conversion, something I learned from C++ Brain Teasers by Anders Schau Knatten](https://www.sandordargo.com/blog/2024/10/16/cpp-brain-teasers). Clang offers this compiler warning which fires on implicit conversions from C-strings to bools. I presented you with three different scenarios where I saw that developers relied on this kind of implicit conversion in production codebases. Two of them are related to assertions and one is about a chain of conversions, ultimately to integral numbers. None of them are difficult to get rid of. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Implicit string conversions to booleans","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool"},"url":"https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool"}</script><title>Implicit string conversions to booleans | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/13"> 13 </a> </span> <span>Implicit string conversions to booleans</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Implicit string conversions to booleans</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 13, 2024, 12:00 AM +0100" prep="on" > Nov 13, 2024 <i class="unloaded">2024-11-13T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="900 words">5 min</span></div></div><div class="post-content"><p>From <a href="https://www.sandordargo.com/blog/2024/10/16/cpp-brain-teasers">C++ Brain Teasers by Anders Schau Knatten</a>, I learned about a compiler warning offered by Clang, called <code class="language-plaintext highlighter-rouge">-Wstring-conversion</code>. It emits a warning when a string literal is implicitly converted into a boolean.</p><p>You might even be surprised that it is even possible. And why would anyone do that?</p><p>Let’s start with the first part by explaining why such an implicit conversion is possible. A string literal is an array of <code class="language-plaintext highlighter-rouge">const char</code>s. Arrays can be converted into pointers, something <a href="https://www.sandordargo.com/blog/2024/11/06/std-span">we talked about last week when we discussed why <code class="language-plaintext highlighter-rouge">span</code>s are so useful</a>. This is also called decay. Furthermore, pointers can be converted into booleans. That is how a string literal can be converted into a <code class="language-plaintext highlighter-rouge">bool</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">static_assert</span><span class="p">(</span><span class="o">!!</span><span class="s">""</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
<span class="k">static_assert</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="s">""</span><span class="p">)</span> <span class="o">==</span> <span class="nb">true</span><span class="p">);</span>
</pre></table></code></div></div><p>What might be surprising though is that even an empty string literal is converted into <code class="language-plaintext highlighter-rouge">true</code>. The reason is that only a <code class="language-plaintext highlighter-rouge">nullptr</code> would be converted into <code class="language-plaintext highlighter-rouge">false</code>, but an empty string literal is an array of a size of one so it’s not a <code class="language-plaintext highlighter-rouge">nullptr</code>. As a result, <code class="language-plaintext highlighter-rouge">""</code> converted to <code class="language-plaintext highlighter-rouge">true</code>. The possible confusion is that the one character in that array of one is the <code class="language-plaintext highlighter-rouge">\0</code> terminator. But this shouldn’t really matter. You shouldn’t use such shady implicit conversions.</p><p>We could end this article right here. But life is not ideal and I tried to turn on <code class="language-plaintext highlighter-rouge">-Wstring-conversion</code> in a production codebase where I found a few different cases of string literals conversions.</p><h2 id="fail-with-a-message">Fail with a message</h2><p>The most frequent usage of these conversions was tied to constantly failing assertions.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">assert</span><span class="p">(</span><span class="o">!</span><span class="s">"Invalid argument"</span><span class="p">)</span>
</pre></table></code></div></div><p>Considering that a string literal can be converted into <code class="language-plaintext highlighter-rouge">true</code>, the above assertion will always fail and the literal <code class="language-plaintext highlighter-rouge">"Invalid argument"</code> will appear in the logs.</p><p>The problem with the above assertion is that if you don’t know about such implicit conversions, it’s hard to understand this line of code. We can replace it in a very simple way.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">assert</span><span class="p">(</span><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="s">"Invalid argument"</span><span class="p">)</span>
</pre></table></code></div></div><p>With the expanded version, the <code class="language-plaintext highlighter-rouge">false &amp;&amp;</code> communicates even to non-C++ developers that the assertion will always fail and it’s easier the deduce that the second part is just an error message.</p><h2 id="fail-conditionally-with-a-message">Fail conditionally with a message</h2><p>The second case is very similar to the previous one, just a bit more complicated. Before the negated literal, there is another condition combined with an <code class="language-plaintext highlighter-rouge">OR</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">assert</span><span class="p">((</span><span class="n">arg</span> <span class="o">!=</span> <span class="mi">42</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="s">"Invalid argument"</span><span class="p">);</span>
</pre></table></code></div></div><p>This combination means that if the condition fails, then the assertion will fire. Otherwise, if the condition is true, then the whole expression is true and we can move on.</p><p>To make it more readable, we should make the same breakdown in code that we just did in words. We should extract the condition and invert it, then we can make the same transformation on the negated literal that we did previously.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">arg</span> <span class="o">==</span> <span class="mi">42</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="s">"Invalid argument"</span><span class="p">);</span>
  <span class="p">}</span>
</pre></table></code></div></div><p>We end up with slightly more code, but it raises way less questions. Our code becomes more readable.</p><p>Remember, when we write production code, we don’t write it to win in a code golf where every character counts. We simply want to make the future maintainers’ lives easier while doing the right thing.</p><p>Now, let’s have a look at a third case.</p><h2 id="allow-additional-implicit-conversions">Allow additional implicit conversions</h2><p>The last case is plain horror. Let’s have a look at it first:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">long</span> <span class="n">l</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="n">arg</span><span class="p">);</span> <span class="c1">// this fails to compile</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">baz</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="o">!!</span><span class="n">arg</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We have a function called <code class="language-plaintext highlighter-rouge">foo</code> that takes a <code class="language-plaintext highlighter-rouge">long</code>, but it can take any other integer-like parameter that we want to call with an argument of <code class="language-plaintext highlighter-rouge">const char*</code>. A <code class="language-plaintext highlighter-rouge">const char*</code> can be implicitly converted to a <code class="language-plaintext highlighter-rouge">bool</code> which can be implicitly converted to a <code class="language-plaintext highlighter-rouge">long</code>. But the compiler cannot invoke both on its own.</p><p>But if we force an implicit conversion to a bool with a negation, the compiler will take care of the other. Of course, due to the negation, we wouldn’t get the value we wanted, so we have to negate the negated value.</p><p>It will always be the same result, unless <code class="language-plaintext highlighter-rouge">arg</code> is <code class="language-plaintext highlighter-rouge">nullptr</code>. But let’s say, we don’t want to eliminate this argument, we want to keep it. How should we do it without relying on the implicit conversion to bool?</p><p>Instead of a double negation, let’s use a <code class="language-plaintext highlighter-rouge">static_cast</code> which is longer, but it’s very clear on its intent</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">bar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">arg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">foo</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span><span class="p">(</span><span class="n">arg</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We still rely on an implicit conversion from <code class="language-plaintext highlighter-rouge">bool</code> to <code class="language-plaintext highlighter-rouge">long</code>, but that’s obviously not reported by <code class="language-plaintext highlighter-rouge">-Wstring-conversion</code>. If it really bothered us, we could use another <code class="language-plaintext highlighter-rouge">static_cast</code>. Though I guess nobody really wants that.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we learned about <code class="language-plaintext highlighter-rouge">-Wstring-conversion</code>, something I learned from C++ Brain Teasers by Anders Schau Knatten](https://www.sandordargo.com/blog/2024/10/16/cpp-brain-teasers). Clang offers this compiler warning which fires on implicit conversions from C-strings to <code class="language-plaintext highlighter-rouge">bool</code>s.</p><p>I presented you with three different scenarios where I saw that developers relied on this kind of implicit conversion in production codebases. Two of them are related to assertions and one is about a chain of conversions, ultimately to integral numbers. None of them are difficult to get rid of.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/builds/" class="post-tag no-text-decoration" >builds</a> <a href="/tags/staticlinking/" class="post-tag no-text-decoration" >staticlinking</a> <a href="/tags/dynamiclinking/" class="post-tag no-text-decoration" >dynamiclinking</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Implicit string conversions to booleans - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Implicit string conversions to booleans - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Implicit string conversions to booleans - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Implicit string conversions to booleans - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/10/02/dynamic-vs-static-linking"><div class="card-body"> <span class="timeago small" > Oct 2, 2024 <i class="unloaded">2024-10-02T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>So shall we use static or dynamic linking?</h3><div class="text-muted small"><p> Last week, we were talking about static vs dynamic linking from a binary size point of view. Around the end of the article, I wrote that I omitted other aspects. Now let’s talk briefly about some ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/09/25/dynamic-vs-static-linking-binary-size"><div class="card-body"> <span class="timeago small" > Sep 25, 2024 <i class="unloaded">2024-09-25T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Binary size: should we use static or dynamic linking?</h3><div class="text-muted small"><p> If at the end of a conference talk, I cannot answer a question and there is nobody to my rescue, I offer to reply later in the form of a blog post. At C++ on Sea, someone asked me about the implic...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/12/builds-and-dependencies"><div class="card-body"> <span class="timeago small" > Jun 12, 2024 <i class="unloaded">2024-06-12T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Limit the number of library dependencies</h3><div class="text-muted small"><p> First, let’s discuss what a dependency is. When we talk about dependencies, we can talk about different approaches. When hearing the word “dependency”, many people first think about dependency inj...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/11/06/std-span" class="btn btn-outline-primary" prompt="Older"><p>Use std::span instead of C-style arrays</p></a> <a href="/blog/2024/11/20/trip-report-meeting-cpp2024" class="btn btn-outline-primary" prompt="Newer"><p>Trip report: Meeting C++ 2024</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Implicit string conversions to booleans'; this.page.url = 'https://www.sandordargo.com/blog/2024/11/13/implicit-string-conversion-to-bool'; this.page.identifier = '/blog/2024/11/13/implicit-string-conversion-to-bool'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
