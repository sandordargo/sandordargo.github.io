<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="How to ensure a class is not copyable or movable" /><meta property="og:locale" content="en_US" /><meta name="description" content="The topic of this post is to show different ways to ensure that a class is either non-moveable or non-copyable. But first of all, why would you need that? If we follow the classification proposed by Sebastian Theophil, we can talk about 4 different class types: value classes container classes resource classes singleton classes While the first two should be regular classes offering both copy and move semantics, the latter two are different. One shouldn’t be able to copy resources and singletons probably shouldn’t be moveable. It’s up to us to ensure that a class we create implements the right special member functions (SMFs from now on). And the Hinnant table is here to guide us. The Hinnant table (source: https://howardhinnant.github.io/) The simplest and most obvious solution The simplest and most obvious solution is to implement the needed SMFs and delete the rest respecting the rule of 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class NonCopyableResource { public: NonCopyableResource() = default; // deleted copy operations NonCopyableResource(const NonCopyableResource&amp;) = delete; NonCopyableResource&amp; operator=(const NonCopyableResource&amp;) = delete; // (default) implemented move operations NonCopyableResource(NonCopyableResource&amp;&amp;) = default; NonCopyableResource&amp; operator=(NonCopyableResource&amp;&amp;) = default; // ... }; class NonMovableSingleton { public: NonMovableSingleton() = default; // (default) implemented copy operations NonMovableSingleton(const NonMovableSingleton&amp;) = default; NonMovableSingleton&amp; operator=(const NonMovableSingleton&amp;) = default; // deleted move operations NonMovableSingleton(NonMovableSingleton&amp;&amp;) = delete; NonMovableSingleton&amp; operator=(NonMovableSingleton&amp;&amp;) = delete; }; This is something we probably all know about. It’s simple, if you’re familiar with C++ it’s even readable. It doesn’t really document intentions though and provides no insurance. More on the latter later. How would you document intentions? You might put a comment somewhere but otherwise, you don’t know why something was made non-copyable or non-movable. That trait probably doesn’t appear in the class name and rightly so. But with C++26 we can document intentions better, because we can = delete something with a reason: 1 2 3 // deleted copy operations NonCopyableResource(const NonCopyableResource&amp;) = delete(&quot;resource shouldn&#39;t be copyable&quot;); NonCopyableResource&amp; operator=(const NonCopyableResource&amp;) = delete(&quot;resource shouldn&#39;t be copyable&quot;); Adding some assertions Now let’s talk about the insurance part. You might accidentally change this code and make your class copyable or movable. Even though when you = delete with a reason, the probabilities are smaller. Back in 2023, Kris van Rens gave a talk at C++ On Sea about special member functions and talked about how to test special member functions. You don’t necessarily want to test the internals of a copy constructor. You don’t necessarily have to test if all the members are copied promptly. Maybe you want to, but you don’t have to go as far. It’s already a great step if you can ensure with the help of type traits (or concepts) and static_cast that a given class satisfies certain characteristics. 1 2 3 4 5 6 static_assert(std::is_trivially_destructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_default_constructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_copy_constructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_copy_assignable&lt;NonMovableSingleton&gt;{}); static_assert(!std::is_trivially_move_constructible&lt;NonMovableSingleton&gt;{}); static_assert(!std::is_trivially_move_assignable&lt;NonMovableSingleton&gt;{}); Then even if you modify the class, you make sure that you don’t lose its copyablity and you keep it non-movable. Such tests might even enhance your understanding of how certain types of members influence a class. Nevertheless, they also document the code. But there is no perfect tool, everything has a shortcoming. Let’s have a look at the following piece of code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;concepts&gt; class SomeClass { public: SomeClass() = default; SomeClass(const SomeClass&amp;) = default; SomeClass&amp; operator=(const SomeClass&amp;) = default; }; static_assert(std::is_destructible&lt;SomeClass&gt;{}); static_assert(std::is_default_constructible&lt;SomeClass&gt;{}); static_assert(std::is_copy_constructible&lt;SomeClass&gt;{}); static_assert(std::is_copy_assignable&lt;SomeClass&gt;{}); static_assert(std::is_move_constructible&lt;SomeClass&gt;{}); static_assert(std::is_move_assignable&lt;SomeClass&gt;{}); While this compiles and you might that you have a nice movable class which you even asserted, the move operations will simply fall back silently to a copy because you forgot to define the move operations. The reason behind this is that with the introduction of move semantics in C++11 it had to be avoided that any existing class without move semantics fail to compile whenever a move seems to be invoked. In any case, in most situations, these assertions work fine and probably you won’t write a new class following only the rule of 3. But it’s still better to keep this in mind Add characteristics with inheritance Let’s move to the next level which is what Sebastian Theophil explained at Meeting C++ 2024. Following the rule of 5 is a good best practice, but it’s also easy to overlook something and can be a lot to type. Therefore you might delegate the task of making something non-copyable or non-moveable to a base class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class NonCopyable { public: NonCopyable() = default; ~NonCopyable() = default; NonCopyable(const NonCopyable&amp; other) = delete; NonCopyable&amp; operator=(const NonCopyable&amp; other) = delete; NonCopyable(NonCopyable&amp;&amp; other) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp; other) = default; }; class File : public NonCopyable { public: File() = default; File(char const* file); File(File&amp;&amp; other) noexcept; File&amp; operator=(File&amp;&amp; other) noexcept; ~File(); private: FILE* fp = nullptr; }; If you saw the original example in Meeting C++ trip report or anywhere else, you might recall that it was terser. True, in the original implementation only the necessary is implemented. According to the Hinnant table, if you provide move operations, the copy operations are deleted. I think it’s just easier to follow the rule of five and write down everything. It’s more readable and leaves no questions. In addition, you’ll only have to do it twice. Once for class NonCopyable and once for class NonMovable and reuse them. You might wonder why the destructor of NonCopyable is not virtual and whether it’s OK to inherit from this class without risking undefined behaviour. Given NonCopyable’s destructor is public, calling code could attempt to destroy the derived class object through a base class pointer and the result would be undefined behaviour. You might ask who in their right mind would try to use a pointer to the NonCopyable or NonMovable base class. It’s hard to imagine. Nevertheless, we can follow the C.35 core guideline and make NonCopyable’s destructor protected: 1 2 3 4 5 6 7 8 9 10 11 class NonCopyable { protected: ~NonCopyable() = default; public: NonCopyable() = default; NonCopyable(const NonCopyable&amp; other) = delete; NonCopyable&amp; operator=(const NonCopyable&amp; other) = delete; NonCopyable(NonCopyable&amp;&amp; other) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp; other) = default; }; As such, we are guaranteed that these base classes won’t be used intended ways. Conclusion In this article, we saw different ways to make sure that a class is non-copyable or non-movable. We started with the obvious solution of following the rule of 5 and implementing everything by hand following the Hinnant table. As a next step, we added some assertions making sure that our class has the traits we want it to have. Finally, we saw how to delegate the implementation of these traits to a base class in a super-readable way. How would you do it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><meta property="og:description" content="The topic of this post is to show different ways to ensure that a class is either non-moveable or non-copyable. But first of all, why would you need that? If we follow the classification proposed by Sebastian Theophil, we can talk about 4 different class types: value classes container classes resource classes singleton classes While the first two should be regular classes offering both copy and move semantics, the latter two are different. One shouldn’t be able to copy resources and singletons probably shouldn’t be moveable. It’s up to us to ensure that a class we create implements the right special member functions (SMFs from now on). And the Hinnant table is here to guide us. The Hinnant table (source: https://howardhinnant.github.io/) The simplest and most obvious solution The simplest and most obvious solution is to implement the needed SMFs and delete the rest respecting the rule of 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class NonCopyableResource { public: NonCopyableResource() = default; // deleted copy operations NonCopyableResource(const NonCopyableResource&amp;) = delete; NonCopyableResource&amp; operator=(const NonCopyableResource&amp;) = delete; // (default) implemented move operations NonCopyableResource(NonCopyableResource&amp;&amp;) = default; NonCopyableResource&amp; operator=(NonCopyableResource&amp;&amp;) = default; // ... }; class NonMovableSingleton { public: NonMovableSingleton() = default; // (default) implemented copy operations NonMovableSingleton(const NonMovableSingleton&amp;) = default; NonMovableSingleton&amp; operator=(const NonMovableSingleton&amp;) = default; // deleted move operations NonMovableSingleton(NonMovableSingleton&amp;&amp;) = delete; NonMovableSingleton&amp; operator=(NonMovableSingleton&amp;&amp;) = delete; }; This is something we probably all know about. It’s simple, if you’re familiar with C++ it’s even readable. It doesn’t really document intentions though and provides no insurance. More on the latter later. How would you document intentions? You might put a comment somewhere but otherwise, you don’t know why something was made non-copyable or non-movable. That trait probably doesn’t appear in the class name and rightly so. But with C++26 we can document intentions better, because we can = delete something with a reason: 1 2 3 // deleted copy operations NonCopyableResource(const NonCopyableResource&amp;) = delete(&quot;resource shouldn&#39;t be copyable&quot;); NonCopyableResource&amp; operator=(const NonCopyableResource&amp;) = delete(&quot;resource shouldn&#39;t be copyable&quot;); Adding some assertions Now let’s talk about the insurance part. You might accidentally change this code and make your class copyable or movable. Even though when you = delete with a reason, the probabilities are smaller. Back in 2023, Kris van Rens gave a talk at C++ On Sea about special member functions and talked about how to test special member functions. You don’t necessarily want to test the internals of a copy constructor. You don’t necessarily have to test if all the members are copied promptly. Maybe you want to, but you don’t have to go as far. It’s already a great step if you can ensure with the help of type traits (or concepts) and static_cast that a given class satisfies certain characteristics. 1 2 3 4 5 6 static_assert(std::is_trivially_destructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_default_constructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_copy_constructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_copy_assignable&lt;NonMovableSingleton&gt;{}); static_assert(!std::is_trivially_move_constructible&lt;NonMovableSingleton&gt;{}); static_assert(!std::is_trivially_move_assignable&lt;NonMovableSingleton&gt;{}); Then even if you modify the class, you make sure that you don’t lose its copyablity and you keep it non-movable. Such tests might even enhance your understanding of how certain types of members influence a class. Nevertheless, they also document the code. But there is no perfect tool, everything has a shortcoming. Let’s have a look at the following piece of code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;concepts&gt; class SomeClass { public: SomeClass() = default; SomeClass(const SomeClass&amp;) = default; SomeClass&amp; operator=(const SomeClass&amp;) = default; }; static_assert(std::is_destructible&lt;SomeClass&gt;{}); static_assert(std::is_default_constructible&lt;SomeClass&gt;{}); static_assert(std::is_copy_constructible&lt;SomeClass&gt;{}); static_assert(std::is_copy_assignable&lt;SomeClass&gt;{}); static_assert(std::is_move_constructible&lt;SomeClass&gt;{}); static_assert(std::is_move_assignable&lt;SomeClass&gt;{}); While this compiles and you might that you have a nice movable class which you even asserted, the move operations will simply fall back silently to a copy because you forgot to define the move operations. The reason behind this is that with the introduction of move semantics in C++11 it had to be avoided that any existing class without move semantics fail to compile whenever a move seems to be invoked. In any case, in most situations, these assertions work fine and probably you won’t write a new class following only the rule of 3. But it’s still better to keep this in mind Add characteristics with inheritance Let’s move to the next level which is what Sebastian Theophil explained at Meeting C++ 2024. Following the rule of 5 is a good best practice, but it’s also easy to overlook something and can be a lot to type. Therefore you might delegate the task of making something non-copyable or non-moveable to a base class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class NonCopyable { public: NonCopyable() = default; ~NonCopyable() = default; NonCopyable(const NonCopyable&amp; other) = delete; NonCopyable&amp; operator=(const NonCopyable&amp; other) = delete; NonCopyable(NonCopyable&amp;&amp; other) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp; other) = default; }; class File : public NonCopyable { public: File() = default; File(char const* file); File(File&amp;&amp; other) noexcept; File&amp; operator=(File&amp;&amp; other) noexcept; ~File(); private: FILE* fp = nullptr; }; If you saw the original example in Meeting C++ trip report or anywhere else, you might recall that it was terser. True, in the original implementation only the necessary is implemented. According to the Hinnant table, if you provide move operations, the copy operations are deleted. I think it’s just easier to follow the rule of five and write down everything. It’s more readable and leaves no questions. In addition, you’ll only have to do it twice. Once for class NonCopyable and once for class NonMovable and reuse them. You might wonder why the destructor of NonCopyable is not virtual and whether it’s OK to inherit from this class without risking undefined behaviour. Given NonCopyable’s destructor is public, calling code could attempt to destroy the derived class object through a base class pointer and the result would be undefined behaviour. You might ask who in their right mind would try to use a pointer to the NonCopyable or NonMovable base class. It’s hard to imagine. Nevertheless, we can follow the C.35 core guideline and make NonCopyable’s destructor protected: 1 2 3 4 5 6 7 8 9 10 11 class NonCopyable { protected: ~NonCopyable() = default; public: NonCopyable() = default; NonCopyable(const NonCopyable&amp; other) = delete; NonCopyable&amp; operator=(const NonCopyable&amp; other) = delete; NonCopyable(NonCopyable&amp;&amp; other) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp; other) = default; }; As such, we are guaranteed that these base classes won’t be used intended ways. Conclusion In this article, we saw different ways to make sure that a class is non-copyable or non-movable. We started with the obvious solution of following the rule of 5 and implementing everything by hand following the Hinnant table. As a next step, we added some assertions making sure that our class has the traits we want it to have. Finally, we saw how to delegate the implementation of these traits to a base class in a super-readable way. How would you do it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/11/27/non-movable-classes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/11/27/non-movable-classes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-11-27T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="How to ensure a class is not copyable or movable" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-11-27T00:00:00+01:00","datePublished":"2024-11-27T00:00:00+01:00","description":"The topic of this post is to show different ways to ensure that a class is either non-moveable or non-copyable. But first of all, why would you need that? If we follow the classification proposed by Sebastian Theophil, we can talk about 4 different class types: value classes container classes resource classes singleton classes While the first two should be regular classes offering both copy and move semantics, the latter two are different. One shouldn’t be able to copy resources and singletons probably shouldn’t be moveable. It’s up to us to ensure that a class we create implements the right special member functions (SMFs from now on). And the Hinnant table is here to guide us. The Hinnant table (source: https://howardhinnant.github.io/) The simplest and most obvious solution The simplest and most obvious solution is to implement the needed SMFs and delete the rest respecting the rule of 5. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 class NonCopyableResource { public: NonCopyableResource() = default; // deleted copy operations NonCopyableResource(const NonCopyableResource&amp;) = delete; NonCopyableResource&amp; operator=(const NonCopyableResource&amp;) = delete; // (default) implemented move operations NonCopyableResource(NonCopyableResource&amp;&amp;) = default; NonCopyableResource&amp; operator=(NonCopyableResource&amp;&amp;) = default; // ... }; class NonMovableSingleton { public: NonMovableSingleton() = default; // (default) implemented copy operations NonMovableSingleton(const NonMovableSingleton&amp;) = default; NonMovableSingleton&amp; operator=(const NonMovableSingleton&amp;) = default; // deleted move operations NonMovableSingleton(NonMovableSingleton&amp;&amp;) = delete; NonMovableSingleton&amp; operator=(NonMovableSingleton&amp;&amp;) = delete; }; This is something we probably all know about. It’s simple, if you’re familiar with C++ it’s even readable. It doesn’t really document intentions though and provides no insurance. More on the latter later. How would you document intentions? You might put a comment somewhere but otherwise, you don’t know why something was made non-copyable or non-movable. That trait probably doesn’t appear in the class name and rightly so. But with C++26 we can document intentions better, because we can = delete something with a reason: 1 2 3 // deleted copy operations NonCopyableResource(const NonCopyableResource&amp;) = delete(&quot;resource shouldn&#39;t be copyable&quot;); NonCopyableResource&amp; operator=(const NonCopyableResource&amp;) = delete(&quot;resource shouldn&#39;t be copyable&quot;); Adding some assertions Now let’s talk about the insurance part. You might accidentally change this code and make your class copyable or movable. Even though when you = delete with a reason, the probabilities are smaller. Back in 2023, Kris van Rens gave a talk at C++ On Sea about special member functions and talked about how to test special member functions. You don’t necessarily want to test the internals of a copy constructor. You don’t necessarily have to test if all the members are copied promptly. Maybe you want to, but you don’t have to go as far. It’s already a great step if you can ensure with the help of type traits (or concepts) and static_cast that a given class satisfies certain characteristics. 1 2 3 4 5 6 static_assert(std::is_trivially_destructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_default_constructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_copy_constructible&lt;NonMovableSingleton&gt;{}); static_assert(std::is_trivially_copy_assignable&lt;NonMovableSingleton&gt;{}); static_assert(!std::is_trivially_move_constructible&lt;NonMovableSingleton&gt;{}); static_assert(!std::is_trivially_move_assignable&lt;NonMovableSingleton&gt;{}); Then even if you modify the class, you make sure that you don’t lose its copyablity and you keep it non-movable. Such tests might even enhance your understanding of how certain types of members influence a class. Nevertheless, they also document the code. But there is no perfect tool, everything has a shortcoming. Let’s have a look at the following piece of code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;concepts&gt; class SomeClass { public: SomeClass() = default; SomeClass(const SomeClass&amp;) = default; SomeClass&amp; operator=(const SomeClass&amp;) = default; }; static_assert(std::is_destructible&lt;SomeClass&gt;{}); static_assert(std::is_default_constructible&lt;SomeClass&gt;{}); static_assert(std::is_copy_constructible&lt;SomeClass&gt;{}); static_assert(std::is_copy_assignable&lt;SomeClass&gt;{}); static_assert(std::is_move_constructible&lt;SomeClass&gt;{}); static_assert(std::is_move_assignable&lt;SomeClass&gt;{}); While this compiles and you might that you have a nice movable class which you even asserted, the move operations will simply fall back silently to a copy because you forgot to define the move operations. The reason behind this is that with the introduction of move semantics in C++11 it had to be avoided that any existing class without move semantics fail to compile whenever a move seems to be invoked. In any case, in most situations, these assertions work fine and probably you won’t write a new class following only the rule of 3. But it’s still better to keep this in mind Add characteristics with inheritance Let’s move to the next level which is what Sebastian Theophil explained at Meeting C++ 2024. Following the rule of 5 is a good best practice, but it’s also easy to overlook something and can be a lot to type. Therefore you might delegate the task of making something non-copyable or non-moveable to a base class. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 class NonCopyable { public: NonCopyable() = default; ~NonCopyable() = default; NonCopyable(const NonCopyable&amp; other) = delete; NonCopyable&amp; operator=(const NonCopyable&amp; other) = delete; NonCopyable(NonCopyable&amp;&amp; other) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp; other) = default; }; class File : public NonCopyable { public: File() = default; File(char const* file); File(File&amp;&amp; other) noexcept; File&amp; operator=(File&amp;&amp; other) noexcept; ~File(); private: FILE* fp = nullptr; }; If you saw the original example in Meeting C++ trip report or anywhere else, you might recall that it was terser. True, in the original implementation only the necessary is implemented. According to the Hinnant table, if you provide move operations, the copy operations are deleted. I think it’s just easier to follow the rule of five and write down everything. It’s more readable and leaves no questions. In addition, you’ll only have to do it twice. Once for class NonCopyable and once for class NonMovable and reuse them. You might wonder why the destructor of NonCopyable is not virtual and whether it’s OK to inherit from this class without risking undefined behaviour. Given NonCopyable’s destructor is public, calling code could attempt to destroy the derived class object through a base class pointer and the result would be undefined behaviour. You might ask who in their right mind would try to use a pointer to the NonCopyable or NonMovable base class. It’s hard to imagine. Nevertheless, we can follow the C.35 core guideline and make NonCopyable’s destructor protected: 1 2 3 4 5 6 7 8 9 10 11 class NonCopyable { protected: ~NonCopyable() = default; public: NonCopyable() = default; NonCopyable(const NonCopyable&amp; other) = delete; NonCopyable&amp; operator=(const NonCopyable&amp; other) = delete; NonCopyable(NonCopyable&amp;&amp; other) = default; NonCopyable&amp; operator=(NonCopyable&amp;&amp; other) = default; }; As such, we are guaranteed that these base classes won’t be used intended ways. Conclusion In this article, we saw different ways to make sure that a class is non-copyable or non-movable. We started with the obvious solution of following the rule of 5 and implementing everything by hand following the Hinnant table. As a next step, we added some assertions making sure that our class has the traits we want it to have. Finally, we saw how to delegate the implementation of these traits to a base class in a super-readable way. How would you do it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter","headline":"How to ensure a class is not copyable or movable","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/11/27/non-movable-classes"},"url":"https://www.sandordargo.com/blog/2024/11/27/non-movable-classes"}</script><title>How to ensure a class is not copyable or movable | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/27"> 27 </a> </span> <span>How to ensure a class is not copyable or movable</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>How to ensure a class is not copyable or movable</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 27, 2024, 12:00 AM +0100" prep="on" > Nov 27, 2024 <i class="unloaded">2024-11-27T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1172 words">6 min</span></div></div><div class="post-content"><p>The topic of this post is to show different ways to ensure that a class is either non-moveable or non-copyable.</p><p>But first of all, why would you need that?</p><p>If we follow the classification proposed by <a href="https://meetingcpp.com/2024/Talks/items/Classes_Cpp23_style.html">Sebastian Theophil</a>, we can talk about 4 different class types:</p><ul><li>value classes<li>container classes<li>resource classes<li>singleton classes</ul><p>While the first two should be regular classes offering both copy and move semantics, the latter two are different. One shouldn’t be able to copy resources and singletons probably shouldn’t be moveable.</p><p>It’s up to us to ensure that a class we create implements the right special member functions (<em>SMF</em>s from now on). And the Hinnant table is here to guide us.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/hinnant-table.jpg" alt="The Hinnant table" title="The Hinnant table" /> <em>The Hinnant table (source: https://howardhinnant.github.io/)</em></p><h2 id="the-simplest-and-most-obvious-solution">The simplest and most obvious solution</h2><p>The simplest and most obvious solution is to implement the needed SMFs and delete the rest respecting the rule of 5.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">NonCopyableResource</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">NonCopyableResource</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	
	<span class="c1">// deleted copy operations</span>
	<span class="n">NonCopyableResource</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyableResource</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">NonCopyableResource</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyableResource</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	
	<span class="c1">// (default) implemented move operations</span>
	<span class="n">NonCopyableResource</span><span class="p">(</span><span class="n">NonCopyableResource</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">NonCopyableResource</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NonCopyableResource</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="c1">// ...</span>
<span class="p">};</span>


<span class="k">class</span> <span class="nc">NonMovableSingleton</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">NonMovableSingleton</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	
	<span class="c1">// (default) implemented copy operations</span>
	<span class="n">NonMovableSingleton</span><span class="p">(</span><span class="k">const</span> <span class="n">NonMovableSingleton</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">NonMovableSingleton</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonMovableSingleton</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	
	<span class="c1">// deleted move operations</span>
	<span class="n">NonMovableSingleton</span><span class="p">(</span><span class="n">NonMovableSingleton</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">NonMovableSingleton</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NonMovableSingleton</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>This is something we probably all know about. It’s simple, if you’re familiar with C++ it’s even readable. It doesn’t really document intentions though and provides no insurance. More on the latter later.</p><p>How would you document intentions? You might put a comment somewhere but otherwise, you don’t know why something was made non-copyable or non-movable. That trait probably doesn’t appear in the class name and rightly so.</p><p>But with C++26 we can document intentions better, because we can <code class="language-plaintext highlighter-rouge">= delete</code> something with a reason:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// deleted copy operations</span>
<span class="n">NonCopyableResource</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyableResource</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">(</span><span class="s">"resource shouldn't be copyable"</span><span class="p">);</span>
<span class="n">NonCopyableResource</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyableResource</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">(</span><span class="s">"resource shouldn't be copyable"</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="adding-some-assertions">Adding some assertions</h2><p>Now let’s talk about the insurance part.</p><p>You might accidentally change this code and make your class copyable or movable. Even though when you <code class="language-plaintext highlighter-rouge">= delete</code> with a reason, the probabilities are smaller.</p><p>Back in 2023, <a href="https://www.sandordargo.com/blog/2023/07/05/trip-report-cpp-on-sea-2023">Kris van Rens gave a talk at C++ On Sea</a> about special member functions and talked about how to test special member functions.</p><p>You don’t necessarily want to test the internals of a copy constructor. You don’t necessarily have to test if all the members are copied promptly. Maybe you want to, but you don’t have to go as far.</p><p>It’s already a great step if you can ensure with the help of type traits (or <a href="https://leanpub.com/cppconcepts">concepts</a>) and <code class="language-plaintext highlighter-rouge">static_cast</code> that a given class satisfies certain characteristics.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_destructible</span><span class="o">&lt;</span><span class="n">NonMovableSingleton</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_default_constructible</span><span class="o">&lt;</span><span class="n">NonMovableSingleton</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_copy_constructible</span><span class="o">&lt;</span><span class="n">NonMovableSingleton</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_copy_assignable</span><span class="o">&lt;</span><span class="n">NonMovableSingleton</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_move_constructible</span><span class="o">&lt;</span><span class="n">NonMovableSingleton</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="o">!</span><span class="n">std</span><span class="o">::</span><span class="n">is_trivially_move_assignable</span><span class="o">&lt;</span><span class="n">NonMovableSingleton</span><span class="o">&gt;</span><span class="p">{});</span>
</pre></table></code></div></div><p>Then even if you modify the class, you make sure that you don’t lose its copyablity and you keep it non-movable. Such tests might even enhance your understanding of how certain types of members influence a class. Nevertheless, they also document the code.</p><p>But there is no perfect tool, everything has a shortcoming. Let’s have a look at the following piece of code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SomeClass</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">SomeClass</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="n">SomeClass</span><span class="p">(</span><span class="k">const</span> <span class="n">SomeClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">SomeClass</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">SomeClass</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_destructible</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_default_constructible</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_assignable</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_constructible</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">{});</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_move_assignable</span><span class="o">&lt;</span><span class="n">SomeClass</span><span class="o">&gt;</span><span class="p">{});</span>
</pre></table></code></div></div><p>While this compiles and you might that you have a nice movable class which you even asserted, the move operations will simply fall back silently to a copy because you forgot to define the move operations. The reason behind this is that with the introduction of move semantics in C++11 it had to be avoided that any existing class without move semantics fail to compile whenever a move seems to be invoked.</p><p>In any case, in most situations, these assertions work fine and probably you won’t write a new class following only the rule of 3. But it’s still better to keep this in mind</p><h2 id="add-characteristics-with-inheritance">Add characteristics with inheritance</h2><p>Let’s move to the next level which is what <a href="https://www.sandordargo.com/blog/2024/11/20/trip-report-meeting-cpp2024#my-three-favourite-ideas">Sebastian Theophil explained at Meeting C++ 2024</a>. Following the rule of 5 is a good best practice, but it’s also easy to overlook something and can be a lot to type.</p><p>Therefore you might delegate the task of making something non-copyable or non-moveable to a base class.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">NonCopyable</span>  <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="o">~</span><span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="p">(</span><span class="n">NonCopyable</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NonCopyable</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">File</span> <span class="o">:</span> <span class="k">public</span> <span class="n">NonCopyable</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">File</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">File</span><span class="p">(</span><span class="kt">char</span> <span class="k">const</span><span class="o">*</span> <span class="n">file</span><span class="p">);</span>

	<span class="n">File</span><span class="p">(</span><span class="n">File</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
	<span class="n">File</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">File</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
	<span class="o">~</span><span class="n">File</span><span class="p">();</span>
<span class="nl">private:</span>
	<span class="kt">FILE</span><span class="o">*</span> <span class="n">fp</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>If you saw the original example in <a href="https://www.sandordargo.com/blog/2024/11/20/trip-report-meeting-cpp2024#my-three-favourite-ideas">Meeting C++ trip report</a> or anywhere else, you might recall that it was terser. True, in the original implementation only the necessary is implemented. According to the Hinnant table, if you provide move operations, the copy operations are deleted.</p><p>I think it’s just easier to follow the rule of five and write down everything. It’s more readable and leaves no questions. In addition, you’ll only have to do it twice. Once for <code class="language-plaintext highlighter-rouge">class NonCopyable</code> and once for <code class="language-plaintext highlighter-rouge">class NonMovable</code> and reuse them.</p><p>You might wonder why the destructor of <code class="language-plaintext highlighter-rouge">NonCopyable</code> is not virtual and whether it’s OK to inherit from this class without risking undefined behaviour.</p><p>Given <code class="language-plaintext highlighter-rouge">NonCopyable</code>’s destructor is public, calling code could attempt to destroy the derived class object through a base class pointer and the result would be undefined behaviour.</p><p>You might ask who in their right mind would try to use a pointer to the <code class="language-plaintext highlighter-rouge">NonCopyable</code> or <code class="language-plaintext highlighter-rouge">NonMovable</code> base class. It’s hard to imagine.</p><p>Nevertheless, we can follow the <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c35-a-base-class-destructor-should-be-either-public-and-virtual-or-protected-and-non-virtual">C.35 core guideline</a> and make <code class="language-plaintext highlighter-rouge">NonCopyable</code>’s destructor protected:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">NonCopyable</span>  <span class="p">{</span>
<span class="nl">protected:</span>
    <span class="o">~</span><span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="nl">public:</span>
    <span class="n">NonCopyable</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="n">NonCopyable</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="p">(</span><span class="n">NonCopyable</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">NonCopyable</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">NonCopyable</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>As such, we are guaranteed that these base classes won’t be used intended ways.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we saw different ways to make sure that a class is non-copyable or non-movable. We started with the obvious solution of following the rule of 5 and implementing everything by hand following the Hinnant table.</p><p>As a next step, we added some assertions making sure that our class has the traits we want it to have. Finally, we saw how to delegate the implementation of these traits to a base class in a super-readable way.</p><p>How would you do it?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a></ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/career/" class="post-tag no-text-decoration" >career</a> <a href="/tags/portfoliojob/" class="post-tag no-text-decoration" >portfoliojob</a> <a href="/tags/watercooler/" class="post-tag no-text-decoration" >watercooler</a> <a href="/tags/business/" class="post-tag no-text-decoration" >business</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=How to ensure a class is not copyable or movable - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/11/27/non-movable-classes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=How to ensure a class is not copyable or movable - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/11/27/non-movable-classes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=How to ensure a class is not copyable or movable - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/11/27/non-movable-classes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=How to ensure a class is not copyable or movable - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/11/27/non-movable-classes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/09/11/the-limits-of-a-portfolio-job"><div class="card-body"> <span class="timeago small" > Sep 11, 2024 <i class="unloaded">2024-09-11T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The limits of a portfolio job</h3><div class="text-muted small"><p> A few years ago, I took on the role of a security white hat in my previous job. It took 20% of my time, about one day per week. It was up to me to get organized. Sometimes working one full day per ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/24/5-reasons-not-to-talk-about-politics-at-work"><div class="card-body"> <span class="timeago small" > Jul 24, 2024 <i class="unloaded">2024-07-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>5 reasons why politics will ruin your career hopes</h3><div class="text-muted small"><p> I’m not apolitical, I do have my opinion and quite a strong one. Yet, I don’t let it interfere with my job. I don’t think that one should talk about his or her political agenda at work or that one ...</p></div></div></a></div><div class="card"> <a href="/blog/2019/10/09/going-down-the-road"><div class="card-body"> <span class="timeago small" > Oct 9, 2019 <i class="unloaded">2019-10-09T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Going down the road</h3><div class="text-muted small"><p> After years of working hard and understanding how the game works, you got promoted. You are happy. You made a few steps forward. It feels exactly like when you got admission to university more th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/11/20/trip-report-meeting-cpp2024" class="btn btn-outline-primary" prompt="Older"><p>Trip report: Meeting C++ 2024</p></a> <a href="/blog/2024/12/04/crtp-vs-concepts" class="btn btn-outline-primary" prompt="Newer"><p>Replace CRTP with concepts?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'How to ensure a class is not copyable or movable'; this.page.url = 'https://www.sandordargo.com/blog/2024/11/27/non-movable-classes'; this.page.identifier = '/blog/2024/11/27/non-movable-classes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
