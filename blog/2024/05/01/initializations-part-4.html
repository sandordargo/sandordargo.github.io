<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="When and how variables are initialized? - Part 4" /><meta property="og:locale" content="en_US" /><meta name="description" content="For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. In part 1, we covered the different initialization syntaxes and copy-initialization. In part 2, we covered direct-, list- and aggregate-initalization. In part 3, we discussed default-, value- and zero-initialization. This week, in this final post on this topic, we are going get into the details of constant- and reference-initialization. Constant-initialization Constant initialization sets the initial values of static variables to a compile-time constant. It is performed before all other initializations. The compiler can and will often perform constant-initialziation at compile-time and thus store the object representations in the binary’s .data section. If the variable is not only constant-initialized, but it’s also const, then it might go into a read-only section such as .rodata. Two conditions have to be fulfilled to perform constant-initialization. A variable either has to have an initializer or needs a default initializer that results in some initialization. 1 2 3 4 5 6 7 8 #include &lt;string&gt; static const std::string s; // default initializer is avaialable, constant-initialization happens static int i; // no constant initialization, undefined value int main() { return 0; } And its intialization has to be a constant experssion or it has to invoke a constexpr constructor. 1 2 3 4 5 6 7 8 9 #include &lt;string&gt; static const std::string s; // default initializer is avaialable, constant-initialization happens static const int num = 42; // constant initialization happens, static constexpr int num2 = s.size(); // constant initialization happens, std::string::size is a constant expression int main() { return 0; } Reference-initialization Reference initialization binds a reference to an object. The referenced object must be the same type as the reference or implicitly convertable to it. Once initialized, a reference cannot be changed to refer to another object. You have pointers for that purpose. Reference initialization might apply both to named lvalue and named rvalue references. What is particular about reference intialization is that the reference can bind to a base class of the target or to any type it has a conversion operator for. But what happens when we try to initialize a reference? It depends on what we have on the right side. If list-initialization syntax is used, then the rules of list-initialization are applied. Otherwise, we can differentiate between direct and indirect binding. Let’s look into direct bindings first. First, let’s see an example of storing a reference to the base class object even though the reference is initialized with the derived object. Direct binding applies if the initialized reference is an lvalue, the target is a non-bit-field lvalue and the type of the reference is reference-compatible with the type of the target. 1 2 3 4 5 6 7 8 class Base {}; class Derived : public Base {}; int main() { Derived d; Base&amp; b = d; } Now let’s see an example of storing a reference to an integer as the result of a conversion operator. Direct binding also can apply if the reference to be initialized is an lvalue reference, the target is class type, but the reference to be initialized is not reference-related to the target’s type. In this case, it’s required that the target can be converted to an lvalue that type is reference-compatible with the type to be initialized. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Wrapper { public: Wrapper(int num): m_num(num) {} int&amp; operator()() { return m_num; } private: int m_num; }; int main() { Wrapper w{42}; int&amp; num = w(); return 0; } Direct initialization can happen also happen for non-bit-field rvalues and function lvalues given that the target’s type and the reference to be initialized are reference compatible. Also, if there is a conversion operator guaranteeing the reference compatibility following the same patterns that we saw for lvalue references, direct reference initialization is performed. If direct binding is not available, indirect binding is considered. In these cases, the reference type and the target are not reference-related to each other. That means that for class types first user-defined conversions are considered. When such conversions are applied, the reference bounds to a temporary object that is copy initialized from the target. The reference is direct-iniatialized from the temporary object that is copy-initialized from the target. Phew. 1 2 const std::string&amp; rs = &quot;abc&quot;; // rs refers to temporary copy-initialized from char array const double&amp; rcd2 = 2; // rcd2 refers to temporary with value 2.0 This leads to the question of lifetimes. The lifetime of the temporary will be extended until the lifetime of the reference. At the same time, the extension can only happen once, if the reference is passed on, the lifetime won’t be extended a second time. There are a couple of exceptions though. A temporary bound to a return value of a function in a return statement is not extended, you’re going to have a dangling pointer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; int&amp; fun() { int a = 66; return a; } int main() { auto b = fun(); } /* warning: reference to local variable &#39;a&#39; returned [-Wreturn-local-addr] Program returned: 139 Program terminated with signal: SIGSEGV */ You have to deal with similar consequences if a function returns a temporary that bounds to a reference parameter. It cannot outlive the function call. Then let’s take the following exception from C++ Reference: a temporary bound to a reference in the initializer used in a new-expression exists until the end of the full expression containing that new-expression, not as long as the initialized object. If the initialized object outlives the full expression, its reference member becomes a dangling reference. This is interesting to show. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; struct S { int mi; const std::pair&lt;int, int&gt;&amp; mp; // reference member }; int main() { S a {1, {2, 3}}; S* p = new S{1, {2, 3}}; std::cout &lt;&lt; a.mi &lt;&lt; &quot; &quot; &lt;&lt; a.mp.first &lt;&lt; &quot; &quot; &lt;&lt; a.mp.second &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; p-&gt;mi &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;mp.first &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;mp.second &lt;&lt; &#39;\n&#39;; return 0; } a is correct, if p works that’s by chance. The temporary references on ps initialization are not extended by definition, because that would be a second a extension. The first extension happens in the expression new S{1, {2, 3}}, the second would be the assignment. On GCC, this works without a problem, Clang on the other hand emits a warning about it. Conclusion Today, we learned about the last two types of initalizations on our plate, constant- and reference-initialization. The most important takeaway is probably to remember that reference lifetime-extension happens only once. This also marks the end of this mini-series on initializations. We’ve seen 9 different kinds of inizitalizations. We saw that even when we talk about one initialization, others are involved. For example when you value initialize an object, members without an explicit intializer will be zero-initialized. Copy-intialization can involve list- or direct-initialization, etc. C++ has many nuances. In my opinion, the best we can do is to avoid relying on them and write code that is straithforward and works in all circumstances. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. In part 1, we covered the different initialization syntaxes and copy-initialization. In part 2, we covered direct-, list- and aggregate-initalization. In part 3, we discussed default-, value- and zero-initialization. This week, in this final post on this topic, we are going get into the details of constant- and reference-initialization. Constant-initialization Constant initialization sets the initial values of static variables to a compile-time constant. It is performed before all other initializations. The compiler can and will often perform constant-initialziation at compile-time and thus store the object representations in the binary’s .data section. If the variable is not only constant-initialized, but it’s also const, then it might go into a read-only section such as .rodata. Two conditions have to be fulfilled to perform constant-initialization. A variable either has to have an initializer or needs a default initializer that results in some initialization. 1 2 3 4 5 6 7 8 #include &lt;string&gt; static const std::string s; // default initializer is avaialable, constant-initialization happens static int i; // no constant initialization, undefined value int main() { return 0; } And its intialization has to be a constant experssion or it has to invoke a constexpr constructor. 1 2 3 4 5 6 7 8 9 #include &lt;string&gt; static const std::string s; // default initializer is avaialable, constant-initialization happens static const int num = 42; // constant initialization happens, static constexpr int num2 = s.size(); // constant initialization happens, std::string::size is a constant expression int main() { return 0; } Reference-initialization Reference initialization binds a reference to an object. The referenced object must be the same type as the reference or implicitly convertable to it. Once initialized, a reference cannot be changed to refer to another object. You have pointers for that purpose. Reference initialization might apply both to named lvalue and named rvalue references. What is particular about reference intialization is that the reference can bind to a base class of the target or to any type it has a conversion operator for. But what happens when we try to initialize a reference? It depends on what we have on the right side. If list-initialization syntax is used, then the rules of list-initialization are applied. Otherwise, we can differentiate between direct and indirect binding. Let’s look into direct bindings first. First, let’s see an example of storing a reference to the base class object even though the reference is initialized with the derived object. Direct binding applies if the initialized reference is an lvalue, the target is a non-bit-field lvalue and the type of the reference is reference-compatible with the type of the target. 1 2 3 4 5 6 7 8 class Base {}; class Derived : public Base {}; int main() { Derived d; Base&amp; b = d; } Now let’s see an example of storing a reference to an integer as the result of a conversion operator. Direct binding also can apply if the reference to be initialized is an lvalue reference, the target is class type, but the reference to be initialized is not reference-related to the target’s type. In this case, it’s required that the target can be converted to an lvalue that type is reference-compatible with the type to be initialized. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Wrapper { public: Wrapper(int num): m_num(num) {} int&amp; operator()() { return m_num; } private: int m_num; }; int main() { Wrapper w{42}; int&amp; num = w(); return 0; } Direct initialization can happen also happen for non-bit-field rvalues and function lvalues given that the target’s type and the reference to be initialized are reference compatible. Also, if there is a conversion operator guaranteeing the reference compatibility following the same patterns that we saw for lvalue references, direct reference initialization is performed. If direct binding is not available, indirect binding is considered. In these cases, the reference type and the target are not reference-related to each other. That means that for class types first user-defined conversions are considered. When such conversions are applied, the reference bounds to a temporary object that is copy initialized from the target. The reference is direct-iniatialized from the temporary object that is copy-initialized from the target. Phew. 1 2 const std::string&amp; rs = &quot;abc&quot;; // rs refers to temporary copy-initialized from char array const double&amp; rcd2 = 2; // rcd2 refers to temporary with value 2.0 This leads to the question of lifetimes. The lifetime of the temporary will be extended until the lifetime of the reference. At the same time, the extension can only happen once, if the reference is passed on, the lifetime won’t be extended a second time. There are a couple of exceptions though. A temporary bound to a return value of a function in a return statement is not extended, you’re going to have a dangling pointer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; int&amp; fun() { int a = 66; return a; } int main() { auto b = fun(); } /* warning: reference to local variable &#39;a&#39; returned [-Wreturn-local-addr] Program returned: 139 Program terminated with signal: SIGSEGV */ You have to deal with similar consequences if a function returns a temporary that bounds to a reference parameter. It cannot outlive the function call. Then let’s take the following exception from C++ Reference: a temporary bound to a reference in the initializer used in a new-expression exists until the end of the full expression containing that new-expression, not as long as the initialized object. If the initialized object outlives the full expression, its reference member becomes a dangling reference. This is interesting to show. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; struct S { int mi; const std::pair&lt;int, int&gt;&amp; mp; // reference member }; int main() { S a {1, {2, 3}}; S* p = new S{1, {2, 3}}; std::cout &lt;&lt; a.mi &lt;&lt; &quot; &quot; &lt;&lt; a.mp.first &lt;&lt; &quot; &quot; &lt;&lt; a.mp.second &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; p-&gt;mi &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;mp.first &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;mp.second &lt;&lt; &#39;\n&#39;; return 0; } a is correct, if p works that’s by chance. The temporary references on ps initialization are not extended by definition, because that would be a second a extension. The first extension happens in the expression new S{1, {2, 3}}, the second would be the assignment. On GCC, this works without a problem, Clang on the other hand emits a warning about it. Conclusion Today, we learned about the last two types of initalizations on our plate, constant- and reference-initialization. The most important takeaway is probably to remember that reference lifetime-extension happens only once. This also marks the end of this mini-series on initializations. We’ve seen 9 different kinds of inizitalizations. We saw that even when we talk about one initialization, others are involved. For example when you value initialize an object, members without an explicit intializer will be zero-initialized. Copy-intialization can involve list- or direct-initialization, etc. C++ has many nuances. In my opinion, the best we can do is to avoid relying on them and write code that is straithforward and works in all circumstances. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/05/01/initializations-part-4" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/05/01/initializations-part-4" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-01T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="When and how variables are initialized? - Part 4" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-05-01T00:00:00+02:00","datePublished":"2024-05-01T00:00:00+02:00","description":"For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. In part 1, we covered the different initialization syntaxes and copy-initialization. In part 2, we covered direct-, list- and aggregate-initalization. In part 3, we discussed default-, value- and zero-initialization. This week, in this final post on this topic, we are going get into the details of constant- and reference-initialization. Constant-initialization Constant initialization sets the initial values of static variables to a compile-time constant. It is performed before all other initializations. The compiler can and will often perform constant-initialziation at compile-time and thus store the object representations in the binary’s .data section. If the variable is not only constant-initialized, but it’s also const, then it might go into a read-only section such as .rodata. Two conditions have to be fulfilled to perform constant-initialization. A variable either has to have an initializer or needs a default initializer that results in some initialization. 1 2 3 4 5 6 7 8 #include &lt;string&gt; static const std::string s; // default initializer is avaialable, constant-initialization happens static int i; // no constant initialization, undefined value int main() { return 0; } And its intialization has to be a constant experssion or it has to invoke a constexpr constructor. 1 2 3 4 5 6 7 8 9 #include &lt;string&gt; static const std::string s; // default initializer is avaialable, constant-initialization happens static const int num = 42; // constant initialization happens, static constexpr int num2 = s.size(); // constant initialization happens, std::string::size is a constant expression int main() { return 0; } Reference-initialization Reference initialization binds a reference to an object. The referenced object must be the same type as the reference or implicitly convertable to it. Once initialized, a reference cannot be changed to refer to another object. You have pointers for that purpose. Reference initialization might apply both to named lvalue and named rvalue references. What is particular about reference intialization is that the reference can bind to a base class of the target or to any type it has a conversion operator for. But what happens when we try to initialize a reference? It depends on what we have on the right side. If list-initialization syntax is used, then the rules of list-initialization are applied. Otherwise, we can differentiate between direct and indirect binding. Let’s look into direct bindings first. First, let’s see an example of storing a reference to the base class object even though the reference is initialized with the derived object. Direct binding applies if the initialized reference is an lvalue, the target is a non-bit-field lvalue and the type of the reference is reference-compatible with the type of the target. 1 2 3 4 5 6 7 8 class Base {}; class Derived : public Base {}; int main() { Derived d; Base&amp; b = d; } Now let’s see an example of storing a reference to an integer as the result of a conversion operator. Direct binding also can apply if the reference to be initialized is an lvalue reference, the target is class type, but the reference to be initialized is not reference-related to the target’s type. In this case, it’s required that the target can be converted to an lvalue that type is reference-compatible with the type to be initialized. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 class Wrapper { public: Wrapper(int num): m_num(num) {} int&amp; operator()() { return m_num; } private: int m_num; }; int main() { Wrapper w{42}; int&amp; num = w(); return 0; } Direct initialization can happen also happen for non-bit-field rvalues and function lvalues given that the target’s type and the reference to be initialized are reference compatible. Also, if there is a conversion operator guaranteeing the reference compatibility following the same patterns that we saw for lvalue references, direct reference initialization is performed. If direct binding is not available, indirect binding is considered. In these cases, the reference type and the target are not reference-related to each other. That means that for class types first user-defined conversions are considered. When such conversions are applied, the reference bounds to a temporary object that is copy initialized from the target. The reference is direct-iniatialized from the temporary object that is copy-initialized from the target. Phew. 1 2 const std::string&amp; rs = &quot;abc&quot;; // rs refers to temporary copy-initialized from char array const double&amp; rcd2 = 2; // rcd2 refers to temporary with value 2.0 This leads to the question of lifetimes. The lifetime of the temporary will be extended until the lifetime of the reference. At the same time, the extension can only happen once, if the reference is passed on, the lifetime won’t be extended a second time. There are a couple of exceptions though. A temporary bound to a return value of a function in a return statement is not extended, you’re going to have a dangling pointer. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; int&amp; fun() { int a = 66; return a; } int main() { auto b = fun(); } /* warning: reference to local variable &#39;a&#39; returned [-Wreturn-local-addr] Program returned: 139 Program terminated with signal: SIGSEGV */ You have to deal with similar consequences if a function returns a temporary that bounds to a reference parameter. It cannot outlive the function call. Then let’s take the following exception from C++ Reference: a temporary bound to a reference in the initializer used in a new-expression exists until the end of the full expression containing that new-expression, not as long as the initialized object. If the initialized object outlives the full expression, its reference member becomes a dangling reference. This is interesting to show. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; struct S { int mi; const std::pair&lt;int, int&gt;&amp; mp; // reference member }; int main() { S a {1, {2, 3}}; S* p = new S{1, {2, 3}}; std::cout &lt;&lt; a.mi &lt;&lt; &quot; &quot; &lt;&lt; a.mp.first &lt;&lt; &quot; &quot; &lt;&lt; a.mp.second &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; p-&gt;mi &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;mp.first &lt;&lt; &quot; &quot; &lt;&lt; p-&gt;mp.second &lt;&lt; &#39;\\n&#39;; return 0; } a is correct, if p works that’s by chance. The temporary references on ps initialization are not extended by definition, because that would be a second a extension. The first extension happens in the expression new S{1, {2, 3}}, the second would be the assignment. On GCC, this works without a problem, Clang on the other hand emits a warning about it. Conclusion Today, we learned about the last two types of initalizations on our plate, constant- and reference-initialization. The most important takeaway is probably to remember that reference lifetime-extension happens only once. This also marks the end of this mini-series on initializations. We’ve seen 9 different kinds of inizitalizations. We saw that even when we talk about one initialization, others are involved. For example when you value initialize an object, members without an explicit intializer will be zero-initialized. Copy-intialization can involve list- or direct-initialization, etc. C++ has many nuances. In my opinion, the best we can do is to avoid relying on them and write code that is straithforward and works in all circumstances. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"When and how variables are initialized? - Part 4","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/05/01/initializations-part-4"},"url":"https://www.sandordargo.com/blog/2024/05/01/initializations-part-4"}</script><title>When and how variables are initialized? - Part 4 | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/01"> 01 </a> </span> <span>When and how variables are initialized? - Part 4</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>When and how variables are initialized? - Part 4</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 1, 2024, 12:00 AM +0200" prep="on" > May 1, 2024 <i class="unloaded">2024-05-01T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1256 words">6 min</span></div></div><div class="post-content"><p>For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. As a reminder, we covered so many different forms of initializations. <a href="https://www.sandordargo.com/blog/2024/04/10/initializations-part-1">In part 1</a>, we covered the different initialization syntaxes and copy-initialization. <a href="https://www.sandordargo.com/blog/2024/04/17/initializations-part-2">In part 2</a>, we covered direct-, list- and aggregate-initalization. <a href="https://www.sandordargo.com/blog/2024/04/24/initializations-part-3">In part 3</a>, we discussed default-, value- and zero-initialization.</p><p>This week, in this final post on this topic, we are going get into the details of constant- and reference-initialization.</p><h2 id="constant-initialization">Constant-initialization</h2><p>Constant initialization sets the initial values of static variables to a compile-time constant. It is performed before all other initializations. The compiler can and will often perform constant-initialziation at compile-time and thus store the object representations in the binary’s <code class="language-plaintext highlighter-rouge">.data</code> section. If the variable is not only constant-initialized, but it’s also <code class="language-plaintext highlighter-rouge">const</code>, then it might go into a read-only section such as <code class="language-plaintext highlighter-rouge">.rodata</code>.</p><p>Two conditions have to be fulfilled to perform constant-initialization.</p><p>A variable either has to have an initializer or needs a default initializer that results in some initialization.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// default initializer is avaialable, constant-initialization happens</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">i</span><span class="p">;</span> <span class="c1">// no constant initialization, undefined value</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>And its intialization has to be a constant experssion or it has to invoke a <code class="language-plaintext highlighter-rouge">constexpr</code> constructor.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">static</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// default initializer is avaialable, constant-initialization happens</span>
<span class="k">static</span> <span class="k">const</span> <span class="kt">int</span> <span class="n">num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// constant initialization happens, </span>
<span class="k">static</span> <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">num2</span> <span class="o">=</span> <span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="c1">// constant initialization happens, std::string::size is a constant expression</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="reference-initialization">Reference-initialization</h2><p>Reference initialization binds a reference to an object. The referenced object must be the same type as the reference or implicitly convertable to it. Once initialized, a reference cannot be changed to refer to another object. You have pointers for that purpose.</p><p>Reference initialization might apply both to named lvalue and named rvalue references.</p><p>What is particular about reference intialization is that the reference can bind to a base class of the target or to any type it has a conversion operator for.</p><p>But what happens when we try to initialize a reference?</p><p>It depends on what we have on the right side. If list-initialization syntax is used, then the rules of list-initialization are applied.</p><p>Otherwise, we can differentiate between direct and indirect binding.</p><p>Let’s look into direct bindings first.</p><p>First, let’s see an example of storing a reference to the base class object even though the reference is initialized with the derived object. Direct binding applies if the initialized reference is an lvalue, the target is a non-bit-field lvalue and the type of the reference is reference-compatible with the type of the target.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Base</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">Base</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now let’s see an example of storing a reference to an integer as the result of a conversion operator. Direct binding also can apply if the reference to be initialized is an lvalue reference, the target is class type, but the reference to be initialized is not reference-related to the target’s type. In this case, it’s required that the target can be converted to an lvalue that type is reference-compatible with the type to be initialized.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Wrapper</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">Wrapper</span><span class="p">(</span><span class="kt">int</span> <span class="n">num</span><span class="p">)</span><span class="o">:</span> <span class="n">m_num</span><span class="p">(</span><span class="n">num</span><span class="p">)</span> <span class="p">{}</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">()()</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="p">}</span>
<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Wrapper</span> <span class="n">w</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="kt">int</span><span class="o">&amp;</span> <span class="n">num</span> <span class="o">=</span> <span class="n">w</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Direct initialization can happen also happen for non-bit-field rvalues and function lvalues given that the target’s type and the reference to be initialized are reference compatible. Also, if there is a conversion operator guaranteeing the reference compatibility following the same patterns that we saw for lvalue references, direct reference initialization is performed.</p><p>If direct binding is not available, indirect binding is considered. In these cases, the reference type and the target are not reference-related to each other. That means that for class types first user-defined conversions are considered. When such conversions are applied, the reference bounds to a temporary object that is copy initialized from the target. The reference is direct-iniatialized from the temporary object that is copy-initialized from the target. Phew.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&amp;</span> <span class="n">rs</span> <span class="o">=</span> <span class="s">"abc"</span><span class="p">;</span> <span class="c1">// rs refers to temporary copy-initialized from char array</span>
<span class="k">const</span> <span class="kt">double</span><span class="o">&amp;</span> <span class="n">rcd2</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>        <span class="c1">// rcd2 refers to temporary with value 2.0</span>
</pre></table></code></div></div><p>This leads to the question of lifetimes. The lifetime of the temporary will be extended until the lifetime of the reference. At the same time, the extension can only happen once, if the reference is passed on, the lifetime won’t be extended a second time.</p><p>There are a couple of exceptions though. A temporary bound to a return value of a function in a <code class="language-plaintext highlighter-rouge">return</code> statement is not extended, you’re going to have a dangling pointer.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span><span class="o">&amp;</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">66</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">b</span> <span class="o">=</span> <span class="n">fun</span><span class="p">();</span>
<span class="p">}</span>
<span class="cm">/*
warning: reference to local variable 'a' returned [-Wreturn-local-addr]

Program returned: 139
Program terminated with signal: SIGSEGV

*/</span>
</pre></table></code></div></div><p>You have to deal with similar consequences if a function returns a temporary that bounds to a reference parameter. It cannot outlive the function call.</p><p>Then let’s take the following exception from C++ Reference: <em>a temporary bound to a reference in the initializer used in a new-expression exists until the end of the full expression containing that new-expression, not as long as the initialized object. If the initialized object outlives the full expression, its reference member becomes a dangling reference.</em></p><p>This is interesting to show.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span> 
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">mp</span><span class="p">;</span> <span class="c1">// reference member</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">a</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span> 
    <span class="n">S</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">S</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">}};</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">mi</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">a</span><span class="p">.</span><span class="n">mp</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>                         
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mi</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">.</span><span class="n">first</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="o">-&gt;</span><span class="n">mp</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p><code class="language-plaintext highlighter-rouge">a</code> is correct, if <code class="language-plaintext highlighter-rouge">p</code> works that’s by chance. The temporary references on <code class="language-plaintext highlighter-rouge">p</code>s initialization are not extended by definition, because that would be a second a extension. The first extension happens in the expression <code class="language-plaintext highlighter-rouge">new S{1, {2, 3}}</code>, the second would be the assignment. On GCC, this works without a problem, Clang on the other hand emits a warning about it.</p><h2 id="conclusion">Conclusion</h2><p>Today, we learned about the last two types of initalizations on our plate, constant- and reference-initialization. The most important takeaway is probably to remember that reference lifetime-extension happens only once.</p><p>This also marks the end of this mini-series on initializations. We’ve seen 9 different kinds of inizitalizations. We saw that even when we talk about one initialization, others are involved. For example when you value initialize an object, members without an explicit intializer will be zero-initialized. Copy-intialization can involve list- or direct-initialization, etc.</p><p>C++ has many nuances. In my opinion, the best we can do is to avoid relying on them and write code that is straithforward and works in all circumstances.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/fundamental/" class="post-tag no-text-decoration" >fundamental</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/undefinedbehaviour/" class="post-tag no-text-decoration" >undefinedbehaviour</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=When and how variables are initialized? - Part 4 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/05/01/initializations-part-4" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=When and how variables are initialized? - Part 4 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/05/01/initializations-part-4" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=When and how variables are initialized? - Part 4 - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/05/01/initializations-part-4" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=When and how variables are initialized? - Part 4 - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/05/01/initializations-part-4" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/24/initializations-part-3"><div class="card-body"> <span class="timeago small" > Apr 24, 2024 <i class="unloaded">2024-04-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 3</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I ma...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/04/24/initializations-part-3" class="btn btn-outline-primary" prompt="Older"><p>When and how variables are initialized? - Part 3</p></a> <a href="/blog/2024/05/08/quo-vadis-this-blog" class="btn btn-outline-primary" prompt="Newer"><p>Quo vadis this blog?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'When and how variables are initialized? - Part 4'; this.page.url = 'https://www.sandordargo.com/blog/2024/05/01/initializations-part-4'; this.page.identifier = '/blog/2024/05/01/initializations-part-4'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
