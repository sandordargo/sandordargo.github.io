<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: chrono related changes" /><meta property="og:locale" content="en_US" /><meta name="description" content="Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one is about what requirements time_point imposes on a clock. DR: Fixing locale handling in chrono formatters P2372R3 is a fix of C++ based on the bug reported in LWG-3547. The problem is a bug in the specification of chrono formatters in the standard. While std::format is locale-independent by default and gives you the possibility to change the locale via format specifiers, the new formatter specializations of C++20 for chrono types are localized by default and don’t let you change the locale via format specifiers. There are three problems with this approach: It goes against the design of std::format (and by the way the fmt implementation) As chrono formatters are automatically localized, you cannot avoid locales, if you want to do so, you have to automatically format date and time manually Some chrono formatters act as if they would provide a locale-independent specifier (%S) and a localized one as well (%OS) which is misleading. So the original behaviour of std::format and std::chrono is the below: 1 2 3 4 5 std::locale::global(std::locale(&quot;ru_RU&quot;)); using sec = std::chrono::duration&lt;double&gt;; std::string s_std = std::format(&quot;{:%S}&quot;, sec(4.2)); // s3 == &quot;04,200&quot; (localized) auto s_std2 = std::format(&quot;{:L%S}&quot;, sec(4.2)); // throws format_error std::string s_fmt = fmt::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) And the fixed one is: 1 2 3 4 5 std::locale::global(std::locale(&quot;ru_RU&quot;)); using sec = std::chrono::duration&lt;double&gt;; auto s_std = std::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) auto s_std2 = std::format(&quot;{:L%S}&quot;, sec(4.2)); // s == &quot;04,200&quot; (localized) std::string s_fmt = fmt::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) Notice that what was automatically localized, is not localized anymore and at the same time, you have the opportunity to manually localize chrono literals. Clarify the handling of encodings in localized formatting of chrono types P2419R2 is solving another problem with std::format and std::chrono. I already wrote about it in C++23: Encoding related changes, but I think it’s worth mentioning here too. While P2372R3 solves the problem of whether chrono types should be localized or not, this proposal solves how to handle encodings, when chrono types have to be localized. Let’s take the example from the paper. 1 2 std::locale::global(std::locale(&quot;Russian.1251&quot;)); auto s = std::format(&quot;День недели: {:L}&quot;, std::chrono::Monday); The problem is that before the acceptance of this paper (P2419R2), the standard didn’t specify what should happen if the literal encoding (in this case of std::chrono::Monday) is UTF-8 and it exists in the specified locale in a different encoding. One option is to use the local encoding and the other is to use a UTF-8 encoding. In this case, with the locale encoding of “Russian.1251”, we’d use CP1251 which is not valid UTF-8. Mixing the results in “День недели: \xcf\xed”, where “\xcf\xed” is in Russian.1251 and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable. Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text. With the acceptance of P2419R2, if the formatted text is in UTF-8 and the locale is among an implementation-defined set of locales, each replacement that depends on the locale is performed as if the replacement character sequence is converted to UTF-8. Relaxing requirements for time_point&lt;&gt;::clock P2212R2 recognizes the need of passing a non-Cpp17Clock-like clock to a std::chrono::time_point. Let’s answer two questions here! What is a time_point and what requirements does a Cpp17Clock have? std::chrono::time_point is a class template that represents a point in time. It takes a clock and a duration as template parameters and it acts as if it stored the time interval passed since the start of the clock’s epoch. The requirements of a clock are listed here. Basically, these requirements fix that a clock’s API must have Clock::rep, Clock::period, Clock::time_point denoting types, must support Clock::now() member function and defines when Clock::is_steady should be true. is_steady should be true if there are two clocks with the same epoch and if the time returned by one is less or equal at one time_point then it should be less or equal at any time_point. The authors of P2212R2 explain a couple of cases when the original requirements are too strict. C++20 introduced a clock that is not really a clock, local_t. It’s a pseudo-clock to indicate that the time point represents local time in a not-yet-specified time zone. Sometimes, you need a stateful clock that requires a non-static now() function. Sometimes, you need to represent “time of day” as a distinct time_point without having the date specified. But what is changing? The standard doesn’t impose Cpp17Clock requirements or local_t on time_point. For threads on the other hand, now it explicitly says that template parameters with the name Clock should model those Cpp17Clock requirements instead of requiring simply is_clock_v to be true. Conclusion In this article, we had a look at C++23 changes related to the chrono library. We saw how the std::format becomes more consistent in handling durations and different locales. We also saw that time_point is relaxing its requirements on a clock. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one is about what requirements time_point imposes on a clock. DR: Fixing locale handling in chrono formatters P2372R3 is a fix of C++ based on the bug reported in LWG-3547. The problem is a bug in the specification of chrono formatters in the standard. While std::format is locale-independent by default and gives you the possibility to change the locale via format specifiers, the new formatter specializations of C++20 for chrono types are localized by default and don’t let you change the locale via format specifiers. There are three problems with this approach: It goes against the design of std::format (and by the way the fmt implementation) As chrono formatters are automatically localized, you cannot avoid locales, if you want to do so, you have to automatically format date and time manually Some chrono formatters act as if they would provide a locale-independent specifier (%S) and a localized one as well (%OS) which is misleading. So the original behaviour of std::format and std::chrono is the below: 1 2 3 4 5 std::locale::global(std::locale(&quot;ru_RU&quot;)); using sec = std::chrono::duration&lt;double&gt;; std::string s_std = std::format(&quot;{:%S}&quot;, sec(4.2)); // s3 == &quot;04,200&quot; (localized) auto s_std2 = std::format(&quot;{:L%S}&quot;, sec(4.2)); // throws format_error std::string s_fmt = fmt::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) And the fixed one is: 1 2 3 4 5 std::locale::global(std::locale(&quot;ru_RU&quot;)); using sec = std::chrono::duration&lt;double&gt;; auto s_std = std::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) auto s_std2 = std::format(&quot;{:L%S}&quot;, sec(4.2)); // s == &quot;04,200&quot; (localized) std::string s_fmt = fmt::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) Notice that what was automatically localized, is not localized anymore and at the same time, you have the opportunity to manually localize chrono literals. Clarify the handling of encodings in localized formatting of chrono types P2419R2 is solving another problem with std::format and std::chrono. I already wrote about it in C++23: Encoding related changes, but I think it’s worth mentioning here too. While P2372R3 solves the problem of whether chrono types should be localized or not, this proposal solves how to handle encodings, when chrono types have to be localized. Let’s take the example from the paper. 1 2 std::locale::global(std::locale(&quot;Russian.1251&quot;)); auto s = std::format(&quot;День недели: {:L}&quot;, std::chrono::Monday); The problem is that before the acceptance of this paper (P2419R2), the standard didn’t specify what should happen if the literal encoding (in this case of std::chrono::Monday) is UTF-8 and it exists in the specified locale in a different encoding. One option is to use the local encoding and the other is to use a UTF-8 encoding. In this case, with the locale encoding of “Russian.1251”, we’d use CP1251 which is not valid UTF-8. Mixing the results in “День недели: \xcf\xed”, where “\xcf\xed” is in Russian.1251 and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable. Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text. With the acceptance of P2419R2, if the formatted text is in UTF-8 and the locale is among an implementation-defined set of locales, each replacement that depends on the locale is performed as if the replacement character sequence is converted to UTF-8. Relaxing requirements for time_point&lt;&gt;::clock P2212R2 recognizes the need of passing a non-Cpp17Clock-like clock to a std::chrono::time_point. Let’s answer two questions here! What is a time_point and what requirements does a Cpp17Clock have? std::chrono::time_point is a class template that represents a point in time. It takes a clock and a duration as template parameters and it acts as if it stored the time interval passed since the start of the clock’s epoch. The requirements of a clock are listed here. Basically, these requirements fix that a clock’s API must have Clock::rep, Clock::period, Clock::time_point denoting types, must support Clock::now() member function and defines when Clock::is_steady should be true. is_steady should be true if there are two clocks with the same epoch and if the time returned by one is less or equal at one time_point then it should be less or equal at any time_point. The authors of P2212R2 explain a couple of cases when the original requirements are too strict. C++20 introduced a clock that is not really a clock, local_t. It’s a pseudo-clock to indicate that the time point represents local time in a not-yet-specified time zone. Sometimes, you need a stateful clock that requires a non-static now() function. Sometimes, you need to represent “time of day” as a distinct time_point without having the date specified. But what is changing? The standard doesn’t impose Cpp17Clock requirements or local_t on time_point. For threads on the other hand, now it explicitly says that template parameters with the name Clock should model those Cpp17Clock requirements instead of requiring simply is_clock_v to be true. Conclusion In this article, we had a look at C++23 changes related to the chrono library. We saw how the std::format becomes more consistent in handling durations and different locales. We also saw that time_point is relaxing its requirements on a clock. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-29T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: chrono related changes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-05-29T00:00:00+02:00","datePublished":"2024-05-29T00:00:00+02:00","description":"Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the chrono library. The first two are related to std::format and using locales, and the last one is about what requirements time_point imposes on a clock. DR: Fixing locale handling in chrono formatters P2372R3 is a fix of C++ based on the bug reported in LWG-3547. The problem is a bug in the specification of chrono formatters in the standard. While std::format is locale-independent by default and gives you the possibility to change the locale via format specifiers, the new formatter specializations of C++20 for chrono types are localized by default and don’t let you change the locale via format specifiers. There are three problems with this approach: It goes against the design of std::format (and by the way the fmt implementation) As chrono formatters are automatically localized, you cannot avoid locales, if you want to do so, you have to automatically format date and time manually Some chrono formatters act as if they would provide a locale-independent specifier (%S) and a localized one as well (%OS) which is misleading. So the original behaviour of std::format and std::chrono is the below: 1 2 3 4 5 std::locale::global(std::locale(&quot;ru_RU&quot;)); using sec = std::chrono::duration&lt;double&gt;; std::string s_std = std::format(&quot;{:%S}&quot;, sec(4.2)); // s3 == &quot;04,200&quot; (localized) auto s_std2 = std::format(&quot;{:L%S}&quot;, sec(4.2)); // throws format_error std::string s_fmt = fmt::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) And the fixed one is: 1 2 3 4 5 std::locale::global(std::locale(&quot;ru_RU&quot;)); using sec = std::chrono::duration&lt;double&gt;; auto s_std = std::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) auto s_std2 = std::format(&quot;{:L%S}&quot;, sec(4.2)); // s == &quot;04,200&quot; (localized) std::string s_fmt = fmt::format(&quot;{:%S}&quot;, sec(4.2)); // s == &quot;04.200&quot; (not localized) Notice that what was automatically localized, is not localized anymore and at the same time, you have the opportunity to manually localize chrono literals. Clarify the handling of encodings in localized formatting of chrono types P2419R2 is solving another problem with std::format and std::chrono. I already wrote about it in C++23: Encoding related changes, but I think it’s worth mentioning here too. While P2372R3 solves the problem of whether chrono types should be localized or not, this proposal solves how to handle encodings, when chrono types have to be localized. Let’s take the example from the paper. 1 2 std::locale::global(std::locale(&quot;Russian.1251&quot;)); auto s = std::format(&quot;День недели: {:L}&quot;, std::chrono::Monday); The problem is that before the acceptance of this paper (P2419R2), the standard didn’t specify what should happen if the literal encoding (in this case of std::chrono::Monday) is UTF-8 and it exists in the specified locale in a different encoding. One option is to use the local encoding and the other is to use a UTF-8 encoding. In this case, with the locale encoding of “Russian.1251”, we’d use CP1251 which is not valid UTF-8. Mixing the results in “День недели: \\xcf\\xed”, where “\\xcf\\xed” is in Russian.1251 and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable. Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text. With the acceptance of P2419R2, if the formatted text is in UTF-8 and the locale is among an implementation-defined set of locales, each replacement that depends on the locale is performed as if the replacement character sequence is converted to UTF-8. Relaxing requirements for time_point&lt;&gt;::clock P2212R2 recognizes the need of passing a non-Cpp17Clock-like clock to a std::chrono::time_point. Let’s answer two questions here! What is a time_point and what requirements does a Cpp17Clock have? std::chrono::time_point is a class template that represents a point in time. It takes a clock and a duration as template parameters and it acts as if it stored the time interval passed since the start of the clock’s epoch. The requirements of a clock are listed here. Basically, these requirements fix that a clock’s API must have Clock::rep, Clock::period, Clock::time_point denoting types, must support Clock::now() member function and defines when Clock::is_steady should be true. is_steady should be true if there are two clocks with the same epoch and if the time returned by one is less or equal at one time_point then it should be less or equal at any time_point. The authors of P2212R2 explain a couple of cases when the original requirements are too strict. C++20 introduced a clock that is not really a clock, local_t. It’s a pseudo-clock to indicate that the time point represents local time in a not-yet-specified time zone. Sometimes, you need a stateful clock that requires a non-static now() function. Sometimes, you need to represent “time of day” as a distinct time_point without having the date specified. But what is changing? The standard doesn’t impose Cpp17Clock requirements or local_t on time_point. For threads on the other hand, now it explicitly says that template parameters with the name Clock should model those Cpp17Clock requirements instead of requiring simply is_clock_v to be true. Conclusion In this article, we had a look at C++23 changes related to the chrono library. We saw how the std::format becomes more consistent in handling durations and different locales. We also saw that time_point is relaxing its requirements on a clock. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: chrono related changes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono"},"url":"https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono"}</script><title>C++23: chrono related changes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/29"> 29 </a> </span> <span>C++23: chrono related changes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: chrono related changes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 29, 2024, 12:00 AM +0200" prep="on" > May 29, 2024 <i class="unloaded">2024-05-29T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="933 words">5 min</span></div></div><div class="post-content"><p>Let’s continue with what is changing in C++23. This time, let’s look at the three changes related to the <code class="language-plaintext highlighter-rouge">chrono</code> library. The first two are related to <code class="language-plaintext highlighter-rouge">std::format</code> and using locales, and the last one is about what requirements <code class="language-plaintext highlighter-rouge">time_point</code> imposes on a clock.</p><h2 id="dr-fixing-locale-handling-in-chrono-formatters">DR: Fixing locale handling in chrono formatters</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2372r3.html">P2372R3</a> is a fix of C++ based on the bug reported in <a href="https://cplusplus.github.io/LWG/issue3547">LWG-3547</a>. The problem is a bug in the specification of chrono formatters in the standard.</p><p>While <code class="language-plaintext highlighter-rouge">std::format</code> is locale-independent by default and gives you the possibility to change the locale via format specifiers, the new formatter specializations of C++20 for chrono types are localized by default and don’t let you change the locale via format specifiers.</p><p>There are three problems with this approach:</p><ul><li>It goes against the design of <code class="language-plaintext highlighter-rouge">std::format</code> (and by the way the <code class="language-plaintext highlighter-rouge">fmt</code> implementation)<li>As chrono formatters are automatically localized, you cannot avoid locales, if you want to do so, you have to automatically format date and time manually<li>Some chrono formatters act as if they would provide a locale-independent specifier (<code class="language-plaintext highlighter-rouge">%S</code>) and a localized one as well (<code class="language-plaintext highlighter-rouge">%OS</code>) which is misleading.</ul><p>So the original behaviour of <code class="language-plaintext highlighter-rouge">std::format</code> and <code class="language-plaintext highlighter-rouge">std::chrono</code> is the below:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="o">::</span><span class="n">global</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">(</span><span class="s">"ru_RU"</span><span class="p">));</span>
<span class="k">using</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s_std</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%S}"</span><span class="p">,</span> <span class="n">sec</span><span class="p">(</span><span class="mf">4.2</span><span class="p">));</span> <span class="c1">// s3 == "04,200" (localized)</span>
<span class="k">auto</span> <span class="n">s_std2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:L%S}"</span><span class="p">,</span> <span class="n">sec</span><span class="p">(</span><span class="mf">4.2</span><span class="p">));</span> <span class="c1">// throws format_error</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s_fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%S}"</span><span class="p">,</span> <span class="n">sec</span><span class="p">(</span><span class="mf">4.2</span><span class="p">));</span>  <span class="c1">// s == "04.200" (not localized)</span>
</pre></table></code></div></div><p>And the fixed one is:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="o">::</span><span class="n">global</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">(</span><span class="s">"ru_RU"</span><span class="p">));</span>
<span class="k">using</span> <span class="n">sec</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">duration</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">;</span>
<span class="k">auto</span> <span class="n">s_std</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%S}"</span><span class="p">,</span> <span class="n">sec</span><span class="p">(</span><span class="mf">4.2</span><span class="p">));</span> <span class="c1">// s == "04.200" (not localized)</span>
<span class="k">auto</span> <span class="n">s_std2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:L%S}"</span><span class="p">,</span> <span class="n">sec</span><span class="p">(</span><span class="mf">4.2</span><span class="p">));</span> <span class="c1">// s == "04,200" (localized)</span>
<span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s_fmt</span> <span class="o">=</span> <span class="n">fmt</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"{:%S}"</span><span class="p">,</span> <span class="n">sec</span><span class="p">(</span><span class="mf">4.2</span><span class="p">));</span>  <span class="c1">// s == "04.200" (not localized)</span>
</pre></table></code></div></div><p>Notice that what was automatically localized, is not localized anymore and at the same time, you have the opportunity to manually localize chrono literals.</p><h2 id="clarify-the-handling-of-encodings-in-localized-formatting-of-chrono-types">Clarify the handling of encodings in localized formatting of chrono types</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html">P2419R2</a> is solving another problem with <code class="language-plaintext highlighter-rouge">std::format</code> and <code class="language-plaintext highlighter-rouge">std::chrono</code>. I already wrote about it in <a href="https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes">C++23: Encoding related changes</a>, but I think it’s worth mentioning here too.</p><p>While <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2372r3.html">P2372R3</a> solves the problem of whether <code class="language-plaintext highlighter-rouge">chrono</code> types should be localized or not, this proposal solves how to handle encodings, when <code class="language-plaintext highlighter-rouge">chrono</code> types have to be localized.</p><p>Let’s take the example from the paper.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="o">::</span><span class="n">global</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">(</span><span class="s">"Russian.1251"</span><span class="p">));</span>
<span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"День недели: {:L}"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">Monday</span><span class="p">);</span>
</pre></table></code></div></div><p>The problem is that before the acceptance of this paper (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html">P2419R2</a>), the standard didn’t specify what should happen if the literal encoding (in this case of <code class="language-plaintext highlighter-rouge">std::chrono::Monday</code>) is UTF-8 and it exists in the specified locale in a different encoding.</p><p>One option is to use the local encoding and the other is to use a UTF-8 encoding.</p><p>In this case, with the locale encoding of “Russian.1251”, we’d use CP1251 which is not valid UTF-8. Mixing the results in <em>“День недели: \xcf\xed”</em>, where “\xcf\xed” is in <em>Russian.1251</em> and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable.</p><blockquote><p>Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text.</p></blockquote><p>With the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html">P2419R2</a>, if the formatted text is in UTF-8 and the locale is among an implementation-defined set of locales, each replacement that depends on the locale is performed as if the replacement character sequence is converted to UTF-8.</p><h2 id="relaxing-requirements-for-time_pointclock">Relaxing requirements for <code class="language-plaintext highlighter-rouge">time_point&lt;&gt;::clock</code></h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html">P2212R2</a> recognizes the need of passing a non-<em>Cpp17Clock</em>-like clock to a <code class="language-plaintext highlighter-rouge">std::chrono::time_point</code>.</p><p>Let’s answer two questions here! What is a <code class="language-plaintext highlighter-rouge">time_point</code> and what requirements does a <em>Cpp17Clock</em> have?</p><p><code class="language-plaintext highlighter-rouge">std::chrono::time_point</code> is a class template that represents a point in time. It takes a clock and a duration as template parameters and it acts as if it stored the time interval passed since the start of the clock’s epoch.</p><p>The requirements of a clock are <a href="https://en.cppreference.com/w/cpp/named_req/Clock">listed here</a>. Basically, these requirements fix that a clock’s API must have <code class="language-plaintext highlighter-rouge">Clock::rep</code>, <code class="language-plaintext highlighter-rouge">Clock::period</code>, <code class="language-plaintext highlighter-rouge">Clock::time_point</code> denoting types, must support <code class="language-plaintext highlighter-rouge">Clock::now()</code> member function and defines when <code class="language-plaintext highlighter-rouge">Clock::is_steady</code> should be true. <code class="language-plaintext highlighter-rouge">is_steady</code> should be true if there are two clocks with the same epoch and if the time returned by one is less or equal at one <code class="language-plaintext highlighter-rouge">time_point</code> then it should be less or equal at any <code class="language-plaintext highlighter-rouge">time_point</code>.</p><p>The authors of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p2212r2.html">P2212R2</a> explain a couple of cases when the original requirements are too strict.</p><ul><li>C++20 introduced a clock that is not really a clock, <code class="language-plaintext highlighter-rouge">local_t</code>. It’s a pseudo-clock to indicate that the time point represents local time in a not-yet-specified time zone.<li>Sometimes, you need a stateful clock that requires a non-static <code class="language-plaintext highlighter-rouge">now()</code> function.<li>Sometimes, you need to represent “time of day” as a distinct time_point without having the date specified.</ul><p>But what is changing?</p><p>The standard doesn’t impose Cpp17Clock requirements or <code class="language-plaintext highlighter-rouge">local_t</code> on <code class="language-plaintext highlighter-rouge">time_point</code>. For threads on the other hand, now it explicitly says that template parameters with the name <code class="language-plaintext highlighter-rouge">Clock</code> should model those Cpp17Clock requirements instead of requiring simply <code class="language-plaintext highlighter-rouge">is_clock_v</code> to be true.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we had a look at C++23 changes related to the <code class="language-plaintext highlighter-rouge">chrono</code> library. We saw how the <code class="language-plaintext highlighter-rouge">std::format</code> becomes more consistent in handling durations and different locales. We also saw that <code class="language-plaintext highlighter-rouge">time_point</code> is relaxing its requirements on a clock.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/chrono/" class="post-tag no-text-decoration" >chrono</a> <a href="/tags/format/" class="post-tag no-text-decoration" >format</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: chrono related changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: chrono related changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: chrono related changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: chrono related changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/05/22/are-we-a-sports-team" class="btn btn-outline-primary" prompt="Older"><p>Do engineering teams really resemble sports teams?</p></a> <a href="/blog/2024/06/05/the-limits-of-maybe-unused" class="btn btn-outline-primary" prompt="Newer"><p>The limits of `[[maybe_unused]]`</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: chrono related changes'; this.page.url = 'https://www.sandordargo.com/blog/2024/05/29/cpp23-chrono'; this.page.identifier = '/blog/2024/05/29/cpp23-chrono'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
