<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Two cases when forward declaring is not enough" /><meta property="og:locale" content="en_US" /><meta name="description" content="Let me share two cases when I had to include some header files instead of just using forward declarations. I was surprised by both at first. As you will see, one was a simple overlook, but the other wasn’t, the class definition was indeed needed. Let’s start with the first one. The case of the “missing” destructor Here is a class definition. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // foo.h #include &lt;memory&gt; #include &lt;string&gt; class Bar; class FooBase { public: virtual ~FooBase() = default; const Bar&amp; bar() const = 0; }; class Foo: public FooBase { public: Foo(std::string text, int num); const Bar&amp; bar() const override; private: std::unique_ptr&lt;Bar&gt; _bar; }; // foo.cpp #include &lt;mylib/include/bar.h&gt; #include &lt;mylib/include/foo.h&gt; Foo::Foo(std::string text, int num) : _bar(std::make_unique&lt;Bar&gt;(text, num)) {} const Bar&amp; Foo::bar() const { return *_bar; } Do you already see what’s wrong? It’s easier here than it was in real production code because the original header was rather big. When I built the library exposing this header, it was all fine. On the other hand, when I built another library that instantiated Foo and owned its lifetime, the compiler started to complain. The compiler said that it cannot destruct Foo because Bar is an incomplete type. To solve that I either had to include #include &lt;mylib/include/bar.h&gt; in foo.h or at the client using Foo. I was reluctant to do either, but to solve the immediate build issue I went with the latter. Obviously, I received a comment on my pull request indicating that if that header is needed I should include it in foo.h. But I didn’t want to do that, because I thought it was needed there. That’s when I looked at it again. Needless to say, in real life, Foo is not called Foo and it’s much bigger with plenty of constructor parameters and members. So when I looked at it once again, I realized that I forgot to declare the destructor and define it out of line. As such, the compiler generated it as if it was part of the header file. Given that, users calling ~Foo, needed Bar’s definition within foo.h. Adding ~Foo() override; to the header and Foo::~Foo() = default to the implementation solved the problem. It’s also worth noting that if you want to get a hold on the Bar object that is returned from Foo::bar(), you need to include bar.h, but if you just want to pass around the reference, or Foo itself, you’ll be fine. Covariant return types Here is another example of when an extra header inclusion was needed. In 2020, we already talked about covariant return types. In short, you can override a function in such a way that it doesn’t return the same type as the base virtual function, but a derived class of the original return type. Let me share the same example as a few years ago. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; class Car { public: virtual ~Car() = default; }; class SUV : public Car {}; class CarFactoryLine { public: virtual Car* produce() { return new Car{}; } }; class SUVFactoryLine : public CarFactoryLine { public: virtual SUV* produce() override { return new SUV{}; } }; int main () { SUVFactoryLine sf; SUV* car = sf.produce(); } As you can see, while the base CarFactoryLine::produce returns a Car*, the override, SUVFactoryLine::produce returns a SUV* and that’s perfectly fine. What I didn’t write about in this example is what this situation requires in terms of Car and SUV definition availability. In real life, you’d hardly have all that code in one file. The following is much more realistic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // car.h class Car { public: virtual ~Car() = default; }; // suv.h #include &lt;car.h&gt; class SUV : public Car {}; // car_factory_line.h class Car; class CarFactoryLine { public: virtual Car* produce(); }; // car_factory_line.cpp #include &lt;car_factory_line.h&gt; #include &lt;car.h&gt; Car* CarFactoryLine::produce() { return new Car{}; } // suv_factory_line.h #include &lt;car_factory_line.h&gt; class SUV; class SUVFactoryLine : public CarFactoryLine { public: virtual SUV* produce() override; }; // suv_factory_line.cpp #include &lt;suv_factory_line.h&gt; #include &lt;suv.h&gt; SUV* SUVFactoryLine::produce() { return new SUV{}; } // main.cpp #include &lt;suv_factory_line.h&gt; #include &lt;suv.h&gt; int main () { SUVFactoryLine sf; SUV* car = sf.produce(); } Note the factories are separated into header and implementation files and even Car and SUV would be. Also, notice that Car and SUV are forward declared in their factories. The problem is that the above example wouldn’t work. While we know that SUV is a covariant of Car and therefore it’s OK to return it, the compiler doesn’t know. All that it sees is that there is a Car forward-declared in car_factory_line.h and SUV in suv_factory_line.h. To the compiler at that point, those two classes are unrelated and the compilation fails. In order to fix that, instead of forward declaring SUV in suv_factory_line.h, we must properly include suv.h. Even though you don’t need to have the full definition available of a class that only appears as a return type, when the compiler needs more information on class relationships, you have no choice. If you wonder, no, you cannot forward declare a class with its base class. I’m not saying that this should prevent you from using the technique of returning covariant types in overrides, but you must be aware of this problem. Conclusion Today, I shared with you two small stories about when forward declarations were not enough and I had to include the header files instead. We saw that the first case was about an overlook on my side, but it’s still a reminder that if you let the compiler implicitly declare and define the destructor then depending on the class, forward declarations of members might not be enough to properly destruct an instance. The second case was about returning covariant types in overrides. It’s not enough that we know that two types are related, the compiler also has to be able to infer it. Solely from forward declarations, that is impossible to do, you have to include the declaration of the derived type (which inevitably brings in the declaration of the base class as well). Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Let me share two cases when I had to include some header files instead of just using forward declarations. I was surprised by both at first. As you will see, one was a simple overlook, but the other wasn’t, the class definition was indeed needed. Let’s start with the first one. The case of the “missing” destructor Here is a class definition. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // foo.h #include &lt;memory&gt; #include &lt;string&gt; class Bar; class FooBase { public: virtual ~FooBase() = default; const Bar&amp; bar() const = 0; }; class Foo: public FooBase { public: Foo(std::string text, int num); const Bar&amp; bar() const override; private: std::unique_ptr&lt;Bar&gt; _bar; }; // foo.cpp #include &lt;mylib/include/bar.h&gt; #include &lt;mylib/include/foo.h&gt; Foo::Foo(std::string text, int num) : _bar(std::make_unique&lt;Bar&gt;(text, num)) {} const Bar&amp; Foo::bar() const { return *_bar; } Do you already see what’s wrong? It’s easier here than it was in real production code because the original header was rather big. When I built the library exposing this header, it was all fine. On the other hand, when I built another library that instantiated Foo and owned its lifetime, the compiler started to complain. The compiler said that it cannot destruct Foo because Bar is an incomplete type. To solve that I either had to include #include &lt;mylib/include/bar.h&gt; in foo.h or at the client using Foo. I was reluctant to do either, but to solve the immediate build issue I went with the latter. Obviously, I received a comment on my pull request indicating that if that header is needed I should include it in foo.h. But I didn’t want to do that, because I thought it was needed there. That’s when I looked at it again. Needless to say, in real life, Foo is not called Foo and it’s much bigger with plenty of constructor parameters and members. So when I looked at it once again, I realized that I forgot to declare the destructor and define it out of line. As such, the compiler generated it as if it was part of the header file. Given that, users calling ~Foo, needed Bar’s definition within foo.h. Adding ~Foo() override; to the header and Foo::~Foo() = default to the implementation solved the problem. It’s also worth noting that if you want to get a hold on the Bar object that is returned from Foo::bar(), you need to include bar.h, but if you just want to pass around the reference, or Foo itself, you’ll be fine. Covariant return types Here is another example of when an extra header inclusion was needed. In 2020, we already talked about covariant return types. In short, you can override a function in such a way that it doesn’t return the same type as the base virtual function, but a derived class of the original return type. Let me share the same example as a few years ago. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; class Car { public: virtual ~Car() = default; }; class SUV : public Car {}; class CarFactoryLine { public: virtual Car* produce() { return new Car{}; } }; class SUVFactoryLine : public CarFactoryLine { public: virtual SUV* produce() override { return new SUV{}; } }; int main () { SUVFactoryLine sf; SUV* car = sf.produce(); } As you can see, while the base CarFactoryLine::produce returns a Car*, the override, SUVFactoryLine::produce returns a SUV* and that’s perfectly fine. What I didn’t write about in this example is what this situation requires in terms of Car and SUV definition availability. In real life, you’d hardly have all that code in one file. The following is much more realistic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // car.h class Car { public: virtual ~Car() = default; }; // suv.h #include &lt;car.h&gt; class SUV : public Car {}; // car_factory_line.h class Car; class CarFactoryLine { public: virtual Car* produce(); }; // car_factory_line.cpp #include &lt;car_factory_line.h&gt; #include &lt;car.h&gt; Car* CarFactoryLine::produce() { return new Car{}; } // suv_factory_line.h #include &lt;car_factory_line.h&gt; class SUV; class SUVFactoryLine : public CarFactoryLine { public: virtual SUV* produce() override; }; // suv_factory_line.cpp #include &lt;suv_factory_line.h&gt; #include &lt;suv.h&gt; SUV* SUVFactoryLine::produce() { return new SUV{}; } // main.cpp #include &lt;suv_factory_line.h&gt; #include &lt;suv.h&gt; int main () { SUVFactoryLine sf; SUV* car = sf.produce(); } Note the factories are separated into header and implementation files and even Car and SUV would be. Also, notice that Car and SUV are forward declared in their factories. The problem is that the above example wouldn’t work. While we know that SUV is a covariant of Car and therefore it’s OK to return it, the compiler doesn’t know. All that it sees is that there is a Car forward-declared in car_factory_line.h and SUV in suv_factory_line.h. To the compiler at that point, those two classes are unrelated and the compilation fails. In order to fix that, instead of forward declaring SUV in suv_factory_line.h, we must properly include suv.h. Even though you don’t need to have the full definition available of a class that only appears as a return type, when the compiler needs more information on class relationships, you have no choice. If you wonder, no, you cannot forward declare a class with its base class. I’m not saying that this should prevent you from using the technique of returning covariant types in overrides, but you must be aware of this problem. Conclusion Today, I shared with you two small stories about when forward declarations were not enough and I had to include the header files instead. We saw that the first case was about an overlook on my side, but it’s still a reminder that if you let the compiler implicitly declare and define the destructor then depending on the class, forward declarations of members might not be enough to properly destruct an instance. The second case was about returning covariant types in overrides. It’s not enough that we know that two types are related, the compiler also has to be able to infer it. Solely from forward declarations, that is impossible to do, you have to include the declaration of the derived type (which inevitably brings in the declaration of the base class as well). Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-05-15T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Two cases when forward declaring is not enough" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-05-15T00:00:00+02:00","datePublished":"2024-05-15T00:00:00+02:00","description":"Let me share two cases when I had to include some header files instead of just using forward declarations. I was surprised by both at first. As you will see, one was a simple overlook, but the other wasn’t, the class definition was indeed needed. Let’s start with the first one. The case of the “missing” destructor Here is a class definition. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // foo.h #include &lt;memory&gt; #include &lt;string&gt; class Bar; class FooBase { public: virtual ~FooBase() = default; const Bar&amp; bar() const = 0; }; class Foo: public FooBase { public: Foo(std::string text, int num); const Bar&amp; bar() const override; private: std::unique_ptr&lt;Bar&gt; _bar; }; // foo.cpp #include &lt;mylib/include/bar.h&gt; #include &lt;mylib/include/foo.h&gt; Foo::Foo(std::string text, int num) : _bar(std::make_unique&lt;Bar&gt;(text, num)) {} const Bar&amp; Foo::bar() const { return *_bar; } Do you already see what’s wrong? It’s easier here than it was in real production code because the original header was rather big. When I built the library exposing this header, it was all fine. On the other hand, when I built another library that instantiated Foo and owned its lifetime, the compiler started to complain. The compiler said that it cannot destruct Foo because Bar is an incomplete type. To solve that I either had to include #include &lt;mylib/include/bar.h&gt; in foo.h or at the client using Foo. I was reluctant to do either, but to solve the immediate build issue I went with the latter. Obviously, I received a comment on my pull request indicating that if that header is needed I should include it in foo.h. But I didn’t want to do that, because I thought it was needed there. That’s when I looked at it again. Needless to say, in real life, Foo is not called Foo and it’s much bigger with plenty of constructor parameters and members. So when I looked at it once again, I realized that I forgot to declare the destructor and define it out of line. As such, the compiler generated it as if it was part of the header file. Given that, users calling ~Foo, needed Bar’s definition within foo.h. Adding ~Foo() override; to the header and Foo::~Foo() = default to the implementation solved the problem. It’s also worth noting that if you want to get a hold on the Bar object that is returned from Foo::bar(), you need to include bar.h, but if you just want to pass around the reference, or Foo itself, you’ll be fine. Covariant return types Here is another example of when an extra header inclusion was needed. In 2020, we already talked about covariant return types. In short, you can override a function in such a way that it doesn’t return the same type as the base virtual function, but a derived class of the original return type. Let me share the same example as a few years ago. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; class Car { public: virtual ~Car() = default; }; class SUV : public Car {}; class CarFactoryLine { public: virtual Car* produce() { return new Car{}; } }; class SUVFactoryLine : public CarFactoryLine { public: virtual SUV* produce() override { return new SUV{}; } }; int main () { SUVFactoryLine sf; SUV* car = sf.produce(); } As you can see, while the base CarFactoryLine::produce returns a Car*, the override, SUVFactoryLine::produce returns a SUV* and that’s perfectly fine. What I didn’t write about in this example is what this situation requires in terms of Car and SUV definition availability. In real life, you’d hardly have all that code in one file. The following is much more realistic. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 // car.h class Car { public: virtual ~Car() = default; }; // suv.h #include &lt;car.h&gt; class SUV : public Car {}; // car_factory_line.h class Car; class CarFactoryLine { public: virtual Car* produce(); }; // car_factory_line.cpp #include &lt;car_factory_line.h&gt; #include &lt;car.h&gt; Car* CarFactoryLine::produce() { return new Car{}; } // suv_factory_line.h #include &lt;car_factory_line.h&gt; class SUV; class SUVFactoryLine : public CarFactoryLine { public: virtual SUV* produce() override; }; // suv_factory_line.cpp #include &lt;suv_factory_line.h&gt; #include &lt;suv.h&gt; SUV* SUVFactoryLine::produce() { return new SUV{}; } // main.cpp #include &lt;suv_factory_line.h&gt; #include &lt;suv.h&gt; int main () { SUVFactoryLine sf; SUV* car = sf.produce(); } Note the factories are separated into header and implementation files and even Car and SUV would be. Also, notice that Car and SUV are forward declared in their factories. The problem is that the above example wouldn’t work. While we know that SUV is a covariant of Car and therefore it’s OK to return it, the compiler doesn’t know. All that it sees is that there is a Car forward-declared in car_factory_line.h and SUV in suv_factory_line.h. To the compiler at that point, those two classes are unrelated and the compilation fails. In order to fix that, instead of forward declaring SUV in suv_factory_line.h, we must properly include suv.h. Even though you don’t need to have the full definition available of a class that only appears as a return type, when the compiler needs more information on class relationships, you have no choice. If you wonder, no, you cannot forward declare a class with its base class. I’m not saying that this should prevent you from using the technique of returning covariant types in overrides, but you must be aware of this problem. Conclusion Today, I shared with you two small stories about when forward declarations were not enough and I had to include the header files instead. We saw that the first case was about an overlook on my side, but it’s still a reminder that if you let the compiler implicitly declare and define the destructor then depending on the class, forward declarations of members might not be enough to properly destruct an instance. The second case was about returning covariant types in overrides. It’s not enough that we know that two types are related, the compiler also has to be able to infer it. Solely from forward declarations, that is impossible to do, you have to include the declaration of the derived type (which inevitably brings in the declaration of the base class as well). Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Two cases when forward declaring is not enough","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed"},"url":"https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed"}</script><title>Two cases when forward declaring is not enough | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/15"> 15 </a> </span> <span>Two cases when forward declaring is not enough</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Two cases when forward declaring is not enough</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 15, 2024, 12:00 AM +0200" prep="on" > May 15, 2024 <i class="unloaded">2024-05-15T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1136 words">6 min</span></div></div><div class="post-content"><p>Let me share two cases when I had to include some header files instead of just using forward declarations. I was surprised by both at first. As you will see, one was a simple overlook, but the other wasn’t, the class definition was indeed needed.</p><p>Let’s start with the first one.</p><h2 id="the-case-of-the-missing-destructor">The case of the “missing” destructor</h2><p>Here is a class definition.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="c1">// foo.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Bar</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">FooBase</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">FooBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="p">};</span>

<span class="k">class</span> <span class="nc">Foo</span><span class="o">:</span> <span class="k">public</span> <span class="n">FooBase</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">);</span>

	<span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">bar</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>

<span class="nl">private:</span>
	<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">_bar</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// foo.cpp</span>

<span class="cp">#include</span> <span class="cpf">&lt;mylib/include/bar.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;mylib/include/foo.h&gt;</span><span class="cp">
</span>
<span class="n">Foo</span><span class="o">::</span><span class="n">Foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">text</span><span class="p">,</span> <span class="kt">int</span> <span class="n">num</span><span class="p">)</span> <span class="o">:</span> <span class="n">_bar</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">(</span><span class="n">text</span><span class="p">,</span> <span class="n">num</span><span class="p">))</span> <span class="p">{}</span>
<span class="k">const</span> <span class="n">Bar</span><span class="o">&amp;</span> <span class="n">Foo</span><span class="o">::</span><span class="n">bar</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="o">*</span><span class="n">_bar</span><span class="p">;</span> <span class="p">}</span>
</pre></table></code></div></div><p>Do you already see what’s wrong? It’s easier here than it was in real production code because the original header was rather big.</p><p>When I built the library exposing this header, it was all fine.</p><p>On the other hand, when I built another library that instantiated <code class="language-plaintext highlighter-rouge">Foo</code> and owned its lifetime, the compiler started to complain.</p><p>The compiler said that it cannot destruct <code class="language-plaintext highlighter-rouge">Foo</code> because <code class="language-plaintext highlighter-rouge">Bar</code> is an incomplete type. To solve that I either had to include <code class="language-plaintext highlighter-rouge">#include &lt;mylib/include/bar.h&gt;</code> in <code class="language-plaintext highlighter-rouge">foo.h</code> or at the client using <code class="language-plaintext highlighter-rouge">Foo</code>. I was reluctant to do either, but to solve the immediate build issue I went with the latter.</p><p>Obviously, I received a comment on my pull request indicating that if that header is needed I should include it in <code class="language-plaintext highlighter-rouge">foo.h</code>. But I didn’t want to do that, because I thought it was needed there. That’s when I looked at it again.</p><p>Needless to say, in real life, <code class="language-plaintext highlighter-rouge">Foo</code> is not called <em>Foo</em> and it’s much bigger with plenty of constructor parameters and members. So when I looked at it once again, I realized that I forgot to declare the destructor and define it out of line. As such, the compiler generated it as if it was part of the header file. Given that, users calling <code class="language-plaintext highlighter-rouge">~Foo</code>, needed <code class="language-plaintext highlighter-rouge">Bar</code>’s definition within <code class="language-plaintext highlighter-rouge">foo.h</code>. Adding <code class="language-plaintext highlighter-rouge">~Foo() override;</code> to the header and <code class="language-plaintext highlighter-rouge">Foo::~Foo() = default</code> to the implementation solved the problem.</p><p>It’s also worth noting that if you want to get a hold on the <code class="language-plaintext highlighter-rouge">Bar</code> object that is returned from <code class="language-plaintext highlighter-rouge">Foo::bar()</code>, you need to include <code class="language-plaintext highlighter-rouge">bar.h</code>, but if you just want to pass around the reference, or <code class="language-plaintext highlighter-rouge">Foo</code> itself, you’ll be fine.</p><h2 id="covariant-return-types">Covariant return types</h2><p>Here is another example of when an extra header inclusion was needed.</p><p>In 2020, <a href="https://www.sandordargo.com/blog/2020/08/19/covariant-return-types">we already talked about covariant return types</a>. In short, you can override a function in such a way that it doesn’t return the same type as the base virtual function, but a derived class of the original return type.</p><p>Let me share the same example as a few years ago.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
 <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SUV</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">Car</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">Car</span><span class="p">{};</span>
	<span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">SUVFactoryLine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">SUV</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
		<span class="k">return</span> <span class="k">new</span> <span class="n">SUV</span><span class="p">{};</span>
	<span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">SUVFactoryLine</span> <span class="n">sf</span><span class="p">;</span>
    <span class="n">SUV</span><span class="o">*</span> <span class="n">car</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">produce</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, while the base <code class="language-plaintext highlighter-rouge">CarFactoryLine::produce</code> returns a <code class="language-plaintext highlighter-rouge">Car*</code>, the override, <code class="language-plaintext highlighter-rouge">SUVFactoryLine::produce</code> returns a <code class="language-plaintext highlighter-rouge">SUV*</code> and that’s perfectly fine.</p><p>What I didn’t write about in this example is what this situation requires in terms of <code class="language-plaintext highlighter-rouge">Car</code> and <code class="language-plaintext highlighter-rouge">SUV</code> definition availability.</p><p>In real life, you’d hardly have all that code in one file.</p><p>The following is much more realistic.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
</pre><td class="rouge-code"><pre><span class="c1">// car.h</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
 <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// suv.h</span>
<span class="cp">#include</span> <span class="cpf">&lt;car.h&gt;</span><span class="cp">
</span><span class="k">class</span> <span class="nc">SUV</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{};</span>


<span class="c1">// car_factory_line.h</span>

<span class="k">class</span> <span class="nc">Car</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">Car</span><span class="o">*</span> <span class="n">produce</span><span class="p">();</span>
<span class="p">};</span>

<span class="c1">// car_factory_line.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;car_factory_line.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;car.h&gt;</span><span class="cp">
</span>
<span class="n">Car</span><span class="o">*</span> <span class="n">CarFactoryLine</span><span class="o">::</span><span class="n">produce</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="n">Car</span><span class="p">{};</span>
<span class="p">}</span>


<span class="c1">// suv_factory_line.h</span>

<span class="cp">#include</span> <span class="cpf">&lt;car_factory_line.h&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SUV</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">SUVFactoryLine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CarFactoryLine</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">virtual</span> <span class="n">SUV</span><span class="o">*</span> <span class="n">produce</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// suv_factory_line.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;suv_factory_line.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;suv.h&gt;</span><span class="cp">
</span>
<span class="n">SUV</span><span class="o">*</span> <span class="n">SUVFactoryLine</span><span class="o">::</span><span class="n">produce</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">return</span> <span class="k">new</span> <span class="n">SUV</span><span class="p">{};</span>
<span class="p">}</span>

<span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;suv_factory_line.h&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;suv.h&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span> <span class="p">()</span> <span class="p">{</span>
    <span class="n">SUVFactoryLine</span> <span class="n">sf</span><span class="p">;</span>
    <span class="n">SUV</span><span class="o">*</span> <span class="n">car</span> <span class="o">=</span> <span class="n">sf</span><span class="p">.</span><span class="n">produce</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Note the factories are separated into header and implementation files and even <code class="language-plaintext highlighter-rouge">Car</code> and <code class="language-plaintext highlighter-rouge">SUV</code> would be. Also, notice that <code class="language-plaintext highlighter-rouge">Car</code> and <code class="language-plaintext highlighter-rouge">SUV</code> are forward declared in their factories.</p><p>The problem is that the above example wouldn’t work. While we know that <code class="language-plaintext highlighter-rouge">SUV</code> is a covariant of <code class="language-plaintext highlighter-rouge">Car</code> and therefore it’s OK to return it, the compiler doesn’t know. All that it sees is that there is a <code class="language-plaintext highlighter-rouge">Car</code> forward-declared in <code class="language-plaintext highlighter-rouge">car_factory_line.h</code> and <code class="language-plaintext highlighter-rouge">SUV</code> in <code class="language-plaintext highlighter-rouge">suv_factory_line.h</code>. To the compiler at that point, those two classes are unrelated and the compilation fails.</p><p>In order to fix that, instead of forward declaring <code class="language-plaintext highlighter-rouge">SUV</code> in <code class="language-plaintext highlighter-rouge">suv_factory_line.h</code>, we must properly include <code class="language-plaintext highlighter-rouge">suv.h</code>. Even though you don’t need to have the full definition available of a class that only appears as a return type, when the compiler needs more information on class relationships, you have no choice.</p><p>If you wonder, no, you cannot forward declare a class with its base class.</p><p>I’m not saying that this should prevent you from using the technique of returning covariant types in overrides, but you must be aware of this problem.</p><h2 id="conclusion">Conclusion</h2><p>Today, I shared with you two small stories about when forward declarations were not enough and I had to include the header files instead. We saw that the first case was about an overlook on my side, but it’s still a reminder that if you let the compiler implicitly declare and define the destructor then depending on the class, forward declarations of members might not be enough to properly destruct an instance.</p><p>The second case was about returning covariant types in overrides. It’s not enough that we know that two types are related, the compiler also has to be able to infer it. Solely from forward declarations, that is impossible to do, you have to include the declaration of the derived type (which inevitably brings in the declaration of the base class as well).</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/forwarddeclaration/" class="post-tag no-text-decoration" >forwarddeclaration</a> <a href="/tags/covariant/" class="post-tag no-text-decoration" >covariant</a> <a href="/tags/oop/" class="post-tag no-text-decoration" >oop</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Two cases when forward declaring is not enough - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Two cases when forward declaring is not enough - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Two cases when forward declaring is not enough - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Two cases when forward declaring is not enough - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2020/08/19/covariant-return-types"><div class="card-body"> <span class="timeago small" > Aug 19, 2020 <i class="unloaded">2020-08-19T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Covariant return types</h3><div class="text-muted small"><p> Even after spending years in software development, you will find expressions that you simply don’t understand. Even if you are considered somewhat a senior. Those terms might express an advanced co...</p></div></div></a></div><div class="card"> <a href="/blog/2020/01/08/default-member-initialization"><div class="card-body"> <span class="timeago small" > Jan 8, 2020 <i class="unloaded">2020-01-08T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Default Member Initializers in C++</h3><div class="text-muted small"><p> This topic came up recently during a coding dojo in our department, while we were working on the ugly trivia kata. We wanted to extract a struct, containing the player data. Later we wanted to turn...</p></div></div></a></div><div class="card"> <a href="/blog/2020/04/01/private-inheritanc-vs-composition"><div class="card-body"> <span class="timeago small" > Apr 1, 2020 <i class="unloaded">2020-04-01T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The quest of private inheritance in C++</h3><div class="text-muted small"><p> I love mentoring. It requires a huge quantity of humility, and if you possess it, it will bring you tremendous benefits on a human as well as on a technical level. A few weeks ago, I met with on...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/05/08/quo-vadis-this-blog" class="btn btn-outline-primary" prompt="Older"><p>Quo vadis this blog?</p></a> <a href="/blog/2024/05/22/are-we-a-sports-team" class="btn btn-outline-primary" prompt="Newer"><p>Do engineering teams really resemble sports teams?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Two cases when forward declaring is not enough'; this.page.url = 'https://www.sandordargo.com/blog/2024/05/15/when-includes-are-needed'; this.page.identifier = '/blog/2024/05/15/when-includes-are-needed'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
