<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="How to write unit tests in C++ relying on non-code files?" /><meta property="og:locale" content="en_US" /><meta name="description" content="Recently we had a coding dojo with my colleagues where we were working on the second part of the Racing Car Katas, called TextConverter. To sum up the problem, the HtmlTextConverter class takes a filename, reads the file into memory and converts its content into a not-very-sophisticated HTML text. The goal is to test the class and potentially refactor it if you find any good reason for that. In my opinion, there are plenty of reasons to refactor this class. The main problem is that it does at least two things. It 1) reads a file and 2) converts its contents to HTML. It is difficult to write unit tests for this class because a unit test should be fast and ideally should not depend on things such as IO or network. In this case, we clearly depend on the file system. Still, it’s possible to provide a test that works. We can create a file and use it in the test. Without having that test, refactoring is not safe as we wouldn’t know if we broke something. A first naive approach As a first attempt, in the test directory, we created a file called simpleText.txt with a few lines in it and wrote this test. 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::string filePath { &quot;simplefile.txt&quot; }; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } We didn’t expect it to work, but we wanted some fast feedback. It failed as the content was not read in, and the file was not found. Oh, by the way, the original code of HtmlTextConverter doesn’t make any difference between an empty and a missing file… As a next step, we updated the CMake settings to compile with C++17 and tried to use std::filesystem. We had some surprises with the filesystem API, such as its lack of support for operator+ and the differences between concat and append or between operator+= and operator/=, but that’s another story. 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::current_path().append(&quot;simplefile.txt&quot;); HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } It still didn’t work, the output was empty. So we decided to print the path. What could have gone wrong? It returned something unexpected to us: 1 filePath: &quot;/Users/sandord/personal/dev/dojos/Racing-Car-Katas/Cpp/cmake-build-script/TextConverter/tests/simplefile.txt&quot; Oh la la! That’s clearly not where we created the file! cmake-build-script/ was an unexpected element of the path! Okay, so the unit test was looking for the file in the build folder, not where the file we wanted to compile originally resided… We found three different approaches to resolve this problem. Use __FILE__ to get the original path If you want the original path of the file, you can use the __FILE__ preprocessor macro. You don’t get the directory path, but the file path. This means that you have to get rid of the file name. Luckily, it’s easy to do with std::filesystem::path::remove_filename. 1 2 3 4 5 6 7 8 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path dirPath = std::filesystem::path(__FILE__).remove_filename(); std::filesystem::path filePath = dirPath /= &quot;simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } It has another downside as well, but we’ll unravel that one later. Create a global variable from CMake So we need the path of the original file. We know the value exactly in CMake. Also in CMake, we can create global constants. To be more precise, with target_compile_definitions, we can populate the COMPILE_DEFINITIONS property with a semicolon-separated list of preprocessor definitions using the syntax VAR or VAR=value. Here is a way to solve our problem. We added this to our CMakeLists.txt file: 1 2 3 4 5 target_compile_definitions( HtmlTextConverter_Test_Gmock PUBLIC RESOURCE_DIR=&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot; ) Then we can use in the tests: 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::path(RESOURCE_DIR) += &quot;/simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } There are a couple of problems. First, if you see this test, you have absolutely no idea where RESOURCE_DIR comes from. We can help a little bit on that problem, by introducing a helper variable somewhere at the beginning of the file. Another potential problem is that it’s a good old char array. But with the helper variable, you solve that problem as well. 1 2 3 4 5 6 7 8 9 std::filesystem::path RESOURCES_PATH {RESOURCE_DIR}; TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = RESOURCES_PATH /= &quot;simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } A third problem which I already hinted about is that what if your tests change the file? You either have to undo the changes. Sure, but how? And how much work is that? rely on git to restore the file. Can we assume that the code is used alongside git? Maybe yes, maybe no, nevertheless it’s something to consider. Let’s say you can rely on Git. How much time is that going to take? or the best would be still to copy the file along with code files and just discard them along with the build folder. Of course, if the test files are big, this is problematic. But unit tests shouldn’t depend on huge test files. Well, they shouldn’t depend on text files anyhow, right…? Copy the resources to the build file It’s not in the scope of this article to discover handling git from C++ or to undo changes on a file, but we are going to see how to copy the resources to the build folder. Copying files over to the build folder is very simple. 1 2 3 configure_file(emptyfile.txt ${CMAKE_CURRENT_BINARY_DIR}/emptyfile.txt COPYONLY) configure_file(escapedfile.txt ${CMAKE_CURRENT_BINARY_DIR}/escapedfile.txt COPYONLY) configure_file(simplefile.txt ${CMAKE_CURRENT_BINARY_DIR}/simplefile.txt COPYONLY) With configure_file, we copy our resources from the current folder (assuming that they are in the same folder as the CMakeLists.txt file) to the CMAKE_CURRENT_BINARY_DIR. In this case, we simply copy them, but you have several options. This step is enough to run the tests successfully. To have a clean solution, we need two more commands. With add_custom_target, we create a target to represent the copying operation. Then with add_dependencies, we establish the dependency relationship between this custom target and other targets in the build process. This separation of concerns allows for better organization and management of the build process in CMake. It’s worth noting that this doesn’t make the text files part of the binary. If you have a binary to distribute that depends on text files, those files still have to be distributed along with the binary. 1 2 3 4 5 add_custom_target(CopyTextFile ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/emptyfile.txt ${CMAKE_CURRENT_BINARY_DIR}/escapedfile.txt ${CMAKE_CURRENT_BINARY_DIR}/simplefile.txt) add_dependencies(HtmlTextConverter_Test_Gmock CopyTextFile) That’s it. In this third solution, we copy over the files each time to the build folder, so any changes done by the tests are discarded. Besides the relative path is kept, we can use such useful constructs as std::filesystem::current_path in our code: 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::current_path().append(&quot;simplefile.txt&quot;); HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } If we have another look, this code actually was one of our first, naive attempts! And eventually, the test would only pass the filename with the full path! Conclusion In this article, I shared the different ways we found to make a unit test work which depends on local files. Our first solution uses the __FILE__ macro, you have to remove the filename from the path, but it will work. The second solution will work as long as you use CMake (just like the third solution), but its readability is not the best and handling changes to the resource files might be tricky. The third solution solves both the readability and issue and the problem of file changes in a test as it always copies the original files to the build folder. That copying might take a bit more time. Hopefully, you don’t rely on huge files in your unit tests… How do you solve this problem? Apart from removing the dependency on such files. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Recently we had a coding dojo with my colleagues where we were working on the second part of the Racing Car Katas, called TextConverter. To sum up the problem, the HtmlTextConverter class takes a filename, reads the file into memory and converts its content into a not-very-sophisticated HTML text. The goal is to test the class and potentially refactor it if you find any good reason for that. In my opinion, there are plenty of reasons to refactor this class. The main problem is that it does at least two things. It 1) reads a file and 2) converts its contents to HTML. It is difficult to write unit tests for this class because a unit test should be fast and ideally should not depend on things such as IO or network. In this case, we clearly depend on the file system. Still, it’s possible to provide a test that works. We can create a file and use it in the test. Without having that test, refactoring is not safe as we wouldn’t know if we broke something. A first naive approach As a first attempt, in the test directory, we created a file called simpleText.txt with a few lines in it and wrote this test. 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::string filePath { &quot;simplefile.txt&quot; }; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } We didn’t expect it to work, but we wanted some fast feedback. It failed as the content was not read in, and the file was not found. Oh, by the way, the original code of HtmlTextConverter doesn’t make any difference between an empty and a missing file… As a next step, we updated the CMake settings to compile with C++17 and tried to use std::filesystem. We had some surprises with the filesystem API, such as its lack of support for operator+ and the differences between concat and append or between operator+= and operator/=, but that’s another story. 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::current_path().append(&quot;simplefile.txt&quot;); HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } It still didn’t work, the output was empty. So we decided to print the path. What could have gone wrong? It returned something unexpected to us: 1 filePath: &quot;/Users/sandord/personal/dev/dojos/Racing-Car-Katas/Cpp/cmake-build-script/TextConverter/tests/simplefile.txt&quot; Oh la la! That’s clearly not where we created the file! cmake-build-script/ was an unexpected element of the path! Okay, so the unit test was looking for the file in the build folder, not where the file we wanted to compile originally resided… We found three different approaches to resolve this problem. Use __FILE__ to get the original path If you want the original path of the file, you can use the __FILE__ preprocessor macro. You don’t get the directory path, but the file path. This means that you have to get rid of the file name. Luckily, it’s easy to do with std::filesystem::path::remove_filename. 1 2 3 4 5 6 7 8 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path dirPath = std::filesystem::path(__FILE__).remove_filename(); std::filesystem::path filePath = dirPath /= &quot;simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } It has another downside as well, but we’ll unravel that one later. Create a global variable from CMake So we need the path of the original file. We know the value exactly in CMake. Also in CMake, we can create global constants. To be more precise, with target_compile_definitions, we can populate the COMPILE_DEFINITIONS property with a semicolon-separated list of preprocessor definitions using the syntax VAR or VAR=value. Here is a way to solve our problem. We added this to our CMakeLists.txt file: 1 2 3 4 5 target_compile_definitions( HtmlTextConverter_Test_Gmock PUBLIC RESOURCE_DIR=&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot; ) Then we can use in the tests: 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::path(RESOURCE_DIR) += &quot;/simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } There are a couple of problems. First, if you see this test, you have absolutely no idea where RESOURCE_DIR comes from. We can help a little bit on that problem, by introducing a helper variable somewhere at the beginning of the file. Another potential problem is that it’s a good old char array. But with the helper variable, you solve that problem as well. 1 2 3 4 5 6 7 8 9 std::filesystem::path RESOURCES_PATH {RESOURCE_DIR}; TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = RESOURCES_PATH /= &quot;simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } A third problem which I already hinted about is that what if your tests change the file? You either have to undo the changes. Sure, but how? And how much work is that? rely on git to restore the file. Can we assume that the code is used alongside git? Maybe yes, maybe no, nevertheless it’s something to consider. Let’s say you can rely on Git. How much time is that going to take? or the best would be still to copy the file along with code files and just discard them along with the build folder. Of course, if the test files are big, this is problematic. But unit tests shouldn’t depend on huge test files. Well, they shouldn’t depend on text files anyhow, right…? Copy the resources to the build file It’s not in the scope of this article to discover handling git from C++ or to undo changes on a file, but we are going to see how to copy the resources to the build folder. Copying files over to the build folder is very simple. 1 2 3 configure_file(emptyfile.txt ${CMAKE_CURRENT_BINARY_DIR}/emptyfile.txt COPYONLY) configure_file(escapedfile.txt ${CMAKE_CURRENT_BINARY_DIR}/escapedfile.txt COPYONLY) configure_file(simplefile.txt ${CMAKE_CURRENT_BINARY_DIR}/simplefile.txt COPYONLY) With configure_file, we copy our resources from the current folder (assuming that they are in the same folder as the CMakeLists.txt file) to the CMAKE_CURRENT_BINARY_DIR. In this case, we simply copy them, but you have several options. This step is enough to run the tests successfully. To have a clean solution, we need two more commands. With add_custom_target, we create a target to represent the copying operation. Then with add_dependencies, we establish the dependency relationship between this custom target and other targets in the build process. This separation of concerns allows for better organization and management of the build process in CMake. It’s worth noting that this doesn’t make the text files part of the binary. If you have a binary to distribute that depends on text files, those files still have to be distributed along with the binary. 1 2 3 4 5 add_custom_target(CopyTextFile ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/emptyfile.txt ${CMAKE_CURRENT_BINARY_DIR}/escapedfile.txt ${CMAKE_CURRENT_BINARY_DIR}/simplefile.txt) add_dependencies(HtmlTextConverter_Test_Gmock CopyTextFile) That’s it. In this third solution, we copy over the files each time to the build folder, so any changes done by the tests are discarded. Besides the relative path is kept, we can use such useful constructs as std::filesystem::current_path in our code: 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::current_path().append(&quot;simplefile.txt&quot;); HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } If we have another look, this code actually was one of our first, naive attempts! And eventually, the test would only pass the filename with the full path! Conclusion In this article, I shared the different ways we found to make a unit test work which depends on local files. Our first solution uses the __FILE__ macro, you have to remove the filename from the path, but it will work. The second solution will work as long as you use CMake (just like the third solution), but its readability is not the best and handling changes to the resource files might be tricky. The third solution solves both the readability and issue and the problem of file changes in a test as it always copies the original files to the build folder. That copying might take a bit more time. Hopefully, you don’t rely on huge files in your unit tests… How do you solve this problem? Apart from removing the dependency on such files. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-02-21T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="How to write unit tests in C++ relying on non-code files?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-02-21T00:00:00+01:00","datePublished":"2024-02-21T00:00:00+01:00","description":"Recently we had a coding dojo with my colleagues where we were working on the second part of the Racing Car Katas, called TextConverter. To sum up the problem, the HtmlTextConverter class takes a filename, reads the file into memory and converts its content into a not-very-sophisticated HTML text. The goal is to test the class and potentially refactor it if you find any good reason for that. In my opinion, there are plenty of reasons to refactor this class. The main problem is that it does at least two things. It 1) reads a file and 2) converts its contents to HTML. It is difficult to write unit tests for this class because a unit test should be fast and ideally should not depend on things such as IO or network. In this case, we clearly depend on the file system. Still, it’s possible to provide a test that works. We can create a file and use it in the test. Without having that test, refactoring is not safe as we wouldn’t know if we broke something. A first naive approach As a first attempt, in the test directory, we created a file called simpleText.txt with a few lines in it and wrote this test. 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::string filePath { &quot;simplefile.txt&quot; }; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } We didn’t expect it to work, but we wanted some fast feedback. It failed as the content was not read in, and the file was not found. Oh, by the way, the original code of HtmlTextConverter doesn’t make any difference between an empty and a missing file… As a next step, we updated the CMake settings to compile with C++17 and tried to use std::filesystem. We had some surprises with the filesystem API, such as its lack of support for operator+ and the differences between concat and append or between operator+= and operator/=, but that’s another story. 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::current_path().append(&quot;simplefile.txt&quot;); HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } It still didn’t work, the output was empty. So we decided to print the path. What could have gone wrong? It returned something unexpected to us: 1 filePath: &quot;/Users/sandord/personal/dev/dojos/Racing-Car-Katas/Cpp/cmake-build-script/TextConverter/tests/simplefile.txt&quot; Oh la la! That’s clearly not where we created the file! cmake-build-script/ was an unexpected element of the path! Okay, so the unit test was looking for the file in the build folder, not where the file we wanted to compile originally resided… We found three different approaches to resolve this problem. Use __FILE__ to get the original path If you want the original path of the file, you can use the __FILE__ preprocessor macro. You don’t get the directory path, but the file path. This means that you have to get rid of the file name. Luckily, it’s easy to do with std::filesystem::path::remove_filename. 1 2 3 4 5 6 7 8 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path dirPath = std::filesystem::path(__FILE__).remove_filename(); std::filesystem::path filePath = dirPath /= &quot;simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } It has another downside as well, but we’ll unravel that one later. Create a global variable from CMake So we need the path of the original file. We know the value exactly in CMake. Also in CMake, we can create global constants. To be more precise, with target_compile_definitions, we can populate the COMPILE_DEFINITIONS property with a semicolon-separated list of preprocessor definitions using the syntax VAR or VAR=value. Here is a way to solve our problem. We added this to our CMakeLists.txt file: 1 2 3 4 5 target_compile_definitions( HtmlTextConverter_Test_Gmock PUBLIC RESOURCE_DIR=&quot;${CMAKE_CURRENT_SOURCE_DIR}&quot; ) Then we can use in the tests: 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::path(RESOURCE_DIR) += &quot;/simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } There are a couple of problems. First, if you see this test, you have absolutely no idea where RESOURCE_DIR comes from. We can help a little bit on that problem, by introducing a helper variable somewhere at the beginning of the file. Another potential problem is that it’s a good old char array. But with the helper variable, you solve that problem as well. 1 2 3 4 5 6 7 8 9 std::filesystem::path RESOURCES_PATH {RESOURCE_DIR}; TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = RESOURCES_PATH /= &quot;simplefile.txt&quot;; HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } A third problem which I already hinted about is that what if your tests change the file? You either have to undo the changes. Sure, but how? And how much work is that? rely on git to restore the file. Can we assume that the code is used alongside git? Maybe yes, maybe no, nevertheless it’s something to consider. Let’s say you can rely on Git. How much time is that going to take? or the best would be still to copy the file along with code files and just discard them along with the build folder. Of course, if the test files are big, this is problematic. But unit tests shouldn’t depend on huge test files. Well, they shouldn’t depend on text files anyhow, right…? Copy the resources to the build file It’s not in the scope of this article to discover handling git from C++ or to undo changes on a file, but we are going to see how to copy the resources to the build folder. Copying files over to the build folder is very simple. 1 2 3 configure_file(emptyfile.txt ${CMAKE_CURRENT_BINARY_DIR}/emptyfile.txt COPYONLY) configure_file(escapedfile.txt ${CMAKE_CURRENT_BINARY_DIR}/escapedfile.txt COPYONLY) configure_file(simplefile.txt ${CMAKE_CURRENT_BINARY_DIR}/simplefile.txt COPYONLY) With configure_file, we copy our resources from the current folder (assuming that they are in the same folder as the CMakeLists.txt file) to the CMAKE_CURRENT_BINARY_DIR. In this case, we simply copy them, but you have several options. This step is enough to run the tests successfully. To have a clean solution, we need two more commands. With add_custom_target, we create a target to represent the copying operation. Then with add_dependencies, we establish the dependency relationship between this custom target and other targets in the build process. This separation of concerns allows for better organization and management of the build process in CMake. It’s worth noting that this doesn’t make the text files part of the binary. If you have a binary to distribute that depends on text files, those files still have to be distributed along with the binary. 1 2 3 4 5 add_custom_target(CopyTextFile ALL DEPENDS ${CMAKE_CURRENT_BINARY_DIR}/emptyfile.txt ${CMAKE_CURRENT_BINARY_DIR}/escapedfile.txt ${CMAKE_CURRENT_BINARY_DIR}/simplefile.txt) add_dependencies(HtmlTextConverter_Test_Gmock CopyTextFile) That’s it. In this third solution, we copy over the files each time to the build folder, so any changes done by the tests are discarded. Besides the relative path is kept, we can use such useful constructs as std::filesystem::current_path in our code: 1 2 3 4 5 6 7 TEST(HTMLTextConverter, CorrectHtmlIsGeneratedWithSimpleNonEscapedInput) { const std::string expectedOutput = R&quot;(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)&quot;; std::filesystem::path filePath = std::filesystem::current_path().append(&quot;simplefile.txt&quot;); HtmlTextConverter converter { filePath }; ASSERT_EQ(expectedOutput, converter.convertToHtml()); } If we have another look, this code actually was one of our first, naive attempts! And eventually, the test would only pass the filename with the full path! Conclusion In this article, I shared the different ways we found to make a unit test work which depends on local files. Our first solution uses the __FILE__ macro, you have to remove the filename from the path, but it will work. The second solution will work as long as you use CMake (just like the third solution), but its readability is not the best and handling changes to the resource files might be tricky. The third solution solves both the readability and issue and the problem of file changes in a test as it always copies the original files to the build folder. That copying might take a bit more time. Hopefully, you don’t rely on huge files in your unit tests… How do you solve this problem? Apart from removing the dependency on such files. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"How to write unit tests in C++ relying on non-code files?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources"},"url":"https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources"}</script><title>How to write unit tests in C++ relying on non-code files? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/21"> 21 </a> </span> <span>How to write unit tests in C++ relying on non-code files?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>How to write unit tests in C++ relying on non-code files?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 21, 2024, 12:00 AM +0100" prep="on" > Feb 21, 2024 <i class="unloaded">2024-02-21T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1369 words">7 min</span></div></div><div class="post-content"><p>Recently we had a coding dojo with my colleagues where we were working on the second part of the <a href="https://github.com/emilybache/Racing-Car-Katas">Racing Car Katas</a>, called <em>TextConverter</em>. To sum up the problem, the <code class="language-plaintext highlighter-rouge">HtmlTextConverter</code> class takes a filename, reads the file into memory and converts its content into a not-very-sophisticated HTML text.</p><p>The goal is to test the class and potentially refactor it if you find any good reason for that. In my opinion, there are plenty of reasons to refactor this class. The main problem is that it does at least two things. It 1) reads a file and 2) converts its contents to HTML. It is difficult to write unit tests for this class because a unit test should be fast and ideally should not depend on things such as IO or network.</p><p>In this case, we clearly depend on the file system. Still, it’s possible to provide a test that works. We can create a file and use it in the test. Without having that test, refactoring is not safe as we wouldn’t know if we broke something.</p><h2 id="a-first-naive-approach">A first naive approach</h2><p>As a first attempt, in the test directory, we created a file called <code class="language-plaintext highlighter-rouge">simpleText.txt</code> with a few lines in it and wrote this test.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">TEST</span><span class="p">(</span><span class="n">HTMLTextConverter</span><span class="p">,</span> <span class="n">CorrectHtmlIsGeneratedWithSimpleNonEscapedInput</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedOutput</span> <span class="o">=</span> <span class="s">R"(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">filePath</span> <span class="p">{</span> <span class="s">"simplefile.txt"</span> <span class="p">};</span>
  <span class="n">HtmlTextConverter</span> <span class="n">converter</span> <span class="p">{</span> <span class="n">filePath</span> <span class="p">};</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">expectedOutput</span><span class="p">,</span> <span class="n">converter</span><span class="p">.</span><span class="n">convertToHtml</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We didn’t expect it to work, but we wanted some fast feedback. It failed as the content was not read in, and the file was not found. Oh, by the way, the original code of <code class="language-plaintext highlighter-rouge">HtmlTextConverter</code> doesn’t make any difference between an empty and a missing file…</p><p>As a next step, we updated the CMake settings to compile with C++17 and tried to use <code class="language-plaintext highlighter-rouge">std::filesystem</code>. We had some surprises with the filesystem API, such as its lack of support for <code class="language-plaintext highlighter-rouge">operator+</code> and the differences between <code class="language-plaintext highlighter-rouge">concat</code> and <code class="language-plaintext highlighter-rouge">append</code> or between <code class="language-plaintext highlighter-rouge">operator+=</code> and <code class="language-plaintext highlighter-rouge">operator/=</code>, but that’s another story.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">TEST</span><span class="p">(</span><span class="n">HTMLTextConverter</span><span class="p">,</span> <span class="n">CorrectHtmlIsGeneratedWithSimpleNonEscapedInput</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedOutput</span> <span class="o">=</span> <span class="s">R"(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filePath</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">current_path</span><span class="p">().</span><span class="n">append</span><span class="p">(</span><span class="s">"simplefile.txt"</span><span class="p">);</span>
  <span class="n">HtmlTextConverter</span> <span class="n">converter</span> <span class="p">{</span> <span class="n">filePath</span> <span class="p">};</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">expectedOutput</span><span class="p">,</span> <span class="n">converter</span><span class="p">.</span><span class="n">convertToHtml</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It still didn’t work, the output was empty. So we decided to print the path. What could have gone wrong? It returned something unexpected to us:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>filePath: "/Users/sandord/personal/dev/dojos/Racing-Car-Katas/Cpp/cmake-build-script/TextConverter/tests/simplefile.txt"
</pre></table></code></div></div><p>Oh la la! That’s clearly not where we created the file! <code class="language-plaintext highlighter-rouge">cmake-build-script/</code> was an unexpected element of the path! Okay, so the unit test was looking for the file in the build folder, not where the file we wanted to compile originally resided…</p><p>We found three different approaches to resolve this problem.</p><h2 id="use-__file__-to-get-the-original-path">Use <code class="language-plaintext highlighter-rouge">__FILE__</code> to get the original path</h2><p>If you want the original path of the file, you can use the <a href="https://gcc.gnu.org/onlinedocs/cpp/Standard-Predefined-Macros.html"><code class="language-plaintext highlighter-rouge">__FILE__</code> preprocessor macro</a>. You don’t get the directory path, but the file path. This means that you have to get rid of the file name. Luckily, it’s easy to do with <code class="language-plaintext highlighter-rouge">std::filesystem::path::remove_filename</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="n">TEST</span><span class="p">(</span><span class="n">HTMLTextConverter</span><span class="p">,</span> <span class="n">CorrectHtmlIsGeneratedWithSimpleNonEscapedInput</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedOutput</span> <span class="o">=</span> <span class="s">R"(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">dirPath</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">).</span><span class="n">remove_filename</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filePath</span> <span class="o">=</span>  <span class="n">dirPath</span> <span class="o">/=</span> <span class="s">"simplefile.txt"</span><span class="p">;</span>
  <span class="n">HtmlTextConverter</span> <span class="n">converter</span> <span class="p">{</span> <span class="n">filePath</span> <span class="p">};</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">expectedOutput</span><span class="p">,</span> <span class="n">converter</span><span class="p">.</span><span class="n">convertToHtml</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It has another downside as well, but we’ll unravel that one later.</p><h2 id="create-a-global-variable-from-cmake">Create a global variable from CMake</h2><p>So we need the path of the original file. We know the value exactly in CMake. Also in CMake, we can create global constants. To be more precise, with <code class="language-plaintext highlighter-rouge">target_compile_definitions</code>, we can populate the <code class="language-plaintext highlighter-rouge">COMPILE_DEFINITIONS</code> property with a semicolon-separated list of preprocessor definitions using the syntax <code class="language-plaintext highlighter-rouge">VAR</code> or <code class="language-plaintext highlighter-rouge">VAR=value</code>.</p><p>Here is a way to solve our problem. We added this to our <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file:</p><div class="language-py highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nf">target_compile_definitions</span><span class="p">(</span>
  <span class="n">HtmlTextConverter_Test_Gmock</span>
  <span class="n">PUBLIC</span>
    <span class="n">RESOURCE_DIR</span><span class="o">=</span><span class="sh">"</span><span class="s">${CMAKE_CURRENT_SOURCE_DIR}</span><span class="sh">"</span>
<span class="p">)</span>
</pre></table></code></div></div><p>Then we can use in the tests:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">TEST</span><span class="p">(</span><span class="n">HTMLTextConverter</span><span class="p">,</span> <span class="n">CorrectHtmlIsGeneratedWithSimpleNonEscapedInput</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedOutput</span> <span class="o">=</span> <span class="s">R"(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filePath</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="n">RESOURCE_DIR</span><span class="p">)</span> <span class="o">+=</span> <span class="s">"/simplefile.txt"</span><span class="p">;</span>
  <span class="n">HtmlTextConverter</span> <span class="n">converter</span> <span class="p">{</span> <span class="n">filePath</span> <span class="p">};</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">expectedOutput</span><span class="p">,</span> <span class="n">converter</span><span class="p">.</span><span class="n">convertToHtml</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>There are a couple of problems.</p><p>First, if you see this test, you have absolutely no idea where <code class="language-plaintext highlighter-rouge">RESOURCE_DIR</code> comes from. We can help a little bit on that problem, by introducing a helper variable somewhere at the beginning of the file. Another potential problem is that it’s a good old char array. But with the helper variable, you solve that problem as well.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">RESOURCES_PATH</span> <span class="p">{</span><span class="n">RESOURCE_DIR</span><span class="p">};</span>

<span class="n">TEST</span><span class="p">(</span><span class="n">HTMLTextConverter</span><span class="p">,</span> <span class="n">CorrectHtmlIsGeneratedWithSimpleNonEscapedInput</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedOutput</span> <span class="o">=</span> <span class="s">R"(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filePath</span> <span class="o">=</span> <span class="n">RESOURCES_PATH</span> <span class="o">/=</span> <span class="s">"simplefile.txt"</span><span class="p">;</span>
  <span class="n">HtmlTextConverter</span> <span class="n">converter</span> <span class="p">{</span> <span class="n">filePath</span> <span class="p">};</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">expectedOutput</span><span class="p">,</span> <span class="n">converter</span><span class="p">.</span><span class="n">convertToHtml</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>A third problem which I already hinted about is that what if your tests change the file?</p><p>You either have to</p><ul><li>undo the changes. Sure, but how? And how much work is that?<li>rely on git to restore the file. Can we assume that the code is used alongside git? Maybe yes, maybe no, nevertheless it’s something to consider. Let’s say you can rely on Git. How much time is that going to take?<li>or the best would be still to copy the file along with code files and just discard them along with the build folder. Of course, if the test files are big, this is problematic. But unit tests shouldn’t depend on huge test files. Well, they shouldn’t depend on text files anyhow, right…?</ul><h2 id="copy-the-resources-to-the-build-file">Copy the resources to the build file</h2><p>It’s not in the scope of this article to discover handling <code class="language-plaintext highlighter-rouge">git</code> from C++ or to undo changes on a file, but we are going to see how to copy the resources to the build folder.</p><p>Copying files over to the build folder is very simple.</p><div class="language-py highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="nf">configure_file</span><span class="p">(</span><span class="n">emptyfile</span><span class="p">.</span><span class="n">txt</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">emptyfile</span><span class="p">.</span><span class="n">txt</span> <span class="n">COPYONLY</span><span class="p">)</span>
<span class="nf">configure_file</span><span class="p">(</span><span class="n">escapedfile</span><span class="p">.</span><span class="n">txt</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">escapedfile</span><span class="p">.</span><span class="n">txt</span> <span class="n">COPYONLY</span><span class="p">)</span>
<span class="nf">configure_file</span><span class="p">(</span><span class="n">simplefile</span><span class="p">.</span><span class="n">txt</span> <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">simplefile</span><span class="p">.</span><span class="n">txt</span> <span class="n">COPYONLY</span><span class="p">)</span>
</pre></table></code></div></div><p>With <code class="language-plaintext highlighter-rouge">configure_file</code>, we copy our resources from the current folder (assuming that they are in the same folder as the <code class="language-plaintext highlighter-rouge">CMakeLists.txt</code> file) to the <code class="language-plaintext highlighter-rouge">CMAKE_CURRENT_BINARY_DIR</code>. In this case, we simply copy them, but <a href="https://cmake.org/cmake/help/latest/command/configure_file.html">you have several options</a>. This step is enough to run the tests successfully.</p><p>To have a clean solution, we need two more commands. With <code class="language-plaintext highlighter-rouge">add_custom_target</code>, we create a target to represent the copying operation. Then with <code class="language-plaintext highlighter-rouge">add_dependencies</code>, we establish the dependency relationship between this custom target and other targets in the build process. This separation of concerns allows for better organization and management of the build process in CMake.</p><blockquote><p><em>It’s worth noting that this doesn’t make the text files part of the binary. If you have a binary to distribute that depends on text files, those files still have to be distributed along with the binary.</em></p></blockquote><div class="language-py highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="nf">add_custom_target</span><span class="p">(</span><span class="n">CopyTextFile</span> <span class="n">ALL</span> <span class="n">DEPENDS</span> 
                    <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">emptyfile</span><span class="p">.</span><span class="n">txt</span>
                    <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">escapedfile</span><span class="p">.</span><span class="n">txt</span>
                    <span class="err">$</span><span class="p">{</span><span class="n">CMAKE_CURRENT_BINARY_DIR</span><span class="p">}</span><span class="o">/</span><span class="n">simplefile</span><span class="p">.</span><span class="n">txt</span><span class="p">)</span>    
<span class="nf">add_dependencies</span><span class="p">(</span><span class="n">HtmlTextConverter_Test_Gmock</span> <span class="n">CopyTextFile</span><span class="p">)</span>
</pre></table></code></div></div><p>That’s it. In this third solution, we copy over the files each time to the build folder, so any changes done by the tests are discarded. Besides the relative path is kept, we can use such useful constructs as <code class="language-plaintext highlighter-rouge">std::filesystem::current_path</code> in our code:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="n">TEST</span><span class="p">(</span><span class="n">HTMLTextConverter</span><span class="p">,</span> <span class="n">CorrectHtmlIsGeneratedWithSimpleNonEscapedInput</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">expectedOutput</span> <span class="o">=</span> <span class="s">R"(line1&lt;br /&gt;line2&lt;br /&gt;line3&lt;br /&gt;)"</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filePath</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">current_path</span><span class="p">().</span><span class="n">append</span><span class="p">(</span><span class="s">"simplefile.txt"</span><span class="p">);</span>
  <span class="n">HtmlTextConverter</span> <span class="n">converter</span> <span class="p">{</span> <span class="n">filePath</span> <span class="p">};</span>
  <span class="n">ASSERT_EQ</span><span class="p">(</span><span class="n">expectedOutput</span><span class="p">,</span> <span class="n">converter</span><span class="p">.</span><span class="n">convertToHtml</span><span class="p">());</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If we have another look, this code actually was one of our first, naive attempts! And eventually, the test would only pass the filename with the full path!</p><h2 id="conclusion">Conclusion</h2><p>In this article, I shared the different ways we found to make a unit test work which depends on local files. Our first solution uses the <code class="language-plaintext highlighter-rouge">__FILE__</code> macro, you have to remove the filename from the path, but it will work. The second solution will work as long as you use CMake (just like the third solution), but its readability is not the best and handling changes to the resource files might be tricky.</p><p>The third solution solves both the readability and issue and the problem of file changes in a test as it always copies the original files to the build folder. That copying might take a bit more time. Hopefully, you don’t rely on huge files in your unit tests…</p><p>How do you solve this problem? Apart from removing the dependency on such files.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/buildsystems/" class="post-tag no-text-decoration" >buildsystems</a> <a href="/tags/testing/" class="post-tag no-text-decoration" >testing</a> <a href="/tags/filesystem/" class="post-tag no-text-decoration" >filesystem</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=How to write unit tests in C++ relying on non-code files? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=How to write unit tests in C++ relying on non-code files? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=How to write unit tests in C++ relying on non-code files? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=How to write unit tests in C++ relying on non-code files? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/01/03/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Jan 3, 2024 <i class="unloaded">2024-01-03T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/02/28/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Feb 28, 2024 <i class="unloaded">2024-02-28T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/03/06/std-filesystem-part2-iterate-over-directories"><div class="card-body"> <span class="timeago small" > Mar 6, 2024 <i class="unloaded">2024-03-06T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My late discovery of std::filesystem - Part II</h3><div class="text-muted small"><p> Last week, we started to discuss the main parts of std::filesystem and we discovered how to work with paths, how to navigate up through the directory structure and how to move files and directories...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/02/17/the-software-engineers-guidebook-by-orosz-gergely" class="btn btn-outline-primary" prompt="Older"><p>The Software Engineer's Guidebook by Orosz Gergely</p></a> <a href="/blog/2024/02/28/std-filesystem-part1-paths-and-operations" class="btn btn-outline-primary" prompt="Newer"><p>My late discovery of std::filesystem - Part I</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'How to write unit tests in C++ relying on non-code files?'; this.page.url = 'https://www.sandordargo.com/blog/2024/02/21/cpp-tests-with-resources'; this.page.identifier = '/blog/2024/02/21/cpp-tests-with-resources'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
