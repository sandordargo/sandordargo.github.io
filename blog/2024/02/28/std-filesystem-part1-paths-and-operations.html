<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="My late discovery of std::filesystem - Part I" /><meta property="og:locale" content="en_US" /><meta name="description" content="I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, I deliberately spent a bit more time exploring it and I want to share what I found. I don’t want to go over the C++ Reference documentation and I also don’t want to simply repeat what Bartek already shared here. I rarely use C++ to manipulate the filesystem. That usually comes up with Python. So I decided to go through my Python use cases and see how that would in C++ with the std::filesystem library. Which was introduced in C++17, but its roots are back in the boost::filesystem library. Get the current filename By current file, I don’t mean the executable file, but the source code file. This is not something that we are going to achieve with std::filesystem. You either need to use the standard __FILE__ macro, or you need to use std::source_location::current()::file_name. Let’s see a little example: 1 2 std::cout &lt;&lt; __FILE__ &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::source_location::current().file_name() &lt;&lt; &#39;\n&#39;; // requires C++20 Even though we don’t do this with std::filesystem, I wanted to include it, because requiring the current filename is often needed for the following use cases. Get the directory of a file Now that we have the absolute path of the current file, let’s see how to get the directory of it. Nothing is simpler than that! Get the absolute path First of all, if we need the current directory, we can use std::filesystem::current_path(). But if that’s not the case and we already have an absolute path of a file anywhere even just as a string, we can use remove_filename(). 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::cout &lt;&lt; std::filesystem::current_path() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; __FILE__ &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::filesystem::path(__FILE__).remove_filename() &lt;&lt; &#39;\n&#39;; } /* &quot;/app&quot; /app/example.cpp &quot;/app/&quot; */ Get the relative path You might say that you are not interested in the absolute path, but rather in the relative. Let’s assume that we have a file called /Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp. Your first idea might be to try std::filesystem::path::relative_path() but then you realize that it doesn’t take any parameters! What does relative mean then? Well, it only removes the prefix that signals the root, e.g. / or C:\… 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path p(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); std::cout &lt;&lt; p &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; p.relative_path() &lt;&lt; &#39;\n&#39;; } /* &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; &quot;Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; */ If you want to get the relative path compared to another path, then instead of the above member function we have to use a free function called std::filesystem::relative. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path filePath(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); std::filesystem::path repoRoot(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/&quot;); std::cout &lt;&lt; std::filesystem::relative(filePath, repoRoot) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::filesystem::relative(repoRoot, filePath) &lt;&lt; &#39;\n&#39;; } /* &quot;Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; &quot;../../../../&quot; */ As we can see, the only question is which path goes first. The correct way to read this is “give me the relative path of the left-hand path compared to the right-hand path”. In my opinion, a nice API could have used a member function, such as std::filesystem::path::relative_to(otherPath). But there must have been other considerations that I’m not aware of. Step up a directory If you have a path at your hands and you want the path of the parent directory, you don’t have a difficult task, just use the parent_path() member function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path p(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); while (p != p.root_directory()) { std::cout &lt;&lt; p.parent_path() &lt;&lt; &#39;\n&#39;; p = p.parent_path(); } } /* &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas&quot; &quot;/Users/sandor/personal/dev/dojos&quot; &quot;/Users/sandor/personal/dev&quot; &quot;/Users/sandor/personal&quot; &quot;/Users/sandor&quot; &quot;/Users&quot; &quot;/&quot; */ Check if a file is a file or directory Let’s check now if a file or directory exists. To do so, we leave behind the RacingKar katas and we are going to use the standard library to create some files and directories. With std::filesystem::create_directory, it’s easy to create a new folder. With std::ofstream we can create a file(stream) and with std::ofstream::put we can add a character to it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::string newDirName {&quot;temp&quot;}; std::cout &lt;&lt; newDirName &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newDirName) &lt;&lt; &#39;\n&#39;; std::filesystem::create_directory(&quot;temp&quot;); std::cout &lt;&lt; newDirName &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newDirName) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newDirName &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(newDirName) &lt;&lt; &#39;\n&#39;; std::filesystem::path newFilePath{&quot;temp/file1.txt&quot;}; // create a file std::ofstream(newFilePath).put(&#39;a&#39;); std::cout &lt;&lt; newFilePath &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is block file? &quot; &lt;&lt; std::filesystem::is_block_file(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is charachter file? &quot; &lt;&lt; std::filesystem::is_character_file(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is regular file? &quot; &lt;&lt; std::filesystem::is_regular_file(newFilePath) &lt;&lt; &#39;\n&#39;; } /* temp exists? false temp exists? true temp is directory? true &quot;temp/file1.txt&quot; exists? true &quot;temp/file1.txt&quot; is directory? false &quot;temp/file1.txt&quot; is block file? false &quot;temp/file1.txt&quot; is charachter file? false &quot;temp/file1.txt&quot; is regular file? true */ As you can see, by calling std::filesystem::exists(path), it’s easy to check whether a file or directory exists and there are different additional query functions available to check if a file object is a directory, a block, character or regular file. These file types are defined in the POSIX standard. Copy or rename a file In the next example, after creating some files and directories, we are going to first copy a directory, then some files and then we will rename a file. To facilitate our example, we’ll also use std::filesystem::remove to remove directories and files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::string newDirName {&quot;temp&quot;}; std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::path newFilePath{&quot;temp/file1.txt&quot;}; std::filesystem::path anotherNewFilePath{&quot;temp/file2.txt&quot;}; // create a file std::ofstream(newFilePath).put(&#39;a&#39;); std::ofstream(anotherNewFilePath).put(&#39;b&#39;); std::cout &lt;&lt; &quot;========= copy a dir ===========\n&quot;; std::filesystem::path anotherDir {&quot;anotherTemp&quot;}; std::cout &lt;&lt; &quot;anotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(anotherDir) &lt;&lt; &#39;\n&#39;; std::filesystem::copy(newDirName, anotherDir); std::cout &lt;&lt; &quot;anotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;anotherTemp/file1.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;anotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;anotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;========= copy a file to...? ===========\n&quot;; std::filesystem::path yetAnotherDir {&quot;yetAnotherTemp&quot;}; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::filesystem::copy(newFilePath, yetAnotherDir); std::cout &lt;&lt; &quot;yetAnotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file1.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; is regualr file? &quot; &lt;&lt; std::filesystem::is_regular_file(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;========= copy files ===========\n&quot;; std::filesystem::remove(yetAnotherDir); std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\n&#39;; // std::filesystem::copy(newFilePath, &quot;yetAnotherTemp/file1.txt&quot;); // ERROR, target directory does not exist std::filesystem::create_directory(yetAnotherDir); std::filesystem::copy(newFilePath, &quot;yetAnotherTemp/file1.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file1.txt&quot;) &lt;&lt; &#39;\n&#39;; std::filesystem::copy_file(anotherNewFilePath, &quot;yetAnotherTemp/file2.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;========== rename ==========\n&quot;; std::filesystem::rename(&quot;yetAnotherTemp/file2.txt&quot;, &quot;yetAnotherTemp/file2R.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp/file2R.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2R.txt&quot;) &lt;&lt; &#39;\n&#39;; } /* ========= copy a dir =========== anotherTemp exists? false anotherTemp/file1.txt exists? true anotherTemp/file2.txt exists? true ========= copy a file to...? =========== yetAnotherTemp exists? false yetAnotherTemp/file1.txt exists? false yetAnotherTemp/file2.txt exists? false yetAnotherTemp exists? true yetAnotherTemp is directory? false yetAnotherTemp is regualr file? true ========= copy files =========== yetAnotherTemp exists? false yetAnotherTemp/file1.txt exists? true yetAnotherTemp/file2.txt exists? true ========== rename ========== yetAnotherTemp/file2.txt exists? false yetAnotherTemp/file2R.txt exists? true */ In the “copy a file to…?” part, we can observe that when we want to copy a file, the destination is not the destination directory, but the destination path. If you don’t pay attention, you might copy a file to a place which was meant to be a directory. But it can only happen if you haven’t created the destination directory yet. It’s important to note, that you cannot use std::filesystem::copy to copy to a non-existing directory. You have to make sure that it exists. Even though as a third, optional parameter, it takes std::filesystem::copy_options, seemingly there is no option to create automatically the needed directory. While std::filesystem::copy can be used to copy both files and directories, there is also std::filesystem::copy_file which can only copy a single file. Its name is more expressive, but that’s not the only difference. While copy is a void function, copy_file returns a boolean to show if a copy was successful (true) or not (false). Conclusion Today, I shared with you a part of what I learned about the std::filesystem library. I must tell you that I found it pretty usable, despite the fact that sometimes I could have imagined a more intuitive API. We had a look into how to navigate up on a path, how to remove a filename from it and also we also checked how to copy, rename or delete files. Next week, we are going to discuss how to iterate over a directory structure, a quite common operation when you have to apply some changes to a whole repository. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, I deliberately spent a bit more time exploring it and I want to share what I found. I don’t want to go over the C++ Reference documentation and I also don’t want to simply repeat what Bartek already shared here. I rarely use C++ to manipulate the filesystem. That usually comes up with Python. So I decided to go through my Python use cases and see how that would in C++ with the std::filesystem library. Which was introduced in C++17, but its roots are back in the boost::filesystem library. Get the current filename By current file, I don’t mean the executable file, but the source code file. This is not something that we are going to achieve with std::filesystem. You either need to use the standard __FILE__ macro, or you need to use std::source_location::current()::file_name. Let’s see a little example: 1 2 std::cout &lt;&lt; __FILE__ &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::source_location::current().file_name() &lt;&lt; &#39;\n&#39;; // requires C++20 Even though we don’t do this with std::filesystem, I wanted to include it, because requiring the current filename is often needed for the following use cases. Get the directory of a file Now that we have the absolute path of the current file, let’s see how to get the directory of it. Nothing is simpler than that! Get the absolute path First of all, if we need the current directory, we can use std::filesystem::current_path(). But if that’s not the case and we already have an absolute path of a file anywhere even just as a string, we can use remove_filename(). 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::cout &lt;&lt; std::filesystem::current_path() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; __FILE__ &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::filesystem::path(__FILE__).remove_filename() &lt;&lt; &#39;\n&#39;; } /* &quot;/app&quot; /app/example.cpp &quot;/app/&quot; */ Get the relative path You might say that you are not interested in the absolute path, but rather in the relative. Let’s assume that we have a file called /Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp. Your first idea might be to try std::filesystem::path::relative_path() but then you realize that it doesn’t take any parameters! What does relative mean then? Well, it only removes the prefix that signals the root, e.g. / or C:\… 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path p(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); std::cout &lt;&lt; p &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; p.relative_path() &lt;&lt; &#39;\n&#39;; } /* &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; &quot;Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; */ If you want to get the relative path compared to another path, then instead of the above member function we have to use a free function called std::filesystem::relative. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path filePath(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); std::filesystem::path repoRoot(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/&quot;); std::cout &lt;&lt; std::filesystem::relative(filePath, repoRoot) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::filesystem::relative(repoRoot, filePath) &lt;&lt; &#39;\n&#39;; } /* &quot;Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; &quot;../../../../&quot; */ As we can see, the only question is which path goes first. The correct way to read this is “give me the relative path of the left-hand path compared to the right-hand path”. In my opinion, a nice API could have used a member function, such as std::filesystem::path::relative_to(otherPath). But there must have been other considerations that I’m not aware of. Step up a directory If you have a path at your hands and you want the path of the parent directory, you don’t have a difficult task, just use the parent_path() member function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path p(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); while (p != p.root_directory()) { std::cout &lt;&lt; p.parent_path() &lt;&lt; &#39;\n&#39;; p = p.parent_path(); } } /* &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas&quot; &quot;/Users/sandor/personal/dev/dojos&quot; &quot;/Users/sandor/personal/dev&quot; &quot;/Users/sandor/personal&quot; &quot;/Users/sandor&quot; &quot;/Users&quot; &quot;/&quot; */ Check if a file is a file or directory Let’s check now if a file or directory exists. To do so, we leave behind the RacingKar katas and we are going to use the standard library to create some files and directories. With std::filesystem::create_directory, it’s easy to create a new folder. With std::ofstream we can create a file(stream) and with std::ofstream::put we can add a character to it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::string newDirName {&quot;temp&quot;}; std::cout &lt;&lt; newDirName &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newDirName) &lt;&lt; &#39;\n&#39;; std::filesystem::create_directory(&quot;temp&quot;); std::cout &lt;&lt; newDirName &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newDirName) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newDirName &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(newDirName) &lt;&lt; &#39;\n&#39;; std::filesystem::path newFilePath{&quot;temp/file1.txt&quot;}; // create a file std::ofstream(newFilePath).put(&#39;a&#39;); std::cout &lt;&lt; newFilePath &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is block file? &quot; &lt;&lt; std::filesystem::is_block_file(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is charachter file? &quot; &lt;&lt; std::filesystem::is_character_file(newFilePath) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is regular file? &quot; &lt;&lt; std::filesystem::is_regular_file(newFilePath) &lt;&lt; &#39;\n&#39;; } /* temp exists? false temp exists? true temp is directory? true &quot;temp/file1.txt&quot; exists? true &quot;temp/file1.txt&quot; is directory? false &quot;temp/file1.txt&quot; is block file? false &quot;temp/file1.txt&quot; is charachter file? false &quot;temp/file1.txt&quot; is regular file? true */ As you can see, by calling std::filesystem::exists(path), it’s easy to check whether a file or directory exists and there are different additional query functions available to check if a file object is a directory, a block, character or regular file. These file types are defined in the POSIX standard. Copy or rename a file In the next example, after creating some files and directories, we are going to first copy a directory, then some files and then we will rename a file. To facilitate our example, we’ll also use std::filesystem::remove to remove directories and files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::string newDirName {&quot;temp&quot;}; std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::path newFilePath{&quot;temp/file1.txt&quot;}; std::filesystem::path anotherNewFilePath{&quot;temp/file2.txt&quot;}; // create a file std::ofstream(newFilePath).put(&#39;a&#39;); std::ofstream(anotherNewFilePath).put(&#39;b&#39;); std::cout &lt;&lt; &quot;========= copy a dir ===========\n&quot;; std::filesystem::path anotherDir {&quot;anotherTemp&quot;}; std::cout &lt;&lt; &quot;anotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(anotherDir) &lt;&lt; &#39;\n&#39;; std::filesystem::copy(newDirName, anotherDir); std::cout &lt;&lt; &quot;anotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;anotherTemp/file1.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;anotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;anotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;========= copy a file to...? ===========\n&quot;; std::filesystem::path yetAnotherDir {&quot;yetAnotherTemp&quot;}; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::filesystem::copy(newFilePath, yetAnotherDir); std::cout &lt;&lt; &quot;yetAnotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file1.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; is regualr file? &quot; &lt;&lt; std::filesystem::is_regular_file(yetAnotherDir) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;========= copy files ===========\n&quot;; std::filesystem::remove(yetAnotherDir); std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\n&#39;; // std::filesystem::copy(newFilePath, &quot;yetAnotherTemp/file1.txt&quot;); // ERROR, target directory does not exist std::filesystem::create_directory(yetAnotherDir); std::filesystem::copy(newFilePath, &quot;yetAnotherTemp/file1.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file1.txt&quot;) &lt;&lt; &#39;\n&#39;; std::filesystem::copy_file(anotherNewFilePath, &quot;yetAnotherTemp/file2.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;========== rename ==========\n&quot;; std::filesystem::rename(&quot;yetAnotherTemp/file2.txt&quot;, &quot;yetAnotherTemp/file2R.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp/file2R.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2R.txt&quot;) &lt;&lt; &#39;\n&#39;; } /* ========= copy a dir =========== anotherTemp exists? false anotherTemp/file1.txt exists? true anotherTemp/file2.txt exists? true ========= copy a file to...? =========== yetAnotherTemp exists? false yetAnotherTemp/file1.txt exists? false yetAnotherTemp/file2.txt exists? false yetAnotherTemp exists? true yetAnotherTemp is directory? false yetAnotherTemp is regualr file? true ========= copy files =========== yetAnotherTemp exists? false yetAnotherTemp/file1.txt exists? true yetAnotherTemp/file2.txt exists? true ========== rename ========== yetAnotherTemp/file2.txt exists? false yetAnotherTemp/file2R.txt exists? true */ In the “copy a file to…?” part, we can observe that when we want to copy a file, the destination is not the destination directory, but the destination path. If you don’t pay attention, you might copy a file to a place which was meant to be a directory. But it can only happen if you haven’t created the destination directory yet. It’s important to note, that you cannot use std::filesystem::copy to copy to a non-existing directory. You have to make sure that it exists. Even though as a third, optional parameter, it takes std::filesystem::copy_options, seemingly there is no option to create automatically the needed directory. While std::filesystem::copy can be used to copy both files and directories, there is also std::filesystem::copy_file which can only copy a single file. Its name is more expressive, but that’s not the only difference. While copy is a void function, copy_file returns a boolean to show if a copy was successful (true) or not (false). Conclusion Today, I shared with you a part of what I learned about the std::filesystem library. I must tell you that I found it pretty usable, despite the fact that sometimes I could have imagined a more intuitive API. We had a look into how to navigate up on a path, how to remove a filename from it and also we also checked how to copy, rename or delete files. Next week, we are going to discuss how to iterate over a directory structure, a quite common operation when you have to apply some changes to a whole repository. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-02-28T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="My late discovery of std::filesystem - Part I" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-02-28T00:00:00+01:00","datePublished":"2024-02-28T00:00:00+01:00","description":"I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, I deliberately spent a bit more time exploring it and I want to share what I found. I don’t want to go over the C++ Reference documentation and I also don’t want to simply repeat what Bartek already shared here. I rarely use C++ to manipulate the filesystem. That usually comes up with Python. So I decided to go through my Python use cases and see how that would in C++ with the std::filesystem library. Which was introduced in C++17, but its roots are back in the boost::filesystem library. Get the current filename By current file, I don’t mean the executable file, but the source code file. This is not something that we are going to achieve with std::filesystem. You either need to use the standard __FILE__ macro, or you need to use std::source_location::current()::file_name. Let’s see a little example: 1 2 std::cout &lt;&lt; __FILE__ &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::source_location::current().file_name() &lt;&lt; &#39;\\n&#39;; // requires C++20 Even though we don’t do this with std::filesystem, I wanted to include it, because requiring the current filename is often needed for the following use cases. Get the directory of a file Now that we have the absolute path of the current file, let’s see how to get the directory of it. Nothing is simpler than that! Get the absolute path First of all, if we need the current directory, we can use std::filesystem::current_path(). But if that’s not the case and we already have an absolute path of a file anywhere even just as a string, we can use remove_filename(). 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::cout &lt;&lt; std::filesystem::current_path() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; __FILE__ &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::filesystem::path(__FILE__).remove_filename() &lt;&lt; &#39;\\n&#39;; } /* &quot;/app&quot; /app/example.cpp &quot;/app/&quot; */ Get the relative path You might say that you are not interested in the absolute path, but rather in the relative. Let’s assume that we have a file called /Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp. Your first idea might be to try std::filesystem::path::relative_path() but then you realize that it doesn’t take any parameters! What does relative mean then? Well, it only removes the prefix that signals the root, e.g. / or C:\\… 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path p(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); std::cout &lt;&lt; p &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; p.relative_path() &lt;&lt; &#39;\\n&#39;; } /* &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; &quot;Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; */ If you want to get the relative path compared to another path, then instead of the above member function we have to use a free function called std::filesystem::relative. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path filePath(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); std::filesystem::path repoRoot(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/&quot;); std::cout &lt;&lt; std::filesystem::relative(filePath, repoRoot) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::filesystem::relative(repoRoot, filePath) &lt;&lt; &#39;\\n&#39;; } /* &quot;Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot; &quot;../../../../&quot; */ As we can see, the only question is which path goes first. The correct way to read this is “give me the relative path of the left-hand path compared to the right-hand path”. In my opinion, a nice API could have used a member function, such as std::filesystem::path::relative_to(otherPath). But there must have been other considerations that I’m not aware of. Step up a directory If you have a path at your hands and you want the path of the parent directory, you don’t have a difficult task, just use the parent_path() member function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::path p(&quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp&quot;); while (p != p.root_directory()) { std::cout &lt;&lt; p.parent_path() &lt;&lt; &#39;\\n&#39;; p = p.parent_path(); } } /* &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp&quot; &quot;/Users/sandor/personal/dev/dojos/Racing-Car-Katas&quot; &quot;/Users/sandor/personal/dev/dojos&quot; &quot;/Users/sandor/personal/dev&quot; &quot;/Users/sandor/personal&quot; &quot;/Users/sandor&quot; &quot;/Users&quot; &quot;/&quot; */ Check if a file is a file or directory Let’s check now if a file or directory exists. To do so, we leave behind the RacingKar katas and we are going to use the standard library to create some files and directories. With std::filesystem::create_directory, it’s easy to create a new folder. With std::ofstream we can create a file(stream) and with std::ofstream::put we can add a character to it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::string newDirName {&quot;temp&quot;}; std::cout &lt;&lt; newDirName &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newDirName) &lt;&lt; &#39;\\n&#39;; std::filesystem::create_directory(&quot;temp&quot;); std::cout &lt;&lt; newDirName &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newDirName) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; newDirName &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(newDirName) &lt;&lt; &#39;\\n&#39;; std::filesystem::path newFilePath{&quot;temp/file1.txt&quot;}; // create a file std::ofstream(newFilePath).put(&#39;a&#39;); std::cout &lt;&lt; newFilePath &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(newFilePath) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(newFilePath) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is block file? &quot; &lt;&lt; std::filesystem::is_block_file(newFilePath) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is charachter file? &quot; &lt;&lt; std::filesystem::is_character_file(newFilePath) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; newFilePath &lt;&lt; &quot; is regular file? &quot; &lt;&lt; std::filesystem::is_regular_file(newFilePath) &lt;&lt; &#39;\\n&#39;; } /* temp exists? false temp exists? true temp is directory? true &quot;temp/file1.txt&quot; exists? true &quot;temp/file1.txt&quot; is directory? false &quot;temp/file1.txt&quot; is block file? false &quot;temp/file1.txt&quot; is charachter file? false &quot;temp/file1.txt&quot; is regular file? true */ As you can see, by calling std::filesystem::exists(path), it’s easy to check whether a file or directory exists and there are different additional query functions available to check if a file object is a directory, a block, character or regular file. These file types are defined in the POSIX standard. Copy or rename a file In the next example, after creating some files and directories, we are going to first copy a directory, then some files and then we will rename a file. To facilitate our example, we’ll also use std::filesystem::remove to remove directories and files. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 #include &lt;filesystem&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;string&gt; int main() { std::cout &lt;&lt; std::boolalpha; std::string newDirName {&quot;temp&quot;}; std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::path newFilePath{&quot;temp/file1.txt&quot;}; std::filesystem::path anotherNewFilePath{&quot;temp/file2.txt&quot;}; // create a file std::ofstream(newFilePath).put(&#39;a&#39;); std::ofstream(anotherNewFilePath).put(&#39;b&#39;); std::cout &lt;&lt; &quot;========= copy a dir ===========\\n&quot;; std::filesystem::path anotherDir {&quot;anotherTemp&quot;}; std::cout &lt;&lt; &quot;anotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(anotherDir) &lt;&lt; &#39;\\n&#39;; std::filesystem::copy(newDirName, anotherDir); std::cout &lt;&lt; &quot;anotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;anotherTemp/file1.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;anotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;anotherTemp/file2.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;========= copy a file to...? ===========\\n&quot;; std::filesystem::path yetAnotherDir {&quot;yetAnotherTemp&quot;}; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\\n&#39;; std::filesystem::copy(newFilePath, yetAnotherDir); std::cout &lt;&lt; &quot;yetAnotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file1.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; is directory? &quot; &lt;&lt; std::filesystem::is_directory(yetAnotherDir) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; is regualr file? &quot; &lt;&lt; std::filesystem::is_regular_file(yetAnotherDir) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;========= copy files ===========\\n&quot;; std::filesystem::remove(yetAnotherDir); std::cout &lt;&lt; &quot;yetAnotherTemp&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(yetAnotherDir) &lt;&lt; &#39;\\n&#39;; // std::filesystem::copy(newFilePath, &quot;yetAnotherTemp/file1.txt&quot;); // ERROR, target directory does not exist std::filesystem::create_directory(yetAnotherDir); std::filesystem::copy(newFilePath, &quot;yetAnotherTemp/file1.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file1.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file1.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::filesystem::copy_file(anotherNewFilePath, &quot;yetAnotherTemp/file2.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;========== rename ==========\\n&quot;; std::filesystem::rename(&quot;yetAnotherTemp/file2.txt&quot;, &quot;yetAnotherTemp/file2R.txt&quot;); std::cout &lt;&lt; &quot;yetAnotherTemp/file2.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2.txt&quot;) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;yetAnotherTemp/file2R.txt&quot; &lt;&lt; &quot; exists? &quot; &lt;&lt; std::filesystem::exists(&quot;yetAnotherTemp/file2R.txt&quot;) &lt;&lt; &#39;\\n&#39;; } /* ========= copy a dir =========== anotherTemp exists? false anotherTemp/file1.txt exists? true anotherTemp/file2.txt exists? true ========= copy a file to...? =========== yetAnotherTemp exists? false yetAnotherTemp/file1.txt exists? false yetAnotherTemp/file2.txt exists? false yetAnotherTemp exists? true yetAnotherTemp is directory? false yetAnotherTemp is regualr file? true ========= copy files =========== yetAnotherTemp exists? false yetAnotherTemp/file1.txt exists? true yetAnotherTemp/file2.txt exists? true ========== rename ========== yetAnotherTemp/file2.txt exists? false yetAnotherTemp/file2R.txt exists? true */ In the “copy a file to…?” part, we can observe that when we want to copy a file, the destination is not the destination directory, but the destination path. If you don’t pay attention, you might copy a file to a place which was meant to be a directory. But it can only happen if you haven’t created the destination directory yet. It’s important to note, that you cannot use std::filesystem::copy to copy to a non-existing directory. You have to make sure that it exists. Even though as a third, optional parameter, it takes std::filesystem::copy_options, seemingly there is no option to create automatically the needed directory. While std::filesystem::copy can be used to copy both files and directories, there is also std::filesystem::copy_file which can only copy a single file. Its name is more expressive, but that’s not the only difference. While copy is a void function, copy_file returns a boolean to show if a copy was successful (true) or not (false). Conclusion Today, I shared with you a part of what I learned about the std::filesystem library. I must tell you that I found it pretty usable, despite the fact that sometimes I could have imagined a more intuitive API. We had a look into how to navigate up on a path, how to remove a filename from it and also we also checked how to copy, rename or delete files. Next week, we are going to discuss how to iterate over a directory structure, a quite common operation when you have to apply some changes to a whole repository. Stay tuned! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"My late discovery of std::filesystem - Part I","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations"},"url":"https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations"}</script><title>My late discovery of std::filesystem - Part I | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/28"> 28 </a> </span> <span>My late discovery of std::filesystem - Part I</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>My late discovery of std::filesystem - Part I</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 28, 2024, 12:00 AM +0100" prep="on" > Feb 28, 2024 <i class="unloaded">2024-02-28T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1674 words">9 min</span></div></div><div class="post-content"><p>I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, I deliberately spent a bit more time exploring it and I want to share what I found.</p><p>I don’t want to go over the C++ Reference documentation and I also don’t want to simply repeat what <a href="https://www.cppstories.com/2017/08/cpp17-details-filesystem/">Bartek already shared here</a>.</p><p>I rarely use C++ to manipulate the filesystem. That usually comes up with Python. So I decided to go through my Python use cases and see how that would in C++ with the std::filesystem library. Which was introduced in C++17, but its roots are back in the <a href="https://www.boost.org/doc/libs/1_84_0/libs/filesystem/doc/index.htm">boost::filesystem</a> library.</p><h2 id="get-the-current-filename">Get the current filename</h2><p>By current file, I don’t mean the executable file, but the source code file. This is not something that we are going to achieve with <code class="language-plaintext highlighter-rouge">std::filesystem</code>. You either need to use the standard <code class="language-plaintext highlighter-rouge">__FILE__</code> macro, or you need to use <code class="language-plaintext highlighter-rouge">std::source_location::current()::file_name</code>. Let’s see a little example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__FILE__</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">source_location</span><span class="o">::</span><span class="n">current</span><span class="p">().</span><span class="n">file_name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// requires C++20</span>
</pre></table></code></div></div><p>Even though we don’t do this with <code class="language-plaintext highlighter-rouge">std::filesystem</code>, I wanted to include it, because requiring the current filename is often needed for the following use cases.</p><h2 id="get-the-directory-of-a-file">Get the directory of a file</h2><p>Now that we have the absolute path of the current file, let’s see how to get the directory of it.</p><p>Nothing is simpler than that!</p><h3 id="get-the-absolute-path">Get the absolute path</h3><p>First of all, if we need the current directory, we can use <code class="language-plaintext highlighter-rouge">std::filesystem::current_path()</code>. But if that’s not the case and we already have an absolute path of a file anywhere even just as a string, we can use <code class="language-plaintext highlighter-rouge">remove_filename()</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">current_path</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">__FILE__</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="p">(</span><span class="n">__FILE__</span><span class="p">).</span><span class="n">remove_filename</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
"/app"
/app/example.cpp
"/app/"
*/</span>
</pre></table></code></div></div><h3 id="get-the-relative-path">Get the relative path</h3><p>You might say that you are not interested in the absolute path, but rather in the relative. Let’s assume that we have a file called <code class="language-plaintext highlighter-rouge">/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp</code>. Your first idea might be to try <code class="language-plaintext highlighter-rouge">std::filesystem::path::relative_path()</code> but then you realize that it doesn’t take any parameters! What does relative mean then? Well, it only removes the prefix that signals the root, e.g. <code class="language-plaintext highlighter-rouge">/</code> or <code class="language-plaintext highlighter-rouge">C:\</code>…</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">p</span><span class="p">(</span><span class="s">"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">relative_path</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp"
"Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp"
*/</span>
</pre></table></code></div></div><p>If you want to get the relative path compared to another path, then instead of the above member function we have to use a free function called <code class="language-plaintext highlighter-rouge">std::filesystem::relative</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">filePath</span><span class="p">(</span><span class="s">"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">repoRoot</span><span class="p">(</span><span class="s">"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">relative</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="n">repoRoot</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">relative</span><span class="p">(</span><span class="n">repoRoot</span><span class="p">,</span> <span class="n">filePath</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
"Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp"
"../../../../"
*/</span>
</pre></table></code></div></div><p>As we can see, the only question is which path goes first. The correct way to read this is <em>“give me the relative path of the left-hand path compared to the right-hand path”</em>.</p><p>In my opinion, a nice API could have used a member function, such as <code class="language-plaintext highlighter-rouge">std::filesystem::path::relative_to(otherPath)</code>. But there must have been other considerations that I’m not aware of.</p><h2 id="step-up-a-directory">Step up a directory</h2><p>If you have a path at your hands and you want the path of the parent directory, you don’t have a difficult task, just use the <code class="language-plaintext highlighter-rouge">parent_path()</code> member function.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">p</span><span class="p">(</span><span class="s">"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests/HtmlTextConverter_Test.cpp"</span><span class="p">);</span>
 
    <span class="k">while</span> <span class="p">(</span><span class="n">p</span> <span class="o">!=</span> <span class="n">p</span><span class="p">.</span><span class="n">root_directory</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">.</span><span class="n">parent_path</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="n">p</span> <span class="o">=</span> <span class="n">p</span><span class="p">.</span><span class="n">parent_path</span><span class="p">();</span>
    <span class="p">}</span>

<span class="p">}</span>

<span class="cm">/*
"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter/tests"
"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp/TextConverter"
"/Users/sandor/personal/dev/dojos/Racing-Car-Katas/Cpp"
"/Users/sandor/personal/dev/dojos/Racing-Car-Katas"
"/Users/sandor/personal/dev/dojos"
"/Users/sandor/personal/dev"
"/Users/sandor/personal"
"/Users/sandor"
"/Users"
"/"
*/</span>
</pre></table></code></div></div><h2 id="check-if-a-file-is-a-file-or-directory">Check if a file is a file or directory</h2><p>Let’s check now if a file or directory exists. To do so, we leave behind the RacingKar katas and we are going to use the standard library to create some files and directories. With <code class="language-plaintext highlighter-rouge">std::filesystem::create_directory</code>, it’s easy to create a new folder. With <code class="language-plaintext highlighter-rouge">std::ofstream</code> we can create a file(stream) and with <code class="language-plaintext highlighter-rouge">std::ofstream::put</code> we can add a character to it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newDirName</span> <span class="p">{</span><span class="s">"temp"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newDirName</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">newDirName</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newDirName</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">newDirName</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newDirName</span> <span class="o">&lt;&lt;</span> <span class="s">" is directory? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_directory</span><span class="p">(</span><span class="n">newDirName</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">newFilePath</span><span class="p">{</span><span class="s">"temp/file1.txt"</span><span class="p">};</span>
    <span class="c1">// create a file</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newFilePath</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newFilePath</span> <span class="o">&lt;&lt;</span> <span class="s">" is directory? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_directory</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newFilePath</span> <span class="o">&lt;&lt;</span> <span class="s">" is block file? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_block_file</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newFilePath</span> <span class="o">&lt;&lt;</span> <span class="s">" is charachter file? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_character_file</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">newFilePath</span> <span class="o">&lt;&lt;</span> <span class="s">" is regular file? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_regular_file</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
temp exists? false
temp exists? true
temp is directory? true
"temp/file1.txt" exists? true
"temp/file1.txt" is directory? false
"temp/file1.txt" is block file? false
"temp/file1.txt" is charachter file? false
"temp/file1.txt" is regular file? true
*/</span>
</pre></table></code></div></div><p>As you can see, by calling <code class="language-plaintext highlighter-rouge">std::filesystem::exists(path)</code>, it’s easy to check whether a file or directory exists and there are different additional query functions available to check if a file object is a directory, a block, character or regular file. These file types are defined in the POSIX standard.</p><h2 id="copy-or-rename-a-file">Copy or rename a file</h2><p>In the next example, after creating some files and directories, we are going to first copy a directory, then some files and then we will rename a file. To facilitate our example, we’ll also use <code class="language-plaintext highlighter-rouge">std::filesystem::remove</code> to remove directories and files.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newDirName</span> <span class="p">{</span><span class="s">"temp"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">newFilePath</span><span class="p">{</span><span class="s">"temp/file1.txt"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">anotherNewFilePath</span><span class="p">{</span><span class="s">"temp/file2.txt"</span><span class="p">};</span>
    <span class="c1">// create a file</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="n">anotherNewFilePath</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"========= copy a dir ===========</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">anotherDir</span> <span class="p">{</span><span class="s">"anotherTemp"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"anotherTemp"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">anotherDir</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">newDirName</span><span class="p">,</span> <span class="n">anotherDir</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"anotherTemp/file1.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"anotherTemp/file1.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"anotherTemp/file2.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"anotherTemp/file2.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"========= copy a file to...? ===========</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span> <span class="n">yetAnotherDir</span> <span class="p">{</span><span class="s">"yetAnotherTemp"</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">,</span> <span class="n">yetAnotherDir</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp/file1.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"yetAnotherTemp/file1.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp/file2.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"yetAnotherTemp/file2.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp"</span> <span class="o">&lt;&lt;</span> <span class="s">" is directory? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_directory</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp"</span> <span class="o">&lt;&lt;</span> <span class="s">" is regualr file? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">is_regular_file</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"========= copy files ===========</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">remove</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// std::filesystem::copy(newFilePath, "yetAnotherTemp/file1.txt"); // ERROR, target directory does not exist</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="n">yetAnotherDir</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">copy</span><span class="p">(</span><span class="n">newFilePath</span><span class="p">,</span> <span class="s">"yetAnotherTemp/file1.txt"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp/file1.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"yetAnotherTemp/file1.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">copy_file</span><span class="p">(</span><span class="n">anotherNewFilePath</span><span class="p">,</span> <span class="s">"yetAnotherTemp/file2.txt"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp/file2.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"yetAnotherTemp/file2.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"========== rename ==========</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">rename</span><span class="p">(</span><span class="s">"yetAnotherTemp/file2.txt"</span><span class="p">,</span> <span class="s">"yetAnotherTemp/file2R.txt"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp/file2.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"yetAnotherTemp/file2.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"yetAnotherTemp/file2R.txt"</span> <span class="o">&lt;&lt;</span> <span class="s">" exists? "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">exists</span><span class="p">(</span><span class="s">"yetAnotherTemp/file2R.txt"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
========= copy a dir ===========
anotherTemp exists? false
anotherTemp/file1.txt exists? true
anotherTemp/file2.txt exists? true
========= copy a file to...? ===========
yetAnotherTemp exists? false
yetAnotherTemp/file1.txt exists? false
yetAnotherTemp/file2.txt exists? false
yetAnotherTemp exists? true
yetAnotherTemp is directory? false
yetAnotherTemp is regualr file? true
========= copy files ===========
yetAnotherTemp exists? false
yetAnotherTemp/file1.txt exists? true
yetAnotherTemp/file2.txt exists? true
========== rename ==========
yetAnotherTemp/file2.txt exists? false
yetAnotherTemp/file2R.txt exists? true
*/</span>
</pre></table></code></div></div><p>In the “copy a file to…?” part, we can observe that when we want to copy a file, the destination is not the destination directory, but the destination path. If you don’t pay attention, you might copy a file to a place which was meant to be a directory.</p><p>But it can only happen if you haven’t created the destination directory yet. It’s important to note, that you cannot use <code class="language-plaintext highlighter-rouge">std::filesystem::copy</code> to copy to a non-existing directory. You have to make sure that it exists. Even though as a third, optional parameter, it takes <code class="language-plaintext highlighter-rouge">std::filesystem::copy_options</code>, seemingly <a href="https://en.cppreference.com/w/cpp/filesystem/copy_options">there is no option to create automatically the needed directory</a>.</p><p>While <code class="language-plaintext highlighter-rouge">std::filesystem::copy</code> can be used to copy both files and directories, there is also <code class="language-plaintext highlighter-rouge">std::filesystem::copy_file</code> which can only copy a single file. Its name is more expressive, but that’s not the only difference. While <code class="language-plaintext highlighter-rouge">copy</code> is a void function, <code class="language-plaintext highlighter-rouge">copy_file</code> returns a boolean to show if a copy was successful (<code class="language-plaintext highlighter-rouge">true</code>) or not (<code class="language-plaintext highlighter-rouge">false</code>).</p><h2 id="conclusion">Conclusion</h2><p>Today, I shared with you a part of what I learned about the <code class="language-plaintext highlighter-rouge">std::filesystem</code> library. I must tell you that I found it pretty usable, despite the fact that sometimes I could have imagined a more intuitive API. We had a look into how to navigate up on a path, how to remove a filename from it and also we also checked how to copy, rename or delete files.</p><p>Next week, we are going to discuss how to iterate over a directory structure, a quite common operation when you have to apply some changes to a whole repository. Stay tuned!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/filesystem/" class="post-tag no-text-decoration" >filesystem</a> <a href="/tags/std/" class="post-tag no-text-decoration" >std</a> <a href="/tags/standardlibrary/" class="post-tag no-text-decoration" >standardlibrary</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=My late discovery of std::filesystem - Part I - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=My late discovery of std::filesystem - Part I - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=My late discovery of std::filesystem - Part I - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=My late discovery of std::filesystem - Part I - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/01/03/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Jan 3, 2024 <i class="unloaded">2024-01-03T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/03/06/std-filesystem-part2-iterate-over-directories"><div class="card-body"> <span class="timeago small" > Mar 6, 2024 <i class="unloaded">2024-03-06T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My late discovery of std::filesystem - Part II</h3><div class="text-muted small"><p> Last week, we started to discuss the main parts of std::filesystem and we discovered how to work with paths, how to navigate up through the directory structure and how to move files and directories...</p></div></div></a></div><div class="card"> <a href="/blog/2024/02/21/cpp-tests-with-resources"><div class="card-body"> <span class="timeago small" > Feb 21, 2024 <i class="unloaded">2024-02-21T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to write unit tests in C++ relying on non-code files?</h3><div class="text-muted small"><p> Recently we had a coding dojo with my colleagues where we were working on the second part of the Racing Car Katas, called TextConverter. To sum up the problem, the HtmlTextConverter class takes a f...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/02/21/cpp-tests-with-resources" class="btn btn-outline-primary" prompt="Older"><p>How to write unit tests in C++ relying on non-code files?</p></a> <a href="/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" class="btn btn-outline-primary" prompt="Newer"><p>My late discovery of std::filesystem - Part II</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'My late discovery of std::filesystem - Part I'; this.page.url = 'https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations'; this.page.identifier = '/blog/2024/02/28/std-filesystem-part1-paths-and-operations'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
