<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Three key philosophies behind C++" /><meta property="og:locale" content="en_US" /><meta name="description" content="Recently, I had to refresh some training material for software engineers who are not new to programming but are new to C++. It’s a short introduction by all means and as participants are expected to know how to program in a C-like language (usually Java, Kotlin or Python), I don’t have to focus on syntax basis. I decided to follow this agenda for this first part of the course: A little bit of C++ history The characteristics of C++ Three key ideas driving C++ Why to still use C++ In this article, I’d like to focus on the third part, the three key ideas driving C++. “What you don’t use, you don’t pay for” In short, this philosophy is explained in the FAQ section of isocpp.org The zero-overhead principle is a guiding principle for the design of C++. It states that: What you don’t use, you don’t pay for (in time or space) and further: What you do use, you couldn’t hand code any better. In other words, no feature should be added to C++ which would make any existing code (not using the new feature) larger or slower, nor should any feature be added for which the compiler would generate code that is not as good as a programmer would create without using the feature. So on the one hand, no new feature should make existing code larger or slower. Fair enough. But there is more to this philosophy, I think. C++ is a language that gives you great control over what exactly the program should do and with that great power it also gives great responsibility. In other words, C++ is not babysitting you, it assumes that you know what you do and why you make certain choices. Think about operator[]. It doesn’t do any bounds checks, it’s your responsibility as a programmer to ensure that operator[] will not look behind the bounds of a container. If you fail to program up to that assumption, your “reward” is undefined behaviour. On the other hand, you made sure that you don’t pay for bounds checks. If you need those checks and you want the compiler to warn you - with an exception - when you are beyond bounds, you can use at() - or implement the checks by hand. You only pay for the bounds checks when you communicate your needs. That’s far from being the only example in the standard library. Just think about smart pointers. Raw pointers require manual memory management which is error-prone and dangerous. std::unique_ptr just gives you the bare minimum to make sure that allocated memory is freed up properly. If you need to share the resource, you can use std::shared_ptr. I love this granularity of C++. On the one hand, it might mean complexity for you, but on the other hand, it means fine-tuned control and optimal costs. Speaking about costs, still part of this are zero-cost abstractions. Abstractions that increase the expressibility of C++ without incurring further runtime costs. Just think about how templates help you avoid repeating (almost) the same code over and over again without any extra runtime costs. Yes, templates increase the binary size and compile-time, but not more than actually repeating the code. Another example of zero-cost abstractions is exceptions. They increase the expressibility of the language and your code, yet you don’t pay any runtime costs for any unthrown exceptions. (You do pay a certain toll in binary size and compile-time though.) Backward compatibility is the superpower of C++ Another key driving idea behind C++ is backward compatibility. If you browse the list of changes of any new standard, you will notice 4 things. 1) There are very few changes that break existing APIs and require code changes from the user. 2) There are sometimes behaviour changes, but they are either by accident and are corrected later or more frequently, they are for the better. Just think about move semantics or the growing support for constexpr. If you upgrade your compiler you might find that certain copy operations became moves and function calls that used to happen in run-time, might happen in compile-time. These kinds of changes are usually not bothering. 3) There are very few deprecations or removals in C++. The reason behind this is that nobody wants to break existing code. There are systems that should work for decades without needing a major rework. Yet, they should benefit from recent compilers having active support and security fixes. Moreover, you should be able to maintain and extend old systems without having to rework all the existing code. The biggest one I remember was the deprecation and removal of std::auto_ptr, but the transition to std::unique_ptr (or std::shared_ptr) was quite straightforward. Other examples include std::bind1st and std::bind2nd, but frankly I had to look them up. 4) As a direct consequence, if you take an old C++ project and want to compile it with a modern compiler, there is a fair chance that it will work right away or with very few modifications. It doesn’t mean that even if it was great code back in time, we would consider it great nowadays, but at least it will be just as correct as it was when it was written and you can improve it gradually. Both Matt Godbolt and Jason Turner have such videos online, but I’m sure you can find others as well. Portability, interoperability, and X-platform development The third key idea behind C++ that I want to discuss today is about where C++ is used and how it is written. No matter how many new features have been introduced and how much more expressible the language has become, these topics still have the utmost importance. From the very beginnings of the language, C++ is designed to be portable across architectures and operating systems. Did you know that even the number of bits in a byte is implementation specified? The standard doesn’t mandate 8 bits, it’s simply the most prevailing value. Indeed, C++ is everywhere starting from microcontrollers, through your browsers, through games to supercomputers. To make it not only possible but also comfortable it offers platform-independent abstractions in the standard library. While it’s certainly possible to provide different implementations in your code for different platforms with preprocessor conditionals, the need is relatively rare and if you need to do so too frequently, your code is probably flawed. But C++ code isn’t only mostly portable between different platforms, it can also work well with, it and can interoperate with code from other languages. You can easily call any C function and you can directly embed assembly code within a C++ file. Beyond that, C++ can communicate with other languages through language bindings. Often, critical libraries for Python applications or JVM-based ones are implemented in C++ to benefit from its raw performance. C++ is ideal for cross-platform development. Usually, code runs with minimal modifications on several platforms and popular libraries are also designed with that in mind. Mostly not only the code has this characteristic, but other parts of the ecosystem as well, such as build systems, package managers, and sometimes even compilers. Conclusion In this post, we discussed 3 ideas behind C++ driving the evolution of the language. As one of C++’s key offerings is raw performance, it’s essential that you don’t pay for what you don’t use. The most well-known example is probably about the missing bounds checks in the subscript operator. If you know what you do, you can live dangerously. The second idea we discussed is backward compatibility which is both a superpower of C++ and the main cause behind the ever-growing complexity of the language. Last, but not least, we listed another key selling point of C++ which is portability, interoperability, and cross-platform development. What other key ideas do you see behind C++? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Recently, I had to refresh some training material for software engineers who are not new to programming but are new to C++. It’s a short introduction by all means and as participants are expected to know how to program in a C-like language (usually Java, Kotlin or Python), I don’t have to focus on syntax basis. I decided to follow this agenda for this first part of the course: A little bit of C++ history The characteristics of C++ Three key ideas driving C++ Why to still use C++ In this article, I’d like to focus on the third part, the three key ideas driving C++. “What you don’t use, you don’t pay for” In short, this philosophy is explained in the FAQ section of isocpp.org The zero-overhead principle is a guiding principle for the design of C++. It states that: What you don’t use, you don’t pay for (in time or space) and further: What you do use, you couldn’t hand code any better. In other words, no feature should be added to C++ which would make any existing code (not using the new feature) larger or slower, nor should any feature be added for which the compiler would generate code that is not as good as a programmer would create without using the feature. So on the one hand, no new feature should make existing code larger or slower. Fair enough. But there is more to this philosophy, I think. C++ is a language that gives you great control over what exactly the program should do and with that great power it also gives great responsibility. In other words, C++ is not babysitting you, it assumes that you know what you do and why you make certain choices. Think about operator[]. It doesn’t do any bounds checks, it’s your responsibility as a programmer to ensure that operator[] will not look behind the bounds of a container. If you fail to program up to that assumption, your “reward” is undefined behaviour. On the other hand, you made sure that you don’t pay for bounds checks. If you need those checks and you want the compiler to warn you - with an exception - when you are beyond bounds, you can use at() - or implement the checks by hand. You only pay for the bounds checks when you communicate your needs. That’s far from being the only example in the standard library. Just think about smart pointers. Raw pointers require manual memory management which is error-prone and dangerous. std::unique_ptr just gives you the bare minimum to make sure that allocated memory is freed up properly. If you need to share the resource, you can use std::shared_ptr. I love this granularity of C++. On the one hand, it might mean complexity for you, but on the other hand, it means fine-tuned control and optimal costs. Speaking about costs, still part of this are zero-cost abstractions. Abstractions that increase the expressibility of C++ without incurring further runtime costs. Just think about how templates help you avoid repeating (almost) the same code over and over again without any extra runtime costs. Yes, templates increase the binary size and compile-time, but not more than actually repeating the code. Another example of zero-cost abstractions is exceptions. They increase the expressibility of the language and your code, yet you don’t pay any runtime costs for any unthrown exceptions. (You do pay a certain toll in binary size and compile-time though.) Backward compatibility is the superpower of C++ Another key driving idea behind C++ is backward compatibility. If you browse the list of changes of any new standard, you will notice 4 things. 1) There are very few changes that break existing APIs and require code changes from the user. 2) There are sometimes behaviour changes, but they are either by accident and are corrected later or more frequently, they are for the better. Just think about move semantics or the growing support for constexpr. If you upgrade your compiler you might find that certain copy operations became moves and function calls that used to happen in run-time, might happen in compile-time. These kinds of changes are usually not bothering. 3) There are very few deprecations or removals in C++. The reason behind this is that nobody wants to break existing code. There are systems that should work for decades without needing a major rework. Yet, they should benefit from recent compilers having active support and security fixes. Moreover, you should be able to maintain and extend old systems without having to rework all the existing code. The biggest one I remember was the deprecation and removal of std::auto_ptr, but the transition to std::unique_ptr (or std::shared_ptr) was quite straightforward. Other examples include std::bind1st and std::bind2nd, but frankly I had to look them up. 4) As a direct consequence, if you take an old C++ project and want to compile it with a modern compiler, there is a fair chance that it will work right away or with very few modifications. It doesn’t mean that even if it was great code back in time, we would consider it great nowadays, but at least it will be just as correct as it was when it was written and you can improve it gradually. Both Matt Godbolt and Jason Turner have such videos online, but I’m sure you can find others as well. Portability, interoperability, and X-platform development The third key idea behind C++ that I want to discuss today is about where C++ is used and how it is written. No matter how many new features have been introduced and how much more expressible the language has become, these topics still have the utmost importance. From the very beginnings of the language, C++ is designed to be portable across architectures and operating systems. Did you know that even the number of bits in a byte is implementation specified? The standard doesn’t mandate 8 bits, it’s simply the most prevailing value. Indeed, C++ is everywhere starting from microcontrollers, through your browsers, through games to supercomputers. To make it not only possible but also comfortable it offers platform-independent abstractions in the standard library. While it’s certainly possible to provide different implementations in your code for different platforms with preprocessor conditionals, the need is relatively rare and if you need to do so too frequently, your code is probably flawed. But C++ code isn’t only mostly portable between different platforms, it can also work well with, it and can interoperate with code from other languages. You can easily call any C function and you can directly embed assembly code within a C++ file. Beyond that, C++ can communicate with other languages through language bindings. Often, critical libraries for Python applications or JVM-based ones are implemented in C++ to benefit from its raw performance. C++ is ideal for cross-platform development. Usually, code runs with minimal modifications on several platforms and popular libraries are also designed with that in mind. Mostly not only the code has this characteristic, but other parts of the ecosystem as well, such as build systems, package managers, and sometimes even compilers. Conclusion In this post, we discussed 3 ideas behind C++ driving the evolution of the language. As one of C++’s key offerings is raw performance, it’s essential that you don’t pay for what you don’t use. The most well-known example is probably about the missing bounds checks in the subscript operator. If you know what you do, you can live dangerously. The second idea we discussed is backward compatibility which is both a superpower of C++ and the main cause behind the ever-growing complexity of the language. Last, but not least, we listed another key selling point of C++ which is portability, interoperability, and cross-platform development. What other key ideas do you see behind C++? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-03-13T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Three key philosophies behind C++" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-03-13T00:00:00+01:00","datePublished":"2024-03-13T00:00:00+01:00","description":"Recently, I had to refresh some training material for software engineers who are not new to programming but are new to C++. It’s a short introduction by all means and as participants are expected to know how to program in a C-like language (usually Java, Kotlin or Python), I don’t have to focus on syntax basis. I decided to follow this agenda for this first part of the course: A little bit of C++ history The characteristics of C++ Three key ideas driving C++ Why to still use C++ In this article, I’d like to focus on the third part, the three key ideas driving C++. “What you don’t use, you don’t pay for” In short, this philosophy is explained in the FAQ section of isocpp.org The zero-overhead principle is a guiding principle for the design of C++. It states that: What you don’t use, you don’t pay for (in time or space) and further: What you do use, you couldn’t hand code any better. In other words, no feature should be added to C++ which would make any existing code (not using the new feature) larger or slower, nor should any feature be added for which the compiler would generate code that is not as good as a programmer would create without using the feature. So on the one hand, no new feature should make existing code larger or slower. Fair enough. But there is more to this philosophy, I think. C++ is a language that gives you great control over what exactly the program should do and with that great power it also gives great responsibility. In other words, C++ is not babysitting you, it assumes that you know what you do and why you make certain choices. Think about operator[]. It doesn’t do any bounds checks, it’s your responsibility as a programmer to ensure that operator[] will not look behind the bounds of a container. If you fail to program up to that assumption, your “reward” is undefined behaviour. On the other hand, you made sure that you don’t pay for bounds checks. If you need those checks and you want the compiler to warn you - with an exception - when you are beyond bounds, you can use at() - or implement the checks by hand. You only pay for the bounds checks when you communicate your needs. That’s far from being the only example in the standard library. Just think about smart pointers. Raw pointers require manual memory management which is error-prone and dangerous. std::unique_ptr just gives you the bare minimum to make sure that allocated memory is freed up properly. If you need to share the resource, you can use std::shared_ptr. I love this granularity of C++. On the one hand, it might mean complexity for you, but on the other hand, it means fine-tuned control and optimal costs. Speaking about costs, still part of this are zero-cost abstractions. Abstractions that increase the expressibility of C++ without incurring further runtime costs. Just think about how templates help you avoid repeating (almost) the same code over and over again without any extra runtime costs. Yes, templates increase the binary size and compile-time, but not more than actually repeating the code. Another example of zero-cost abstractions is exceptions. They increase the expressibility of the language and your code, yet you don’t pay any runtime costs for any unthrown exceptions. (You do pay a certain toll in binary size and compile-time though.) Backward compatibility is the superpower of C++ Another key driving idea behind C++ is backward compatibility. If you browse the list of changes of any new standard, you will notice 4 things. 1) There are very few changes that break existing APIs and require code changes from the user. 2) There are sometimes behaviour changes, but they are either by accident and are corrected later or more frequently, they are for the better. Just think about move semantics or the growing support for constexpr. If you upgrade your compiler you might find that certain copy operations became moves and function calls that used to happen in run-time, might happen in compile-time. These kinds of changes are usually not bothering. 3) There are very few deprecations or removals in C++. The reason behind this is that nobody wants to break existing code. There are systems that should work for decades without needing a major rework. Yet, they should benefit from recent compilers having active support and security fixes. Moreover, you should be able to maintain and extend old systems without having to rework all the existing code. The biggest one I remember was the deprecation and removal of std::auto_ptr, but the transition to std::unique_ptr (or std::shared_ptr) was quite straightforward. Other examples include std::bind1st and std::bind2nd, but frankly I had to look them up. 4) As a direct consequence, if you take an old C++ project and want to compile it with a modern compiler, there is a fair chance that it will work right away or with very few modifications. It doesn’t mean that even if it was great code back in time, we would consider it great nowadays, but at least it will be just as correct as it was when it was written and you can improve it gradually. Both Matt Godbolt and Jason Turner have such videos online, but I’m sure you can find others as well. Portability, interoperability, and X-platform development The third key idea behind C++ that I want to discuss today is about where C++ is used and how it is written. No matter how many new features have been introduced and how much more expressible the language has become, these topics still have the utmost importance. From the very beginnings of the language, C++ is designed to be portable across architectures and operating systems. Did you know that even the number of bits in a byte is implementation specified? The standard doesn’t mandate 8 bits, it’s simply the most prevailing value. Indeed, C++ is everywhere starting from microcontrollers, through your browsers, through games to supercomputers. To make it not only possible but also comfortable it offers platform-independent abstractions in the standard library. While it’s certainly possible to provide different implementations in your code for different platforms with preprocessor conditionals, the need is relatively rare and if you need to do so too frequently, your code is probably flawed. But C++ code isn’t only mostly portable between different platforms, it can also work well with, it and can interoperate with code from other languages. You can easily call any C function and you can directly embed assembly code within a C++ file. Beyond that, C++ can communicate with other languages through language bindings. Often, critical libraries for Python applications or JVM-based ones are implemented in C++ to benefit from its raw performance. C++ is ideal for cross-platform development. Usually, code runs with minimal modifications on several platforms and popular libraries are also designed with that in mind. Mostly not only the code has this characteristic, but other parts of the ecosystem as well, such as build systems, package managers, and sometimes even compilers. Conclusion In this post, we discussed 3 ideas behind C++ driving the evolution of the language. As one of C++’s key offerings is raw performance, it’s essential that you don’t pay for what you don’t use. The most well-known example is probably about the missing bounds checks in the subscript operator. If you know what you do, you can live dangerously. The second idea we discussed is backward compatibility which is both a superpower of C++ and the main cause behind the ever-growing complexity of the language. Last, but not least, we listed another key selling point of C++ which is portability, interoperability, and cross-platform development. What other key ideas do you see behind C++? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Three key philosophies behind C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp"},"url":"https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp"}</script><title>Three key philosophies behind C++ | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/13"> 13 </a> </span> <span>Three key philosophies behind C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Three key philosophies behind C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 13, 2024, 12:00 AM +0100" prep="on" > Mar 13, 2024 <i class="unloaded">2024-03-13T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1320 words">7 min</span></div></div><div class="post-content"><p>Recently, I had to refresh some training material for software engineers who are not new to programming but are new to C++. It’s a short introduction by all means and as participants are expected to know how to program in a C-like language (usually Java, Kotlin or Python), I don’t have to focus on syntax basis.</p><p>I decided to follow this agenda for this first part of the course:</p><ul><li>A little bit of C++ history<li>The characteristics of C++<li>Three key ideas driving C++<li>Why to still use C++</ul><p>In this article, I’d like to focus on the third part, the three key ideas driving C++.</p><h2 id="what-you-dont-use-you-dont-pay-for">“What you don’t use, you don’t pay for”</h2><p>In short, this philosophy is explained in the FAQ section of <a href="https://isocpp.org/wiki/faq/big-picture#zero-overhead-principle">isocpp.org</a></p><blockquote><p><em>The zero-overhead principle is a guiding principle for the design of C++. It states that: What you don’t use, you don’t pay for (in time or space) and further: What you do use, you couldn’t hand code any better.</em></p><p><em>In other words, no feature should be added to C++ which would make any existing code (not using the new feature) larger or slower, nor should any feature be added for which the compiler would generate code that is not as good as a programmer would create without using the feature.</em></p></blockquote><p>So on the one hand, no new feature should make existing code larger or slower. Fair enough. But there is more to this philosophy, I think.</p><p>C++ is a language that gives you great control over what exactly the program should do and with that great power it also gives great responsibility. In other words, C++ is not babysitting you, it assumes that you know what you do and why you make certain choices.</p><p>Think about <code class="language-plaintext highlighter-rouge">operator[]</code>. It doesn’t do any bounds checks, it’s your responsibility as a programmer to ensure that <code class="language-plaintext highlighter-rouge">operator[]</code> will not look behind the bounds of a container. If you fail to program up to that assumption, your “reward” is undefined behaviour. On the other hand, you made sure that you don’t pay for bounds checks. If you need those checks and you want the compiler to warn you - with an exception - when you are beyond bounds, you can use <code class="language-plaintext highlighter-rouge">at()</code> - or implement the checks by hand. You only pay for the bounds checks when you communicate your needs.</p><p>That’s far from being the only example in the standard library. Just think about smart pointers. Raw pointers require manual memory management which is error-prone and dangerous. <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> just gives you the bare minimum to make sure that allocated memory is freed up properly. If you need to share the resource, you can use <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>. I love this granularity of C++. On the one hand, it might mean complexity for you, but on the other hand, it means fine-tuned control and optimal costs.</p><p>Speaking about costs, still part of this are zero-cost abstractions. Abstractions that increase the expressibility of C++ without incurring further runtime costs. Just think about how templates help you avoid repeating (almost) the same code over and over again without any extra runtime costs. Yes, <a href="https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates">templates increase the binary size</a> and compile-time, but not more than actually repeating the code.</p><p>Another example of zero-cost abstractions is exceptions. They increase the expressibility of the language and your code, yet you don’t pay any runtime costs for any unthrown exceptions. (<a href="https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions">You do pay a certain toll in binary size and compile-time though.</a>)</p><h2 id="backward-compatibility-is-the-superpower-of-c"><a href="https://www.youtube.com/watch?v=0_UttFDnV3k">Backward compatibility is the superpower of C++</a></h2><p>Another key driving idea behind C++ is backward compatibility. If you browse the list of changes of any new standard, you will notice 4 things.</p><p>1) There are very few changes that break existing APIs and require code changes from the user.</p><p>2) There are sometimes behaviour changes, but they are either by accident and are corrected later or more frequently, they are for the better. Just think about move semantics or the growing support for <code class="language-plaintext highlighter-rouge">constexpr</code>.</p><p>If you upgrade your compiler you might find that certain copy operations became moves and function calls that used to happen in run-time, might happen in compile-time. These kinds of changes are usually not bothering.</p><p>3) There are very few deprecations or removals in C++. The reason behind this is that nobody wants to break existing code. There are systems that should work for decades without needing a major rework. Yet, they should benefit from recent compilers having active support and security fixes. Moreover, you should be able to maintain and extend old systems without having to rework all the existing code.</p><p>The biggest one I remember was the deprecation and removal of <code class="language-plaintext highlighter-rouge">std::auto_ptr</code>, but the transition to <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> (or <code class="language-plaintext highlighter-rouge">std::shared_ptr</code>) was quite straightforward. Other examples include <code class="language-plaintext highlighter-rouge">std::bind1st</code> and <code class="language-plaintext highlighter-rouge">std::bind2nd</code>, but frankly I had to look them up.</p><p>4) As a direct consequence, if you take an old C++ project and want to compile it with a modern compiler, there is a fair chance that it will work right away or with very few modifications. It doesn’t mean that even if it was great code back in time, we would consider it great nowadays, but at least it will be just as correct as it was when it was written and you can improve it gradually. Both Matt Godbolt and Jason Turner have such videos online, but I’m sure you can find others as well.</p><h2 id="portability-interoperability-and-x-platform-development">Portability, interoperability, and X-platform development</h2><p>The third key idea behind C++ that I want to discuss today is about where C++ is used and how it is written. No matter how many new features have been introduced and how much more expressible the language has become, these topics still have the utmost importance.</p><p>From the very beginnings of the language, C++ is designed to be portable across architectures and operating systems. Did you know that even the number of bits in a byte is implementation specified? The standard doesn’t mandate 8 bits, it’s simply the most prevailing value. Indeed, C++ is everywhere starting from microcontrollers, through your browsers, through games to supercomputers.</p><p>To make it not only possible but also comfortable it offers platform-independent abstractions in the standard library. While it’s certainly possible to provide different implementations in your code for different platforms with preprocessor conditionals, the need is relatively rare and if you need to do so too frequently, your code is probably flawed.</p><p>But C++ code isn’t only mostly portable between different platforms, it can also work well with, it and can interoperate with code from other languages. You can easily call any <em>C</em> function and <a href="https://en.cppreference.com/w/cpp/language/asm">you can directly embed assembly code</a> within a C++ file.</p><p>Beyond that, C++ can communicate with other languages through language bindings. Often, critical libraries for Python applications or JVM-based ones are implemented in C++ to benefit from its raw performance.</p><p>C++ is ideal for cross-platform development. Usually, code runs with minimal modifications on several platforms and popular libraries are also designed with that in mind. Mostly not only the code has this characteristic, but other parts of the ecosystem as well, such as build systems, package managers, and sometimes even compilers.</p><h2 id="conclusion">Conclusion</h2><p>In this post, we discussed 3 ideas behind C++ driving the evolution of the language. As one of C++’s key offerings is raw performance, it’s essential that you don’t pay for what you don’t use. The most well-known example is probably about the missing bounds checks in the subscript operator. If you know what you do, you can live dangerously.</p><p>The second idea we discussed is backward compatibility which is both a superpower of C++ and the main cause behind the ever-growing complexity of the language. Last, but not least, we listed another key selling point of C++ which is portability, interoperability, and cross-platform development.</p><p>What other key ideas do you see behind C++?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/meta/" class="post-tag no-text-decoration" >meta</a> <a href="/tags/philosophy/" class="post-tag no-text-decoration" >philosophy</a> <a href="/tags/design/" class="post-tag no-text-decoration" >design</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Three key philosophies behind C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Three key philosophies behind C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Three key philosophies behind C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Three key philosophies behind C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2018/04/13/new-design"><div class="card-body"> <span class="timeago small" > Apr 13, 2018 <i class="unloaded">2018-04-13T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>New design - just keep it simple</h3><div class="text-muted small"><p> My blog is powered by Jekyll and hosted on GitHub Pages. To build it I learnt a lot about HTML, CSS, Javascript and the Jekyll framework itself. It’s been a great experience. Although, I’m neither ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/12/11/start-exploring-cpp26"><div class="card-body"> <span class="timeago small" > Dec 11, 2024 <i class="unloaded">2024-12-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Let's start exploring C++26</h3><div class="text-muted small"><p> During the last 2 years, we spent a lot of time exploring C++23 resulting in almost 40 blog posts. I’m not saying that we covered every single new language or library feature, but we covered most o...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/10/cpponsea2024-trip-report"><div class="card-body"> <span class="timeago small" > Jul 10, 2024 <i class="unloaded">2024-07-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: C++ On Sea 2024</h3><div class="text-muted small"><p> Last week, between the 3rd and 5th of July, I had the privilege to attend and present at C++ on Sea 2024 for the 5th time in a row! I’m grateful that the organizers accepted me not simply as a spe...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" class="btn btn-outline-primary" prompt="Older"><p>My late discovery of std::filesystem - Part II</p></a> <a href="/blog/2024/03/16/tidy-first-by-kent-beck" class="btn btn-outline-primary" prompt="Newer"><p>Tidy First? by Kent Beck</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Three key philosophies behind C++'; this.page.url = 'https://www.sandordargo.com/blog/2024/03/13/3-key-philosophies-behind-cpp'; this.page.identifier = '/blog/2024/03/13/3-key-philosophies-behind-cpp'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
