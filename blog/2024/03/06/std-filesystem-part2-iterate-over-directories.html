<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="My late discovery of std::filesystem - Part II" /><meta property="og:locale" content="en_US" /><meta name="description" content="Last week, we started to discuss the main parts of std::filesystem and we discovered how to work with paths, how to navigate up through the directory structure and how to move files and directories around. This week, we are going to see how to iterate over a directory structure based on different needs and expectations. Let’s start by simply listing the contents of a single directory. Iterate with directory_iterator Iterating over a directory and listing its items is a simple task thanks to range-based for loops and std::filesystem::directory_iterator. We have to pass a valid path (even in the form of a string) to the iterator and well… iterate over it. It’s also worth noting how to get only the filename as a string from the full path. From the iterator entry, we get the full path by calling path(), then we can get the filename by calling filename and then we just call the string() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); std::cout &lt;&lt; &quot;The contents of temp:\n&quot;; for (const auto&amp; entry : std::filesystem::directory_iterator(&quot;temp&quot;)) { const auto filename = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; &quot;directory: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else if (entry.is_regular_file()) { std::cout &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } /* The contents of temp: directory: subdir file: file1.txt file: file2.txt */ The above example only lists the contents of one single directory, it doesn’t get into the subfolders recursively. In order to do so, we have to extract the iteration into its own method and call it with a subfolder path whenever we find a subfolder. Notice that in order to print the contents in a tree-like structure, we keep track of the level or depth of the path. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); std::cout &lt;&lt; &quot;The contents of temp:\n&quot;; iterateOverDirectory(&quot;temp&quot;); } /* The contents of temp: directory: subdir file: file3.txt file: file1.txt file: file2.txt */ But there is a simpler solution! Iterate with recursive_directory_iterator We can use the recursive_directory_iterator, hide the recursive calls and get all the paths. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (const auto&amp; entry : std::filesystem::recursive_directory_iterator(root)) { std::cout &lt;&lt; entry &lt;&lt; &#39;\n&#39;; } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); iterateOverDirectory(&quot;temp&quot;); } /* &quot;temp/subdir&quot; &quot;temp/subdir/file3.txt&quot; &quot;temp/file1.txt&quot; &quot;temp/file2.txt&quot; */ If we need access to the depth and display a directory tree, we can still do that with recursive_directory_iterator, but we cannot use a range-based for loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (auto entry = std::filesystem::recursive_directory_iterator(root); entry != std::filesystem::recursive_directory_iterator(); ++entry) { const auto filename = entry-&gt;path().filename().string(); const auto level = entry.depth(); if (entry-&gt;is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; } else if (entry-&gt;is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: subdir file: file3.txt file: file1.txt file: file2.txt */ The reason behind is that the value_type of recursive_directory_iterator is std::filesystem::directory_entry which has no notion of depth. By using the range-based version, we lose access to the iterator type. Skip certain files and folders If we want to skip certain extensions, we can have a guard clause at the beginning of the body of the loop. If we use a regular iterator, where we take care of going into the subfolders, we also have to make sure that we don’t skip directories just because they don’t match the allowed extensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); const auto extension = entry.path().extension().string(); if (!entry.is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: include file: moduleB.h file: moduleA.h directory: src file: moduleA.cpp file: moduleB.cpp */ In fact, if you want to print directory names like in the above example, then even in the recursive version you should keep the !entry.is_directory() part of the guard clause. But even if you remove it, all the subdirectories will still be searched. To skip certain folders, let’s add another guard clause in which we check if an entry is a directory and if it matches the name “build” as in our next example, we want to avoid listing the contents of build folders. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); const auto extension = entry.path().extension().string(); if (!entry.is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry.is_directory() &amp;&amp; filename == &quot;build&quot;) { continue; } if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/build&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.cpp&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } This approach will not work if you want to use a recursive iterator, we’d only avoid printing directory: build, but we’d list it’s contents. We have to disable recursing for that folder and we can do that by calling std::filesystem::recursive_directory_iterator::disable_recursion_pending. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (auto entry = std::filesystem::recursive_directory_iterator(root); entry != std::filesystem::recursive_directory_iterator(); ++entry) { const auto filename = entry-&gt;path().filename().string(); const auto extension = entry-&gt;path().extension().string(); const auto level = entry.depth(); if (!entry-&gt;is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry-&gt;is_directory() &amp;&amp; filename == &quot;build&quot;) { entry.disable_recursion_pending(); continue; } if (entry-&gt;is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; } else if (entry-&gt;is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/build&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.cpp&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: include file: moduleB.h file: moduleA.h directory: src file: moduleA.cpp file: moduleB.cpp */ It’s up to you which approach you like better. Probably this latter one is a bit more neat, but the name disable_recursion_pending might give you some extra time to figure out what is going on. Conclusion In this article, continued learning about std::filesystem. This week we targeted one single topic, how to iterate over the files of a directory or recursively over a whole directory structure. We also saw how to skip files with certain extensions or even directories with certain names. What’s your favourite way of iterating over directories in C++? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Last week, we started to discuss the main parts of std::filesystem and we discovered how to work with paths, how to navigate up through the directory structure and how to move files and directories around. This week, we are going to see how to iterate over a directory structure based on different needs and expectations. Let’s start by simply listing the contents of a single directory. Iterate with directory_iterator Iterating over a directory and listing its items is a simple task thanks to range-based for loops and std::filesystem::directory_iterator. We have to pass a valid path (even in the form of a string) to the iterator and well… iterate over it. It’s also worth noting how to get only the filename as a string from the full path. From the iterator entry, we get the full path by calling path(), then we can get the filename by calling filename and then we just call the string() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); std::cout &lt;&lt; &quot;The contents of temp:\n&quot;; for (const auto&amp; entry : std::filesystem::directory_iterator(&quot;temp&quot;)) { const auto filename = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; &quot;directory: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else if (entry.is_regular_file()) { std::cout &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } /* The contents of temp: directory: subdir file: file1.txt file: file2.txt */ The above example only lists the contents of one single directory, it doesn’t get into the subfolders recursively. In order to do so, we have to extract the iteration into its own method and call it with a subfolder path whenever we find a subfolder. Notice that in order to print the contents in a tree-like structure, we keep track of the level or depth of the path. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); std::cout &lt;&lt; &quot;The contents of temp:\n&quot;; iterateOverDirectory(&quot;temp&quot;); } /* The contents of temp: directory: subdir file: file3.txt file: file1.txt file: file2.txt */ But there is a simpler solution! Iterate with recursive_directory_iterator We can use the recursive_directory_iterator, hide the recursive calls and get all the paths. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (const auto&amp; entry : std::filesystem::recursive_directory_iterator(root)) { std::cout &lt;&lt; entry &lt;&lt; &#39;\n&#39;; } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); iterateOverDirectory(&quot;temp&quot;); } /* &quot;temp/subdir&quot; &quot;temp/subdir/file3.txt&quot; &quot;temp/file1.txt&quot; &quot;temp/file2.txt&quot; */ If we need access to the depth and display a directory tree, we can still do that with recursive_directory_iterator, but we cannot use a range-based for loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (auto entry = std::filesystem::recursive_directory_iterator(root); entry != std::filesystem::recursive_directory_iterator(); ++entry) { const auto filename = entry-&gt;path().filename().string(); const auto level = entry.depth(); if (entry-&gt;is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; } else if (entry-&gt;is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: subdir file: file3.txt file: file1.txt file: file2.txt */ The reason behind is that the value_type of recursive_directory_iterator is std::filesystem::directory_entry which has no notion of depth. By using the range-based version, we lose access to the iterator type. Skip certain files and folders If we want to skip certain extensions, we can have a guard clause at the beginning of the body of the loop. If we use a regular iterator, where we take care of going into the subfolders, we also have to make sure that we don’t skip directories just because they don’t match the allowed extensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); const auto extension = entry.path().extension().string(); if (!entry.is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: include file: moduleB.h file: moduleA.h directory: src file: moduleA.cpp file: moduleB.cpp */ In fact, if you want to print directory names like in the above example, then even in the recursive version you should keep the !entry.is_directory() part of the guard clause. But even if you remove it, all the subdirectories will still be searched. To skip certain folders, let’s add another guard clause in which we check if an entry is a directory and if it matches the name “build” as in our next example, we want to avoid listing the contents of build folders. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); const auto extension = entry.path().extension().string(); if (!entry.is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry.is_directory() &amp;&amp; filename == &quot;build&quot;) { continue; } if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/build&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.cpp&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } This approach will not work if you want to use a recursive iterator, we’d only avoid printing directory: build, but we’d list it’s contents. We have to disable recursing for that folder and we can do that by calling std::filesystem::recursive_directory_iterator::disable_recursion_pending. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (auto entry = std::filesystem::recursive_directory_iterator(root); entry != std::filesystem::recursive_directory_iterator(); ++entry) { const auto filename = entry-&gt;path().filename().string(); const auto extension = entry-&gt;path().extension().string(); const auto level = entry.depth(); if (!entry-&gt;is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry-&gt;is_directory() &amp;&amp; filename == &quot;build&quot;) { entry.disable_recursion_pending(); continue; } if (entry-&gt;is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\n&#39;; } else if (entry-&gt;is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/build&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.cpp&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: include file: moduleB.h file: moduleA.h directory: src file: moduleA.cpp file: moduleB.cpp */ It’s up to you which approach you like better. Probably this latter one is a bit more neat, but the name disable_recursion_pending might give you some extra time to figure out what is going on. Conclusion In this article, continued learning about std::filesystem. This week we targeted one single topic, how to iterate over the files of a directory or recursively over a whole directory structure. We also saw how to skip files with certain extensions or even directories with certain names. What’s your favourite way of iterating over directories in C++? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-03-06T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="My late discovery of std::filesystem - Part II" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-03-06T00:00:00+01:00","datePublished":"2024-03-06T00:00:00+01:00","description":"Last week, we started to discuss the main parts of std::filesystem and we discovered how to work with paths, how to navigate up through the directory structure and how to move files and directories around. This week, we are going to see how to iterate over a directory structure based on different needs and expectations. Let’s start by simply listing the contents of a single directory. Iterate with directory_iterator Iterating over a directory and listing its items is a simple task thanks to range-based for loops and std::filesystem::directory_iterator. We have to pass a valid path (even in the form of a string) to the iterator and well… iterate over it. It’s also worth noting how to get only the filename as a string from the full path. From the iterator entry, we get the full path by calling path(), then we can get the filename by calling filename and then we just call the string() function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); std::cout &lt;&lt; &quot;The contents of temp:\\n&quot;; for (const auto&amp; entry : std::filesystem::directory_iterator(&quot;temp&quot;)) { const auto filename = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; &quot;directory: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else if (entry.is_regular_file()) { std::cout &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } } } /* The contents of temp: directory: subdir file: file1.txt file: file2.txt */ The above example only lists the contents of one single directory, it doesn’t get into the subfolders recursively. In order to do so, we have to extract the iteration into its own method and call it with a subfolder path whenever we find a subfolder. Notice that in order to print the contents in a tree-like structure, we keep track of the level or depth of the path. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); std::cout &lt;&lt; &quot;The contents of temp:\\n&quot;; iterateOverDirectory(&quot;temp&quot;); } /* The contents of temp: directory: subdir file: file3.txt file: file1.txt file: file2.txt */ But there is a simpler solution! Iterate with recursive_directory_iterator We can use the recursive_directory_iterator, hide the recursive calls and get all the paths. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (const auto&amp; entry : std::filesystem::recursive_directory_iterator(root)) { std::cout &lt;&lt; entry &lt;&lt; &#39;\\n&#39;; } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); iterateOverDirectory(&quot;temp&quot;); } /* &quot;temp/subdir&quot; &quot;temp/subdir/file3.txt&quot; &quot;temp/file1.txt&quot; &quot;temp/file2.txt&quot; */ If we need access to the depth and display a directory tree, we can still do that with recursive_directory_iterator, but we cannot use a range-based for loop. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (auto entry = std::filesystem::recursive_directory_iterator(root); entry != std::filesystem::recursive_directory_iterator(); ++entry) { const auto filename = entry-&gt;path().filename().string(); const auto level = entry.depth(); if (entry-&gt;is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\\n&#39;; } else if (entry-&gt;is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/subdir&quot;); // create files std::ofstream(&quot;temp/file1.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/file2.txt&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/subdir/file3.txt&quot;).put(&#39;c&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: subdir file: file3.txt file: file1.txt file: file2.txt */ The reason behind is that the value_type of recursive_directory_iterator is std::filesystem::directory_entry which has no notion of depth. By using the range-based version, we lose access to the iterator type. Skip certain files and folders If we want to skip certain extensions, we can have a guard clause at the beginning of the body of the loop. If we use a regular iterator, where we take care of going into the subfolders, we also have to make sure that we don’t skip directories just because they don’t match the allowed extensions. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); const auto extension = entry.path().extension().string(); if (!entry.is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: include file: moduleB.h file: moduleA.h directory: src file: moduleA.cpp file: moduleB.cpp */ In fact, if you want to print directory names like in the above example, then even in the recursive version you should keep the !entry.is_directory() part of the guard clause. But even if you remove it, all the subdirectories will still be searched. To skip certain folders, let’s add another guard clause in which we check if an entry is a directory and if it matches the name “build” as in our next example, we want to avoid listing the contents of build folders. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root, int level = 0) { for (const auto&amp; entry : std::filesystem::directory_iterator(root)) { const auto filename = entry.path().filename().string(); const auto extension = entry.path().extension().string(); if (!entry.is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry.is_directory() &amp;&amp; filename == &quot;build&quot;) { continue; } if (entry.is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\\n&#39;; iterateOverDirectory(entry, level + 1); } else if (entry.is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/build&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.cpp&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } This approach will not work if you want to use a recursive iterator, we’d only avoid printing directory: build, but we’d list it’s contents. We have to disable recursing for that folder and we can do that by calling std::filesystem::recursive_directory_iterator::disable_recursion_pending. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 #include &lt;algorithm&gt; #include &lt;array&gt; #include &lt;fstream&gt; #include &lt;iostream&gt; #include &lt;filesystem&gt; std::array&lt;std::string, 2&gt; allowed_extensions {&quot;.h&quot;, &quot;.cpp&quot;}; void iterateOverDirectory(const std::filesystem::path&amp; root) { for (auto entry = std::filesystem::recursive_directory_iterator(root); entry != std::filesystem::recursive_directory_iterator(); ++entry) { const auto filename = entry-&gt;path().filename().string(); const auto extension = entry-&gt;path().extension().string(); const auto level = entry.depth(); if (!entry-&gt;is_directory() &amp;&amp; std::ranges::find(allowed_extensions, extension) == allowed_extensions.end()) { continue; } if (entry-&gt;is_directory() &amp;&amp; filename == &quot;build&quot;) { entry.disable_recursion_pending(); continue; } if (entry-&gt;is_directory()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;directory: &quot; &lt;&lt;filename &lt;&lt; &#39;\\n&#39;; } else if (entry-&gt;is_regular_file()) { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;file: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } else { std::cout &lt;&lt; std::setw(level * 3) &lt;&lt; &quot;&quot; &lt;&lt; &quot;unknown type: &quot; &lt;&lt; filename &lt;&lt; &#39;\\n&#39;; } } } int main() { std::filesystem::create_directory(&quot;temp&quot;); std::filesystem::create_directory(&quot;temp/build&quot;); std::filesystem::create_directory(&quot;temp/include&quot;); std::filesystem::create_directory(&quot;temp/src&quot;); // create files std::ofstream(&quot;temp/CMakeLists.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/build/moduleA.cpp&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/include/moreinfo.txt&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleA.h&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/include/moduleB.h&quot;).put(&#39;b&#39;); std::ofstream(&quot;temp/src/moduleA.cpp&quot;).put(&#39;a&#39;); std::ofstream(&quot;temp/src/moduleB.cpp&quot;).put(&#39;b&#39;); iterateOverDirectory(&quot;temp&quot;); } /* directory: include file: moduleB.h file: moduleA.h directory: src file: moduleA.cpp file: moduleB.cpp */ It’s up to you which approach you like better. Probably this latter one is a bit more neat, but the name disable_recursion_pending might give you some extra time to figure out what is going on. Conclusion In this article, continued learning about std::filesystem. This week we targeted one single topic, how to iterate over the files of a directory or recursively over a whole directory structure. We also saw how to skip files with certain extensions or even directories with certain names. What’s your favourite way of iterating over directories in C++? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"My late discovery of std::filesystem - Part II","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories"},"url":"https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories"}</script><title>My late discovery of std::filesystem - Part II | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/06"> 06 </a> </span> <span>My late discovery of std::filesystem - Part II</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>My late discovery of std::filesystem - Part II</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 6, 2024, 12:00 AM +0100" prep="on" > Mar 6, 2024 <i class="unloaded">2024-03-06T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1693 words">9 min</span></div></div><div class="post-content"><p>Last week, <a href="https://www.sandordargo.com/blog/2024/02/28/std-filesystem-part1-paths-and-operations">we started to discuss the main parts of <code class="language-plaintext highlighter-rouge">std::filesystem</code></a> and we discovered how to work with paths, how to navigate up through the directory structure and how to move files and directories around.</p><p>This week, we are going to see how to iterate over a directory structure based on different needs and expectations.</p><p>Let’s start by simply listing the contents of a single directory.</p><h2 id="iterate-with-directory_iterator">Iterate with <code class="language-plaintext highlighter-rouge">directory_iterator</code></h2><p>Iterating over a directory and listing its items is a simple task thanks to range-based for loops and <code class="language-plaintext highlighter-rouge">std::filesystem::directory_iterator</code>. We have to pass a valid path (even in the form of a string) to the iterator and well… iterate over it.</p><p>It’s also worth noting how to get only the filename as a string from the full path. From the iterator entry, we get the full path by calling <code class="language-plaintext highlighter-rouge">path()</code>, then we can get the filename by calling <code class="language-plaintext highlighter-rouge">filename</code> and then we just call the <code class="language-plaintext highlighter-rouge">string()</code> function.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/subdir"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file1.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file2.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/subdir/file3.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The contents of temp:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">directory_iterator</span><span class="p">(</span><span class="s">"temp"</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">().</span><span class="n">filename</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"directory: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_regular_file</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"unknown type: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="cm">/*
The contents of temp:
directory: subdir
file: file1.txt
file: file2.txt
*/</span>
</pre></table></code></div></div><p>The above example only lists the contents of one single directory, it doesn’t get into the subfolders recursively. In order to do so, we have to extract the iteration into its own method and call it with a subfolder path whenever we find a subfolder. Notice that in order to print the contents in a tree-like structure, we keep track of the level or depth of the path.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">iterateOverDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">directory_iterator</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">().</span><span class="n">filename</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"directory: "</span> <span class="o">&lt;&lt;</span><span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_regular_file</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"unknown type: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/subdir"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file1.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file2.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/subdir/file3.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"The contents of temp:</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
The contents of temp:
directory: subdir
   file: file3.txt
file: file1.txt
file: file2.txt
*/</span>
</pre></table></code></div></div><p>But there is a simpler solution!</p><h2 id="iterate-with-recursive_directory_iterator">Iterate with <code class="language-plaintext highlighter-rouge">recursive_directory_iterator</code></h2><p>We can use the <code class="language-plaintext highlighter-rouge">recursive_directory_iterator</code>, hide the recursive calls and get all the paths.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">iterateOverDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">recursive_directory_iterator</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">entry</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/subdir"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file1.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file2.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/subdir/file3.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

    <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
"temp/subdir"
"temp/subdir/file3.txt"
"temp/file1.txt"
"temp/file2.txt"
*/</span>
</pre></table></code></div></div><p>If we need access to the depth and display a directory tree, we can still do that with <code class="language-plaintext highlighter-rouge">recursive_directory_iterator</code>, but we cannot use a range-based for loop.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">iterateOverDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">recursive_directory_iterator</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> <span class="n">entry</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">recursive_directory_iterator</span><span class="p">();</span> <span class="o">++</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">().</span><span class="n">filename</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">level</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">depth</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">is_directory</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"directory: "</span> <span class="o">&lt;&lt;</span><span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">is_regular_file</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"unknown type: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/subdir"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file1.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/file2.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/subdir/file3.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'c'</span><span class="p">);</span>

    <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
directory: subdir
   file: file3.txt
file: file1.txt
file: file2.txt
*/</span>
</pre></table></code></div></div><p>The reason behind is that the <code class="language-plaintext highlighter-rouge">value_type</code> of <code class="language-plaintext highlighter-rouge">recursive_directory_iterator</code> is <code class="language-plaintext highlighter-rouge">std::filesystem::directory_entry</code> which has no notion of depth. By using the range-based version, we lose access to the iterator type.</p><h2 id="skip-certain-files-and-folders">Skip certain files and folders</h2><p>If we want to skip certain extensions, we can have a guard clause at the beginning of the body of the loop. If we use a regular iterator, where we take care of going into the subfolders, we also have to make sure that we don’t skip directories just because they don’t match the allowed extensions.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">allowed_extensions</span> <span class="p">{</span><span class="s">".h"</span><span class="p">,</span> <span class="s">".cpp"</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">iterateOverDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">directory_iterator</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">().</span><span class="n">filename</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">().</span><span class="n">extension</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">allowed_extensions</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span> <span class="o">==</span> <span class="n">allowed_extensions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"directory: "</span> <span class="o">&lt;&lt;</span><span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_regular_file</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"unknown type: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/include"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/src"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/CMakeLists.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moreinfo.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moduleA.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moduleB.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/src/moduleA.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/src/moduleB.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>

    <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
directory: include
   file: moduleB.h
   file: moduleA.h
directory: src
   file: moduleA.cpp
   file: moduleB.cpp
*/</span>
</pre></table></code></div></div><p>In fact, if you want to print directory names like in the above example, then even in the recursive version you should keep the <code class="language-plaintext highlighter-rouge">!entry.is_directory()</code> part of the guard clause. But even if you remove it, all the subdirectories will still be searched.</p><p>To skip certain folders, let’s add another guard clause in which we check if an entry is a directory and if it matches the name “build” as in our next example, we want to avoid listing the contents of <code class="language-plaintext highlighter-rouge">build</code> folders.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">allowed_extensions</span> <span class="p">{</span><span class="s">".h"</span><span class="p">,</span> <span class="s">".cpp"</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">iterateOverDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">,</span> <span class="kt">int</span> <span class="n">level</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">entry</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">directory_iterator</span><span class="p">(</span><span class="n">root</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">().</span><span class="n">filename</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">path</span><span class="p">().</span><span class="n">extension</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">allowed_extensions</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span> <span class="o">==</span> <span class="n">allowed_extensions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">filename</span> <span class="o">==</span> <span class="s">"build"</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_directory</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"directory: "</span> <span class="o">&lt;&lt;</span><span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
            <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="n">entry</span><span class="p">,</span> <span class="n">level</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">entry</span><span class="p">.</span><span class="n">is_regular_file</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"unknown type: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/build"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/include"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/src"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/CMakeLists.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/build/moduleA.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/build/moduleA.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moreinfo.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moduleA.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moduleB.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/src/moduleA.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/src/moduleB.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>

    <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This approach will not work if you want to use a recursive iterator, we’d only avoid printing <em>directory: build</em>, but we’d list it’s contents. We have to disable recursing for that folder and we can do that by calling <code class="language-plaintext highlighter-rouge">std::filesystem::recursive_directory_iterator::disable_recursion_pending</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;fstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;filesystem&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="mi">2</span><span class="o">&gt;</span> <span class="n">allowed_extensions</span> <span class="p">{</span><span class="s">".h"</span><span class="p">,</span> <span class="s">".cpp"</span><span class="p">};</span>

<span class="kt">void</span> <span class="nf">iterateOverDirectory</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">path</span><span class="o">&amp;</span> <span class="n">root</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">recursive_directory_iterator</span><span class="p">(</span><span class="n">root</span><span class="p">);</span> <span class="n">entry</span> <span class="o">!=</span> <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">recursive_directory_iterator</span><span class="p">();</span> <span class="o">++</span><span class="n">entry</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">filename</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">().</span><span class="n">filename</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">extension</span> <span class="o">=</span> <span class="n">entry</span><span class="o">-&gt;</span><span class="n">path</span><span class="p">().</span><span class="n">extension</span><span class="p">().</span><span class="n">string</span><span class="p">();</span>
        <span class="k">const</span> <span class="k">auto</span> <span class="n">level</span> <span class="o">=</span> <span class="n">entry</span><span class="p">.</span><span class="n">depth</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">is_directory</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">find</span><span class="p">(</span><span class="n">allowed_extensions</span><span class="p">,</span> <span class="n">extension</span><span class="p">)</span> <span class="o">==</span> <span class="n">allowed_extensions</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">is_directory</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">filename</span> <span class="o">==</span> <span class="s">"build"</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">entry</span><span class="p">.</span><span class="n">disable_recursion_pending</span><span class="p">();</span>
            <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">is_directory</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"directory: "</span> <span class="o">&lt;&lt;</span><span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">entry</span><span class="o">-&gt;</span><span class="n">is_regular_file</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"file: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">setw</span><span class="p">(</span><span class="n">level</span> <span class="o">*</span> <span class="mi">3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">""</span> <span class="o">&lt;&lt;</span> <span class="s">"unknown type: "</span> <span class="o">&lt;&lt;</span> <span class="n">filename</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/build"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/include"</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">filesystem</span><span class="o">::</span><span class="n">create_directory</span><span class="p">(</span><span class="s">"temp/src"</span><span class="p">);</span>
    
    <span class="c1">// create files</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/CMakeLists.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/build/moduleA.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/build/moduleA.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moreinfo.txt"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moduleA.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/include/moduleB.h"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/src/moduleA.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'a'</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ofstream</span><span class="p">(</span><span class="s">"temp/src/moduleB.cpp"</span><span class="p">).</span><span class="n">put</span><span class="p">(</span><span class="sc">'b'</span><span class="p">);</span>

    <span class="n">iterateOverDirectory</span><span class="p">(</span><span class="s">"temp"</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
directory: include
   file: moduleB.h
   file: moduleA.h
directory: src
   file: moduleA.cpp
   file: moduleB.cpp
*/</span>
</pre></table></code></div></div><p>It’s up to you which approach you like better. Probably this latter one is a bit more neat, but the name <code class="language-plaintext highlighter-rouge">disable_recursion_pending</code> might give you some extra time to figure out what is going on.</p><h2 id="conclusion">Conclusion</h2><p>In this article, continued learning about <code class="language-plaintext highlighter-rouge">std::filesystem</code>. This week we targeted one single topic, how to iterate over the files of a directory or recursively over a whole directory structure. We also saw how to skip files with certain extensions or even directories with certain names.</p><p>What’s your favourite way of iterating over directories in C++?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/filesystem/" class="post-tag no-text-decoration" >filesystem</a> <a href="/tags/std/" class="post-tag no-text-decoration" >std</a> <a href="/tags/standardlibrary/" class="post-tag no-text-decoration" >standardlibrary</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=My late discovery of std::filesystem - Part II - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=My late discovery of std::filesystem - Part II - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=My late discovery of std::filesystem - Part II - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=My late discovery of std::filesystem - Part II - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/01/03/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Jan 3, 2024 <i class="unloaded">2024-01-03T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/02/28/std-filesystem-part1-paths-and-operations"><div class="card-body"> <span class="timeago small" > Feb 28, 2024 <i class="unloaded">2024-02-28T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My late discovery of std::filesystem - Part I</h3><div class="text-muted small"><p> I know that this is not a new topic at all. But this blog in its roots is to document what I learn, and I haven’t used the filesystem library up until a few weeks ago. After the initial encounter, ...</p></div></div></a></div><div class="card"> <a href="/blog/2025/04/30/cpp26-constexpr-library-changes"><div class="card-body"> <span class="timeago small" > Apr 30, 2025 <i class="unloaded">2025-04-30T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++26: more constexpr in the standard library</h3><div class="text-muted small"><p> Last week, we discussed language features that are becoming constexpr in C++26. Today, let’s turn our attention to the standard library features that will soon be usable at compile time. One topic ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/02/28/std-filesystem-part1-paths-and-operations" class="btn btn-outline-primary" prompt="Older"><p>My late discovery of std::filesystem - Part I</p></a> <a href="/blog/2024/03/13/3-key-philosophies-behind-cpp" class="btn btn-outline-primary" prompt="Newer"><p>Three key philosophies behind C++</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'My late discovery of std::filesystem - Part II'; this.page.url = 'https://www.sandordargo.com/blog/2024/03/06/std-filesystem-part2-iterate-over-directories'; this.page.identifier = '/blog/2024/03/06/std-filesystem-part2-iterate-over-directories'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
