<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: Encoding related changes" /><meta property="og:locale" content="en_US" /><meta name="description" content="Today, we are going to go through a couple of changes introduced by C++23 where the common theme is encoding. These changes are all related to how the code we write will be encoded by the compiler. Often these papers don’t introduce big changes, simply the common and desirable behaviour got standardized. Yet, these are all important to have code that works as expected and that is portable between different platforms and compilers. Trimming whitespaces before line splicing As of C++20, what’s the output of the below piece of code (Godbolt)? 1 2 3 4 5 6 7 int main() { int i = 1 // \ + 42 ; return i; } Without having seen how the code is formatted I would have said that it’s 1 + 42, so 43. And actually, that’s the real output. On MSVC. Not on other compilers, such as GCC and Clang. These latter ones return 1. The reason is that they trim the trailing whitespaces before handling \ splicing. The new-line character following \ is a whitespace, it’s deleted, therefore + 42 ends up on the same line as // \ and it becomes part of the comment. Just for the record, both implementation strategies are valid. P2223R2 change this situation and set the GCC/Clang implementation strategy into stone standard. This might be a breaking one for code that is only compiled with MSVC, but it shouldn’t happen on a big scale. We might remember Matt Godbolt saying earlier in one of his talks that one of the superpowers of C++ is backward compatibility and here the change potentially breaks code. At the same time, it’s worth noting that implementation-defined behaviour would break here and not standardized behaviour. The reason behind going in this direction is that many IDEs, code formatters and other tools already discard trailing whitespaces as the Google style guide and most of its derivations already forbid them. Removing mixed wide string literal concatenation Adjacent string literals are concatenated. 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; int main() { auto a = &quot;Hello&quot; &quot;World&quot;; std::cout &lt;&lt; a &lt;&lt; &#39;\n&#39;; } /* HelloWorld */ In the above example, the value of a is HelloWorld. Fair enough. But what if the string literals have encoding prefixes, such as L&quot;&quot;, u8&quot;&quot;, u&quot;&quot; or U&quot;&quot;? As long as only one of the literals has such a prefix, the resulting concatenated string will have the same prefix. But if string literals involved in the concatenation have different prefixes, the behaviour is implementation-defined. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; int main() { { auto a = L&quot;&quot; + u&quot;&quot;; } { auto a = L&quot;&quot; + u8&quot;&quot;; } { auto a = L&quot;&quot; + U&quot;&quot;; } { auto a = u8&quot;&quot; L&quot;&quot;; } { auto a = u8&quot;&quot; u&quot;&quot;; } { auto a = u8&quot;&quot; U&quot;&quot;; } { auto a = u&quot;&quot; L&quot;&quot;; } { auto a = u&quot;&quot; u8&quot;&quot;; } { auto a = u&quot;&quot; U&quot;&quot;; } { auto a = U&quot;&quot; L&quot;&quot;; } { auto a = U&quot;&quot; u&quot;&quot;; } { auto a = U&quot;&quot; u8&quot;&quot;; } } All the major compilers issue an error. And thanks to P2201R1, that behaviour is getting standardized. All mixed-encoding prefixes are ill-formed. Consistent character literal encoding As of C++20, “the value of character literals in preprocessor conditional is not required to be identical to that of character literals in expressions”. #if &#39;A&#39; == &#39;\x41&#39; and if (&#39;A&#39; == 0x41) might have different results. According to a survey involving more than 1300 open source projects available on vcpkg, the expectation is clear. The primary use case for these macros is to detect narrow literal encoding at compile-time. In fact, all the major compilers treat these literals as if they were encoded in narrow literals. Therefore, P2316R2, doesn’t change what people expect from C++, it won’t even change the implementation of all the major compilers, it simply adjusts the standard to real-life behaviour and expectations. With its adoption, the standard guarantees that the value of character literals in preprocessor conditional is identical to that of character literals in expressions. Missing feature test macros for C++20 core papers As it’s pointed out in P2493R0, some feature-test macros have been missing for the language or they have not been bumped as necessary. This paper proposed to bump __cpp_concepts from 201907L to 202002L, and for __cpp_constexpr a bump to 202110L is coming from another paper. Without these bumped values, compilers cannot know whether some features are available or not and as such, they cannot use them. Character sets and encodings P2314R4 introduces a few terminology changes and also a couple of behaviour changes. Changes that won’t directly influence most people’s life who code in C++. Let me try to share with you the gist of this paper. The main change is that “universal-character-names are no longer formed in the translation phase”. Instead, all Unicode input characters are retained throughout the translation. For example, up until C++20, if you had a “stringizing” preprocessor operator such as #define S(x) # X, then both S(Köppe) and S(K\u00f6ppe) could have been translated into “K\u00f6ppe”, but with this paper, both translates into simply Köppe. Interestingly, all the major compilers have been already in line with P2314R4, so no change to them. That was the main behaviour “change” - which is not really a change, but rather an adjustment of the standard to reflect implementation behaviour. Here are also the terminologies introduced by this paper: translation character set: the abstract character set used during translation; can represent the character equivalent of all valid universal-character-names basic character set: minimum character set needed to express C++ program source basic literal character set: minimum set of characters expressible by literals ordinary / wide literal encoding: compile-time encoding used for initializing string literal objects Support for UTF-8 as a portable source file encoding From P2295R6, I learned something I would have never thought of. In C++, it’s impossible to write code that can be strictly considered portable. It was a surprising fact to me, as portability always seemed an important goal when writing code for enterprises in C++. And now I learned from P2295R6 that even though in practice you could write portable code, in theory, it was not the case. The reason behind this is that “the set of source file character sets is implementation-defined, which makes writing portable C++ code impossible.” Thanks to this paper, it will be mandatory to accept UTF-8 as an input format which will both increase general portability and ensure that Unicode-related features can be used widely. It’s worth noting that all the major compilers support UTF-8 as source file encoding and Clang only supports this file format. The paper doesn’t go further than mandating to accept UTF-8 encoded source files. It doesn’t try to provide a standard way to detect the encoding of the files to be compiled. It also doesn’t restrict in any way what encodings should be accepted. It also doesn’t speak about the conservation of code point sequences during the translation, or in other words the formation of “universal-character-names”, that’s what the above-mentioned P2314R1 is for. Interestingly, today compilers validate (or not) non-UTF-8 inputs differently. MSVC emits a warning if you use some invalid UTF-8 characters even in your comments. Clang doesn’t check comments but it emits errors if it finds invalid Unicode characters in string literals. GCC supports different input character sets. For non-UTF-8 inputs it makes sure that they decode cleanly, otherwise, it raises an error. On the other hand, UTF-8 input is not decoded at all, its handling is inconsistent with others. Clarify the handling of encodings in localized formatting of chrono types One last proposal that is related to encodings is P2419R2. C++20 added formatting of chrono types with std::format but left unspecified what happens during localized formatting when the locale and literal encodings do not match. Let’s take the example directly from the published paper: 1 2 std::locale::global(std::locale(&quot;Russian.1251&quot;)); auto s = std::format(&quot;День недели: {}&quot;, std::chrono::Monday); In this case, we can have a mismatch between the UTF-8 local encoding and the “Russian.1251”. The standard hasn’t specified what should happen in such scenarios until the acceptance of P2419R2. One option is to have “День недели: Пн”. In that case, everything is in UTF-8. The other option would be to have “День недели: \xcf\xed”, where “\xcf\xed” is in Russian.1251 and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable. Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text. With the acceptance of P2419R2, implementations are allowed to do transcoding or substituting the locale so that the result is in a consistent encoding and there should be no mojibakes. Conclusion In this article, we reviewed changes that are related to how the compiler encodes our code. We saw that there is less and less implementation-defined behaviour in that area. While the behaviour often doesn’t change, it becomes standardized. We also saw that C++ has a growing Unicode support. It’s nice to see how portability is getting better and better. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Today, we are going to go through a couple of changes introduced by C++23 where the common theme is encoding. These changes are all related to how the code we write will be encoded by the compiler. Often these papers don’t introduce big changes, simply the common and desirable behaviour got standardized. Yet, these are all important to have code that works as expected and that is portable between different platforms and compilers. Trimming whitespaces before line splicing As of C++20, what’s the output of the below piece of code (Godbolt)? 1 2 3 4 5 6 7 int main() { int i = 1 // \ + 42 ; return i; } Without having seen how the code is formatted I would have said that it’s 1 + 42, so 43. And actually, that’s the real output. On MSVC. Not on other compilers, such as GCC and Clang. These latter ones return 1. The reason is that they trim the trailing whitespaces before handling \ splicing. The new-line character following \ is a whitespace, it’s deleted, therefore + 42 ends up on the same line as // \ and it becomes part of the comment. Just for the record, both implementation strategies are valid. P2223R2 change this situation and set the GCC/Clang implementation strategy into stone standard. This might be a breaking one for code that is only compiled with MSVC, but it shouldn’t happen on a big scale. We might remember Matt Godbolt saying earlier in one of his talks that one of the superpowers of C++ is backward compatibility and here the change potentially breaks code. At the same time, it’s worth noting that implementation-defined behaviour would break here and not standardized behaviour. The reason behind going in this direction is that many IDEs, code formatters and other tools already discard trailing whitespaces as the Google style guide and most of its derivations already forbid them. Removing mixed wide string literal concatenation Adjacent string literals are concatenated. 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; int main() { auto a = &quot;Hello&quot; &quot;World&quot;; std::cout &lt;&lt; a &lt;&lt; &#39;\n&#39;; } /* HelloWorld */ In the above example, the value of a is HelloWorld. Fair enough. But what if the string literals have encoding prefixes, such as L&quot;&quot;, u8&quot;&quot;, u&quot;&quot; or U&quot;&quot;? As long as only one of the literals has such a prefix, the resulting concatenated string will have the same prefix. But if string literals involved in the concatenation have different prefixes, the behaviour is implementation-defined. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; int main() { { auto a = L&quot;&quot; + u&quot;&quot;; } { auto a = L&quot;&quot; + u8&quot;&quot;; } { auto a = L&quot;&quot; + U&quot;&quot;; } { auto a = u8&quot;&quot; L&quot;&quot;; } { auto a = u8&quot;&quot; u&quot;&quot;; } { auto a = u8&quot;&quot; U&quot;&quot;; } { auto a = u&quot;&quot; L&quot;&quot;; } { auto a = u&quot;&quot; u8&quot;&quot;; } { auto a = u&quot;&quot; U&quot;&quot;; } { auto a = U&quot;&quot; L&quot;&quot;; } { auto a = U&quot;&quot; u&quot;&quot;; } { auto a = U&quot;&quot; u8&quot;&quot;; } } All the major compilers issue an error. And thanks to P2201R1, that behaviour is getting standardized. All mixed-encoding prefixes are ill-formed. Consistent character literal encoding As of C++20, “the value of character literals in preprocessor conditional is not required to be identical to that of character literals in expressions”. #if &#39;A&#39; == &#39;\x41&#39; and if (&#39;A&#39; == 0x41) might have different results. According to a survey involving more than 1300 open source projects available on vcpkg, the expectation is clear. The primary use case for these macros is to detect narrow literal encoding at compile-time. In fact, all the major compilers treat these literals as if they were encoded in narrow literals. Therefore, P2316R2, doesn’t change what people expect from C++, it won’t even change the implementation of all the major compilers, it simply adjusts the standard to real-life behaviour and expectations. With its adoption, the standard guarantees that the value of character literals in preprocessor conditional is identical to that of character literals in expressions. Missing feature test macros for C++20 core papers As it’s pointed out in P2493R0, some feature-test macros have been missing for the language or they have not been bumped as necessary. This paper proposed to bump __cpp_concepts from 201907L to 202002L, and for __cpp_constexpr a bump to 202110L is coming from another paper. Without these bumped values, compilers cannot know whether some features are available or not and as such, they cannot use them. Character sets and encodings P2314R4 introduces a few terminology changes and also a couple of behaviour changes. Changes that won’t directly influence most people’s life who code in C++. Let me try to share with you the gist of this paper. The main change is that “universal-character-names are no longer formed in the translation phase”. Instead, all Unicode input characters are retained throughout the translation. For example, up until C++20, if you had a “stringizing” preprocessor operator such as #define S(x) # X, then both S(Köppe) and S(K\u00f6ppe) could have been translated into “K\u00f6ppe”, but with this paper, both translates into simply Köppe. Interestingly, all the major compilers have been already in line with P2314R4, so no change to them. That was the main behaviour “change” - which is not really a change, but rather an adjustment of the standard to reflect implementation behaviour. Here are also the terminologies introduced by this paper: translation character set: the abstract character set used during translation; can represent the character equivalent of all valid universal-character-names basic character set: minimum character set needed to express C++ program source basic literal character set: minimum set of characters expressible by literals ordinary / wide literal encoding: compile-time encoding used for initializing string literal objects Support for UTF-8 as a portable source file encoding From P2295R6, I learned something I would have never thought of. In C++, it’s impossible to write code that can be strictly considered portable. It was a surprising fact to me, as portability always seemed an important goal when writing code for enterprises in C++. And now I learned from P2295R6 that even though in practice you could write portable code, in theory, it was not the case. The reason behind this is that “the set of source file character sets is implementation-defined, which makes writing portable C++ code impossible.” Thanks to this paper, it will be mandatory to accept UTF-8 as an input format which will both increase general portability and ensure that Unicode-related features can be used widely. It’s worth noting that all the major compilers support UTF-8 as source file encoding and Clang only supports this file format. The paper doesn’t go further than mandating to accept UTF-8 encoded source files. It doesn’t try to provide a standard way to detect the encoding of the files to be compiled. It also doesn’t restrict in any way what encodings should be accepted. It also doesn’t speak about the conservation of code point sequences during the translation, or in other words the formation of “universal-character-names”, that’s what the above-mentioned P2314R1 is for. Interestingly, today compilers validate (or not) non-UTF-8 inputs differently. MSVC emits a warning if you use some invalid UTF-8 characters even in your comments. Clang doesn’t check comments but it emits errors if it finds invalid Unicode characters in string literals. GCC supports different input character sets. For non-UTF-8 inputs it makes sure that they decode cleanly, otherwise, it raises an error. On the other hand, UTF-8 input is not decoded at all, its handling is inconsistent with others. Clarify the handling of encodings in localized formatting of chrono types One last proposal that is related to encodings is P2419R2. C++20 added formatting of chrono types with std::format but left unspecified what happens during localized formatting when the locale and literal encodings do not match. Let’s take the example directly from the published paper: 1 2 std::locale::global(std::locale(&quot;Russian.1251&quot;)); auto s = std::format(&quot;День недели: {}&quot;, std::chrono::Monday); In this case, we can have a mismatch between the UTF-8 local encoding and the “Russian.1251”. The standard hasn’t specified what should happen in such scenarios until the acceptance of P2419R2. One option is to have “День недели: Пн”. In that case, everything is in UTF-8. The other option would be to have “День недели: \xcf\xed”, where “\xcf\xed” is in Russian.1251 and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable. Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text. With the acceptance of P2419R2, implementations are allowed to do transcoding or substituting the locale so that the result is in a consistent encoding and there should be no mojibakes. Conclusion In this article, we reviewed changes that are related to how the compiler encodes our code. We saw that there is less and less implementation-defined behaviour in that area. While the behaviour often doesn’t change, it becomes standardized. We also saw that C++ has a growing Unicode support. It’s nice to see how portability is getting better and better. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2024-03-20T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: Encoding related changes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-03-22T01:01:14+01:00","datePublished":"2024-03-20T00:00:00+01:00","description":"Today, we are going to go through a couple of changes introduced by C++23 where the common theme is encoding. These changes are all related to how the code we write will be encoded by the compiler. Often these papers don’t introduce big changes, simply the common and desirable behaviour got standardized. Yet, these are all important to have code that works as expected and that is portable between different platforms and compilers. Trimming whitespaces before line splicing As of C++20, what’s the output of the below piece of code (Godbolt)? 1 2 3 4 5 6 7 int main() { int i = 1 // \\ + 42 ; return i; } Without having seen how the code is formatted I would have said that it’s 1 + 42, so 43. And actually, that’s the real output. On MSVC. Not on other compilers, such as GCC and Clang. These latter ones return 1. The reason is that they trim the trailing whitespaces before handling \\ splicing. The new-line character following \\ is a whitespace, it’s deleted, therefore + 42 ends up on the same line as // \\ and it becomes part of the comment. Just for the record, both implementation strategies are valid. P2223R2 change this situation and set the GCC/Clang implementation strategy into stone standard. This might be a breaking one for code that is only compiled with MSVC, but it shouldn’t happen on a big scale. We might remember Matt Godbolt saying earlier in one of his talks that one of the superpowers of C++ is backward compatibility and here the change potentially breaks code. At the same time, it’s worth noting that implementation-defined behaviour would break here and not standardized behaviour. The reason behind going in this direction is that many IDEs, code formatters and other tools already discard trailing whitespaces as the Google style guide and most of its derivations already forbid them. Removing mixed wide string literal concatenation Adjacent string literals are concatenated. 1 2 3 4 5 6 7 8 9 #include &lt;iostream&gt; int main() { auto a = &quot;Hello&quot; &quot;World&quot;; std::cout &lt;&lt; a &lt;&lt; &#39;\\n&#39;; } /* HelloWorld */ In the above example, the value of a is HelloWorld. Fair enough. But what if the string literals have encoding prefixes, such as L&quot;&quot;, u8&quot;&quot;, u&quot;&quot; or U&quot;&quot;? As long as only one of the literals has such a prefix, the resulting concatenated string will have the same prefix. But if string literals involved in the concatenation have different prefixes, the behaviour is implementation-defined. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; int main() { { auto a = L&quot;&quot; + u&quot;&quot;; } { auto a = L&quot;&quot; + u8&quot;&quot;; } { auto a = L&quot;&quot; + U&quot;&quot;; } { auto a = u8&quot;&quot; L&quot;&quot;; } { auto a = u8&quot;&quot; u&quot;&quot;; } { auto a = u8&quot;&quot; U&quot;&quot;; } { auto a = u&quot;&quot; L&quot;&quot;; } { auto a = u&quot;&quot; u8&quot;&quot;; } { auto a = u&quot;&quot; U&quot;&quot;; } { auto a = U&quot;&quot; L&quot;&quot;; } { auto a = U&quot;&quot; u&quot;&quot;; } { auto a = U&quot;&quot; u8&quot;&quot;; } } All the major compilers issue an error. And thanks to P2201R1, that behaviour is getting standardized. All mixed-encoding prefixes are ill-formed. Consistent character literal encoding As of C++20, “the value of character literals in preprocessor conditional is not required to be identical to that of character literals in expressions”. #if &#39;A&#39; == &#39;\\x41&#39; and if (&#39;A&#39; == 0x41) might have different results. According to a survey involving more than 1300 open source projects available on vcpkg, the expectation is clear. The primary use case for these macros is to detect narrow literal encoding at compile-time. In fact, all the major compilers treat these literals as if they were encoded in narrow literals. Therefore, P2316R2, doesn’t change what people expect from C++, it won’t even change the implementation of all the major compilers, it simply adjusts the standard to real-life behaviour and expectations. With its adoption, the standard guarantees that the value of character literals in preprocessor conditional is identical to that of character literals in expressions. Missing feature test macros for C++20 core papers As it’s pointed out in P2493R0, some feature-test macros have been missing for the language or they have not been bumped as necessary. This paper proposed to bump __cpp_concepts from 201907L to 202002L, and for __cpp_constexpr a bump to 202110L is coming from another paper. Without these bumped values, compilers cannot know whether some features are available or not and as such, they cannot use them. Character sets and encodings P2314R4 introduces a few terminology changes and also a couple of behaviour changes. Changes that won’t directly influence most people’s life who code in C++. Let me try to share with you the gist of this paper. The main change is that “universal-character-names are no longer formed in the translation phase”. Instead, all Unicode input characters are retained throughout the translation. For example, up until C++20, if you had a “stringizing” preprocessor operator such as #define S(x) # X, then both S(Köppe) and S(K\\u00f6ppe) could have been translated into “K\\u00f6ppe”, but with this paper, both translates into simply Köppe. Interestingly, all the major compilers have been already in line with P2314R4, so no change to them. That was the main behaviour “change” - which is not really a change, but rather an adjustment of the standard to reflect implementation behaviour. Here are also the terminologies introduced by this paper: translation character set: the abstract character set used during translation; can represent the character equivalent of all valid universal-character-names basic character set: minimum character set needed to express C++ program source basic literal character set: minimum set of characters expressible by literals ordinary / wide literal encoding: compile-time encoding used for initializing string literal objects Support for UTF-8 as a portable source file encoding From P2295R6, I learned something I would have never thought of. In C++, it’s impossible to write code that can be strictly considered portable. It was a surprising fact to me, as portability always seemed an important goal when writing code for enterprises in C++. And now I learned from P2295R6 that even though in practice you could write portable code, in theory, it was not the case. The reason behind this is that “the set of source file character sets is implementation-defined, which makes writing portable C++ code impossible.” Thanks to this paper, it will be mandatory to accept UTF-8 as an input format which will both increase general portability and ensure that Unicode-related features can be used widely. It’s worth noting that all the major compilers support UTF-8 as source file encoding and Clang only supports this file format. The paper doesn’t go further than mandating to accept UTF-8 encoded source files. It doesn’t try to provide a standard way to detect the encoding of the files to be compiled. It also doesn’t restrict in any way what encodings should be accepted. It also doesn’t speak about the conservation of code point sequences during the translation, or in other words the formation of “universal-character-names”, that’s what the above-mentioned P2314R1 is for. Interestingly, today compilers validate (or not) non-UTF-8 inputs differently. MSVC emits a warning if you use some invalid UTF-8 characters even in your comments. Clang doesn’t check comments but it emits errors if it finds invalid Unicode characters in string literals. GCC supports different input character sets. For non-UTF-8 inputs it makes sure that they decode cleanly, otherwise, it raises an error. On the other hand, UTF-8 input is not decoded at all, its handling is inconsistent with others. Clarify the handling of encodings in localized formatting of chrono types One last proposal that is related to encodings is P2419R2. C++20 added formatting of chrono types with std::format but left unspecified what happens during localized formatting when the locale and literal encodings do not match. Let’s take the example directly from the published paper: 1 2 std::locale::global(std::locale(&quot;Russian.1251&quot;)); auto s = std::format(&quot;День недели: {}&quot;, std::chrono::Monday); In this case, we can have a mismatch between the UTF-8 local encoding and the “Russian.1251”. The standard hasn’t specified what should happen in such scenarios until the acceptance of P2419R2. One option is to have “День недели: Пн”. In that case, everything is in UTF-8. The other option would be to have “День недели: \\xcf\\xed”, where “\\xcf\\xed” is in Russian.1251 and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable. Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text. With the acceptance of P2419R2, implementations are allowed to do transcoding or substituting the locale so that the result is in a consistent encoding and there should be no mojibakes. Conclusion In this article, we reviewed changes that are related to how the compiler encodes our code. We saw that there is less and less implementation-defined behaviour in that area. While the behaviour often doesn’t change, it becomes standardized. We also saw that C++ has a growing Unicode support. It’s nice to see how portability is getting better and better. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: Encoding related changes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes"},"url":"https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes"}</script><title>C++23: Encoding related changes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2024"> 2024 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/20"> 20 </a> </span> <span>C++23: Encoding related changes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: Encoding related changes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 20, 2024, 12:00 AM +0100" prep="on" > Mar 20, 2024 <i class="unloaded">2024-03-20T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Mar 21, 2024, 8:01 PM -0400" prefix="Updated " > Mar 21, 2024 <i class="unloaded">2024-03-22T01:01:14+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1611 words">8 min</span></div></div><div class="post-content"><p>Today, we are going to go through a couple of changes introduced by C++23 where the common theme is encoding. These changes are all related to how the code we write will be encoded by the compiler. Often these papers don’t introduce big changes, simply the common and desirable behaviour got standardized.</p><p>Yet, these are all important to have code that works as expected and that is portable between different platforms and compilers.</p><h2 id="trimming-whitespaces-before-line-splicing">Trimming whitespaces before line splicing</h2><p>As of C++20, what’s the output of the below piece of code (<a href="https://godbolt.org/z/qq378vvKM">Godbolt</a>)?</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
<span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span>
<span class="c1">// \ </span>
<span class="o">+</span> <span class="mi">42</span>
<span class="p">;</span>
<span class="k">return</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Without having seen how the code is formatted I would have said that it’s <code class="language-plaintext highlighter-rouge">1 + 42</code>, so <code class="language-plaintext highlighter-rouge">43</code>. And actually, that’s the real output. On MSVC. Not on other compilers, such as GCC and Clang.</p><p>These latter ones return <code class="language-plaintext highlighter-rouge">1</code>. The reason is that they trim the trailing whitespaces before handling <code class="language-plaintext highlighter-rouge">\</code> splicing. The new-line character following <code class="language-plaintext highlighter-rouge">\</code> is a whitespace, it’s deleted, therefore <code class="language-plaintext highlighter-rouge">+ 42</code> ends up on the same line as <code class="language-plaintext highlighter-rouge">// \</code> and it becomes part of the comment.</p><p>Just for the record, both implementation strategies are valid.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2223r2.pdf">P2223R2</a> change this situation and set the GCC/Clang implementation strategy into <del>stone</del> standard. This might be a breaking one for code that is only compiled with MSVC, but it shouldn’t happen on a big scale.</p><p>We might remember <a href="https://www.youtube.com/watch?v=5P7fnH9cCR0">Matt Godbolt saying earlier in one of his talks that one of the superpowers of C++ is backward compatibility</a> and here the change potentially breaks code. At the same time, it’s worth noting that implementation-defined behaviour would break here and not standardized behaviour.</p><p>The reason behind going in this direction is that many IDEs, code formatters and other tools already discard trailing whitespaces as the Google style guide and most of its derivations already forbid them.</p><h2 id="removing-mixed-wide-string-literal-concatenation">Removing mixed wide string literal concatenation</h2><p>Adjacent string literals are concatenated.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
     <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">"Hello"</span> <span class="s">"World"</span><span class="p">;</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
HelloWorld
*/</span>
</pre></table></code></div></div><p>In the above example, the value of <code class="language-plaintext highlighter-rouge">a</code> is <em>HelloWorld</em>. Fair enough. But what if the string literals have encoding prefixes, such as <code class="language-plaintext highlighter-rouge">L""</code>, <code class="language-plaintext highlighter-rouge">u8""</code>, <code class="language-plaintext highlighter-rouge">u""</code> or <code class="language-plaintext highlighter-rouge">U""</code>? As long as only one of the literals has such a prefix, the resulting concatenated string will have the same prefix. But if string literals involved in the concatenation have different prefixes, the behaviour is implementation-defined.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">L""</span> <span class="o">+</span> <span class="s">u""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">L""</span> <span class="o">+</span> <span class="s">u8""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">L""</span> <span class="o">+</span> <span class="s">U""</span><span class="p">;</span> <span class="p">}</span>

  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u8""</span> <span class="s">L""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u8""</span> <span class="s">u""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u8""</span> <span class="s">U""</span><span class="p">;</span> <span class="p">}</span>

  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u""</span> <span class="s">L""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u""</span> <span class="s">u8""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">u""</span> <span class="s">U""</span><span class="p">;</span> <span class="p">}</span>

  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">U""</span> <span class="s">L""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">U""</span> <span class="s">u""</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">{</span> <span class="k">auto</span> <span class="n">a</span> <span class="o">=</span> <span class="s">U""</span> <span class="s">u8""</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>All the major compilers issue an error.</p><p>And thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2201r1.html">P2201R1</a>, that behaviour is getting standardized. All mixed-encoding prefixes are ill-formed.</p><h2 id="consistent-character-literal-encoding">Consistent character literal encoding</h2><p>As of C++20, <em>“the value of character literals in preprocessor conditional is not required to be identical to that of character literals in expressions”</em>.</p><p><code class="language-plaintext highlighter-rouge">#if 'A' == '\x41'</code> and <code class="language-plaintext highlighter-rouge">if ('A' == 0x41)</code> might have different results. According to a survey involving more than 1300 open source projects available on <em>vcpkg</em>, the expectation is clear. The primary use case for these macros is to detect narrow literal encoding at compile-time. In fact, all the major compilers treat these literals as if they were encoded in narrow literals.</p><p>Therefore, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2316r2.pdf">P2316R2</a>, doesn’t change what people expect from C++, it won’t even change the implementation of all the major compilers, it simply adjusts the standard to real-life behaviour and expectations. With its adoption, the standard guarantees that the value of character literals in preprocessor conditional is identical to that of character literals in expressions.</p><h2 id="missing-feature-test-macros-for-c20-core-papers">Missing feature test macros for C++20 core papers</h2><p>As it’s pointed out in <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2493r0.html">P2493R0</a>, some feature-test macros have been missing for the language or they have not been bumped as necessary. This paper proposed to bump <code class="language-plaintext highlighter-rouge">__cpp_concepts</code> from <em>201907L</em> to <em>202002L</em>, and for <code class="language-plaintext highlighter-rouge">__cpp_constexpr</code> a bump to <em>202110L</em> is coming from another paper.</p><p>Without these bumped values, compilers cannot know whether some features are available or not and as such, they cannot use them.</p><h2 id="character-sets-and-encodings">Character sets and encodings</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r4.html">P2314R4</a> introduces a few terminology changes and also a couple of behaviour changes. Changes that won’t directly influence most people’s life who code in C++. Let me try to share with you the gist of this paper.</p><p>The main change is that “<em>universal-character-names</em> are no longer formed in the translation phase”. Instead, all Unicode input characters are retained throughout the translation.</p><p>For example, up until C++20, if you had a “stringizing” preprocessor operator such as <code class="language-plaintext highlighter-rouge">#define S(x) # X</code>, then both <code class="language-plaintext highlighter-rouge">S(Köppe)</code> and <code class="language-plaintext highlighter-rouge">S(K\u00f6ppe)</code> could have been translated into “K\u00f6ppe”, but with this paper, both translates into simply <code class="language-plaintext highlighter-rouge">Köppe</code>. Interestingly, all the major compilers have been already in line with <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r4.html">P2314R4</a>, so no change to them.</p><p>That was the main behaviour “change” - which is not really a change, but rather an adjustment of the standard to reflect implementation behaviour.</p><p>Here are also the terminologies introduced by this paper:</p><ul><li><em>translation character set</em>: the abstract character set used during translation; can represent the character equivalent of all valid universal-character-names<li><em>basic character set</em>: minimum character set needed to express C++ program source<li><em>basic literal character set</em>: minimum set of characters expressible by literals<li><em>ordinary / wide literal encoding</em>: compile-time encoding used for initializing string literal objects</ul><h2 id="support-for-utf-8-as-a-portable-source-file-encoding">Support for UTF-8 as a portable source file encoding</h2><p>From <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2295r6.pdf">P2295R6</a>, I learned something I would have never thought of. In C++, it’s impossible to write code that can be strictly considered portable.</p><p>It was a surprising fact to me, as portability always seemed an important goal when writing code for enterprises in C++. And now I learned from <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2295r6.pdf">P2295R6</a> that even though in practice you could write portable code, in theory, it was not the case.</p><p>The reason behind this is that “the set of source file character sets is implementation-defined, which makes writing portable C++ code impossible.” Thanks to this paper, it will be mandatory to accept UTF-8 as an input format which will both increase general portability and ensure that Unicode-related features can be used widely.</p><p>It’s worth noting that all the major compilers support UTF-8 as source file encoding and Clang only supports this file format.</p><p>The paper doesn’t go further than mandating to accept UTF-8 encoded source files. It doesn’t try to provide a standard way to detect the encoding of the files to be compiled. It also doesn’t restrict in any way what encodings should be accepted. It also doesn’t speak about the conservation of code point sequences during the translation, or in other words the formation of “<em>universal-character-names</em>”, that’s what the above-mentioned <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2314r1.html">P2314R1</a> is for.</p><p>Interestingly, today compilers validate (or not) non-UTF-8 inputs differently. MSVC emits a warning if you use some invalid UTF-8 characters even in your comments. Clang doesn’t check comments but it emits errors if it finds invalid Unicode characters in string literals.</p><p>GCC supports different input character sets. For non-UTF-8 inputs it makes sure that they decode cleanly, otherwise, it raises an error. On the other hand, UTF-8 input is not decoded at all, its handling is inconsistent with others.</p><h2 id="clarify-the-handling-of-encodings-in-localized-formatting-of-chrono-types">Clarify the handling of encodings in localized formatting of chrono types</h2><p>One last proposal that is related to encodings is <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html">P2419R2</a>. C++20 added formatting of chrono types with <code class="language-plaintext highlighter-rouge">std::format</code> but left unspecified what happens during localized formatting when the locale and literal encodings do not match.</p><p>Let’s take the example directly from the published paper:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="o">::</span><span class="n">global</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">locale</span><span class="p">(</span><span class="s">"Russian.1251"</span><span class="p">));</span>
<span class="k">auto</span> <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">format</span><span class="p">(</span><span class="s">"День недели: {}"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">chrono</span><span class="o">::</span><span class="n">Monday</span><span class="p">);</span>
</pre></table></code></div></div><p>In this case, we can have a mismatch between the UTF-8 local encoding and the “Russian.1251”. The standard hasn’t specified what should happen in such scenarios until the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html">P2419R2</a>.</p><p>One option is to have <em>“День недели: Пн”</em>. In that case, everything is in UTF-8. The other option would be to have <em>“День недели: \xcf\xed”</em>, where “\xcf\xed” is in <em>Russian.1251</em> and it’s not valid UTF-8. This is also called a “Mojibake” and is undesirable.</p><blockquote><p>Mojibake (文字化け) is a term in Japanese that translates to “character transformation” or “character corruption” in English. It refers to the phenomenon where text that is encoded or decoded incorrectly results in a display of garbled or unreadable characters. Mojibake is often seen when there is a mismatch between the encoding used to store or transmit text and the encoding expected by the software or system trying to interpret that text.</p></blockquote><p>With the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2419r2.html">P2419R2</a>, implementations are allowed to do transcoding or substituting the locale so that the result is in a consistent encoding and there should be no mojibakes.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed changes that are related to how the compiler encodes our code. We saw that there is less and less implementation-defined behaviour in that area. While the behaviour often doesn’t change, it becomes standardized. We also saw that C++ has a growing Unicode support. It’s nice to see how portability is getting better and better.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/utf8/" class="post-tag no-text-decoration" >utf8</a> <a href="/tags/encoding/" class="post-tag no-text-decoration" >encoding</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: Encoding related changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: Encoding related changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: Encoding related changes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: Encoding related changes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2024/03/16/tidy-first-by-kent-beck" class="btn btn-outline-primary" prompt="Older"><p>Tidy First? by Kent Beck</p></a> <a href="/blog/2024/03/27/move-from-funtamental" class="btn btn-outline-primary" prompt="Newer"><p>Should we move from fundamental types?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: Encoding related changes'; this.page.url = 'https://www.sandordargo.com/blog/2024/03/20/cpp23-encoding-related-changes'; this.page.identifier = '/blog/2024/03/20/cpp23-encoding-related-changes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
