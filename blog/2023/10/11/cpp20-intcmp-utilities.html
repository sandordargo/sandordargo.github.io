<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="How to compare signed and unsigned integers in C++20?" /><meta property="og:locale" content="en_US" /><meta name="description" content="Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with an unsigned integer there are several possible outcomes. It might actually work and you will never know what you risked. Maybe it will not work as you expected and you’ll spend quite some time scratching your head about what just happened. It’s also possible that it will not work according to your expectation but it will go unnoticed. Another option is that you get a compiler warning either by specifically turning on -Wsign-compare or -Wextra. If it’s combined with -Werror, the compilation will even break and you must fix it. In this and the coming two articles, we are going to talk about integer comparisons. Let’s start by checking a bit deeper what can go wrong and then we walk through in detail the C++20 solution. The problem of comparing a signed with an unsigned What are integral types in C++? There are quite a few of them: bool, char, char8_t, char16_t, char32_t, short, int, long, long long, and the unsigned versions of them. Let’s put aside that we can also cv qualify them and that there are a big bunch of implementation-defined types such as uint32_t et al. Even though these are all integrals, bool and char types are not meant to store numbers. We are limiting our focus to short, int, long, long long and their unsigned versions. If you take the signed and unsigned versions of the same type, they are going to occupy the same size in memory. For example, both a short and an unsigned short will need 2 bytes. 2 bytes give us 2**16 possibilities, 2**16 different values to store. Therefore the range of a short is from -2**8 to 2**8-1, while the range of an unsigned short is from 0 to 2**16-1. The bitwise representations of -1 and 4294967295 are the same, but depending on how those two bytes are flagged, their interpretation will be different. Unsigned integers can only carry non-negative numbers, therefore there is no need to reserve a bit for the sign. The least significant bit represents 2^0, the next one 2^1, then 2^2 and so on. On the other hand, a signed integer can hold both negative and positive numbers. To be able to represent all of them, it uses the two’s complement form. The most significant bit represents the sign (0 for positive, 1 for negative numbers) To convert a positive value to its negative counterpart, you invert all the bits and then add 1 But what does this mean in practice? If you try to interpret -1 as an unsigned int - assuming a 4-byte size - the result will be something big, in this case 4294967295. -1 is represented as 111111111’111111111’111111111’111111111 in memory. The first byte shows that we deal with a negative value, then we have to negate everything bitwise and subtract -1 to get the value it stores. By negating bitwise we get 0 and if we subtract -1 we are at -1. But if 111111111&#39;111111111&#39;111111111&#39;111111111 is treated as an unsigned number we simply get the biggest possible positive number that can be represented on 32 bits. This also means that big enough unsigned numbers cannot be represented in 2’s complement form given that the size of the variable stays the same. It’s straightforward given that there is one bit reserved to store the sign of the stored number. This difference in representation makes it potentially unsafe to compare signed and unsigned numbers to each other. To put in code the above, unless you use -Werror the below will compile. If you don’t use -Wextra or -Wsign-compare you won’t even get a warning. 1 2 3 4 5 6 7 8 9 int main() { static_assert(static_cast&lt;unsigned int&gt;(-1) &gt; 42); constexpr int n = -1; constexpr size_t m = 42; static_assert(n &gt; m); return 0; } The modern solution C++20 introduced the so-called “intcmp” functions in the &lt;utility&gt; header to provide a safe way to compare signed and unsigned integers and at the same time get mathematically reasonable results. In other words, they will treat -1 smaller than any non-negative number. First, let’s see what are the available functions and what are their meaning: Function Meaning std::cmp_equal(n, m) n == m std::cmp_not_equal(n, m) n != m std::cmp_less(n, m) n &lt; m std::cmp_greater(n, m) n &gt; m std::cmp_less_equal(n, m) n &lt;= m std::cmp_greater_equal(n, m) n &gt;= m This means that when reading out the function name the relation such as “less” is always compared to the first first parameter. The first parameter is less than or greater than the second. While these functions are only available since C++20, they are easy to backport as they require no new language features (C++17 suffices) and the reference implementation on C++ Reference is good enough. Let me first put here the code and then let’s go through it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Template parameters T and U should be numbers that we can ensure both with concepts or with static assertions */ template&lt;class T, class U&gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t == u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;T&gt;(t) == u; else return u &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;U&gt;(u) == t; } template&lt;class T, class U&gt; constexpr bool cmp_not_equal(T t, U u) noexcept { return !cmp_equal(t, u); } template&lt;class T, class U&gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t &lt; u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u; else return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u); } template&lt;class T, class U&gt; constexpr bool cmp_greater(T t, U u) noexcept { return cmp_less(u, t); } template&lt;class T, class U&gt; constexpr bool cmp_less_equal(T t, U u) noexcept { return !cmp_less(u, t); } template&lt;class T, class U&gt; constexpr bool cmp_greater_equal(T t, U u) noexcept { return !cmp_less(t, u); } We only have to understand cmp_equal and cmp_less as the rest is implemented with the help of these two. cmp_equal Let’s repeat the reference implementation of cmp_equal: 1 2 3 4 5 6 7 8 9 10 template&lt;class T, class U&gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t == u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;T&gt;(t) == u; else return u &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;U&gt;(u) == t; } What we first see when we look at the function is that we use type traits to decide how to perform a comparison: if both numbers are signed or both are unsigned, then we simply check if they are equal or not if only the first parameter is a signed number then we check if it’s non-negative and by casting it to an unsigned type does that equal to the second value if only the second parameter is a signed number, we do the same thing as in the previous case, just by replacing the role of the two parameters. Let’s play with these a bit, what do they mean in practice? Let’s ignore the case when we pass two numbers with the same signedness. If we compare int{-5} and unsigned int{5}, we go to the second branch and we fail on the first condition as t is a negative number. What happens if we pass int{5} and unsigned int {5}. We go to the second branch and the first condition evaluates to true. If we cast int{5} to unsigned int, it will keep its value and we can safely check if they are equal. If we swap the two parameters, we could observe the same set of events. Let’s go to cmp_less, it’s probably more interesting. cmp_less Let’s put here the reference implementation as a reminder: 1 2 3 4 5 6 7 8 9 10 template&lt;class T, class U&gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t &lt; u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u; else return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u); } Again, at first glance, we can see that we have three compile-time if branches based on the signedness of the two parameters. If both are signed or if both are unsigned, we do a simple comparison If only the first one is signed, we check whether it’s a negative number or(!) if we cast it to the unsigned version, is it smaller than u If only the second parameter is signed, then we check whether it’s positive and if it is, then we cast it to unsigned and check if it’s bigger than t This implementation is interesting because the second and third branches follow a different logic. Let’s go through them step by step. If we compare int{-5} and unsigned int{5}, we go to the second branch. t’s type is signed and its value is negative, so we know that it must be smaller than any u as it’s an unsigned value, it cannot be negative. We can stop there, we know that t &lt; u. If we compare int{5} and unsigned int {5}, we still go to the second branch, but as t is non-negative, we can safely cast to its unsigned type and compare it to u. If we compare unsigned int{5} to int{-5}, we go to the third branch. We check if u is non-negative, but it’s not, so we can stop there because we know that t which is unsigned in that case, must be greater. If we compare unsigned int{5} and int {5}, we go again to the second branch. As u is positive, we can safely cast it to its unsigned type and compare it to t. This implementation is safe, smart and correct. And if you go it through and take the time to understand it, it’s also straightforward. But it also shows that probably if you try to do this every time on your own, there is a fair chance that you’ll make some mistakes so it’s better to use the standard version now that we have one. Conclusion In this article, we saw why it’s error-prone to compare two integral numbers with differently signed types and how the same bitwise representations can be interpreted as two completely different numbers. Then we saw that C++20’s intcmp utilities solve this issue and we also had a deep dive into the implementation of these new utility functions. Comparing integers with different signs is not simply error-prone, but depending on your compilation settings it might also emit warnings or even errors. In the next two articles, I’ll share with you what are the most common and most horrendous violations I’ve seen so far while I was trying to remove such warnings over the last few years. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with an unsigned integer there are several possible outcomes. It might actually work and you will never know what you risked. Maybe it will not work as you expected and you’ll spend quite some time scratching your head about what just happened. It’s also possible that it will not work according to your expectation but it will go unnoticed. Another option is that you get a compiler warning either by specifically turning on -Wsign-compare or -Wextra. If it’s combined with -Werror, the compilation will even break and you must fix it. In this and the coming two articles, we are going to talk about integer comparisons. Let’s start by checking a bit deeper what can go wrong and then we walk through in detail the C++20 solution. The problem of comparing a signed with an unsigned What are integral types in C++? There are quite a few of them: bool, char, char8_t, char16_t, char32_t, short, int, long, long long, and the unsigned versions of them. Let’s put aside that we can also cv qualify them and that there are a big bunch of implementation-defined types such as uint32_t et al. Even though these are all integrals, bool and char types are not meant to store numbers. We are limiting our focus to short, int, long, long long and their unsigned versions. If you take the signed and unsigned versions of the same type, they are going to occupy the same size in memory. For example, both a short and an unsigned short will need 2 bytes. 2 bytes give us 2**16 possibilities, 2**16 different values to store. Therefore the range of a short is from -2**8 to 2**8-1, while the range of an unsigned short is from 0 to 2**16-1. The bitwise representations of -1 and 4294967295 are the same, but depending on how those two bytes are flagged, their interpretation will be different. Unsigned integers can only carry non-negative numbers, therefore there is no need to reserve a bit for the sign. The least significant bit represents 2^0, the next one 2^1, then 2^2 and so on. On the other hand, a signed integer can hold both negative and positive numbers. To be able to represent all of them, it uses the two’s complement form. The most significant bit represents the sign (0 for positive, 1 for negative numbers) To convert a positive value to its negative counterpart, you invert all the bits and then add 1 But what does this mean in practice? If you try to interpret -1 as an unsigned int - assuming a 4-byte size - the result will be something big, in this case 4294967295. -1 is represented as 111111111’111111111’111111111’111111111 in memory. The first byte shows that we deal with a negative value, then we have to negate everything bitwise and subtract -1 to get the value it stores. By negating bitwise we get 0 and if we subtract -1 we are at -1. But if 111111111&#39;111111111&#39;111111111&#39;111111111 is treated as an unsigned number we simply get the biggest possible positive number that can be represented on 32 bits. This also means that big enough unsigned numbers cannot be represented in 2’s complement form given that the size of the variable stays the same. It’s straightforward given that there is one bit reserved to store the sign of the stored number. This difference in representation makes it potentially unsafe to compare signed and unsigned numbers to each other. To put in code the above, unless you use -Werror the below will compile. If you don’t use -Wextra or -Wsign-compare you won’t even get a warning. 1 2 3 4 5 6 7 8 9 int main() { static_assert(static_cast&lt;unsigned int&gt;(-1) &gt; 42); constexpr int n = -1; constexpr size_t m = 42; static_assert(n &gt; m); return 0; } The modern solution C++20 introduced the so-called “intcmp” functions in the &lt;utility&gt; header to provide a safe way to compare signed and unsigned integers and at the same time get mathematically reasonable results. In other words, they will treat -1 smaller than any non-negative number. First, let’s see what are the available functions and what are their meaning: Function Meaning std::cmp_equal(n, m) n == m std::cmp_not_equal(n, m) n != m std::cmp_less(n, m) n &lt; m std::cmp_greater(n, m) n &gt; m std::cmp_less_equal(n, m) n &lt;= m std::cmp_greater_equal(n, m) n &gt;= m This means that when reading out the function name the relation such as “less” is always compared to the first first parameter. The first parameter is less than or greater than the second. While these functions are only available since C++20, they are easy to backport as they require no new language features (C++17 suffices) and the reference implementation on C++ Reference is good enough. Let me first put here the code and then let’s go through it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Template parameters T and U should be numbers that we can ensure both with concepts or with static assertions */ template&lt;class T, class U&gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t == u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;T&gt;(t) == u; else return u &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;U&gt;(u) == t; } template&lt;class T, class U&gt; constexpr bool cmp_not_equal(T t, U u) noexcept { return !cmp_equal(t, u); } template&lt;class T, class U&gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t &lt; u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u; else return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u); } template&lt;class T, class U&gt; constexpr bool cmp_greater(T t, U u) noexcept { return cmp_less(u, t); } template&lt;class T, class U&gt; constexpr bool cmp_less_equal(T t, U u) noexcept { return !cmp_less(u, t); } template&lt;class T, class U&gt; constexpr bool cmp_greater_equal(T t, U u) noexcept { return !cmp_less(t, u); } We only have to understand cmp_equal and cmp_less as the rest is implemented with the help of these two. cmp_equal Let’s repeat the reference implementation of cmp_equal: 1 2 3 4 5 6 7 8 9 10 template&lt;class T, class U&gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t == u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;T&gt;(t) == u; else return u &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;U&gt;(u) == t; } What we first see when we look at the function is that we use type traits to decide how to perform a comparison: if both numbers are signed or both are unsigned, then we simply check if they are equal or not if only the first parameter is a signed number then we check if it’s non-negative and by casting it to an unsigned type does that equal to the second value if only the second parameter is a signed number, we do the same thing as in the previous case, just by replacing the role of the two parameters. Let’s play with these a bit, what do they mean in practice? Let’s ignore the case when we pass two numbers with the same signedness. If we compare int{-5} and unsigned int{5}, we go to the second branch and we fail on the first condition as t is a negative number. What happens if we pass int{5} and unsigned int {5}. We go to the second branch and the first condition evaluates to true. If we cast int{5} to unsigned int, it will keep its value and we can safely check if they are equal. If we swap the two parameters, we could observe the same set of events. Let’s go to cmp_less, it’s probably more interesting. cmp_less Let’s put here the reference implementation as a reminder: 1 2 3 4 5 6 7 8 9 10 template&lt;class T, class U&gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t &lt; u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u; else return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u); } Again, at first glance, we can see that we have three compile-time if branches based on the signedness of the two parameters. If both are signed or if both are unsigned, we do a simple comparison If only the first one is signed, we check whether it’s a negative number or(!) if we cast it to the unsigned version, is it smaller than u If only the second parameter is signed, then we check whether it’s positive and if it is, then we cast it to unsigned and check if it’s bigger than t This implementation is interesting because the second and third branches follow a different logic. Let’s go through them step by step. If we compare int{-5} and unsigned int{5}, we go to the second branch. t’s type is signed and its value is negative, so we know that it must be smaller than any u as it’s an unsigned value, it cannot be negative. We can stop there, we know that t &lt; u. If we compare int{5} and unsigned int {5}, we still go to the second branch, but as t is non-negative, we can safely cast to its unsigned type and compare it to u. If we compare unsigned int{5} to int{-5}, we go to the third branch. We check if u is non-negative, but it’s not, so we can stop there because we know that t which is unsigned in that case, must be greater. If we compare unsigned int{5} and int {5}, we go again to the second branch. As u is positive, we can safely cast it to its unsigned type and compare it to t. This implementation is safe, smart and correct. And if you go it through and take the time to understand it, it’s also straightforward. But it also shows that probably if you try to do this every time on your own, there is a fair chance that you’ll make some mistakes so it’s better to use the standard version now that we have one. Conclusion In this article, we saw why it’s error-prone to compare two integral numbers with differently signed types and how the same bitwise representations can be interpreted as two completely different numbers. Then we saw that C++20’s intcmp utilities solve this issue and we also had a deep dive into the implementation of these new utility functions. Comparing integers with different signs is not simply error-prone, but depending on your compilation settings it might also emit warnings or even errors. In the next two articles, I’ll share with you what are the most common and most horrendous violations I’ve seen so far while I was trying to remove such warnings over the last few years. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-10-11T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="How to compare signed and unsigned integers in C++20?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-11T00:00:00+02:00","datePublished":"2023-10-11T00:00:00+02:00","description":"Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with an unsigned integer there are several possible outcomes. It might actually work and you will never know what you risked. Maybe it will not work as you expected and you’ll spend quite some time scratching your head about what just happened. It’s also possible that it will not work according to your expectation but it will go unnoticed. Another option is that you get a compiler warning either by specifically turning on -Wsign-compare or -Wextra. If it’s combined with -Werror, the compilation will even break and you must fix it. In this and the coming two articles, we are going to talk about integer comparisons. Let’s start by checking a bit deeper what can go wrong and then we walk through in detail the C++20 solution. The problem of comparing a signed with an unsigned What are integral types in C++? There are quite a few of them: bool, char, char8_t, char16_t, char32_t, short, int, long, long long, and the unsigned versions of them. Let’s put aside that we can also cv qualify them and that there are a big bunch of implementation-defined types such as uint32_t et al. Even though these are all integrals, bool and char types are not meant to store numbers. We are limiting our focus to short, int, long, long long and their unsigned versions. If you take the signed and unsigned versions of the same type, they are going to occupy the same size in memory. For example, both a short and an unsigned short will need 2 bytes. 2 bytes give us 2**16 possibilities, 2**16 different values to store. Therefore the range of a short is from -2**8 to 2**8-1, while the range of an unsigned short is from 0 to 2**16-1. The bitwise representations of -1 and 4294967295 are the same, but depending on how those two bytes are flagged, their interpretation will be different. Unsigned integers can only carry non-negative numbers, therefore there is no need to reserve a bit for the sign. The least significant bit represents 2^0, the next one 2^1, then 2^2 and so on. On the other hand, a signed integer can hold both negative and positive numbers. To be able to represent all of them, it uses the two’s complement form. The most significant bit represents the sign (0 for positive, 1 for negative numbers) To convert a positive value to its negative counterpart, you invert all the bits and then add 1 But what does this mean in practice? If you try to interpret -1 as an unsigned int - assuming a 4-byte size - the result will be something big, in this case 4294967295. -1 is represented as 111111111’111111111’111111111’111111111 in memory. The first byte shows that we deal with a negative value, then we have to negate everything bitwise and subtract -1 to get the value it stores. By negating bitwise we get 0 and if we subtract -1 we are at -1. But if 111111111&#39;111111111&#39;111111111&#39;111111111 is treated as an unsigned number we simply get the biggest possible positive number that can be represented on 32 bits. This also means that big enough unsigned numbers cannot be represented in 2’s complement form given that the size of the variable stays the same. It’s straightforward given that there is one bit reserved to store the sign of the stored number. This difference in representation makes it potentially unsafe to compare signed and unsigned numbers to each other. To put in code the above, unless you use -Werror the below will compile. If you don’t use -Wextra or -Wsign-compare you won’t even get a warning. 1 2 3 4 5 6 7 8 9 int main() { static_assert(static_cast&lt;unsigned int&gt;(-1) &gt; 42); constexpr int n = -1; constexpr size_t m = 42; static_assert(n &gt; m); return 0; } The modern solution C++20 introduced the so-called “intcmp” functions in the &lt;utility&gt; header to provide a safe way to compare signed and unsigned integers and at the same time get mathematically reasonable results. In other words, they will treat -1 smaller than any non-negative number. First, let’s see what are the available functions and what are their meaning: Function Meaning std::cmp_equal(n, m) n == m std::cmp_not_equal(n, m) n != m std::cmp_less(n, m) n &lt; m std::cmp_greater(n, m) n &gt; m std::cmp_less_equal(n, m) n &lt;= m std::cmp_greater_equal(n, m) n &gt;= m This means that when reading out the function name the relation such as “less” is always compared to the first first parameter. The first parameter is less than or greater than the second. While these functions are only available since C++20, they are easy to backport as they require no new language features (C++17 suffices) and the reference implementation on C++ Reference is good enough. Let me first put here the code and then let’s go through it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 /* Template parameters T and U should be numbers that we can ensure both with concepts or with static assertions */ template&lt;class T, class U&gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t == u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;T&gt;(t) == u; else return u &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;U&gt;(u) == t; } template&lt;class T, class U&gt; constexpr bool cmp_not_equal(T t, U u) noexcept { return !cmp_equal(t, u); } template&lt;class T, class U&gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t &lt; u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u; else return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u); } template&lt;class T, class U&gt; constexpr bool cmp_greater(T t, U u) noexcept { return cmp_less(u, t); } template&lt;class T, class U&gt; constexpr bool cmp_less_equal(T t, U u) noexcept { return !cmp_less(u, t); } template&lt;class T, class U&gt; constexpr bool cmp_greater_equal(T t, U u) noexcept { return !cmp_less(t, u); } We only have to understand cmp_equal and cmp_less as the rest is implemented with the help of these two. cmp_equal Let’s repeat the reference implementation of cmp_equal: 1 2 3 4 5 6 7 8 9 10 template&lt;class T, class U&gt; constexpr bool cmp_equal(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t == u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;T&gt;(t) == u; else return u &gt;= 0 &amp;&amp; std::make_unsigned_t&lt;U&gt;(u) == t; } What we first see when we look at the function is that we use type traits to decide how to perform a comparison: if both numbers are signed or both are unsigned, then we simply check if they are equal or not if only the first parameter is a signed number then we check if it’s non-negative and by casting it to an unsigned type does that equal to the second value if only the second parameter is a signed number, we do the same thing as in the previous case, just by replacing the role of the two parameters. Let’s play with these a bit, what do they mean in practice? Let’s ignore the case when we pass two numbers with the same signedness. If we compare int{-5} and unsigned int{5}, we go to the second branch and we fail on the first condition as t is a negative number. What happens if we pass int{5} and unsigned int {5}. We go to the second branch and the first condition evaluates to true. If we cast int{5} to unsigned int, it will keep its value and we can safely check if they are equal. If we swap the two parameters, we could observe the same set of events. Let’s go to cmp_less, it’s probably more interesting. cmp_less Let’s put here the reference implementation as a reminder: 1 2 3 4 5 6 7 8 9 10 template&lt;class T, class U&gt; constexpr bool cmp_less(T t, U u) noexcept { if constexpr (std::is_signed_v&lt;T&gt; == std::is_signed_v&lt;U&gt;) return t &lt; u; else if constexpr (std::is_signed_v&lt;T&gt;) return t &lt; 0 || std::make_unsigned_t&lt;T&gt;(t) &lt; u; else return u &gt;= 0 &amp;&amp; t &lt; std::make_unsigned_t&lt;U&gt;(u); } Again, at first glance, we can see that we have three compile-time if branches based on the signedness of the two parameters. If both are signed or if both are unsigned, we do a simple comparison If only the first one is signed, we check whether it’s a negative number or(!) if we cast it to the unsigned version, is it smaller than u If only the second parameter is signed, then we check whether it’s positive and if it is, then we cast it to unsigned and check if it’s bigger than t This implementation is interesting because the second and third branches follow a different logic. Let’s go through them step by step. If we compare int{-5} and unsigned int{5}, we go to the second branch. t’s type is signed and its value is negative, so we know that it must be smaller than any u as it’s an unsigned value, it cannot be negative. We can stop there, we know that t &lt; u. If we compare int{5} and unsigned int {5}, we still go to the second branch, but as t is non-negative, we can safely cast to its unsigned type and compare it to u. If we compare unsigned int{5} to int{-5}, we go to the third branch. We check if u is non-negative, but it’s not, so we can stop there because we know that t which is unsigned in that case, must be greater. If we compare unsigned int{5} and int {5}, we go again to the second branch. As u is positive, we can safely cast it to its unsigned type and compare it to t. This implementation is safe, smart and correct. And if you go it through and take the time to understand it, it’s also straightforward. But it also shows that probably if you try to do this every time on your own, there is a fair chance that you’ll make some mistakes so it’s better to use the standard version now that we have one. Conclusion In this article, we saw why it’s error-prone to compare two integral numbers with differently signed types and how the same bitwise representations can be interpreted as two completely different numbers. Then we saw that C++20’s intcmp utilities solve this issue and we also had a deep dive into the implementation of these new utility functions. Comparing integers with different signs is not simply error-prone, but depending on your compilation settings it might also emit warnings or even errors. In the next two articles, I’ll share with you what are the most common and most horrendous violations I’ve seen so far while I was trying to remove such warnings over the last few years. Stay tuned. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"How to compare signed and unsigned integers in C++20?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities"},"url":"https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities"}</script><title>How to compare signed and unsigned integers in C++20? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/11"> 11 </a> </span> <span>How to compare signed and unsigned integers in C++20?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>How to compare signed and unsigned integers in C++20?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 11, 2023, 12:00 AM +0200" prep="on" > Oct 11, 2023 <i class="unloaded">2023-10-11T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1892 words">10 min</span></div></div><div class="post-content"><p>Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers.</p><p>If you try to compare a signed with an unsigned integer there are several possible outcomes. It might actually work and you will never know what you risked. Maybe it will not work as you expected and you’ll spend quite some time scratching your head about what just happened. It’s also possible that it will not work according to your expectation but it will go unnoticed.</p><p>Another option is that you get a compiler warning either by specifically turning on <code class="language-plaintext highlighter-rouge">-Wsign-compare</code> or <code class="language-plaintext highlighter-rouge">-Wextra</code>. If it’s combined with <code class="language-plaintext highlighter-rouge">-Werror</code>, the compilation will even break and you must fix it. In this and the coming two articles, we are going to talk about integer comparisons.</p><p>Let’s start by checking a bit deeper what can go wrong and then we walk through in detail the C++20 solution.</p><h2 id="the-problem-of-comparing-a-signed-with-an-unsigned">The problem of comparing a signed with an unsigned</h2><p>What are integral types in C++?</p><p>There are quite a few of them: <code class="language-plaintext highlighter-rouge">bool</code>, <code class="language-plaintext highlighter-rouge">char</code>, <code class="language-plaintext highlighter-rouge">char8_t</code>, <code class="language-plaintext highlighter-rouge">char16_t</code>, <code class="language-plaintext highlighter-rouge">char32_t</code>, <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">long long</code>, and the unsigned versions of them. Let’s put aside that we can also <em>cv</em> qualify them and that there are a big bunch of implementation-defined types such as <code class="language-plaintext highlighter-rouge">uint32_t</code> et al.</p><p>Even though these are all integrals, <code class="language-plaintext highlighter-rouge">bool</code> and <code class="language-plaintext highlighter-rouge">char</code> types are not meant to store numbers. We are limiting our focus to <code class="language-plaintext highlighter-rouge">short</code>, <code class="language-plaintext highlighter-rouge">int</code>, <code class="language-plaintext highlighter-rouge">long</code>, <code class="language-plaintext highlighter-rouge">long long</code> and their unsigned versions.</p><p>If you take the signed and unsigned versions of the same type, they are going to occupy the same size in memory. For example, both a <code class="language-plaintext highlighter-rouge">short</code> and an <code class="language-plaintext highlighter-rouge">unsigned short</code> will need 2 bytes. 2 bytes give us 2**16 possibilities, 2**16 different values to store. Therefore the range of a short is from -2**8 to 2**8-1, while the range of an <code class="language-plaintext highlighter-rouge">unsigned short</code> is from 0 to 2**16-1.</p><p>The bitwise representations of <em>-1</em> and <em>4294967295</em> are the same, but depending on how those two bytes are flagged, their interpretation will be different. Unsigned integers can only carry non-negative numbers, therefore there is no need to reserve a bit for the sign. The least significant bit represents 2^0, the next one 2^1, then 2^2 and so on.</p><p>On the other hand, a signed integer can hold both negative and positive numbers. To be able to represent all of them, it uses the two’s complement form.</p><ul><li>The most significant bit represents the sign (0 for positive, 1 for negative numbers)<li>To convert a positive value to its negative counterpart, you invert all the bits and then add 1</ul><p>But what does this mean in practice?</p><p>If you try to interpret <em>-1</em> as an <code class="language-plaintext highlighter-rouge">unsigned int</code> - assuming a 4-byte size - the result will be something big, in this case <em>4294967295</em>. <em>-1</em> is represented as <em>111111111’111111111’111111111’111111111</em> in memory. The first byte shows that we deal with a negative value, then we have to negate everything bitwise and subtract -1 to get the value it stores. By negating bitwise we get 0 and if we subtract -1 we are at -1.</p><p>But if <code class="language-plaintext highlighter-rouge">111111111'111111111'111111111'111111111</code> is treated as an unsigned number we simply get the biggest possible positive number that can be represented on 32 bits.</p><p>This also means that big enough unsigned numbers cannot be represented in 2’s complement form given that the size of the variable stays the same. It’s straightforward given that there is one bit reserved to store the sign of the stored number.</p><p>This difference in representation makes it potentially unsafe to compare signed and unsigned numbers to each other.</p><p>To put in code the above, unless you use <code class="language-plaintext highlighter-rouge">-Werror</code> the below will compile. If you don’t use <code class="language-plaintext highlighter-rouge">-Wextra</code> or <code class="language-plaintext highlighter-rouge">-Wsign-compare</code> you won’t even get a warning.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">42</span><span class="p">);</span>

    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">m</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="n">n</span> <span class="o">&gt;</span> <span class="n">m</span><span class="p">);</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="the-modern-solution">The modern solution</h2><p>C++20 introduced the so-called <em>“intcmp”</em> functions in the <code class="language-plaintext highlighter-rouge">&lt;utility&gt;</code> header to provide a safe way to compare signed and unsigned integers and at the same time get mathematically reasonable results. In other words, they will treat <code class="language-plaintext highlighter-rouge">-1</code> smaller than any non-negative number.</p><p>First, let’s see what are the available functions and what are their meaning:</p><div class="table-wrapper"><table><thead><tr><th>Function<th>Meaning<tbody><tr><td>std::cmp_equal(n, m)<td>n == m<tr><td>std::cmp_not_equal(n, m)<td>n != m<tr><td>std::cmp_less(n, m)<td>n &lt; m<tr><td>std::cmp_greater(n, m)<td>n &gt; m<tr><td>std::cmp_less_equal(n, m)<td>n &lt;= m<tr><td>std::cmp_greater_equal(n, m)<td>n &gt;= m</table></div><p>This means that when reading out the function name the relation such as “less” is always compared to the first first parameter. The first parameter is less than or greater than the second.</p><p>While these functions are only available since C++20, they are easy to backport as they require no new language features (C++17 suffices) and the reference implementation on C++ Reference is good enough.</p><p>Let me first put here the code and then let’s go through it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
</pre><td class="rouge-code"><pre><span class="cm">/*
Template parameters T and U should be numbers that we can ensure both with concepts or with static assertions
*/</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">cmp_equal</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">cmp_not_equal</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">cmp_equal</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">cmp_less</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">cmp_greater</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">cmp_less</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">cmp_less_equal</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">cmp_less</span><span class="p">(</span><span class="n">u</span><span class="p">,</span> <span class="n">t</span><span class="p">);</span>
<span class="p">}</span>
 
<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">cmp_greater_equal</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="o">!</span><span class="n">cmp_less</span><span class="p">(</span><span class="n">t</span><span class="p">,</span> <span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We only have to understand <code class="language-plaintext highlighter-rouge">cmp_equal</code> and <code class="language-plaintext highlighter-rouge">cmp_less</code> as the rest is implemented with the help of these two.</p><h3 id="cmp_equal"><code class="language-plaintext highlighter-rouge">cmp_equal</code></h3><p>Let’s repeat the reference implementation of <code class="language-plaintext highlighter-rouge">cmp_equal</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">cmp_equal</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">==</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">==</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="o">==</span> <span class="n">t</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>What we first see when we look at the function is that we use type traits to decide how to perform a comparison:</p><ul><li>if both numbers are signed or both are unsigned, then we simply check if they are equal or not<li>if only the first parameter is a signed number then we check if it’s non-negative and by casting it to an unsigned type does that equal to the second value<li>if only the second parameter is a signed number, we do the same thing as in the previous case, just by replacing the role of the two parameters.</ul><p>Let’s play with these a bit, what do they mean in practice?</p><p>Let’s ignore the case when we pass two numbers with the same signedness.</p><p>If we compare <code class="language-plaintext highlighter-rouge">int{-5}</code> and <code class="language-plaintext highlighter-rouge">unsigned int{5}</code>, we go to the second branch and we fail on the first condition as <code class="language-plaintext highlighter-rouge">t</code> is a negative number.</p><p>What happens if we pass <code class="language-plaintext highlighter-rouge">int{5}</code> and <code class="language-plaintext highlighter-rouge">unsigned int {5}</code>. We go to the second branch and the first condition evaluates to <code class="language-plaintext highlighter-rouge">true</code>. If we cast <code class="language-plaintext highlighter-rouge">int{5}</code> to <code class="language-plaintext highlighter-rouge">unsigned int</code>, it will keep its value and we can safely check if they are equal.</p><p>If we swap the two parameters, we could observe the same set of events.</p><p>Let’s go to <code class="language-plaintext highlighter-rouge">cmp_less</code>, it’s probably more interesting.</p><h3 id="cmp_less"><code class="language-plaintext highlighter-rouge">cmp_less</code></h3><p>Let’s put here the reference implementation as a reminder:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">U</span><span class="p">&gt;</span>
<span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">cmp_less</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">,</span> <span class="n">U</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">==</span> <span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span> <span class="k">if</span> <span class="k">constexpr</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_signed_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">||</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">u</span><span class="p">;</span>
    <span class="k">else</span>
        <span class="k">return</span> <span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unsigned_t</span><span class="o">&lt;</span><span class="n">U</span><span class="o">&gt;</span><span class="p">(</span><span class="n">u</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Again, at first glance, we can see that we have three compile-time <code class="language-plaintext highlighter-rouge">if</code> branches based on the signedness of the two parameters.</p><ul><li>If both are signed or if both are unsigned, we do a simple comparison<li>If only the first one is signed, we check whether it’s a negative number or(!) if we cast it to the unsigned version, is it smaller than <code class="language-plaintext highlighter-rouge">u</code><li>If only the second parameter is signed, then we check whether it’s positive and if it is, then we cast it to unsigned and check if it’s bigger than <code class="language-plaintext highlighter-rouge">t</code></ul><p>This implementation is interesting because the second and third branches follow a different logic.</p><p>Let’s go through them step by step.</p><p>If we compare <code class="language-plaintext highlighter-rouge">int{-5}</code> and <code class="language-plaintext highlighter-rouge">unsigned int{5}</code>, we go to the second branch. <code class="language-plaintext highlighter-rouge">t</code>’s type is signed and its value is negative, so we know that it must be smaller than any <code class="language-plaintext highlighter-rouge">u</code> as it’s an unsigned value, it cannot be negative. We can stop there, we know that <code class="language-plaintext highlighter-rouge">t &lt; u</code>.</p><p>If we compare <code class="language-plaintext highlighter-rouge">int{5}</code> and <code class="language-plaintext highlighter-rouge">unsigned int {5}</code>, we still go to the second branch, but as <code class="language-plaintext highlighter-rouge">t</code> is non-negative, we can safely cast to its unsigned type and compare it to <code class="language-plaintext highlighter-rouge">u</code>.</p><p>If we compare <code class="language-plaintext highlighter-rouge">unsigned int{5}</code> to <code class="language-plaintext highlighter-rouge">int{-5}</code>, we go to the third branch. We check if <code class="language-plaintext highlighter-rouge">u</code> is non-negative, but it’s not, so we can stop there because we know that <code class="language-plaintext highlighter-rouge">t</code> which is unsigned in that case, must be greater.</p><p>If we compare <code class="language-plaintext highlighter-rouge">unsigned int{5}</code> and <code class="language-plaintext highlighter-rouge">int {5}</code>, we go again to the second branch. As <code class="language-plaintext highlighter-rouge">u</code> is positive, we can safely cast it to its unsigned type and compare it to <code class="language-plaintext highlighter-rouge">t</code>.</p><p>This implementation is safe, smart and correct. And if you go it through and take the time to understand it, it’s also straightforward. But it also shows that probably if you try to do this every time on your own, there is a fair chance that you’ll make some mistakes so <a href="https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms">it’s better to use the standard version</a> now that we have one.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we saw why it’s error-prone to compare two integral numbers with differently signed types and how the same bitwise representations can be interpreted as two completely different numbers. Then we saw that C++20’s <em>intcmp</em> utilities solve this issue and we also had a deep dive into the implementation of these new utility functions.</p><p>Comparing integers with different signs is not simply error-prone, but depending on your compilation settings it might also emit warnings or even errors. In the next two articles, I’ll share with you what are the most common and most horrendous violations I’ve seen so far while I was trying to remove such warnings over the last few years.</p><p>Stay tuned.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/cleancode/" class="post-tag no-text-decoration" >cleancode</a> <a href="/tags/integercomparison/" class="post-tag no-text-decoration" >integercomparison</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=How to compare signed and unsigned integers in C++20? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=How to compare signed and unsigned integers in C++20? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=How to compare signed and unsigned integers in C++20? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=How to compare signed and unsigned integers in C++20? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/10/04/trip-report-dev-talks-cluj-2023"><div class="card-body"> <span class="timeago small" > Oct 4, 2023 <i class="unloaded">2023-10-04T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: Dev Talks Cluj 2023</h3><div class="text-muted small"><p> The last week of September I had the honour to share my thoughts in the heart of Transylvania about clean code and software quality at DevTalks Cluj. Over the last few years, DevTalks became a succ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations"><div class="card-body"> <span class="timeago small" > Oct 18, 2023 <i class="unloaded">2023-10-18T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My battle against signed/unsigned comparison: the most usual violations</h3><div class="text-muted small"><p> As we discussed last week, comparing numbers with different signs can be dangerous in C++. If you try to compare a signed with an unsigned integer, you might get a result that makes no sense if you...</p></div></div></a></div><div class="card"> <a href="/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations"><div class="card-body"> <span class="timeago small" > Oct 25, 2023 <i class="unloaded">2023-10-25T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My battle against signed/unsigned comparison: the worst violations</h3><div class="text-muted small"><p> We spent the last two weeks discussing the dangers of signed/unsigned comparisons. First, we discussed why it’s a problem in the first place, and how we can safely compare signed and unsigned types...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/10/04/trip-report-dev-talks-cluj-2023" class="btn btn-outline-primary" prompt="Older"><p>Trip report: Dev Talks Cluj 2023</p></a> <a href="/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" class="btn btn-outline-primary" prompt="Newer"><p>My battle against signed/unsigned comparison: the most usual violations</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'How to compare signed and unsigned integers in C++20?'; this.page.url = 'https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities'; this.page.identifier = '/blog/2023/10/11/cpp20-intcmp-utilities'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
