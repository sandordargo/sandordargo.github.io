<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="My battle against signed/unsigned comparison: the worst violations" /><meta property="og:locale" content="en_US" /><meta name="description" content="We spent the last two weeks discussing the dangers of signed/unsigned comparisons. First, we discussed why it’s a problem in the first place, and how we can safely compare signed and unsigned types to each other, then I shared with you which are the most common ways -Wsign-compare is violated. This week, let me share with you the strangest violations. The worst offenders, the things I didn’t want to see. (Obviously I simplified and anonymized the examples) Comparing enumerations with the wrong sign The following example is bleeding from several wounds. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;random&gt; enum TheChoice { A, B, C, D, EMPTY_CHOICE = -1 }; unsigned int choose() { std::random_device dev; std::mt19937 rng(dev()); std::uniform_int_distribution&lt;std::mt19937::result_type&gt; dist4(0,3); return dist4(rng); } int main() { if (choose() == EMPTY_CHOICE) { std::cout &lt;&lt; &quot;Oh boy, do we have some problem?\n&quot;; } // ... return 0; } We have an enum which is not a modern enum class and one of the enumerators has the value -1 to represent a kind of error state. Then we have a function that returns an unsigned int. And then the enum is compared to the unsigned int. Let alone that they can never be equal, that also generates a compiler warning. Ideally, you would fix this by choose() returning an enumerator and it’d be also nice to turn the TheChoice to an enum class. If that doesn’t work, you could still match the types, either by modifying TheChoice so that its underlying value is an unsigned int and with that EMPTY_CHOICE must get a new value or by updating the return type of choose() to an int. If none of those is an option, you can fall back to the new integer comparison utilities. But as you cannot use std::cmp_* to compare an int and an enum, you must cast the enum to its underlying type. 1 2 if (std::cmp_equal(choose(), static_cast&lt;std::underlying_type_t&lt;TheChoice&gt;&gt;(EMPTY_CHOICE))) You could also simply static_cast to int without accessing the underlying type with std::underlying_type_t. Relying on narrowing an unsigned value The following one took me some time even understand why it can actually work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; class Resource { public: long /* originally ssize_t */ getSize() const { return 42; } private: // ... }; std::unique_ptr&lt;Resource&gt; getResource() { return std::make_unique&lt;Resource&gt;(); } int main() { auto resource = getResource(); if (!resource) { return 0; } if (const auto size = resource-&gt;getSize(); size != static_cast&lt;size_t&gt;(-1)) { // perform something } // ... return 0; } Let’s concentrate on main(). What on Earth goes on here?! First, we get a resource that is a - unique - pointer. Then within the if statement’s condition we first get the size of the resource and save it in the size variable (we can do this since C++17), and then we compare it to -1 after it’s statically casted to an unsigned value. First I thought that this comparison would always be true as the two sides cannot be equal but I was wrong. Let’s break this down. The variable size has the type of const long - that’s usually the type behind ssize_t. On the other side, we have -1 that is casted to a size_t. That is std::numeric_limits&lt;size_t&gt;::max() which is the same as std::numeric_limits&lt;unsigned long&gt;::max(). The compiler will implicitly cast the long on the left side to an unsigned long (size_t). long and unsigned long have the same ranks when it comes to integer promotions, but the rule says that when “the unsigned type has conversion rank greater than or equal to the rank of the signed type, then the operand with the signed type is implicitly converted to the unsigned type.” Overall, it’s possible that on both sides we have -1 converted to unsigned long. Quite overcomplicated. Well, that’s life. Now how can we get rid of this mayhem? The simplest answer is to just compare a signed value to another signed value! 1 if (const auto size = resource-&gt;getSize(); size != -1) This will be just good enough. But I was wondering why someone wrote such code? Originally, the code looked like this - I omit the class and function definitions: 1 2 3 4 5 6 7 8 9 int main() { auto resource = getResource(); auto size = resource ? resource-&gt;getSize() : -1; if (size != static_cast&lt;size_t&gt;(-1)) { // perform something } // ... return 0; } Before C++17, size had to be declared and initialized before the if statement. It was the result of a ternary and its type was long as both -1 and resource-&gt;getSize() return a signed value and ssize_t has a higher rank so -1 would be promoted to a long. size could be set to -1 in case the resource is not available. In other words, we use -1 to handle an error case, the unavailability of a resource. Not the best solution, but it’s nothing horrendous. After C++17, the declaration of size was pulled into the conditional and a guard clause was added to return early if resource is not available. The reason why -1 was left there is because getSize() returned a ssize_t. But after further analysis, it turned out that it never returned a signed value, it actually always returned something that would fit size_t. The correct solution was to change the return type of getSize() and remove the condition completely as the guard clause already covered the error case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; class Resource { public: long /* originally ssize_t */ getSize() const { return 42; } private: // ... }; std::unique_ptr&lt;Resource&gt; getResource() { return std::make_unique&lt;Resource&gt;(); } int main() { auto resource = getResource(); if (!resource) { return 0; } // perform something that was previously conditional // ... return 0; } The moral of the story? When you modernize code, don’t just blindly do it, but have a deeper look, because you might be able to further simplify it. Explicit C-cast to the wrong type This last one is very easy to fix and the code becomes more readable. Check this piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; class Container { public: int length() const { return 42; } }; int main() { Container c; int someOffset = 39; for (int i = 0; i &lt; c.length(); ++i) { if ((unsigned int)(i + someOffset) &lt; c.length()) { std::cout &lt;&lt; &quot;We are still below c.length()\n&quot;; } } return 0; } In the body of the for-loop there is a conditional where i + someOffset is casted to an unsigned int. While it’s problematic in 2023 to use a C-style cast, that’s not our biggest issue here. The type of that expression is int and on the other side of the comparison there is a function call that also returns an int. There is no reason for that cast so the fix is as easy as removing it. 1 2 3 // ... if ((i + someOffset) &lt; c.length()) { // ... As you can see, I didn’t even bother to remove the parentheses around i + someOffset because I think it enhances readability. I was thinking for a while why some code like that might have been introduced. My best guess is that Container::length() returned unsigned int or size_t one day but when it was updated for whatever reason, the usages were not checked. Conclusion In this third and last article of the signed/unsigned comparison mini-series, I shared with you the three strangest cases of -Wsign-compare violations. While std::cmp_* often comes in handy, most of the time there is a better solution. Often we can simplify and correct the code which is always preferable as long as the solution is correct. Do you care about -Wsign-compare? If so, how do you deal with it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="We spent the last two weeks discussing the dangers of signed/unsigned comparisons. First, we discussed why it’s a problem in the first place, and how we can safely compare signed and unsigned types to each other, then I shared with you which are the most common ways -Wsign-compare is violated. This week, let me share with you the strangest violations. The worst offenders, the things I didn’t want to see. (Obviously I simplified and anonymized the examples) Comparing enumerations with the wrong sign The following example is bleeding from several wounds. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;random&gt; enum TheChoice { A, B, C, D, EMPTY_CHOICE = -1 }; unsigned int choose() { std::random_device dev; std::mt19937 rng(dev()); std::uniform_int_distribution&lt;std::mt19937::result_type&gt; dist4(0,3); return dist4(rng); } int main() { if (choose() == EMPTY_CHOICE) { std::cout &lt;&lt; &quot;Oh boy, do we have some problem?\n&quot;; } // ... return 0; } We have an enum which is not a modern enum class and one of the enumerators has the value -1 to represent a kind of error state. Then we have a function that returns an unsigned int. And then the enum is compared to the unsigned int. Let alone that they can never be equal, that also generates a compiler warning. Ideally, you would fix this by choose() returning an enumerator and it’d be also nice to turn the TheChoice to an enum class. If that doesn’t work, you could still match the types, either by modifying TheChoice so that its underlying value is an unsigned int and with that EMPTY_CHOICE must get a new value or by updating the return type of choose() to an int. If none of those is an option, you can fall back to the new integer comparison utilities. But as you cannot use std::cmp_* to compare an int and an enum, you must cast the enum to its underlying type. 1 2 if (std::cmp_equal(choose(), static_cast&lt;std::underlying_type_t&lt;TheChoice&gt;&gt;(EMPTY_CHOICE))) You could also simply static_cast to int without accessing the underlying type with std::underlying_type_t. Relying on narrowing an unsigned value The following one took me some time even understand why it can actually work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; class Resource { public: long /* originally ssize_t */ getSize() const { return 42; } private: // ... }; std::unique_ptr&lt;Resource&gt; getResource() { return std::make_unique&lt;Resource&gt;(); } int main() { auto resource = getResource(); if (!resource) { return 0; } if (const auto size = resource-&gt;getSize(); size != static_cast&lt;size_t&gt;(-1)) { // perform something } // ... return 0; } Let’s concentrate on main(). What on Earth goes on here?! First, we get a resource that is a - unique - pointer. Then within the if statement’s condition we first get the size of the resource and save it in the size variable (we can do this since C++17), and then we compare it to -1 after it’s statically casted to an unsigned value. First I thought that this comparison would always be true as the two sides cannot be equal but I was wrong. Let’s break this down. The variable size has the type of const long - that’s usually the type behind ssize_t. On the other side, we have -1 that is casted to a size_t. That is std::numeric_limits&lt;size_t&gt;::max() which is the same as std::numeric_limits&lt;unsigned long&gt;::max(). The compiler will implicitly cast the long on the left side to an unsigned long (size_t). long and unsigned long have the same ranks when it comes to integer promotions, but the rule says that when “the unsigned type has conversion rank greater than or equal to the rank of the signed type, then the operand with the signed type is implicitly converted to the unsigned type.” Overall, it’s possible that on both sides we have -1 converted to unsigned long. Quite overcomplicated. Well, that’s life. Now how can we get rid of this mayhem? The simplest answer is to just compare a signed value to another signed value! 1 if (const auto size = resource-&gt;getSize(); size != -1) This will be just good enough. But I was wondering why someone wrote such code? Originally, the code looked like this - I omit the class and function definitions: 1 2 3 4 5 6 7 8 9 int main() { auto resource = getResource(); auto size = resource ? resource-&gt;getSize() : -1; if (size != static_cast&lt;size_t&gt;(-1)) { // perform something } // ... return 0; } Before C++17, size had to be declared and initialized before the if statement. It was the result of a ternary and its type was long as both -1 and resource-&gt;getSize() return a signed value and ssize_t has a higher rank so -1 would be promoted to a long. size could be set to -1 in case the resource is not available. In other words, we use -1 to handle an error case, the unavailability of a resource. Not the best solution, but it’s nothing horrendous. After C++17, the declaration of size was pulled into the conditional and a guard clause was added to return early if resource is not available. The reason why -1 was left there is because getSize() returned a ssize_t. But after further analysis, it turned out that it never returned a signed value, it actually always returned something that would fit size_t. The correct solution was to change the return type of getSize() and remove the condition completely as the guard clause already covered the error case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; class Resource { public: long /* originally ssize_t */ getSize() const { return 42; } private: // ... }; std::unique_ptr&lt;Resource&gt; getResource() { return std::make_unique&lt;Resource&gt;(); } int main() { auto resource = getResource(); if (!resource) { return 0; } // perform something that was previously conditional // ... return 0; } The moral of the story? When you modernize code, don’t just blindly do it, but have a deeper look, because you might be able to further simplify it. Explicit C-cast to the wrong type This last one is very easy to fix and the code becomes more readable. Check this piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; class Container { public: int length() const { return 42; } }; int main() { Container c; int someOffset = 39; for (int i = 0; i &lt; c.length(); ++i) { if ((unsigned int)(i + someOffset) &lt; c.length()) { std::cout &lt;&lt; &quot;We are still below c.length()\n&quot;; } } return 0; } In the body of the for-loop there is a conditional where i + someOffset is casted to an unsigned int. While it’s problematic in 2023 to use a C-style cast, that’s not our biggest issue here. The type of that expression is int and on the other side of the comparison there is a function call that also returns an int. There is no reason for that cast so the fix is as easy as removing it. 1 2 3 // ... if ((i + someOffset) &lt; c.length()) { // ... As you can see, I didn’t even bother to remove the parentheses around i + someOffset because I think it enhances readability. I was thinking for a while why some code like that might have been introduced. My best guess is that Container::length() returned unsigned int or size_t one day but when it was updated for whatever reason, the usages were not checked. Conclusion In this third and last article of the signed/unsigned comparison mini-series, I shared with you the three strangest cases of -Wsign-compare violations. While std::cmp_* often comes in handy, most of the time there is a better solution. Often we can simplify and correct the code which is always preferable as long as the solution is correct. Do you care about -Wsign-compare? If so, how do you deal with it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-10-25T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="My battle against signed/unsigned comparison: the worst violations" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-25T00:00:00+02:00","datePublished":"2023-10-25T00:00:00+02:00","description":"We spent the last two weeks discussing the dangers of signed/unsigned comparisons. First, we discussed why it’s a problem in the first place, and how we can safely compare signed and unsigned types to each other, then I shared with you which are the most common ways -Wsign-compare is violated. This week, let me share with you the strangest violations. The worst offenders, the things I didn’t want to see. (Obviously I simplified and anonymized the examples) Comparing enumerations with the wrong sign The following example is bleeding from several wounds. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;random&gt; enum TheChoice { A, B, C, D, EMPTY_CHOICE = -1 }; unsigned int choose() { std::random_device dev; std::mt19937 rng(dev()); std::uniform_int_distribution&lt;std::mt19937::result_type&gt; dist4(0,3); return dist4(rng); } int main() { if (choose() == EMPTY_CHOICE) { std::cout &lt;&lt; &quot;Oh boy, do we have some problem?\\n&quot;; } // ... return 0; } We have an enum which is not a modern enum class and one of the enumerators has the value -1 to represent a kind of error state. Then we have a function that returns an unsigned int. And then the enum is compared to the unsigned int. Let alone that they can never be equal, that also generates a compiler warning. Ideally, you would fix this by choose() returning an enumerator and it’d be also nice to turn the TheChoice to an enum class. If that doesn’t work, you could still match the types, either by modifying TheChoice so that its underlying value is an unsigned int and with that EMPTY_CHOICE must get a new value or by updating the return type of choose() to an int. If none of those is an option, you can fall back to the new integer comparison utilities. But as you cannot use std::cmp_* to compare an int and an enum, you must cast the enum to its underlying type. 1 2 if (std::cmp_equal(choose(), static_cast&lt;std::underlying_type_t&lt;TheChoice&gt;&gt;(EMPTY_CHOICE))) You could also simply static_cast to int without accessing the underlying type with std::underlying_type_t. Relying on narrowing an unsigned value The following one took me some time even understand why it can actually work. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; class Resource { public: long /* originally ssize_t */ getSize() const { return 42; } private: // ... }; std::unique_ptr&lt;Resource&gt; getResource() { return std::make_unique&lt;Resource&gt;(); } int main() { auto resource = getResource(); if (!resource) { return 0; } if (const auto size = resource-&gt;getSize(); size != static_cast&lt;size_t&gt;(-1)) { // perform something } // ... return 0; } Let’s concentrate on main(). What on Earth goes on here?! First, we get a resource that is a - unique - pointer. Then within the if statement’s condition we first get the size of the resource and save it in the size variable (we can do this since C++17), and then we compare it to -1 after it’s statically casted to an unsigned value. First I thought that this comparison would always be true as the two sides cannot be equal but I was wrong. Let’s break this down. The variable size has the type of const long - that’s usually the type behind ssize_t. On the other side, we have -1 that is casted to a size_t. That is std::numeric_limits&lt;size_t&gt;::max() which is the same as std::numeric_limits&lt;unsigned long&gt;::max(). The compiler will implicitly cast the long on the left side to an unsigned long (size_t). long and unsigned long have the same ranks when it comes to integer promotions, but the rule says that when “the unsigned type has conversion rank greater than or equal to the rank of the signed type, then the operand with the signed type is implicitly converted to the unsigned type.” Overall, it’s possible that on both sides we have -1 converted to unsigned long. Quite overcomplicated. Well, that’s life. Now how can we get rid of this mayhem? The simplest answer is to just compare a signed value to another signed value! 1 if (const auto size = resource-&gt;getSize(); size != -1) This will be just good enough. But I was wondering why someone wrote such code? Originally, the code looked like this - I omit the class and function definitions: 1 2 3 4 5 6 7 8 9 int main() { auto resource = getResource(); auto size = resource ? resource-&gt;getSize() : -1; if (size != static_cast&lt;size_t&gt;(-1)) { // perform something } // ... return 0; } Before C++17, size had to be declared and initialized before the if statement. It was the result of a ternary and its type was long as both -1 and resource-&gt;getSize() return a signed value and ssize_t has a higher rank so -1 would be promoted to a long. size could be set to -1 in case the resource is not available. In other words, we use -1 to handle an error case, the unavailability of a resource. Not the best solution, but it’s nothing horrendous. After C++17, the declaration of size was pulled into the conditional and a guard clause was added to return early if resource is not available. The reason why -1 was left there is because getSize() returned a ssize_t. But after further analysis, it turned out that it never returned a signed value, it actually always returned something that would fit size_t. The correct solution was to change the return type of getSize() and remove the condition completely as the guard clause already covered the error case. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;utility&gt; class Resource { public: long /* originally ssize_t */ getSize() const { return 42; } private: // ... }; std::unique_ptr&lt;Resource&gt; getResource() { return std::make_unique&lt;Resource&gt;(); } int main() { auto resource = getResource(); if (!resource) { return 0; } // perform something that was previously conditional // ... return 0; } The moral of the story? When you modernize code, don’t just blindly do it, but have a deeper look, because you might be able to further simplify it. Explicit C-cast to the wrong type This last one is very easy to fix and the code becomes more readable. Check this piece of code: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; class Container { public: int length() const { return 42; } }; int main() { Container c; int someOffset = 39; for (int i = 0; i &lt; c.length(); ++i) { if ((unsigned int)(i + someOffset) &lt; c.length()) { std::cout &lt;&lt; &quot;We are still below c.length()\\n&quot;; } } return 0; } In the body of the for-loop there is a conditional where i + someOffset is casted to an unsigned int. While it’s problematic in 2023 to use a C-style cast, that’s not our biggest issue here. The type of that expression is int and on the other side of the comparison there is a function call that also returns an int. There is no reason for that cast so the fix is as easy as removing it. 1 2 3 // ... if ((i + someOffset) &lt; c.length()) { // ... As you can see, I didn’t even bother to remove the parentheses around i + someOffset because I think it enhances readability. I was thinking for a while why some code like that might have been introduced. My best guess is that Container::length() returned unsigned int or size_t one day but when it was updated for whatever reason, the usages were not checked. Conclusion In this third and last article of the signed/unsigned comparison mini-series, I shared with you the three strangest cases of -Wsign-compare violations. While std::cmp_* often comes in handy, most of the time there is a better solution. Often we can simplify and correct the code which is always preferable as long as the solution is correct. Do you care about -Wsign-compare? If so, how do you deal with it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"My battle against signed/unsigned comparison: the worst violations","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations"},"url":"https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations"}</script><title>My battle against signed/unsigned comparison: the worst violations | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/25"> 25 </a> </span> <span>My battle against signed/unsigned comparison: the worst violations</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>My battle against signed/unsigned comparison: the worst violations</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 25, 2023, 12:00 AM +0200" prep="on" > Oct 25, 2023 <i class="unloaded">2023-10-25T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1406 words">7 min</span></div></div><div class="post-content"><p>We spent the last two weeks discussing the dangers of signed/unsigned comparisons. First, we discussed why it’s a problem in the first place, and <a href="https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities">how we can safely compare signed and unsigned types to each other</a>, then I shared with you which are <a href="https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations">the most common ways <code class="language-plaintext highlighter-rouge">-Wsign-compare</code> is violated</a>.</p><p>This week, let me share with you the strangest violations. The worst offenders, the things I didn’t want to see.</p><p><em>(Obviously I simplified and anonymized the examples)</em></p><h2 id="comparing-enumerations-with-the-wrong-sign">Comparing enumerations with the wrong sign</h2><p>The following example is bleeding from several wounds.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;random&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">TheChoice</span> <span class="p">{</span>
    <span class="n">A</span><span class="p">,</span>
    <span class="n">B</span><span class="p">,</span>
    <span class="n">C</span><span class="p">,</span>
    <span class="n">D</span><span class="p">,</span>
    <span class="n">EMPTY_CHOICE</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
<span class="p">};</span>


<span class="kt">unsigned</span> <span class="kt">int</span> <span class="nf">choose</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">random_device</span> <span class="n">dev</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">mt19937</span> <span class="n">rng</span><span class="p">(</span><span class="n">dev</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">uniform_int_distribution</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">mt19937</span><span class="o">::</span><span class="n">result_type</span><span class="o">&gt;</span> <span class="n">dist4</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">3</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">dist4</span><span class="p">(</span><span class="n">rng</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">choose</span><span class="p">()</span> <span class="o">==</span> <span class="n">EMPTY_CHOICE</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Oh boy, do we have some problem?</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>We have an <code class="language-plaintext highlighter-rouge">enum</code> which is not a modern <code class="language-plaintext highlighter-rouge">enum class</code> and one of the enumerators has the value <code class="language-plaintext highlighter-rouge">-1</code> to represent a kind of error state.</p><p>Then we have a function that returns an <code class="language-plaintext highlighter-rouge">unsigned int</code>.</p><p>And then the <code class="language-plaintext highlighter-rouge">enum</code> is compared to the <code class="language-plaintext highlighter-rouge">unsigned int</code>. Let alone that they can never be equal, that also generates a compiler warning.</p><p>Ideally, you would fix this by <code class="language-plaintext highlighter-rouge">choose()</code> returning an enumerator and it’d be also nice to turn the <code class="language-plaintext highlighter-rouge">TheChoice</code> to an <code class="language-plaintext highlighter-rouge">enum class</code>.</p><p>If that doesn’t work, you could still match the types, either by modifying <code class="language-plaintext highlighter-rouge">TheChoice</code> so that its underlying value is an unsigned int and with that <code class="language-plaintext highlighter-rouge">EMPTY_CHOICE</code> must get a new value or by updating the return type of <code class="language-plaintext highlighter-rouge">choose()</code> to an <code class="language-plaintext highlighter-rouge">int</code>.</p><p>If none of those is an option, you can fall back to the new integer comparison utilities. But as you cannot use <code class="language-plaintext highlighter-rouge">std::cmp_*</code> to compare an <code class="language-plaintext highlighter-rouge">int</code> and an <code class="language-plaintext highlighter-rouge">enum</code>, you must cast the enum to its underlying type.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">cmp_equal</span><span class="p">(</span><span class="n">choose</span><span class="p">(),</span> 
                   <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">TheChoice</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">EMPTY_CHOICE</span><span class="p">)))</span> 
</pre></table></code></div></div><p>You could also simply <code class="language-plaintext highlighter-rouge">static_cast</code> to <code class="language-plaintext highlighter-rouge">int</code> without accessing the underlying type with <code class="language-plaintext highlighter-rouge">std::underlying_type_t</code>.</p><h2 id="relying-on-narrowing-an-unsigned-value">Relying on narrowing an unsigned value</h2><p>The following one took me some time even understand why it can actually work.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>

<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="kt">long</span> <span class="cm">/* originally ssize_t */</span> <span class="n">getSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span> 
 <span class="k">private</span><span class="o">:</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">getResource</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">getResource</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="n">size</span> <span class="o">!=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// perform something        </span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Let’s concentrate on <code class="language-plaintext highlighter-rouge">main()</code>. What on Earth goes on here?! First, we get a resource that is a - unique - pointer. Then within the <code class="language-plaintext highlighter-rouge">if</code> statement’s condition we first get the size of the resource and save it in the <code class="language-plaintext highlighter-rouge">size</code> variable (we can do this since C++17), and then we compare it to <code class="language-plaintext highlighter-rouge">-1</code> after it’s statically casted to an unsigned value.</p><p>First I thought that this comparison would always be true as the two sides cannot be equal but I was wrong.</p><p>Let’s break this down.</p><p>The variable <code class="language-plaintext highlighter-rouge">size</code> has the type of <code class="language-plaintext highlighter-rouge">const long</code> - that’s usually the type behind <code class="language-plaintext highlighter-rouge">ssize_t</code>. On the other side, we have <code class="language-plaintext highlighter-rouge">-1</code> that is casted to a <code class="language-plaintext highlighter-rouge">size_t</code>. That is <code class="language-plaintext highlighter-rouge">std::numeric_limits&lt;size_t&gt;::max()</code> which is the same as <code class="language-plaintext highlighter-rouge">std::numeric_limits&lt;unsigned long&gt;::max()</code>.</p><p>The compiler will implicitly cast the <code class="language-plaintext highlighter-rouge">long</code> on the left side to an <code class="language-plaintext highlighter-rouge">unsigned long</code> (<code class="language-plaintext highlighter-rouge">size_t</code>). <code class="language-plaintext highlighter-rouge">long</code> and <code class="language-plaintext highlighter-rouge">unsigned long</code> have the same ranks when it comes to integer promotions, but the rule says that when “the unsigned type has conversion rank greater than or equal to the rank of the signed type, then the operand with the signed type is implicitly converted to the unsigned type.”</p><p>Overall, it’s possible that on both sides we have -1 converted to <code class="language-plaintext highlighter-rouge">unsigned long</code>.</p><p>Quite overcomplicated.</p><p>Well, that’s life.</p><p>Now how can we get rid of this mayhem?</p><p>The simplest answer is to just compare a signed value to another signed value!</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">();</span> <span class="n">size</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
</pre></table></code></div></div><p>This will be just good enough.</p><p>But I was wondering why someone wrote such code?</p><p>Originally, the code looked like this - I omit the class and function definitions:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">getResource</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">size</span> <span class="o">=</span> <span class="n">resource</span> <span class="o">?</span> <span class="n">resource</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">()</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">!=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// perform something        </span>
    <span class="p">}</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Before C++17, <code class="language-plaintext highlighter-rouge">size</code> had to be declared and initialized before the <code class="language-plaintext highlighter-rouge">if</code> statement. It was the result of a ternary and its type was <code class="language-plaintext highlighter-rouge">long</code> as both <code class="language-plaintext highlighter-rouge">-1</code> and <code class="language-plaintext highlighter-rouge">resource-&gt;getSize()</code> return a signed value and <code class="language-plaintext highlighter-rouge">ssize_t</code> has a higher rank so <code class="language-plaintext highlighter-rouge">-1</code> would be promoted to a <code class="language-plaintext highlighter-rouge">long</code>.</p><p><code class="language-plaintext highlighter-rouge">size</code> could be set to <code class="language-plaintext highlighter-rouge">-1</code> in case the resource is not available. In other words, we use <code class="language-plaintext highlighter-rouge">-1</code> to handle an error case, the unavailability of a resource. Not the best solution, but it’s nothing horrendous.</p><p>After C++17, the declaration of size was pulled into the conditional and a guard clause was added to return early if <code class="language-plaintext highlighter-rouge">resource</code> is not available.</p><p>The reason why <code class="language-plaintext highlighter-rouge">-1</code> was left there is because <code class="language-plaintext highlighter-rouge">getSize()</code> returned a <code class="language-plaintext highlighter-rouge">ssize_t</code>. But after further analysis, it turned out that it never returned a signed value, it actually always returned something that would fit <code class="language-plaintext highlighter-rouge">size_t</code>.</p><p>The correct solution was to change the return type of <code class="language-plaintext highlighter-rouge">getSize()</code> and remove the condition completely as the guard clause already covered the error case.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>

<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="kt">long</span> <span class="cm">/* originally ssize_t */</span> <span class="n">getSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span> 
 <span class="k">private</span><span class="o">:</span>
    <span class="c1">// ...</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">getResource</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">resource</span> <span class="o">=</span> <span class="n">getResource</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">resource</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// perform something that was previously conditional</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The moral of the story? When you modernize code, don’t just blindly do it, but have a deeper look, because you might be able to further simplify it.</p><h2 id="explicit-c-cast-to-the-wrong-type">Explicit C-cast to the wrong type</h2><p>This last one is very easy to fix and the code becomes more readable.</p><p>Check this piece of code:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">int</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
   <span class="kt">int</span> <span class="n">someOffset</span> <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">length</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
     <span class="k">if</span> <span class="p">((</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">i</span> <span class="o">+</span> <span class="n">someOffset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"We are still below c.length()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
     <span class="p">}</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the body of the <code class="language-plaintext highlighter-rouge">for</code>-loop there is a conditional where <code class="language-plaintext highlighter-rouge">i + someOffset</code> is casted to an <code class="language-plaintext highlighter-rouge">unsigned int</code>. While it’s problematic in 2023 to use a C-style cast, that’s not our biggest issue here. The type of that expression is <code class="language-plaintext highlighter-rouge">int</code> and on the other side of the comparison there is a function call that also returns an <code class="language-plaintext highlighter-rouge">int</code>. There is no reason for that cast so the fix is as easy as removing it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="c1">// ...</span>
     <span class="k">if</span> <span class="p">((</span><span class="n">i</span> <span class="o">+</span> <span class="n">someOffset</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">length</span><span class="p">())</span> <span class="p">{</span>
<span class="c1">// ...</span>
</pre></table></code></div></div><p>As you can see, I didn’t even bother to remove the parentheses around <code class="language-plaintext highlighter-rouge">i + someOffset</code> because I think it enhances readability.</p><p>I was thinking for a while why some code like that might have been introduced. My best guess is that <code class="language-plaintext highlighter-rouge">Container::length()</code> returned <code class="language-plaintext highlighter-rouge">unsigned int</code> or <code class="language-plaintext highlighter-rouge">size_t</code> one day but when it was updated for whatever reason, the usages were not checked.</p><h2 id="conclusion">Conclusion</h2><p>In this third and last article of the signed/unsigned comparison mini-series, I shared with you the three strangest cases of <code class="language-plaintext highlighter-rouge">-Wsign-compare</code> violations.</p><p>While <code class="language-plaintext highlighter-rouge">std::cmp_*</code> often comes in handy, most of the time there is a better solution. Often we can simplify and correct the code which is always preferable as long as the solution is correct.</p><p>Do you care about <code class="language-plaintext highlighter-rouge">-Wsign-compare</code>? If so, how do you deal with it?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/cleancode/" class="post-tag no-text-decoration" >cleancode</a> <a href="/tags/integercomparison/" class="post-tag no-text-decoration" >integercomparison</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=My battle against signed/unsigned comparison: the worst violations - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=My battle against signed/unsigned comparison: the worst violations - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=My battle against signed/unsigned comparison: the worst violations - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=My battle against signed/unsigned comparison: the worst violations - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/10/04/trip-report-dev-talks-cluj-2023"><div class="card-body"> <span class="timeago small" > Oct 4, 2023 <i class="unloaded">2023-10-04T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: Dev Talks Cluj 2023</h3><div class="text-muted small"><p> The last week of September I had the honour to share my thoughts in the heart of Transylvania about clean code and software quality at DevTalks Cluj. Over the last few years, DevTalks became a succ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/10/11/cpp20-intcmp-utilities"><div class="card-body"> <span class="timeago small" > Oct 11, 2023 <i class="unloaded">2023-10-11T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to compare signed and unsigned integers in C++20?</h3><div class="text-muted small"><p> Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with...</p></div></div></a></div><div class="card"> <a href="/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations"><div class="card-body"> <span class="timeago small" > Oct 18, 2023 <i class="unloaded">2023-10-18T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My battle against signed/unsigned comparison: the most usual violations</h3><div class="text-muted small"><p> As we discussed last week, comparing numbers with different signs can be dangerous in C++. If you try to compare a signed with an unsigned integer, you might get a result that makes no sense if you...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" class="btn btn-outline-primary" prompt="Older"><p>My battle against signed/unsigned comparison: the most usual violations</p></a> <a href="/blog/2023/11/01/cpp23-garbage-collection" class="btn btn-outline-primary" prompt="Newer"><p>C++23: Removing garbage collection support</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'My battle against signed/unsigned comparison: the worst violations'; this.page.url = 'https://www.sandordargo.com/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations'; this.page.identifier = '/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
