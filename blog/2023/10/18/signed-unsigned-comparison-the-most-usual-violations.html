<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="My battle against signed/unsigned comparison: the most usual violations" /><meta property="og:locale" content="en_US" /><meta name="description" content="As we discussed last week, comparing numbers with different signs can be dangerous in C++. If you try to compare a signed with an unsigned integer, you might get a result that makes no sense if you approach the question from a mathematical point of view. At least, with the right compiler settings, you’d get a warning. We also saw that C++20 offers an easy and safe way to compare numbers anytime and it will always return you the result you’d expect. As such, the warnings also go away. Whatever project I work on, introducing or using a stricter set of warnings and treating them as errors come up over time. An unsafe integer comparison is one of the nastiest warnings to fix because the fix is sometimes not evident but at the same time, usually, you have a lot of similar warnings. In this article, I’ll share with you according to my experience the 3 most common ways -Wsign-compare warnings are invoked. Using a wrongly typed loop control variable The simplest and the most frequent form of this abuse is when the loop control variable is wrongly typed. Most often it means that the loop control is either declared as int i = 0 or auto i = 0 which are both signed integers, but they are compared against the size of a standard container which is a size_t. 1 2 3 4 5 std::vector&lt;int&gt; v; for(int i = 0; i &lt; v.size(); ++i) { std::cout &lt;&lt; i; } This is not very dangerous because on most platforms an int is 4 bytes and a size_t is an unsigned long long that is 8 bytes. As such, in the comparison i is statically cast to an unsigned long or unsigned long long which is safe as long as i is positive. If i is negative you will have surprises, but if you modify i in the body of your loop, you have bigger design issues. Another possible problem is that a signed int and therefore i cannot represent all the positive values size_t can, so with numbers that require a larger type than int to represent positive values, this comparison will fail. To be fair, that is rarely a problem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;limits&gt; int main() { std::cout &lt;&lt; &quot;std::numeric_limits&lt;int&gt;::max(): &quot; &lt;&lt; std::numeric_limits&lt;int&gt;::max() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;std::numeric_limits&lt;size_t&gt;::max(): &quot; &lt;&lt; std::numeric_limits&lt;size_t&gt;::max() &lt;&lt; &#39;\n&#39;; return 0; } /* std::numeric_limits&lt;int&gt;::max(): 2147483647 std::numeric_limits&lt;size_t&gt;::max(): 18446744073709551615 */ To fix this issue you simply have to change the declaration of i to size_t i = 0 or to auto i = 0uz (on C++23), auto i = 0u is not a good option, read here why. I also saw that some user-defined containers return int or ssize_t as a length, and the loop control variable is defined as size_t. As long as the maximum - due to a potential error condition - is not negative, all is fine. But if the ssize_t length() method might return -1 for example, you’ll end up with a loop that will go until one before the maximum value of a size_t (std::numeric_limits&lt;size_t&gt;::max()-1) This is also easy to fix, you simply have to match the type of the loop index with the type of the other value in the stop condition. Mixed conditions in loop control A bit more complex and slightly less frequent case is when you set a more complex stop condition in a loop. Take this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; class Container { public: size_t length() const { return 42; } }; int maxLength() { return 576; } int main() { Container c; for (size_t i = 0; i &lt; c.length() &amp;&amp; i &lt;= maxLength(); ++i) { std::cout &lt;&lt; i &lt;&lt; &#39;\n&#39;; } return 0; } You cannot fix such an error by modifying the type of the loop index. If i is signed, the first condition will emit a signed/unsigned comparison warning, if it’s unsigned, then the second one will. The fix depends on your possibilities in terms of modifying code. If you can safely and rightly change the type of one of the variables in the expression, then do so. In our case that would either be the return type of Container::length() or the return type of maxLength(). If you cannot do that for any reason, you have to make that comparison safe one way or another. If you can, use the standard integer comparison tools that I wrote about last week. In the above example, the for-loop control block would look like this: 1 for (size_t i = 0; i &lt; c.length() &amp;&amp; std::cmp_less_equal(i, maxLength()); ++i) That’s safe and still quite readable. If you don’t have access to it, backport it. You have a reference implementation on C++ Reference and you can check the actual implementations on GitHub (clang here, gcc here, msvc here). If you don’t want to backport it… I think you really should… But let’s imagine that you don’t. In that case, use a static_cast to cast one of the values in the conditional to overcome the warning. To choose your cast, you have to think wisely to make sure that nothing can go wrong considering the potential values of both variables. In our case, we should ask ourselves the question if it’s safe to cast i to an int. For that we have to know if i can have a value that is bigger than std::numeric_limits&lt;int&gt;::max(). If it might be larger, then casting it to int potentially leaves us with a negative value that we clearly don’t want. If we know for sure that the container in this case cannot be so large (because for example, it contains the number of countries in the world), we can go ahead. We can also cast it to a larger type. So for example instead of an int we can use a long long. Or we have to consider if it’s safe to cast the other value, in this case, that would mean casting maxLength() to a size_t. Again, for that, we have to know if realistically it can return a negative value. If so, it’s an unsafe cast. It’s better to backport those new integer comparison utilities. Saving values into the wrong type Another frequent root cause behind signed/unsigned comparisons is that one of the variables participating in the comparison is saved into the wrong type. The called method would return the right type, but it’s saved into a wrongly typed variable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;vector&gt; size_t foo() { return 42; } int main() { std::vector&lt;int&gt; v; int bar = foo(); if (v.size() == bar) { std::cout &lt;&lt; &quot;same size\n&quot;; } else { std::cout &lt;&lt; &quot;different size\n&quot;; } } You’d be surprised to see how frequently this is the case and how ignorant we - developers - are. As std::vector&lt;T&gt;::size() returns size_t and bar is an int, we have a warning. But in such cases, it’s easy to fix the problem, we simply have to update the declaration of bar so that it matches the return type of foo and the problem is gone. Conclusion In this article, we reminded ourselves how comparing signed with unsigned types can go wrong. Then I shared with you the 3 most common cases I encountered while fighting against -Wsign-compare warnings. They are often trivial to fix and they are often the result of ignorance and bad compiler settings. But there might be some cases when using the C++ intcmp utilities is the best way to go. Next week, let’s continue with the three strangest cases I encountered battling signed/unsigned comparison warnings. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="As we discussed last week, comparing numbers with different signs can be dangerous in C++. If you try to compare a signed with an unsigned integer, you might get a result that makes no sense if you approach the question from a mathematical point of view. At least, with the right compiler settings, you’d get a warning. We also saw that C++20 offers an easy and safe way to compare numbers anytime and it will always return you the result you’d expect. As such, the warnings also go away. Whatever project I work on, introducing or using a stricter set of warnings and treating them as errors come up over time. An unsafe integer comparison is one of the nastiest warnings to fix because the fix is sometimes not evident but at the same time, usually, you have a lot of similar warnings. In this article, I’ll share with you according to my experience the 3 most common ways -Wsign-compare warnings are invoked. Using a wrongly typed loop control variable The simplest and the most frequent form of this abuse is when the loop control variable is wrongly typed. Most often it means that the loop control is either declared as int i = 0 or auto i = 0 which are both signed integers, but they are compared against the size of a standard container which is a size_t. 1 2 3 4 5 std::vector&lt;int&gt; v; for(int i = 0; i &lt; v.size(); ++i) { std::cout &lt;&lt; i; } This is not very dangerous because on most platforms an int is 4 bytes and a size_t is an unsigned long long that is 8 bytes. As such, in the comparison i is statically cast to an unsigned long or unsigned long long which is safe as long as i is positive. If i is negative you will have surprises, but if you modify i in the body of your loop, you have bigger design issues. Another possible problem is that a signed int and therefore i cannot represent all the positive values size_t can, so with numbers that require a larger type than int to represent positive values, this comparison will fail. To be fair, that is rarely a problem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;limits&gt; int main() { std::cout &lt;&lt; &quot;std::numeric_limits&lt;int&gt;::max(): &quot; &lt;&lt; std::numeric_limits&lt;int&gt;::max() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; &quot;std::numeric_limits&lt;size_t&gt;::max(): &quot; &lt;&lt; std::numeric_limits&lt;size_t&gt;::max() &lt;&lt; &#39;\n&#39;; return 0; } /* std::numeric_limits&lt;int&gt;::max(): 2147483647 std::numeric_limits&lt;size_t&gt;::max(): 18446744073709551615 */ To fix this issue you simply have to change the declaration of i to size_t i = 0 or to auto i = 0uz (on C++23), auto i = 0u is not a good option, read here why. I also saw that some user-defined containers return int or ssize_t as a length, and the loop control variable is defined as size_t. As long as the maximum - due to a potential error condition - is not negative, all is fine. But if the ssize_t length() method might return -1 for example, you’ll end up with a loop that will go until one before the maximum value of a size_t (std::numeric_limits&lt;size_t&gt;::max()-1) This is also easy to fix, you simply have to match the type of the loop index with the type of the other value in the stop condition. Mixed conditions in loop control A bit more complex and slightly less frequent case is when you set a more complex stop condition in a loop. Take this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; class Container { public: size_t length() const { return 42; } }; int maxLength() { return 576; } int main() { Container c; for (size_t i = 0; i &lt; c.length() &amp;&amp; i &lt;= maxLength(); ++i) { std::cout &lt;&lt; i &lt;&lt; &#39;\n&#39;; } return 0; } You cannot fix such an error by modifying the type of the loop index. If i is signed, the first condition will emit a signed/unsigned comparison warning, if it’s unsigned, then the second one will. The fix depends on your possibilities in terms of modifying code. If you can safely and rightly change the type of one of the variables in the expression, then do so. In our case that would either be the return type of Container::length() or the return type of maxLength(). If you cannot do that for any reason, you have to make that comparison safe one way or another. If you can, use the standard integer comparison tools that I wrote about last week. In the above example, the for-loop control block would look like this: 1 for (size_t i = 0; i &lt; c.length() &amp;&amp; std::cmp_less_equal(i, maxLength()); ++i) That’s safe and still quite readable. If you don’t have access to it, backport it. You have a reference implementation on C++ Reference and you can check the actual implementations on GitHub (clang here, gcc here, msvc here). If you don’t want to backport it… I think you really should… But let’s imagine that you don’t. In that case, use a static_cast to cast one of the values in the conditional to overcome the warning. To choose your cast, you have to think wisely to make sure that nothing can go wrong considering the potential values of both variables. In our case, we should ask ourselves the question if it’s safe to cast i to an int. For that we have to know if i can have a value that is bigger than std::numeric_limits&lt;int&gt;::max(). If it might be larger, then casting it to int potentially leaves us with a negative value that we clearly don’t want. If we know for sure that the container in this case cannot be so large (because for example, it contains the number of countries in the world), we can go ahead. We can also cast it to a larger type. So for example instead of an int we can use a long long. Or we have to consider if it’s safe to cast the other value, in this case, that would mean casting maxLength() to a size_t. Again, for that, we have to know if realistically it can return a negative value. If so, it’s an unsafe cast. It’s better to backport those new integer comparison utilities. Saving values into the wrong type Another frequent root cause behind signed/unsigned comparisons is that one of the variables participating in the comparison is saved into the wrong type. The called method would return the right type, but it’s saved into a wrongly typed variable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;vector&gt; size_t foo() { return 42; } int main() { std::vector&lt;int&gt; v; int bar = foo(); if (v.size() == bar) { std::cout &lt;&lt; &quot;same size\n&quot;; } else { std::cout &lt;&lt; &quot;different size\n&quot;; } } You’d be surprised to see how frequently this is the case and how ignorant we - developers - are. As std::vector&lt;T&gt;::size() returns size_t and bar is an int, we have a warning. But in such cases, it’s easy to fix the problem, we simply have to update the declaration of bar so that it matches the return type of foo and the problem is gone. Conclusion In this article, we reminded ourselves how comparing signed with unsigned types can go wrong. Then I shared with you the 3 most common cases I encountered while fighting against -Wsign-compare warnings. They are often trivial to fix and they are often the result of ignorance and bad compiler settings. But there might be some cases when using the C++ intcmp utilities is the best way to go. Next week, let’s continue with the three strangest cases I encountered battling signed/unsigned comparison warnings. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-10-18T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="My battle against signed/unsigned comparison: the most usual violations" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-10-18T00:00:00+02:00","datePublished":"2023-10-18T00:00:00+02:00","description":"As we discussed last week, comparing numbers with different signs can be dangerous in C++. If you try to compare a signed with an unsigned integer, you might get a result that makes no sense if you approach the question from a mathematical point of view. At least, with the right compiler settings, you’d get a warning. We also saw that C++20 offers an easy and safe way to compare numbers anytime and it will always return you the result you’d expect. As such, the warnings also go away. Whatever project I work on, introducing or using a stricter set of warnings and treating them as errors come up over time. An unsafe integer comparison is one of the nastiest warnings to fix because the fix is sometimes not evident but at the same time, usually, you have a lot of similar warnings. In this article, I’ll share with you according to my experience the 3 most common ways -Wsign-compare warnings are invoked. Using a wrongly typed loop control variable The simplest and the most frequent form of this abuse is when the loop control variable is wrongly typed. Most often it means that the loop control is either declared as int i = 0 or auto i = 0 which are both signed integers, but they are compared against the size of a standard container which is a size_t. 1 2 3 4 5 std::vector&lt;int&gt; v; for(int i = 0; i &lt; v.size(); ++i) { std::cout &lt;&lt; i; } This is not very dangerous because on most platforms an int is 4 bytes and a size_t is an unsigned long long that is 8 bytes. As such, in the comparison i is statically cast to an unsigned long or unsigned long long which is safe as long as i is positive. If i is negative you will have surprises, but if you modify i in the body of your loop, you have bigger design issues. Another possible problem is that a signed int and therefore i cannot represent all the positive values size_t can, so with numbers that require a larger type than int to represent positive values, this comparison will fail. To be fair, that is rarely a problem. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;limits&gt; int main() { std::cout &lt;&lt; &quot;std::numeric_limits&lt;int&gt;::max(): &quot; &lt;&lt; std::numeric_limits&lt;int&gt;::max() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; &quot;std::numeric_limits&lt;size_t&gt;::max(): &quot; &lt;&lt; std::numeric_limits&lt;size_t&gt;::max() &lt;&lt; &#39;\\n&#39;; return 0; } /* std::numeric_limits&lt;int&gt;::max(): 2147483647 std::numeric_limits&lt;size_t&gt;::max(): 18446744073709551615 */ To fix this issue you simply have to change the declaration of i to size_t i = 0 or to auto i = 0uz (on C++23), auto i = 0u is not a good option, read here why. I also saw that some user-defined containers return int or ssize_t as a length, and the loop control variable is defined as size_t. As long as the maximum - due to a potential error condition - is not negative, all is fine. But if the ssize_t length() method might return -1 for example, you’ll end up with a loop that will go until one before the maximum value of a size_t (std::numeric_limits&lt;size_t&gt;::max()-1) This is also easy to fix, you simply have to match the type of the loop index with the type of the other value in the stop condition. Mixed conditions in loop control A bit more complex and slightly less frequent case is when you set a more complex stop condition in a loop. Take this example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; class Container { public: size_t length() const { return 42; } }; int maxLength() { return 576; } int main() { Container c; for (size_t i = 0; i &lt; c.length() &amp;&amp; i &lt;= maxLength(); ++i) { std::cout &lt;&lt; i &lt;&lt; &#39;\\n&#39;; } return 0; } You cannot fix such an error by modifying the type of the loop index. If i is signed, the first condition will emit a signed/unsigned comparison warning, if it’s unsigned, then the second one will. The fix depends on your possibilities in terms of modifying code. If you can safely and rightly change the type of one of the variables in the expression, then do so. In our case that would either be the return type of Container::length() or the return type of maxLength(). If you cannot do that for any reason, you have to make that comparison safe one way or another. If you can, use the standard integer comparison tools that I wrote about last week. In the above example, the for-loop control block would look like this: 1 for (size_t i = 0; i &lt; c.length() &amp;&amp; std::cmp_less_equal(i, maxLength()); ++i) That’s safe and still quite readable. If you don’t have access to it, backport it. You have a reference implementation on C++ Reference and you can check the actual implementations on GitHub (clang here, gcc here, msvc here). If you don’t want to backport it… I think you really should… But let’s imagine that you don’t. In that case, use a static_cast to cast one of the values in the conditional to overcome the warning. To choose your cast, you have to think wisely to make sure that nothing can go wrong considering the potential values of both variables. In our case, we should ask ourselves the question if it’s safe to cast i to an int. For that we have to know if i can have a value that is bigger than std::numeric_limits&lt;int&gt;::max(). If it might be larger, then casting it to int potentially leaves us with a negative value that we clearly don’t want. If we know for sure that the container in this case cannot be so large (because for example, it contains the number of countries in the world), we can go ahead. We can also cast it to a larger type. So for example instead of an int we can use a long long. Or we have to consider if it’s safe to cast the other value, in this case, that would mean casting maxLength() to a size_t. Again, for that, we have to know if realistically it can return a negative value. If so, it’s an unsafe cast. It’s better to backport those new integer comparison utilities. Saving values into the wrong type Another frequent root cause behind signed/unsigned comparisons is that one of the variables participating in the comparison is saved into the wrong type. The called method would return the right type, but it’s saved into a wrongly typed variable. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;vector&gt; size_t foo() { return 42; } int main() { std::vector&lt;int&gt; v; int bar = foo(); if (v.size() == bar) { std::cout &lt;&lt; &quot;same size\\n&quot;; } else { std::cout &lt;&lt; &quot;different size\\n&quot;; } } You’d be surprised to see how frequently this is the case and how ignorant we - developers - are. As std::vector&lt;T&gt;::size() returns size_t and bar is an int, we have a warning. But in such cases, it’s easy to fix the problem, we simply have to update the declaration of bar so that it matches the return type of foo and the problem is gone. Conclusion In this article, we reminded ourselves how comparing signed with unsigned types can go wrong. Then I shared with you the 3 most common cases I encountered while fighting against -Wsign-compare warnings. They are often trivial to fix and they are often the result of ignorance and bad compiler settings. But there might be some cases when using the C++ intcmp utilities is the best way to go. Next week, let’s continue with the three strangest cases I encountered battling signed/unsigned comparison warnings. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"My battle against signed/unsigned comparison: the most usual violations","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations"},"url":"https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations"}</script><title>My battle against signed/unsigned comparison: the most usual violations | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/10"> 10 </a> </span> <span> <a href="/18"> 18 </a> </span> <span>My battle against signed/unsigned comparison: the most usual violations</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>My battle against signed/unsigned comparison: the most usual violations</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Oct 18, 2023, 12:00 AM +0200" prep="on" > Oct 18, 2023 <i class="unloaded">2023-10-18T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1329 words">7 min</span></div></div><div class="post-content"><p>As we discussed last week, comparing numbers with different signs can be dangerous in C++. If you try to compare a signed with an unsigned integer, you might get a result that makes no sense if you approach the question from a mathematical point of view. At least, with the right compiler settings, you’d get a warning.</p><p>We also saw that C++20 offers an easy and safe way to compare numbers anytime and it will always return you the result you’d expect.</p><p>As such, the warnings also go away.</p><p>Whatever project I work on, introducing or using a stricter set of warnings and treating them as errors come up over time. An unsafe integer comparison is one of the nastiest warnings to fix because the fix is sometimes not evident but at the same time, usually, you have a lot of similar warnings.</p><p>In this article, I’ll share with you according to my experience the 3 most common ways <code class="language-plaintext highlighter-rouge">-Wsign-compare</code> warnings are invoked.</p><h2 id="using-a-wrongly-typed-loop-control-variable">Using a wrongly typed loop control variable</h2><p>The simplest and the most frequent form of this abuse is when the loop control variable is wrongly typed. Most often it means that the loop control is either declared as <code class="language-plaintext highlighter-rouge">int i = 0</code> or <code class="language-plaintext highlighter-rouge">auto i = 0</code> which are both signed integers, but they are compared against the size of a standard container which is a <code class="language-plaintext highlighter-rouge">size_t</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span> 

<span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This is not very dangerous because on most platforms an <code class="language-plaintext highlighter-rouge">int</code> is 4 bytes and a <code class="language-plaintext highlighter-rouge">size_t</code> is an <code class="language-plaintext highlighter-rouge">unsigned long long</code> that is 8 bytes. As such, in the comparison <code class="language-plaintext highlighter-rouge">i</code> is statically cast to an <code class="language-plaintext highlighter-rouge">unsigned long</code> or <code class="language-plaintext highlighter-rouge">unsigned long long</code> which is safe as long as <code class="language-plaintext highlighter-rouge">i</code> is positive. If <code class="language-plaintext highlighter-rouge">i</code> is negative you will have surprises, but if you modify <code class="language-plaintext highlighter-rouge">i</code> in the body of your loop, you have bigger design issues.</p><p>Another possible problem is that a signed <code class="language-plaintext highlighter-rouge">int</code> and therefore <code class="language-plaintext highlighter-rouge">i</code> cannot represent all the positive values <code class="language-plaintext highlighter-rouge">size_t</code> can, so with numbers that require a larger type than <code class="language-plaintext highlighter-rouge">int</code> to represent positive values, this comparison will fail. To be fair, that is rarely a problem.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="c1"> </span><span class="cp">
#include</span> <span class="cpf">&lt;limits&gt;</span><span class="c1"> </span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"std::numeric_limits&lt;int&gt;::max(): "</span>    <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"std::numeric_limits&lt;size_t&gt;::max(): "</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">numeric_limits</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;::</span><span class="n">max</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
std::numeric_limits&lt;int&gt;::max(): 2147483647
std::numeric_limits&lt;size_t&gt;::max(): 18446744073709551615
*/</span>
</pre></table></code></div></div><p>To fix this issue you simply have to change the declaration of <code class="language-plaintext highlighter-rouge">i</code> to <code class="language-plaintext highlighter-rouge">size_t i = 0</code> or to <code class="language-plaintext highlighter-rouge">auto i = 0uz</code> (<a href="https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t">on C++23</a>), <code class="language-plaintext highlighter-rouge">auto i = 0u</code> is not a good option, <a href="https://www.sandordargo.com/blog/2022/05/25/literal_suffix_for_signed_size_t">read here why</a>.</p><p>I also saw that some user-defined containers return <code class="language-plaintext highlighter-rouge">int</code> or <code class="language-plaintext highlighter-rouge">ssize_t</code> as a length, and the loop control variable is defined as <code class="language-plaintext highlighter-rouge">size_t</code>. As long as the maximum - due to a potential error condition - is not negative, all is fine. But if the <code class="language-plaintext highlighter-rouge">ssize_t length()</code> method might return <code class="language-plaintext highlighter-rouge">-1</code> for example, you’ll end up with a loop that will go until one before the maximum value of a <code class="language-plaintext highlighter-rouge">size_t</code> (<code class="language-plaintext highlighter-rouge">std::numeric_limits&lt;size_t&gt;::max()-1</code>)</p><p>This is also easy to fix, you simply have to match the type of the loop index with the type of the other value in the stop condition.</p><h2 id="mixed-conditions-in-loop-control">Mixed conditions in loop control</h2><p>A bit more complex and slightly less frequent case is when you set a more complex stop condition in a loop.</p><p>Take this example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
    <span class="nl">public:</span>
    <span class="kt">size_t</span> <span class="n">length</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">maxLength</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">576</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">Container</span> <span class="n">c</span><span class="p">;</span>
   <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span>  <span class="n">i</span> <span class="o">&lt;=</span> <span class="n">maxLength</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
   <span class="p">}</span>
   <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You cannot fix such an error by modifying the type of the loop index. If <code class="language-plaintext highlighter-rouge">i</code> is signed, the first condition will emit a signed/unsigned comparison warning, if it’s unsigned, then the second one will.</p><p>The fix depends on your possibilities in terms of modifying code.</p><p>If you can safely and rightly change the type of one of the variables in the expression, then do so. In our case that would either be the return type of <code class="language-plaintext highlighter-rouge">Container::length()</code> or the return type of <code class="language-plaintext highlighter-rouge">maxLength()</code>.</p><p>If you cannot do that for any reason, you have to make that comparison safe one way or another.</p><p>If you can, use <a href="https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities">the standard integer comparison tools that I wrote about last week</a>. In the above example, the <code class="language-plaintext highlighter-rouge">for</code>-loop control block would look like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">c</span><span class="p">.</span><span class="n">length</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">std</span><span class="o">::</span><span class="n">cmp_less_equal</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">maxLength</span><span class="p">());</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
</pre></table></code></div></div><p>That’s safe and still quite readable.</p><p>If you don’t have access to it, backport it. You have a reference implementation on C++ Reference and you can check the actual implementations on GitHub (<a href="https://github.com/llvm/llvm-project/blob/main/libcxx/include/__utility/cmp.h">clang here</a>, <a href="https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/utility">gcc here</a>, <a href="https://github.com/microsoft/STL/blob/main/stl/inc/utility">msvc here</a>).</p><p>If you don’t want to backport it… I think you really should… But let’s imagine that you don’t. In that case, use a <code class="language-plaintext highlighter-rouge">static_cast</code> to cast one of the values in the conditional to overcome the warning. To choose your cast, you have to think wisely to make sure that nothing can go wrong considering the potential values of both variables.</p><p>In our case, we should ask ourselves the question if it’s safe to cast <code class="language-plaintext highlighter-rouge">i</code> to an <code class="language-plaintext highlighter-rouge">int</code>. For that we have to know if <code class="language-plaintext highlighter-rouge">i</code> can have a value that is bigger than <code class="language-plaintext highlighter-rouge">std::numeric_limits&lt;int&gt;::max()</code>. If it might be larger, then casting it to <code class="language-plaintext highlighter-rouge">int</code> potentially leaves us with a negative value that we clearly don’t want. If we know for sure that the container in this case cannot be so large (because for example, it contains the number of countries in the world), we can go ahead. We can also cast it to a larger type. So for example instead of an <code class="language-plaintext highlighter-rouge">int</code> we can use a <code class="language-plaintext highlighter-rouge">long long</code>.</p><p>Or we have to consider if it’s safe to cast the other value, in this case, that would mean casting <code class="language-plaintext highlighter-rouge">maxLength()</code> to a <code class="language-plaintext highlighter-rouge">size_t</code>. Again, for that, we have to know if realistically it can return a negative value. If so, it’s an unsafe cast.</p><p>It’s better to backport those new integer comparison utilities.</p><h2 id="saving-values-into-the-wrong-type">Saving values into the wrong type</h2><p>Another frequent root cause behind signed/unsigned comparisons is that one of the variables participating in the comparison is saved into the wrong type. The called method would return the right type, but it’s saved into a wrongly typed variable.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">size_t</span> <span class="nf">foo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>

   <span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="n">foo</span><span class="p">();</span>

   <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">bar</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"same size</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"different size</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
   <span class="p">}</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You’d be surprised to see how frequently this is the case and how ignorant we - developers - are.</p><p>As <code class="language-plaintext highlighter-rouge">std::vector&lt;T&gt;::size()</code> returns <code class="language-plaintext highlighter-rouge">size_t</code> and <code class="language-plaintext highlighter-rouge">bar</code> is an <code class="language-plaintext highlighter-rouge">int</code>, we have a warning. But in such cases, it’s easy to fix the problem, we simply have to update the declaration of <code class="language-plaintext highlighter-rouge">bar</code> so that it matches the return type of <code class="language-plaintext highlighter-rouge">foo</code> and the problem is gone.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reminded ourselves how comparing signed with unsigned types can go wrong. Then I shared with you the 3 most common cases I encountered while fighting against <code class="language-plaintext highlighter-rouge">-Wsign-compare</code> warnings.</p><p>They are often trivial to fix and they are often the result of ignorance and bad compiler settings. But there might be some cases when using <a href="https://www.sandordargo.com/blog/2023/10/11/cpp20-intcmp-utilities">the C++ intcmp utilities</a> is the best way to go.</p><p>Next week, let’s continue with the three strangest cases I encountered battling signed/unsigned comparison warnings.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/cleancode/" class="post-tag no-text-decoration" >cleancode</a> <a href="/tags/integercomparison/" class="post-tag no-text-decoration" >integercomparison</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=My battle against signed/unsigned comparison: the most usual violations - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=My battle against signed/unsigned comparison: the most usual violations - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=My battle against signed/unsigned comparison: the most usual violations - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=My battle against signed/unsigned comparison: the most usual violations - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/10/04/trip-report-dev-talks-cluj-2023"><div class="card-body"> <span class="timeago small" > Oct 4, 2023 <i class="unloaded">2023-10-04T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: Dev Talks Cluj 2023</h3><div class="text-muted small"><p> The last week of September I had the honour to share my thoughts in the heart of Transylvania about clean code and software quality at DevTalks Cluj. Over the last few years, DevTalks became a succ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/10/11/cpp20-intcmp-utilities"><div class="card-body"> <span class="timeago small" > Oct 11, 2023 <i class="unloaded">2023-10-11T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>How to compare signed and unsigned integers in C++20?</h3><div class="text-muted small"><p> Comparing two numbers should be easy right? Maybe it should, yet it’s not the case in C++ even if we constrain the comparison to the domain of integral numbers. If you try to compare a signed with...</p></div></div></a></div><div class="card"> <a href="/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations"><div class="card-body"> <span class="timeago small" > Oct 25, 2023 <i class="unloaded">2023-10-25T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My battle against signed/unsigned comparison: the worst violations</h3><div class="text-muted small"><p> We spent the last two weeks discussing the dangers of signed/unsigned comparisons. First, we discussed why it’s a problem in the first place, and how we can safely compare signed and unsigned types...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/10/11/cpp20-intcmp-utilities" class="btn btn-outline-primary" prompt="Older"><p>How to compare signed and unsigned integers in C++20?</p></a> <a href="/blog/2023/10/25/signed-unsigned-comparison-the-worst-violations" class="btn btn-outline-primary" prompt="Newer"><p>My battle against signed/unsigned comparison: the worst violations</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'My battle against signed/unsigned comparison: the most usual violations'; this.page.url = 'https://www.sandordargo.com/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations'; this.page.identifier = '/blog/2023/10/18/signed-unsigned-comparison-the-most-usual-violations'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
