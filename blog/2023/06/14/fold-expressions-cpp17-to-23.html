<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Fold expressions in C++" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this article, we are going to talk about time expressions. First, we are going to take some time to define what they are in case you’re not familiar with them. We’ll do this using C++ syntax, but we must keep in time that the concept is not exclusive to our favourite language. Then we are going to see what the standard library offers us in terms of algorithms and we’ll also see how they evolved so far since they were introduced in C++17 and what new functions we are going to get with C++23. What are fold expressions? When you have several values of the same type and you’d like to apply a binary function to each of these values and produce one single result then you essentially want to fold or reduce them. When you sum up several values and return the result, then you use might use a fold expression. Using a fold expression lets you not use an ugly loop, it gives you a concise way to perform any binary operation and give back a single result. We differentiate between left and right fold operations depending on from which direction we apply the operation. When we start from the left, we talk about left folding and when we start from the right, we talk about right folding. Using the example of summing up 5 numbers, let’s represent the difference between left and right folding. 1 2 3 4 5 operator+ 1 2 3 4 // equivalent to left folding (((1 + 2) + 3) + 4) // equivalent to right folding (1 + (2 + (3 + 4))) While the direction doesn’t matter if an operation is associative, in other cases, it’s important, such as for division. A fold expression can be also called parameter pack expansion. The syntax in C++ There are two ways to approach fold expressions in C++. The first is through the syntax supporting writing fold expression and we can use fold expressions thanks to algorithms in the standard library. In this section, let’s talk about the syntax that was introduced in C++17. The fold expression syntax (...) can be used only with variadic templates???, they cannot be directly used on standard containers. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;vector&gt; #include &lt;iostream&gt; template &lt;typename ...Ts&gt; auto sum(Ts... numbers) { return (numbers + ...); } int main() { std::cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; &#39;\n&#39;; return 0; } In the above example, there are three items to notice. In the template parameter list there, there are three dots after the typename keyword, indicating that there can be more than one item of the same type In the function parameter list, there are also three dots, but after the actual type indicating also that there can be many of them You could read about the details of those in this article on variadic templates. The third thing to notice is the (numbers + ...) expression. That is called the fold expression and this particular one is a unary right fold. It will be expanded as (1 + (2 + (3 + 4))). The parameter pack you have on the left will be “combined” by using the operator in the middle. If the fold expression would have started with the three dots ((... + numbers)) then we would talk about a unary left fold expression expanded as (((1 + 2) + 3) + 4). There are a couple of more things here. Why did I use the unary word? Can we pass in a standard container? I used the unary keyword because the above is not the only type of fold expression that exists. Binary fold expressions are also a thing. The main difference is that with binary fold expressions, you define an initial value so that folding doesn’t start by combining the first two elements of the variable pack, but by combining the first item with the initial value. If we rewrite a unary fold to a binary fold by using the identity element of a given type/operation combination, then we can be sure to have a well-defined and meaningful behaviour even if the variable pack does not contain any items. Binary fold expression can also start from the left ((0 + ... + numbers)) or from the right ((numbers + ... + 0)). For standard containers, we’ll see how to use the standard algorithms. We could pass a container to the above sum() function but it wouldn’t sum up the vector. The template would be expanded into a function that takes one std::vector as Ts. But it could effectively use the operator+ on different vectors combining them into one std::vector. Fold algorithms While fold expressions were only introduced in C++17, we already had fold algorithms earlier in the standard. The most well-known is std::accumulate which was added in C++11. std::reduce is another fold operation added by C++17. With C++23, we get 6(!) other fold operations, namely: std::ranges::fold_left std::ranges::fold_left_first std::ranges::fold_right std::ranges::fold_right_last std::ranges::fold_left_with_iter std::ranges::fold_left_first_with_iter std::accumulate std::accumulate takes 4 parameters. The first two define the range of elements it should fold. It also takes an initial value for the folding operation and as a last parameter, it takes a binary operation that it will apply on the running accumulated value (starting with the initial value) and the next item of the input range going from left to right. The binary operation defaults to operator+. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; &quot;sum: &quot; &lt;&lt; std::accumulate(nums.begin(), nums.end(), 0, [] (int previousResult, int item) { return previousResult + item; }) &lt;&lt;&#39;\n&#39;; } /* sum: 10 */ As mentioned above, std::accumulate performs a left fold. In order to apply a right fold, we have to pass in the input range in reverse order. It’s also worth noting that we can fold a range of items into a type that is different from the initial value. So for example we can accumulate a range of ints to a single string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), std::string(), [] (std::string previousResult, int item) { if (previousResult.empty()) { return std::to_string(item); } return previousResult + &#39;-&#39; + std::to_string(item); }) &lt;&lt;&#39;\n&#39;; } /* 1-2-3-4 */ If you want to avoid having an additional initial value and fold items starting right with the first item, just use the first item as an initial value and leave it out of the range you pass in. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin()+1, nums.end(), std::to_string(nums[0]), [] (std::string previousResult, int item) { return previousResult + &#39;-&#39; + std::to_string(item); }) &lt;&lt;&#39;\n&#39;; } /* 1-2-3-4 */ std::reduce std::reduce was introduced later than std::accumulate, only in C++17. While std::accumulate is a left-fold operation, std::reduce doesn’t guarantee any order, it can take pairs of items in just any order. As such, its binary operation can only operate on elements that are at least convertible into the value type of the range. In other words, you cannot fold a container of integers into a string as an integer is not implicitly convertible to a string. On the other hand, std::reduce can be parallelized, and accordingly, it takes an optional ExecutionPolicy parameter before all the others. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), 0) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(nums.begin(), nums.end()) &lt;&lt;&#39;\n&#39;; } /* 10 10 */ The initial value is missing from the parameters of std::reduce as it can default it to the default constructed value of the passed-in range’s value type. This might be dangerous because the default constructed type might not always be the identity value. As reduce might take items in just any order, the results might differ from the result of a left-fold operation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;execution&gt; int main() { std::vector nums {32,16,8, 4, 2, 1}; std::cout &lt;&lt; std::accumulate(nums.begin()+1, nums.end(), *nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(std::execution::seq, nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(std::execution::unseq, nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; &quot;======\n&quot;; std::cout &lt;&lt; std::reduce(std::execution::par, nums.begin()+1, nums.end(),*nums.begin(), [](int a, int b){ std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &#39;\n&#39;; return a-b; }) &lt;&lt;&#39;\n&#39;; } /* 1 25 25 1 ====== 16 8 4 2 8 2 32 6 26 1 25 */ With accumulate we get 1 as expected, but reduce produces different outputs except for with the unsequenced_policy. The last call, where we pass in a lambda doing an identical operation compared to std::minus, reveals the reason. Subtraction is not commutative and associative, therefore when the items are evaluated in a different order, you won’t have the same result. So when you make a decision between accumulate and reduce, you have to take into account that as well. Now let’s move on to algorithms introduced by C++23. std::ranges::fold_left and std::ranges::fold_right The names of these algorithms are straightforward. They either perform a left- or a right-fold on the passed-in range. As they are part of the ranges library they can directly take a range (such as a container), but they also have overloads to take a range defined by its beginning and the end. Both the initial value and the binary operation must be provided. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::ranges::fold_left(nums, 0, std::plus{}); } /* 10 */ As we saw with std::accumulate, these new fold algorithms can also fold items of a range into a different type, such as ints to a string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::ranges::fold_left(nums, &quot;&quot;, [](std::string previous, int item) { if (!previous.empty()) { previous += &quot;-&quot;; } previous += std::to_string(item); return previous; }); } /* 1-2-3-4 */ std::ranges::fold_left_first and std::ranges::fold_right_last It might happen that you don’t have an identity element for the type you’re folding. In those cases, you can start folding starting from the second item and use the first as the initial value. We already saw earlier how to do it with std::accumulate when we passed numbers[0] as the initial value and numbers.begin()+1 as the beginning of the input range. C++23 provides library support for those cases so you don’t have to write error-prone code, you simply pass in the range, you skip the initial value and call the function that will take the first value from the range. There are 2 such functions so that we have support both for left and right folding. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;optional&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; nums {8, 2, 2, 2}; std::optional&lt;int&gt; r = std::ranges::fold_left_first(nums, std::divides{}); if (r) { std::cout &lt;&lt; r.value(); } else { std::cout &lt;&lt; &quot;folding has no value!\n&quot;; } std::cout &lt;&lt; &#39;\n&#39;; std::vector&lt;int&gt; reversedNums(nums.rbegin(), nums.rend()); std::optional&lt;int&gt; r2 = std::ranges::fold_right_last(reversedNums, [](int item, int previous) { return previous / item; }); if (r2) { std::cout &lt;&lt; r2.value(); } else { std::cout &lt;&lt; &quot;folding has no value!\n&quot;; } return 0; } It’s worth noting that in the second example we could not use std::divides, because when we fold from the right to the left, we have to also change the order of the parameters for a non-commutative operation. Sadly, we cannot use these two functions when we want to fold a collection of elements into another type. We cannot fold a vector of integers into a string. std::ranges::fold_left_with_iter and std::ranges::fold_left_first_with_iter The previous functions returned only the folded value. These two functions return two values. In the first position, they return the iterator pointing at the end of the range and in the second position there comes the result. The main difference between these two functions is that std::ranges::fold_left_with_iter takes an initial value and therefore it always returns a folded value, while std::ranges::fold_left_first_with_iter doesn’t take an initializer, uses the first item as the initial value and only returns a std::optional as a value. Why are these functions needed? A range is not necessarily defined by two iterators. The first iterator denoting the beginning of a range is mandatory, but the second one can also be a sentinel, a condition defining when the iteration should finish. As the fold functions must compute the end, why not return them just in case? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ranges&gt; int main() { auto oneDigitNums = std::views::iota(1) | std::views::take_while([](int i) { return i &lt; 10;}); std::cout &lt;&lt; std::ranges::fold_left(oneDigitNums, 0, std::plus{}) &lt;&lt; &#39;\n&#39;; auto [end, result] = std::ranges::fold_left_with_iter(oneDigitNums, 0, std::plus{}); std::cout &lt;&lt; &quot;Folding finished at &quot; &lt;&lt; *end &lt;&lt; &quot; with the value &quot; &lt;&lt; result &lt;&lt; &#39;\n&#39;; auto [end2, result2] = std::ranges::fold_left_first_with_iter(oneDigitNums, std::plus{}); std::cout &lt;&lt; &quot;Folding finished at &quot; &lt;&lt; *end2 &lt;&lt; &quot; with the value &quot; &lt;&lt; result2.value_or(-1) &lt;&lt; &#39;\n&#39;; } /* 45 Folding finished at 10 with the value 45 Folding finished at 10 with the value 45 */ Conclusion In this article, we reviewed how fold expressions and functions evolved in C++. The first fold function (std::accumulate) was introduced by C++11. Then C++17 also introduced std::reduce and language support as well in the form of fold expressions to simplify folding for variadic templates. Last, but not least, we reviewed the 6 brand new fold functions C++23 is going to give us. We’ll have the chance to fold from both directions, use the first or last value as the initial value and we can even get back the iterator pointing just past the last value that was taken into account from a range. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this article, we are going to talk about time expressions. First, we are going to take some time to define what they are in case you’re not familiar with them. We’ll do this using C++ syntax, but we must keep in time that the concept is not exclusive to our favourite language. Then we are going to see what the standard library offers us in terms of algorithms and we’ll also see how they evolved so far since they were introduced in C++17 and what new functions we are going to get with C++23. What are fold expressions? When you have several values of the same type and you’d like to apply a binary function to each of these values and produce one single result then you essentially want to fold or reduce them. When you sum up several values and return the result, then you use might use a fold expression. Using a fold expression lets you not use an ugly loop, it gives you a concise way to perform any binary operation and give back a single result. We differentiate between left and right fold operations depending on from which direction we apply the operation. When we start from the left, we talk about left folding and when we start from the right, we talk about right folding. Using the example of summing up 5 numbers, let’s represent the difference between left and right folding. 1 2 3 4 5 operator+ 1 2 3 4 // equivalent to left folding (((1 + 2) + 3) + 4) // equivalent to right folding (1 + (2 + (3 + 4))) While the direction doesn’t matter if an operation is associative, in other cases, it’s important, such as for division. A fold expression can be also called parameter pack expansion. The syntax in C++ There are two ways to approach fold expressions in C++. The first is through the syntax supporting writing fold expression and we can use fold expressions thanks to algorithms in the standard library. In this section, let’s talk about the syntax that was introduced in C++17. The fold expression syntax (...) can be used only with variadic templates???, they cannot be directly used on standard containers. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;vector&gt; #include &lt;iostream&gt; template &lt;typename ...Ts&gt; auto sum(Ts... numbers) { return (numbers + ...); } int main() { std::cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; &#39;\n&#39;; return 0; } In the above example, there are three items to notice. In the template parameter list there, there are three dots after the typename keyword, indicating that there can be more than one item of the same type In the function parameter list, there are also three dots, but after the actual type indicating also that there can be many of them You could read about the details of those in this article on variadic templates. The third thing to notice is the (numbers + ...) expression. That is called the fold expression and this particular one is a unary right fold. It will be expanded as (1 + (2 + (3 + 4))). The parameter pack you have on the left will be “combined” by using the operator in the middle. If the fold expression would have started with the three dots ((... + numbers)) then we would talk about a unary left fold expression expanded as (((1 + 2) + 3) + 4). There are a couple of more things here. Why did I use the unary word? Can we pass in a standard container? I used the unary keyword because the above is not the only type of fold expression that exists. Binary fold expressions are also a thing. The main difference is that with binary fold expressions, you define an initial value so that folding doesn’t start by combining the first two elements of the variable pack, but by combining the first item with the initial value. If we rewrite a unary fold to a binary fold by using the identity element of a given type/operation combination, then we can be sure to have a well-defined and meaningful behaviour even if the variable pack does not contain any items. Binary fold expression can also start from the left ((0 + ... + numbers)) or from the right ((numbers + ... + 0)). For standard containers, we’ll see how to use the standard algorithms. We could pass a container to the above sum() function but it wouldn’t sum up the vector. The template would be expanded into a function that takes one std::vector as Ts. But it could effectively use the operator+ on different vectors combining them into one std::vector. Fold algorithms While fold expressions were only introduced in C++17, we already had fold algorithms earlier in the standard. The most well-known is std::accumulate which was added in C++11. std::reduce is another fold operation added by C++17. With C++23, we get 6(!) other fold operations, namely: std::ranges::fold_left std::ranges::fold_left_first std::ranges::fold_right std::ranges::fold_right_last std::ranges::fold_left_with_iter std::ranges::fold_left_first_with_iter std::accumulate std::accumulate takes 4 parameters. The first two define the range of elements it should fold. It also takes an initial value for the folding operation and as a last parameter, it takes a binary operation that it will apply on the running accumulated value (starting with the initial value) and the next item of the input range going from left to right. The binary operation defaults to operator+. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; &quot;sum: &quot; &lt;&lt; std::accumulate(nums.begin(), nums.end(), 0, [] (int previousResult, int item) { return previousResult + item; }) &lt;&lt;&#39;\n&#39;; } /* sum: 10 */ As mentioned above, std::accumulate performs a left fold. In order to apply a right fold, we have to pass in the input range in reverse order. It’s also worth noting that we can fold a range of items into a type that is different from the initial value. So for example we can accumulate a range of ints to a single string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), std::string(), [] (std::string previousResult, int item) { if (previousResult.empty()) { return std::to_string(item); } return previousResult + &#39;-&#39; + std::to_string(item); }) &lt;&lt;&#39;\n&#39;; } /* 1-2-3-4 */ If you want to avoid having an additional initial value and fold items starting right with the first item, just use the first item as an initial value and leave it out of the range you pass in. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin()+1, nums.end(), std::to_string(nums[0]), [] (std::string previousResult, int item) { return previousResult + &#39;-&#39; + std::to_string(item); }) &lt;&lt;&#39;\n&#39;; } /* 1-2-3-4 */ std::reduce std::reduce was introduced later than std::accumulate, only in C++17. While std::accumulate is a left-fold operation, std::reduce doesn’t guarantee any order, it can take pairs of items in just any order. As such, its binary operation can only operate on elements that are at least convertible into the value type of the range. In other words, you cannot fold a container of integers into a string as an integer is not implicitly convertible to a string. On the other hand, std::reduce can be parallelized, and accordingly, it takes an optional ExecutionPolicy parameter before all the others. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), 0) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(nums.begin(), nums.end()) &lt;&lt;&#39;\n&#39;; } /* 10 10 */ The initial value is missing from the parameters of std::reduce as it can default it to the default constructed value of the passed-in range’s value type. This might be dangerous because the default constructed type might not always be the identity value. As reduce might take items in just any order, the results might differ from the result of a left-fold operation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;execution&gt; int main() { std::vector nums {32,16,8, 4, 2, 1}; std::cout &lt;&lt; std::accumulate(nums.begin()+1, nums.end(), *nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(std::execution::seq, nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; std::reduce(std::execution::unseq, nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\n&#39;; std::cout &lt;&lt; &quot;======\n&quot;; std::cout &lt;&lt; std::reduce(std::execution::par, nums.begin()+1, nums.end(),*nums.begin(), [](int a, int b){ std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &#39;\n&#39;; return a-b; }) &lt;&lt;&#39;\n&#39;; } /* 1 25 25 1 ====== 16 8 4 2 8 2 32 6 26 1 25 */ With accumulate we get 1 as expected, but reduce produces different outputs except for with the unsequenced_policy. The last call, where we pass in a lambda doing an identical operation compared to std::minus, reveals the reason. Subtraction is not commutative and associative, therefore when the items are evaluated in a different order, you won’t have the same result. So when you make a decision between accumulate and reduce, you have to take into account that as well. Now let’s move on to algorithms introduced by C++23. std::ranges::fold_left and std::ranges::fold_right The names of these algorithms are straightforward. They either perform a left- or a right-fold on the passed-in range. As they are part of the ranges library they can directly take a range (such as a container), but they also have overloads to take a range defined by its beginning and the end. Both the initial value and the binary operation must be provided. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::ranges::fold_left(nums, 0, std::plus{}); } /* 10 */ As we saw with std::accumulate, these new fold algorithms can also fold items of a range into a different type, such as ints to a string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::ranges::fold_left(nums, &quot;&quot;, [](std::string previous, int item) { if (!previous.empty()) { previous += &quot;-&quot;; } previous += std::to_string(item); return previous; }); } /* 1-2-3-4 */ std::ranges::fold_left_first and std::ranges::fold_right_last It might happen that you don’t have an identity element for the type you’re folding. In those cases, you can start folding starting from the second item and use the first as the initial value. We already saw earlier how to do it with std::accumulate when we passed numbers[0] as the initial value and numbers.begin()+1 as the beginning of the input range. C++23 provides library support for those cases so you don’t have to write error-prone code, you simply pass in the range, you skip the initial value and call the function that will take the first value from the range. There are 2 such functions so that we have support both for left and right folding. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;optional&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; nums {8, 2, 2, 2}; std::optional&lt;int&gt; r = std::ranges::fold_left_first(nums, std::divides{}); if (r) { std::cout &lt;&lt; r.value(); } else { std::cout &lt;&lt; &quot;folding has no value!\n&quot;; } std::cout &lt;&lt; &#39;\n&#39;; std::vector&lt;int&gt; reversedNums(nums.rbegin(), nums.rend()); std::optional&lt;int&gt; r2 = std::ranges::fold_right_last(reversedNums, [](int item, int previous) { return previous / item; }); if (r2) { std::cout &lt;&lt; r2.value(); } else { std::cout &lt;&lt; &quot;folding has no value!\n&quot;; } return 0; } It’s worth noting that in the second example we could not use std::divides, because when we fold from the right to the left, we have to also change the order of the parameters for a non-commutative operation. Sadly, we cannot use these two functions when we want to fold a collection of elements into another type. We cannot fold a vector of integers into a string. std::ranges::fold_left_with_iter and std::ranges::fold_left_first_with_iter The previous functions returned only the folded value. These two functions return two values. In the first position, they return the iterator pointing at the end of the range and in the second position there comes the result. The main difference between these two functions is that std::ranges::fold_left_with_iter takes an initial value and therefore it always returns a folded value, while std::ranges::fold_left_first_with_iter doesn’t take an initializer, uses the first item as the initial value and only returns a std::optional as a value. Why are these functions needed? A range is not necessarily defined by two iterators. The first iterator denoting the beginning of a range is mandatory, but the second one can also be a sentinel, a condition defining when the iteration should finish. As the fold functions must compute the end, why not return them just in case? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ranges&gt; int main() { auto oneDigitNums = std::views::iota(1) | std::views::take_while([](int i) { return i &lt; 10;}); std::cout &lt;&lt; std::ranges::fold_left(oneDigitNums, 0, std::plus{}) &lt;&lt; &#39;\n&#39;; auto [end, result] = std::ranges::fold_left_with_iter(oneDigitNums, 0, std::plus{}); std::cout &lt;&lt; &quot;Folding finished at &quot; &lt;&lt; *end &lt;&lt; &quot; with the value &quot; &lt;&lt; result &lt;&lt; &#39;\n&#39;; auto [end2, result2] = std::ranges::fold_left_first_with_iter(oneDigitNums, std::plus{}); std::cout &lt;&lt; &quot;Folding finished at &quot; &lt;&lt; *end2 &lt;&lt; &quot; with the value &quot; &lt;&lt; result2.value_or(-1) &lt;&lt; &#39;\n&#39;; } /* 45 Folding finished at 10 with the value 45 Folding finished at 10 with the value 45 */ Conclusion In this article, we reviewed how fold expressions and functions evolved in C++. The first fold function (std::accumulate) was introduced by C++11. Then C++17 also introduced std::reduce and language support as well in the form of fold expressions to simplify folding for variadic templates. Last, but not least, we reviewed the 6 brand new fold functions C++23 is going to give us. We’ll have the chance to fold from both directions, use the first or last value as the initial value and we can even get back the iterator pointing just past the last value that was taken into account from a range. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-06-14T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Fold expressions in C++" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-06-16T06:14:48+02:00","datePublished":"2023-06-14T00:00:00+02:00","description":"In this article, we are going to talk about time expressions. First, we are going to take some time to define what they are in case you’re not familiar with them. We’ll do this using C++ syntax, but we must keep in time that the concept is not exclusive to our favourite language. Then we are going to see what the standard library offers us in terms of algorithms and we’ll also see how they evolved so far since they were introduced in C++17 and what new functions we are going to get with C++23. What are fold expressions? When you have several values of the same type and you’d like to apply a binary function to each of these values and produce one single result then you essentially want to fold or reduce them. When you sum up several values and return the result, then you use might use a fold expression. Using a fold expression lets you not use an ugly loop, it gives you a concise way to perform any binary operation and give back a single result. We differentiate between left and right fold operations depending on from which direction we apply the operation. When we start from the left, we talk about left folding and when we start from the right, we talk about right folding. Using the example of summing up 5 numbers, let’s represent the difference between left and right folding. 1 2 3 4 5 operator+ 1 2 3 4 // equivalent to left folding (((1 + 2) + 3) + 4) // equivalent to right folding (1 + (2 + (3 + 4))) While the direction doesn’t matter if an operation is associative, in other cases, it’s important, such as for division. A fold expression can be also called parameter pack expansion. The syntax in C++ There are two ways to approach fold expressions in C++. The first is through the syntax supporting writing fold expression and we can use fold expressions thanks to algorithms in the standard library. In this section, let’s talk about the syntax that was introduced in C++17. The fold expression syntax (...) can be used only with variadic templates???, they cannot be directly used on standard containers. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;vector&gt; #include &lt;iostream&gt; template &lt;typename ...Ts&gt; auto sum(Ts... numbers) { return (numbers + ...); } int main() { std::cout &lt;&lt; sum(1, 2, 3, 4) &lt;&lt; &#39;\\n&#39;; return 0; } In the above example, there are three items to notice. In the template parameter list there, there are three dots after the typename keyword, indicating that there can be more than one item of the same type In the function parameter list, there are also three dots, but after the actual type indicating also that there can be many of them You could read about the details of those in this article on variadic templates. The third thing to notice is the (numbers + ...) expression. That is called the fold expression and this particular one is a unary right fold. It will be expanded as (1 + (2 + (3 + 4))). The parameter pack you have on the left will be “combined” by using the operator in the middle. If the fold expression would have started with the three dots ((... + numbers)) then we would talk about a unary left fold expression expanded as (((1 + 2) + 3) + 4). There are a couple of more things here. Why did I use the unary word? Can we pass in a standard container? I used the unary keyword because the above is not the only type of fold expression that exists. Binary fold expressions are also a thing. The main difference is that with binary fold expressions, you define an initial value so that folding doesn’t start by combining the first two elements of the variable pack, but by combining the first item with the initial value. If we rewrite a unary fold to a binary fold by using the identity element of a given type/operation combination, then we can be sure to have a well-defined and meaningful behaviour even if the variable pack does not contain any items. Binary fold expression can also start from the left ((0 + ... + numbers)) or from the right ((numbers + ... + 0)). For standard containers, we’ll see how to use the standard algorithms. We could pass a container to the above sum() function but it wouldn’t sum up the vector. The template would be expanded into a function that takes one std::vector as Ts. But it could effectively use the operator+ on different vectors combining them into one std::vector. Fold algorithms While fold expressions were only introduced in C++17, we already had fold algorithms earlier in the standard. The most well-known is std::accumulate which was added in C++11. std::reduce is another fold operation added by C++17. With C++23, we get 6(!) other fold operations, namely: std::ranges::fold_left std::ranges::fold_left_first std::ranges::fold_right std::ranges::fold_right_last std::ranges::fold_left_with_iter std::ranges::fold_left_first_with_iter std::accumulate std::accumulate takes 4 parameters. The first two define the range of elements it should fold. It also takes an initial value for the folding operation and as a last parameter, it takes a binary operation that it will apply on the running accumulated value (starting with the initial value) and the next item of the input range going from left to right. The binary operation defaults to operator+. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; &quot;sum: &quot; &lt;&lt; std::accumulate(nums.begin(), nums.end(), 0, [] (int previousResult, int item) { return previousResult + item; }) &lt;&lt;&#39;\\n&#39;; } /* sum: 10 */ As mentioned above, std::accumulate performs a left fold. In order to apply a right fold, we have to pass in the input range in reverse order. It’s also worth noting that we can fold a range of items into a type that is different from the initial value. So for example we can accumulate a range of ints to a single string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), std::string(), [] (std::string previousResult, int item) { if (previousResult.empty()) { return std::to_string(item); } return previousResult + &#39;-&#39; + std::to_string(item); }) &lt;&lt;&#39;\\n&#39;; } /* 1-2-3-4 */ If you want to avoid having an additional initial value and fold items starting right with the first item, just use the first item as an initial value and leave it out of the range you pass in. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin()+1, nums.end(), std::to_string(nums[0]), [] (std::string previousResult, int item) { return previousResult + &#39;-&#39; + std::to_string(item); }) &lt;&lt;&#39;\\n&#39;; } /* 1-2-3-4 */ std::reduce std::reduce was introduced later than std::accumulate, only in C++17. While std::accumulate is a left-fold operation, std::reduce doesn’t guarantee any order, it can take pairs of items in just any order. As such, its binary operation can only operate on elements that are at least convertible into the value type of the range. In other words, you cannot fold a container of integers into a string as an integer is not implicitly convertible to a string. On the other hand, std::reduce can be parallelized, and accordingly, it takes an optional ExecutionPolicy parameter before all the others. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::accumulate(nums.begin(), nums.end(), 0) &lt;&lt;&#39;\\n&#39;; std::cout &lt;&lt; std::reduce(nums.begin(), nums.end()) &lt;&lt;&#39;\\n&#39;; } /* 10 10 */ The initial value is missing from the parameters of std::reduce as it can default it to the default constructed value of the passed-in range’s value type. This might be dangerous because the default constructed type might not always be the identity value. As reduce might take items in just any order, the results might differ from the result of a left-fold operation. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;iostream&gt; #include &lt;numeric&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;execution&gt; int main() { std::vector nums {32,16,8, 4, 2, 1}; std::cout &lt;&lt; std::accumulate(nums.begin()+1, nums.end(), *nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\\n&#39;; std::cout &lt;&lt; std::reduce(nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\\n&#39;; std::cout &lt;&lt; std::reduce(std::execution::seq, nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\\n&#39;; std::cout &lt;&lt; std::reduce(std::execution::unseq, nums.begin()+1, nums.end(),*nums.begin(), std::minus&lt;&gt;{}) &lt;&lt;&#39;\\n&#39;; std::cout &lt;&lt; &quot;======\\n&quot;; std::cout &lt;&lt; std::reduce(std::execution::par, nums.begin()+1, nums.end(),*nums.begin(), [](int a, int b){ std::cout &lt;&lt; a &lt;&lt; &quot; &quot; &lt;&lt; b &lt;&lt; &#39;\\n&#39;; return a-b; }) &lt;&lt;&#39;\\n&#39;; } /* 1 25 25 1 ====== 16 8 4 2 8 2 32 6 26 1 25 */ With accumulate we get 1 as expected, but reduce produces different outputs except for with the unsequenced_policy. The last call, where we pass in a lambda doing an identical operation compared to std::minus, reveals the reason. Subtraction is not commutative and associative, therefore when the items are evaluated in a different order, you won’t have the same result. So when you make a decision between accumulate and reduce, you have to take into account that as well. Now let’s move on to algorithms introduced by C++23. std::ranges::fold_left and std::ranges::fold_right The names of these algorithms are straightforward. They either perform a left- or a right-fold on the passed-in range. As they are part of the ranges library they can directly take a range (such as a container), but they also have overloads to take a range defined by its beginning and the end. Both the initial value and the binary operation must be provided. 1 2 3 4 5 6 7 8 9 10 11 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::ranges::fold_left(nums, 0, std::plus{}); } /* 10 */ As we saw with std::accumulate, these new fold algorithms can also fold items of a range into a different type, such as ints to a string. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector nums {1, 2, 3, 4}; std::cout &lt;&lt; std::ranges::fold_left(nums, &quot;&quot;, [](std::string previous, int item) { if (!previous.empty()) { previous += &quot;-&quot;; } previous += std::to_string(item); return previous; }); } /* 1-2-3-4 */ std::ranges::fold_left_first and std::ranges::fold_right_last It might happen that you don’t have an identity element for the type you’re folding. In those cases, you can start folding starting from the second item and use the first as the initial value. We already saw earlier how to do it with std::accumulate when we passed numbers[0] as the initial value and numbers.begin()+1 as the beginning of the input range. C++23 provides library support for those cases so you don’t have to write error-prone code, you simply pass in the range, you skip the initial value and call the function that will take the first value from the range. There are 2 such functions so that we have support both for left and right folding. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;optional&gt; #include &lt;string&gt; #include &lt;vector&gt; int main() { std::vector&lt;int&gt; nums {8, 2, 2, 2}; std::optional&lt;int&gt; r = std::ranges::fold_left_first(nums, std::divides{}); if (r) { std::cout &lt;&lt; r.value(); } else { std::cout &lt;&lt; &quot;folding has no value!\\n&quot;; } std::cout &lt;&lt; &#39;\\n&#39;; std::vector&lt;int&gt; reversedNums(nums.rbegin(), nums.rend()); std::optional&lt;int&gt; r2 = std::ranges::fold_right_last(reversedNums, [](int item, int previous) { return previous / item; }); if (r2) { std::cout &lt;&lt; r2.value(); } else { std::cout &lt;&lt; &quot;folding has no value!\\n&quot;; } return 0; } It’s worth noting that in the second example we could not use std::divides, because when we fold from the right to the left, we have to also change the order of the parameters for a non-commutative operation. Sadly, we cannot use these two functions when we want to fold a collection of elements into another type. We cannot fold a vector of integers into a string. std::ranges::fold_left_with_iter and std::ranges::fold_left_first_with_iter The previous functions returned only the folded value. These two functions return two values. In the first position, they return the iterator pointing at the end of the range and in the second position there comes the result. The main difference between these two functions is that std::ranges::fold_left_with_iter takes an initial value and therefore it always returns a folded value, while std::ranges::fold_left_first_with_iter doesn’t take an initializer, uses the first item as the initial value and only returns a std::optional as a value. Why are these functions needed? A range is not necessarily defined by two iterators. The first iterator denoting the beginning of a range is mandatory, but the second one can also be a sentinel, a condition defining when the iteration should finish. As the fold functions must compute the end, why not return them just in case? 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #include &lt;iostream&gt; #include &lt;algorithm&gt; #include &lt;ranges&gt; int main() { auto oneDigitNums = std::views::iota(1) | std::views::take_while([](int i) { return i &lt; 10;}); std::cout &lt;&lt; std::ranges::fold_left(oneDigitNums, 0, std::plus{}) &lt;&lt; &#39;\\n&#39;; auto [end, result] = std::ranges::fold_left_with_iter(oneDigitNums, 0, std::plus{}); std::cout &lt;&lt; &quot;Folding finished at &quot; &lt;&lt; *end &lt;&lt; &quot; with the value &quot; &lt;&lt; result &lt;&lt; &#39;\\n&#39;; auto [end2, result2] = std::ranges::fold_left_first_with_iter(oneDigitNums, std::plus{}); std::cout &lt;&lt; &quot;Folding finished at &quot; &lt;&lt; *end2 &lt;&lt; &quot; with the value &quot; &lt;&lt; result2.value_or(-1) &lt;&lt; &#39;\\n&#39;; } /* 45 Folding finished at 10 with the value 45 Folding finished at 10 with the value 45 */ Conclusion In this article, we reviewed how fold expressions and functions evolved in C++. The first fold function (std::accumulate) was introduced by C++11. Then C++17 also introduced std::reduce and language support as well in the form of fold expressions to simplify folding for variadic templates. Last, but not least, we reviewed the 6 brand new fold functions C++23 is going to give us. We’ll have the chance to fold from both directions, use the first or last value as the initial value and we can even get back the iterator pointing just past the last value that was taken into account from a range. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Fold expressions in C++","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23"},"url":"https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23"}</script><title>Fold expressions in C++ | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/06"> 06 </a> </span> <span> <a href="/14"> 14 </a> </span> <span>Fold expressions in C++</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Fold expressions in C++</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jun 14, 2023, 12:00 AM +0200" prep="on" > Jun 14, 2023 <i class="unloaded">2023-06-14T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, Jun 16, 2023, 6:14 AM +0200" prefix="Updated " > Jun 16, 2023 <i class="unloaded">2023-06-16T06:14:48+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2461 words">13 min</span></div></div><div class="post-content"><p>In this article, we are going to talk about time expressions. First, we are going to take some time to define what they are in case you’re not familiar with them. We’ll do this using C++ syntax, but we must keep in time that the concept is not exclusive to our favourite language.</p><p>Then we are going to see what the standard library offers us in terms of algorithms and we’ll also see how they evolved so far since they were introduced in C++17 and what new functions we are going to get with C++23.</p><h2 id="what-are-fold-expressions">What are fold expressions?</h2><p>When you have several values of the same type and you’d like to apply a binary function to each of these values and produce one single result then you essentially want to fold or reduce them. When you sum up several values and return the result, then you use might use a fold expression.</p><p>Using a fold expression lets you <a href="https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms">not use an ugly loop</a>, it gives you a concise way to perform any binary operation and give back a single result.</p><p>We differentiate between left and right fold operations depending on from which direction we apply the operation.</p><p>When we start from the left, we talk about left folding and when we start from the right, we talk about right folding.</p><p>Using the example of summing up 5 numbers, let’s represent the difference between left and right folding.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">operator</span><span class="o">+</span> <span class="mi">1</span> <span class="mi">2</span> <span class="mi">3</span> <span class="mi">4</span>
<span class="c1">// equivalent to left folding</span>
<span class="p">(((</span><span class="mi">1</span> <span class="o">+</span> <span class="mi">2</span><span class="p">)</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)</span>
<span class="c1">// equivalent to right folding</span>
<span class="p">(</span><span class="mi">1</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="mi">3</span> <span class="o">+</span> <span class="mi">4</span><span class="p">)))</span>
</pre></table></code></div></div><p>While the direction doesn’t matter if an operation is associative, in other cases, it’s important, such as for division.</p><p>A fold expression can be also called <em>parameter pack expansion</em>.</p><h2 id="the-syntax-in-c">The syntax in C++</h2><p>There are two ways to approach fold expressions in C++. The first is through the syntax supporting writing fold expression and we can use fold expressions thanks to algorithms in the standard library.</p><p>In this section, let’s talk about the syntax that was introduced in C++17.</p><p>The fold expression syntax (<code class="language-plaintext highlighter-rouge">...</code>) can be used only with <a href="https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates">variadic templates???</a>, they cannot be directly used on standard containers.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="o">...</span><span class="nc">Ts</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">sum</span><span class="p">(</span><span class="n">Ts</span><span class="p">...</span> <span class="n">numbers</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">numbers</span> <span class="o">+</span> <span class="p">...);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the above example, there are three items to notice.</p><ul><li>In the template parameter list there, there are three dots after the <code class="language-plaintext highlighter-rouge">typename</code> keyword, indicating that there can be more than one item of the same type<li>In the function parameter list, there are also three dots, but after the actual type indicating also that there can be many of them</ul><p>You could read about the details of those in <a href="https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates">this article on variadic templates</a>.</p><p>The third thing to notice is the <code class="language-plaintext highlighter-rouge">(numbers + ...)</code> expression. That is called the fold expression and this particular one is a unary right fold. It will be expanded as <code class="language-plaintext highlighter-rouge">(1 + (2 + (3 + 4)))</code>. The parameter pack you have on the left will be “combined” by using the operator in the middle. If the fold expression would have started with the three dots (<code class="language-plaintext highlighter-rouge">(... + numbers)</code>) then we would talk about a unary left fold expression expanded as <code class="language-plaintext highlighter-rouge">(((1 + 2) + 3) + 4)</code>.</p><p>There are a couple of more things here.</p><ul><li>Why did I use the <em>unary</em> word?<li>Can we pass in a standard container?</ul><p>I used the unary keyword because the above is not the only type of fold expression that exists. Binary fold expressions are also a thing. The main difference is that with binary fold expressions, you define an initial value so that folding doesn’t start by combining the first two elements of the variable pack, but by combining the first item with the initial value.</p><p>If we rewrite a unary fold to a binary fold by using the identity element of a given type/operation combination, then we can be sure to have a well-defined and meaningful behaviour even if the variable pack does not contain any items. Binary fold expression can also start from the left (<code class="language-plaintext highlighter-rouge">(0 + ... + numbers)</code>) or from the right (<code class="language-plaintext highlighter-rouge">(numbers + ... + 0)</code>).</p><p>For standard containers, we’ll see how to use the standard algorithms. We could pass a container to the above <code class="language-plaintext highlighter-rouge">sum()</code> function but it wouldn’t sum up the <code class="language-plaintext highlighter-rouge">vector</code>. The template would be expanded into a function that takes one <code class="language-plaintext highlighter-rouge">std::vector</code> as <code class="language-plaintext highlighter-rouge">Ts</code>. But it could effectively use the <code class="language-plaintext highlighter-rouge">operator+</code> on different vectors combining them into one <code class="language-plaintext highlighter-rouge">std::vector</code>.</p><h2 id="fold-algorithms">Fold algorithms</h2><p>While fold expressions were only introduced in C++17, we already had fold algorithms earlier in the standard. The most well-known is <code class="language-plaintext highlighter-rouge">std::accumulate</code> which was added in C++11. <code class="language-plaintext highlighter-rouge">std::reduce</code> is another fold operation added by C++17.</p><p>With C++23, we get 6(!) other fold operations, namely:</p><ul><li><code class="language-plaintext highlighter-rouge">std::ranges::fold_left</code><li><code class="language-plaintext highlighter-rouge">std::ranges::fold_left_first</code><li><code class="language-plaintext highlighter-rouge">std::ranges::fold_right</code><li><code class="language-plaintext highlighter-rouge">std::ranges::fold_right_last</code><li><code class="language-plaintext highlighter-rouge">std::ranges::fold_left_with_iter</code><li><code class="language-plaintext highlighter-rouge">std::ranges::fold_left_first_with_iter</code></ul><h3 id="stdaccumulate"><code class="language-plaintext highlighter-rouge">std::accumulate</code></h3><p><code class="language-plaintext highlighter-rouge">std::accumulate</code> takes 4 parameters. The first two define the range of elements it should fold. It also takes an initial value for the folding operation and as a last parameter, it takes a binary operation that it will apply on the running accumulated value (starting with the initial value) and the next item of the input range going from left to right. The binary operation defaults to <code class="language-plaintext highlighter-rouge">operator+</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"sum: "</span> 
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span>  <span class="p">[]</span> <span class="p">(</span><span class="kt">int</span> <span class="n">previousResult</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">previousResult</span> <span class="o">+</span> <span class="n">item</span><span class="p">;</span>
                  <span class="p">})</span>
              <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
sum: 10
*/</span>
</pre></table></code></div></div><p>As mentioned above, <code class="language-plaintext highlighter-rouge">std::accumulate</code> performs a left fold. In order to apply a right fold, we have to pass in the input range in reverse order.</p><p>It’s also worth noting that we can fold a range of items into a type that is different from the initial value. So for example we can accumulate a range of <code class="language-plaintext highlighter-rouge">int</code>s to a single <code class="language-plaintext highlighter-rouge">string</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(),</span>  <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">previousResult</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">previousResult</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="k">return</span> <span class="n">previousResult</span> <span class="o">+</span> <span class="sc">'-'</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                  <span class="p">})</span>
              <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
1-2-3-4
*/</span>
</pre></table></code></div></div><p>If you want to avoid having an additional initial value and fold items starting right with the first item, just use the first item as an initial value and leave it out of the range you pass in.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">nums</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span>  <span class="p">[]</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">previousResult</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
                    <span class="k">return</span> <span class="n">previousResult</span> <span class="o">+</span> <span class="sc">'-'</span> <span class="o">+</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
                  <span class="p">})</span>
              <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
1-2-3-4
*/</span>
</pre></table></code></div></div><h3 id="stdreduce"><code class="language-plaintext highlighter-rouge">std::reduce</code></h3><p><code class="language-plaintext highlighter-rouge">std::reduce</code> was introduced later than <code class="language-plaintext highlighter-rouge">std::accumulate</code>, only in C++17. While <code class="language-plaintext highlighter-rouge">std::accumulate</code> is a left-fold operation, <code class="language-plaintext highlighter-rouge">std::reduce</code> doesn’t guarantee any order, it can take pairs of items in just any order. As such, its binary operation can only operate on elements that are at least convertible into the value type of the range. In other words, you cannot fold a container of integers into a string as an integer is not implicitly convertible to a string.</p><p>On the other hand, <code class="language-plaintext highlighter-rouge">std::reduce</code> can be parallelized, and accordingly, it takes an optional <code class="language-plaintext highlighter-rouge">ExecutionPolicy</code> parameter before all the others.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
10
10
*/</span>
</pre></table></code></div></div><p>The initial value is missing from the parameters of <code class="language-plaintext highlighter-rouge">std::reduce</code> as it can default it to the default constructed value of the passed-in range’s value type. This might be dangerous because the default constructed type might not always be the identity value.</p><p>As <code class="language-plaintext highlighter-rouge">reduce</code> might take items in just any order, the results might differ from the result of a left-fold operation.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;numeric&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;execution&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">32</span><span class="p">,</span><span class="mi">16</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">accumulate</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="o">*</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;&gt;</span><span class="p">{})</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="o">*</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;&gt;</span><span class="p">{})</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">seq</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="o">*</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;&gt;</span><span class="p">{})</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">unseq</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="o">*</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">std</span><span class="o">::</span><span class="n">minus</span><span class="o">&lt;&gt;</span><span class="p">{})</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"======</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">reduce</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">execution</span><span class="o">::</span><span class="n">par</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nums</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span><span class="o">*</span><span class="n">nums</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">){</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">a</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span> <span class="o">&lt;&lt;</span> <span class="n">b</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">a</span><span class="o">-</span><span class="n">b</span><span class="p">;</span>
    <span class="p">})</span> <span class="o">&lt;&lt;</span><span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
1
25
25
1
======
16 8
4 2
8 2
32 6
26 1
25
*/</span>
</pre></table></code></div></div><p>With <code class="language-plaintext highlighter-rouge">accumulate</code> we get <code class="language-plaintext highlighter-rouge">1</code> as expected, but <code class="language-plaintext highlighter-rouge">reduce</code> produces different outputs except for with the <code class="language-plaintext highlighter-rouge">unsequenced_policy</code>. The last call, where we pass in a lambda doing an identical operation compared to <code class="language-plaintext highlighter-rouge">std::minus</code>, reveals the reason. Subtraction is not commutative and associative, therefore when the items are evaluated in a different order, you won’t have the same result.</p><p>So when you make a decision between <code class="language-plaintext highlighter-rouge">accumulate</code> and <code class="language-plaintext highlighter-rouge">reduce</code>, you have to take into account that as well.</p><p>Now let’s move on to algorithms introduced by C++23.</p><h3 id="stdrangesfold_left-and-stdrangesfold_right"><code class="language-plaintext highlighter-rouge">std::ranges::fold_left</code> and <code class="language-plaintext highlighter-rouge">std::ranges::fold_right</code></h3><p>The names of these algorithms are straightforward. They either perform a left- or a right-fold on the passed-in range. As they are part of the <em>ranges</em> library they can directly take a range (such as a container), but they also have overloads to take a range defined by its beginning and the end.</p><p>Both the initial value and the binary operation must be provided.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">{});</span>
<span class="p">}</span>
<span class="cm">/*
10
*/</span>
</pre></table></code></div></div><p>As we saw with <code class="language-plaintext highlighter-rouge">std::accumulate</code>, these new fold algorithms can also fold items of a range into a different type, such as <code class="language-plaintext highlighter-rouge">int</code>s to a <code class="language-plaintext highlighter-rouge">string</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="s">""</span><span class="p">,</span>
        <span class="p">[](</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">previous</span><span class="p">,</span> <span class="kt">int</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">previous</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
                <span class="n">previous</span> <span class="o">+=</span> <span class="s">"-"</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">previous</span> <span class="o">+=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_string</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">previous</span><span class="p">;</span>
        <span class="p">});</span>
<span class="p">}</span>
<span class="cm">/*
1-2-3-4
*/</span>
</pre></table></code></div></div><h3 id="stdrangesfold_left_first-and-stdrangesfold_right_last"><code class="language-plaintext highlighter-rouge">std::ranges::fold_left_first</code> and <code class="language-plaintext highlighter-rouge">std::ranges::fold_right_last</code></h3><p>It might happen that you don’t have an identity element for the type you’re folding. In those cases, you can start folding starting from the second item and use the first as the initial value. We already saw earlier how to do it with <code class="language-plaintext highlighter-rouge">std::accumulate</code> when we passed <code class="language-plaintext highlighter-rouge">numbers[0]</code> as the initial value and <code class="language-plaintext highlighter-rouge">numbers.begin()+1</code> as the beginning of the input range.</p><p>C++23 provides library support for those cases so you don’t have to write error-prone code, you simply pass in the range, you skip the initial value and call the function that will take the first value from the range. There are 2 such functions so that we have support both for left and right folding.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">nums</span> <span class="p">{</span><span class="mi">8</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left_first</span><span class="p">(</span><span class="n">nums</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">divides</span><span class="p">{});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"folding has no value!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">reversedNums</span><span class="p">(</span><span class="n">nums</span><span class="p">.</span><span class="n">rbegin</span><span class="p">(),</span> <span class="n">nums</span><span class="p">.</span><span class="n">rend</span><span class="p">());</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_right_last</span><span class="p">(</span><span class="n">reversedNums</span><span class="p">,</span>
        <span class="p">[](</span><span class="kt">int</span> <span class="n">item</span><span class="p">,</span> <span class="kt">int</span> <span class="n">previous</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">previous</span> <span class="o">/</span> <span class="n">item</span><span class="p">;</span> <span class="p">});</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">r2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">r2</span><span class="p">.</span><span class="n">value</span><span class="p">();</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"folding has no value!</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s worth noting that in the second example we could not use <code class="language-plaintext highlighter-rouge">std::divides</code>, because when we fold from the right to the left, we have to also change the order of the parameters for a non-commutative operation.</p><p>Sadly, we cannot use these two functions when we want to fold a collection of elements into another type. We cannot fold a vector of integers into a <code class="language-plaintext highlighter-rouge">string</code>.</p><h3 id="stdrangesfold_left_with_iter-and-stdrangesfold_left_first_with_iter"><code class="language-plaintext highlighter-rouge">std::ranges::fold_left_with_iter</code> and <code class="language-plaintext highlighter-rouge">std::ranges::fold_left_first_with_iter</code></h3><p>The previous functions returned only the folded value. These two functions return two values. In the first position, they return the iterator pointing at the end of the range and in the second position there comes the result. The main difference between these two functions is that <code class="language-plaintext highlighter-rouge">std::ranges::fold_left_with_iter</code> takes an initial value and therefore it always returns a folded value, while <code class="language-plaintext highlighter-rouge">std::ranges::fold_left_first_with_iter</code> doesn’t take an initializer, uses the first item as the initial value and only returns a <code class="language-plaintext highlighter-rouge">std::optional</code> as a value.</p><p>Why are these functions needed?</p><p>A range is not necessarily defined by two iterators. The first iterator denoting the beginning of a range is mandatory, but the second one can also be a sentinel, a condition defining when the iteration should finish.</p><p>As the fold functions must compute the end, why not return them just in case?</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;algorithm&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ranges&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">auto</span> <span class="n">oneDigitNums</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">iota</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">|</span> <span class="n">std</span><span class="o">::</span><span class="n">views</span><span class="o">::</span><span class="n">take_while</span><span class="p">([](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">10</span><span class="p">;});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left</span><span class="p">(</span><span class="n">oneDigitNums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">{})</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="k">auto</span> <span class="p">[</span><span class="n">end</span><span class="p">,</span> <span class="n">result</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left_with_iter</span><span class="p">(</span><span class="n">oneDigitNums</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">{});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Folding finished at "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">end</span> <span class="o">&lt;&lt;</span> <span class="s">" with the value "</span> <span class="o">&lt;&lt;</span> <span class="n">result</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="k">auto</span> <span class="p">[</span><span class="n">end2</span><span class="p">,</span> <span class="n">result2</span><span class="p">]</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">ranges</span><span class="o">::</span><span class="n">fold_left_first_with_iter</span><span class="p">(</span><span class="n">oneDigitNums</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">plus</span><span class="p">{});</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Folding finished at "</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">end2</span> <span class="o">&lt;&lt;</span> <span class="s">" with the value "</span> <span class="o">&lt;&lt;</span> <span class="n">result2</span><span class="p">.</span><span class="n">value_or</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
45
Folding finished at 10 with the value 45
Folding finished at 10 with the value 45
*/</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed how fold expressions and functions evolved in C++. The first fold function (<code class="language-plaintext highlighter-rouge">std::accumulate</code>) was introduced by C++11. Then C++17 also introduced <code class="language-plaintext highlighter-rouge">std::reduce</code> and language support as well in the form of fold expressions to simplify folding for variadic templates.</p><p>Last, but not least, we reviewed the 6 brand new fold functions C++23 is going to give us. We’ll have the chance to</p><ul><li>fold from both directions,<li>use the first or last value as the initial value and<li>we can even get back the iterator pointing just past the last value that was taken into account from a range.</ul><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/fold/" class="post-tag no-text-decoration" >fold</a> <a href="/tags/reduce/" class="post-tag no-text-decoration" >reduce</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Fold expressions in C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Fold expressions in C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Fold expressions in C++ - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Fold expressions in C++ - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/06/07/recent-changes-and-commitments" class="btn btn-outline-primary" prompt="Older"><p>Recent changes and personal commitments</p></a> <a href="/blog/2023/06/21/3-best-books-you-level-up-your-cpp" class="btn btn-outline-primary" prompt="Newer"><p>The 3 best books to level up your C++</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Fold expressions in C++'; this.page.url = 'https://www.sandordargo.com/blog/2023/06/14/fold-expressions-cpp17-to-23'; this.page.identifier = '/blog/2023/06/14/fold-expressions-cpp17-to-23'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
