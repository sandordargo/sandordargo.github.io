<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Struct initialization" /><meta property="og:locale" content="en_US" /><meta name="description" content="This article is inspired by a compiler warning that I fixed recently. The warning is -Wmissing-field-initializers. This flag will report you potentially uninitialized fields. Sometimes it’s overly paranoid, but nevertheless, you’ll end up with more readable code if you follow what the compiler tells you. The lack of parentheses matters Let’s start from the beginning with a simple struct that has two members. One member is of a fundamental type and the other is a class type. We’ll see what happens if we instantiate the struct and try to print the values of the members. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 1600677166, s.m_text: */ Our small program will print some garbage value for s.m_num and nothing for s.m_text. That’s all right. When it comes to class members in case they are not explicitly initialized, their default constructor is called, but fundamental types are left uninitialized. The default constructor will not do anything for us. That’s what we were taught about member initialization. Or at least that’s what I learned. Let’s change main() a little bit. 1 2 3 4 int main() { S s(); std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } Oh, now it doesn’t compile. It’s just the most vexing parse and we just declared a function. Read this if you’re not familiar with this mistake and let’s move on. This is what I intended to do: 1 2 3 4 5 6 7 int main() { S s = S(); std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 0, s.m_text: */ Now s.m_num prints 0. What has changed? Default- vs value-initialization vs zero-initialization When we created s by S s; we’re using default-initialization. In that case, all the members of fundamental types will be left uninitialised, while all the class-type members having a default constructor will be initialised through that. If a member is class-type and is not default constructible, then the compilation fails as S::S() gets implicitely deleted. (Check it on godbolt!) In the second case (S s = S()), we perform value-initialization. This means that all class-type members which are default-constructible will be default constructed and all the members of fundamental types are zero-initialized. That last part (if simplified) means that the variable is initialized “to the value obtained by explicitly converting the integer literal 0”. We’d also be in the second case if we replaced S s = S(); by S s{}. Just by adding = S() or {} we made sure that our object is “properly” initialized. I’d personally argue that this is a great solution. I’d provide an explicit initializer for m_num to avoid any possibility for undefined behaviour. But for the sake of the example, I haven’t do so. Let’s add a twist. Let’s say that for some reason you’re compelled to provide a default constructor. Let’s not care about the why. So you end up with this code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() {}; // Maybe you have some other constructors as well int m_num; std::string m_text; }; int main() { S s{}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 1600677166, s.m_text: */ Now s.m_num contains some garbage once again. Instead of zero-initialization, it gets default initialization. The reason is that S now has a user-provided default constructor. Let’s assume that you cannot remove the default constructor, but you still want to benefit from zero-initialization. You have to make sure that the default constructor is not “user-provided”. The rules say that a function is user-provided if it’s user-declared and not explicitely defaulted or deleted on its first declaration. This means for us that if we = default S() when it’s declared, we’ll benefit from zero-intialization once again. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() = default; // Maybe you have some other constructors as well int m_num; std::string m_text; }; int main() { S s{}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 0, s.m_text: */ On the other hand, if for some reason we defaulted S out-of-line, we’d fall back to default-initialization once again. A readable and maintainable initialization Sadly, the compiler hasn’t warned me during the whole quest and not even static code analyzers built-in to Compiler Explorer. Note that I compiled with -Wall -Wextra -Werror -pedantic -std=c++20 -Wmissing-field-initializers -O3 (I wanted to make -Wmissing-field-initializers very explicit in the shared links). Probably UBSAN would have helped. But that’s not available there, it’s not turned on in many project and anyways in the situation that inspired me to write this article, there was no undefined behaviour. What I had was a compiler warning. Now that we have seen when zero-initialization is applied, let’s get back to that warning. When there is absolutely no constructor - user-provided or even user-declared -, you can initialize the member of a struct (or the public members of a class for that matter) when you declare a new variable and you don’t have to provide all the values! The below code is valid: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 42, s.m_text: */ But when you turn on -Wmissing-field-initializers or -Wextra which includes -Wmissing-field-initializers, you get a compiler warning which hopefully is treated as an error. In this case, what the compiler just found is only about readability and therefore maintainability. Even if there are other fundamental members and you provide a value only for one, the rest will be zero-initialized as you can see: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;string&gt; struct S2 { // S2() = default; // S2(...) {} // Maybe you have some other constructors as well int m_num; int m_other_num; }; int main() { S2 s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_other_num: &quot; &lt;&lt; s.m_other_num &lt;&lt; &#39;\n&#39;; } /* s.m_num: 42, s.m_other_num: 0 */ While with a bit of C++ experience, it seems evident that the initialization of members will happen from top to bottom, I must agree that it’s misleading and it’s better to be explicit and change the declaration in a way that it passes all the initial values: 1 S s{42, &quot;&quot;}; // assuming we went back to our original S If we want to avoid that, we should start providing constructors to S. But we might end up having to provide 4 of them: the default constructor one that only takes the initial value of the first member another for the second member and finally one for all the members Quite some code and it can become worse if we have more members. Instead, we should just explicitly enumerate all the starting values. There is another way to get rid of the warning as well as the need to pass in default values at construction time. The explicit in-class member initialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num = 0; std::string m_text{}; }; int main() { S s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 42, s.m_text: */ If you’re saying that well, there are no warnings, but this solution is still as misleading as the original solution, I have to say, you’re partially right. When you look at the declaration of variable s, you don’t know that there are other members too. But at least when you look up S you see directly that all members are explicitly initialized. You don’t have to know the rules about default- vs value-initialization. Let’s make two remarks: changing std::string m_text; to std::string m_text{}; did not change anything, because object members are initialized with their default constructors anyway in every situation. we got rid of the warning, that’s already something… If you want to make the code not just warning free, but more readable as well, you can use designated initializers to show explicitly what members you are initializing: 1 S s{.m_num = 42}; This makes the code way more readable. Use it together with in-class member initialization and you’ll get a warning-free and readable solution. Conclusion In this article, we looked into how member variables are initialized when they are not assigned to a value through a user-provided constructor. We saw the differences between zero- and value-initialization. Then we checked what -Wmissing-field-initializers is and how to get rid of the warnings while keeping our code both concise and readable. In-class member initialization and designated initializers for structs are great tools for such matters. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="This article is inspired by a compiler warning that I fixed recently. The warning is -Wmissing-field-initializers. This flag will report you potentially uninitialized fields. Sometimes it’s overly paranoid, but nevertheless, you’ll end up with more readable code if you follow what the compiler tells you. The lack of parentheses matters Let’s start from the beginning with a simple struct that has two members. One member is of a fundamental type and the other is a class type. We’ll see what happens if we instantiate the struct and try to print the values of the members. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 1600677166, s.m_text: */ Our small program will print some garbage value for s.m_num and nothing for s.m_text. That’s all right. When it comes to class members in case they are not explicitly initialized, their default constructor is called, but fundamental types are left uninitialized. The default constructor will not do anything for us. That’s what we were taught about member initialization. Or at least that’s what I learned. Let’s change main() a little bit. 1 2 3 4 int main() { S s(); std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } Oh, now it doesn’t compile. It’s just the most vexing parse and we just declared a function. Read this if you’re not familiar with this mistake and let’s move on. This is what I intended to do: 1 2 3 4 5 6 7 int main() { S s = S(); std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 0, s.m_text: */ Now s.m_num prints 0. What has changed? Default- vs value-initialization vs zero-initialization When we created s by S s; we’re using default-initialization. In that case, all the members of fundamental types will be left uninitialised, while all the class-type members having a default constructor will be initialised through that. If a member is class-type and is not default constructible, then the compilation fails as S::S() gets implicitely deleted. (Check it on godbolt!) In the second case (S s = S()), we perform value-initialization. This means that all class-type members which are default-constructible will be default constructed and all the members of fundamental types are zero-initialized. That last part (if simplified) means that the variable is initialized “to the value obtained by explicitly converting the integer literal 0”. We’d also be in the second case if we replaced S s = S(); by S s{}. Just by adding = S() or {} we made sure that our object is “properly” initialized. I’d personally argue that this is a great solution. I’d provide an explicit initializer for m_num to avoid any possibility for undefined behaviour. But for the sake of the example, I haven’t do so. Let’s add a twist. Let’s say that for some reason you’re compelled to provide a default constructor. Let’s not care about the why. So you end up with this code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() {}; // Maybe you have some other constructors as well int m_num; std::string m_text; }; int main() { S s{}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 1600677166, s.m_text: */ Now s.m_num contains some garbage once again. Instead of zero-initialization, it gets default initialization. The reason is that S now has a user-provided default constructor. Let’s assume that you cannot remove the default constructor, but you still want to benefit from zero-initialization. You have to make sure that the default constructor is not “user-provided”. The rules say that a function is user-provided if it’s user-declared and not explicitely defaulted or deleted on its first declaration. This means for us that if we = default S() when it’s declared, we’ll benefit from zero-intialization once again. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() = default; // Maybe you have some other constructors as well int m_num; std::string m_text; }; int main() { S s{}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 0, s.m_text: */ On the other hand, if for some reason we defaulted S out-of-line, we’d fall back to default-initialization once again. A readable and maintainable initialization Sadly, the compiler hasn’t warned me during the whole quest and not even static code analyzers built-in to Compiler Explorer. Note that I compiled with -Wall -Wextra -Werror -pedantic -std=c++20 -Wmissing-field-initializers -O3 (I wanted to make -Wmissing-field-initializers very explicit in the shared links). Probably UBSAN would have helped. But that’s not available there, it’s not turned on in many project and anyways in the situation that inspired me to write this article, there was no undefined behaviour. What I had was a compiler warning. Now that we have seen when zero-initialization is applied, let’s get back to that warning. When there is absolutely no constructor - user-provided or even user-declared -, you can initialize the member of a struct (or the public members of a class for that matter) when you declare a new variable and you don’t have to provide all the values! The below code is valid: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 42, s.m_text: */ But when you turn on -Wmissing-field-initializers or -Wextra which includes -Wmissing-field-initializers, you get a compiler warning which hopefully is treated as an error. In this case, what the compiler just found is only about readability and therefore maintainability. Even if there are other fundamental members and you provide a value only for one, the rest will be zero-initialized as you can see: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;string&gt; struct S2 { // S2() = default; // S2(...) {} // Maybe you have some other constructors as well int m_num; int m_other_num; }; int main() { S2 s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_other_num: &quot; &lt;&lt; s.m_other_num &lt;&lt; &#39;\n&#39;; } /* s.m_num: 42, s.m_other_num: 0 */ While with a bit of C++ experience, it seems evident that the initialization of members will happen from top to bottom, I must agree that it’s misleading and it’s better to be explicit and change the declaration in a way that it passes all the initial values: 1 S s{42, &quot;&quot;}; // assuming we went back to our original S If we want to avoid that, we should start providing constructors to S. But we might end up having to provide 4 of them: the default constructor one that only takes the initial value of the first member another for the second member and finally one for all the members Quite some code and it can become worse if we have more members. Instead, we should just explicitly enumerate all the starting values. There is another way to get rid of the warning as well as the need to pass in default values at construction time. The explicit in-class member initialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num = 0; std::string m_text{}; }; int main() { S s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\n&#39;; } /* s.m_num: 42, s.m_text: */ If you’re saying that well, there are no warnings, but this solution is still as misleading as the original solution, I have to say, you’re partially right. When you look at the declaration of variable s, you don’t know that there are other members too. But at least when you look up S you see directly that all members are explicitly initialized. You don’t have to know the rules about default- vs value-initialization. Let’s make two remarks: changing std::string m_text; to std::string m_text{}; did not change anything, because object members are initialized with their default constructors anyway in every situation. we got rid of the warning, that’s already something… If you want to make the code not just warning free, but more readable as well, you can use designated initializers to show explicitly what members you are initializing: 1 S s{.m_num = 42}; This makes the code way more readable. Use it together with in-class member initialization and you’ll get a warning-free and readable solution. Conclusion In this article, we looked into how member variables are initialized when they are not assigned to a value through a user-provided constructor. We saw the differences between zero- and value-initialization. Then we checked what -Wmissing-field-initializers is and how to get rid of the warnings while keeping our code both concise and readable. In-class member initialization and designated initializers for structs are great tools for such matters. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/11/22/struct-initialization" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/11/22/struct-initialization" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-11-22T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Struct initialization" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-05T06:38:47+01:00","datePublished":"2023-11-22T00:00:00+01:00","description":"This article is inspired by a compiler warning that I fixed recently. The warning is -Wmissing-field-initializers. This flag will report you potentially uninitialized fields. Sometimes it’s overly paranoid, but nevertheless, you’ll end up with more readable code if you follow what the compiler tells you. The lack of parentheses matters Let’s start from the beginning with a simple struct that has two members. One member is of a fundamental type and the other is a class type. We’ll see what happens if we instantiate the struct and try to print the values of the members. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 1600677166, s.m_text: */ Our small program will print some garbage value for s.m_num and nothing for s.m_text. That’s all right. When it comes to class members in case they are not explicitly initialized, their default constructor is called, but fundamental types are left uninitialized. The default constructor will not do anything for us. That’s what we were taught about member initialization. Or at least that’s what I learned. Let’s change main() a little bit. 1 2 3 4 int main() { S s(); std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } Oh, now it doesn’t compile. It’s just the most vexing parse and we just declared a function. Read this if you’re not familiar with this mistake and let’s move on. This is what I intended to do: 1 2 3 4 5 6 7 int main() { S s = S(); std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 0, s.m_text: */ Now s.m_num prints 0. What has changed? Default- vs value-initialization vs zero-initialization When we created s by S s; we’re using default-initialization. In that case, all the members of fundamental types will be left uninitialised, while all the class-type members having a default constructor will be initialised through that. If a member is class-type and is not default constructible, then the compilation fails as S::S() gets implicitely deleted. (Check it on godbolt!) In the second case (S s = S()), we perform value-initialization. This means that all class-type members which are default-constructible will be default constructed and all the members of fundamental types are zero-initialized. That last part (if simplified) means that the variable is initialized “to the value obtained by explicitly converting the integer literal 0”. We’d also be in the second case if we replaced S s = S(); by S s{}. Just by adding = S() or {} we made sure that our object is “properly” initialized. I’d personally argue that this is a great solution. I’d provide an explicit initializer for m_num to avoid any possibility for undefined behaviour. But for the sake of the example, I haven’t do so. Let’s add a twist. Let’s say that for some reason you’re compelled to provide a default constructor. Let’s not care about the why. So you end up with this code. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() {}; // Maybe you have some other constructors as well int m_num; std::string m_text; }; int main() { S s{}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 1600677166, s.m_text: */ Now s.m_num contains some garbage once again. Instead of zero-initialization, it gets default initialization. The reason is that S now has a user-provided default constructor. Let’s assume that you cannot remove the default constructor, but you still want to benefit from zero-initialization. You have to make sure that the default constructor is not “user-provided”. The rules say that a function is user-provided if it’s user-declared and not explicitely defaulted or deleted on its first declaration. This means for us that if we = default S() when it’s declared, we’ll benefit from zero-intialization once again. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;iostream&gt; #include &lt;string&gt; struct S { S() = default; // Maybe you have some other constructors as well int m_num; std::string m_text; }; int main() { S s{}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 0, s.m_text: */ On the other hand, if for some reason we defaulted S out-of-line, we’d fall back to default-initialization once again. A readable and maintainable initialization Sadly, the compiler hasn’t warned me during the whole quest and not even static code analyzers built-in to Compiler Explorer. Note that I compiled with -Wall -Wextra -Werror -pedantic -std=c++20 -Wmissing-field-initializers -O3 (I wanted to make -Wmissing-field-initializers very explicit in the shared links). Probably UBSAN would have helped. But that’s not available there, it’s not turned on in many project and anyways in the situation that inspired me to write this article, there was no undefined behaviour. What I had was a compiler warning. Now that we have seen when zero-initialization is applied, let’s get back to that warning. When there is absolutely no constructor - user-provided or even user-declared -, you can initialize the member of a struct (or the public members of a class for that matter) when you declare a new variable and you don’t have to provide all the values! The below code is valid: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num; std::string m_text; }; int main() { S s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 42, s.m_text: */ But when you turn on -Wmissing-field-initializers or -Wextra which includes -Wmissing-field-initializers, you get a compiler warning which hopefully is treated as an error. In this case, what the compiler just found is only about readability and therefore maintainability. Even if there are other fundamental members and you provide a value only for one, the rest will be zero-initialized as you can see: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;string&gt; struct S2 { // S2() = default; // S2(...) {} // Maybe you have some other constructors as well int m_num; int m_other_num; }; int main() { S2 s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_other_num: &quot; &lt;&lt; s.m_other_num &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 42, s.m_other_num: 0 */ While with a bit of C++ experience, it seems evident that the initialization of members will happen from top to bottom, I must agree that it’s misleading and it’s better to be explicit and change the declaration in a way that it passes all the initial values: 1 S s{42, &quot;&quot;}; // assuming we went back to our original S If we want to avoid that, we should start providing constructors to S. But we might end up having to provide 4 of them: the default constructor one that only takes the initial value of the first member another for the second member and finally one for all the members Quite some code and it can become worse if we have more members. Instead, we should just explicitly enumerate all the starting values. There is another way to get rid of the warning as well as the need to pass in default values at construction time. The explicit in-class member initialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; #include &lt;string&gt; struct S { int m_num = 0; std::string m_text{}; }; int main() { S s{42}; std::cout &lt;&lt; &quot;s.m_num: &quot; &lt;&lt; s.m_num &lt;&lt; &quot;, s.m_text: &quot; &lt;&lt; s.m_text &lt;&lt; &#39;\\n&#39;; } /* s.m_num: 42, s.m_text: */ If you’re saying that well, there are no warnings, but this solution is still as misleading as the original solution, I have to say, you’re partially right. When you look at the declaration of variable s, you don’t know that there are other members too. But at least when you look up S you see directly that all members are explicitly initialized. You don’t have to know the rules about default- vs value-initialization. Let’s make two remarks: changing std::string m_text; to std::string m_text{}; did not change anything, because object members are initialized with their default constructors anyway in every situation. we got rid of the warning, that’s already something… If you want to make the code not just warning free, but more readable as well, you can use designated initializers to show explicitly what members you are initializing: 1 S s{.m_num = 42}; This makes the code way more readable. Use it together with in-class member initialization and you’ll get a warning-free and readable solution. Conclusion In this article, we looked into how member variables are initialized when they are not assigned to a value through a user-provided constructor. We saw the differences between zero- and value-initialization. Then we checked what -Wmissing-field-initializers is and how to get rid of the warnings while keeping our code both concise and readable. In-class member initialization and designated initializers for structs are great tools for such matters. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Struct initialization","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/11/22/struct-initialization"},"url":"https://www.sandordargo.com/blog/2023/11/22/struct-initialization"}</script><title>Struct initialization | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/22"> 22 </a> </span> <span>Struct initialization</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Struct initialization</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 22, 2023, 12:00 AM +0100" prep="on" > Nov 22, 2023 <i class="unloaded">2023-11-22T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 5, 2024, 6:38 AM +0100" prefix="Updated " > Dec 5, 2024 <i class="unloaded">2024-12-05T06:38:47+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1598 words">8 min</span></div></div><div class="post-content"><p>This article is inspired by a compiler warning that I fixed recently. The warning is <code class="language-plaintext highlighter-rouge">-Wmissing-field-initializers</code>. This flag will report you potentially uninitialized fields. Sometimes it’s overly paranoid, but nevertheless, you’ll end up with more readable code if you follow what the compiler tells you.</p><h2 id="the-lack-of-parentheses-matters">The lack of parentheses matters</h2><p>Let’s start from the beginning with a simple <code class="language-plaintext highlighter-rouge">struct</code> that has two members. One member is of a fundamental type and the other is a class type. We’ll see what happens if we instantiate the <code class="language-plaintext highlighter-rouge">struct</code> and try to print the values of the members.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
s.m_num: 1600677166, s.m_text: 
*/</span>
</pre></table></code></div></div><p>Our small program will print some garbage value for <code class="language-plaintext highlighter-rouge">s.m_num</code> and nothing for <code class="language-plaintext highlighter-rouge">s.m_text</code>.</p><p>That’s all right. When it comes to class members in case they are not explicitly initialized, their default constructor is called, but fundamental types are left uninitialized. The default constructor will not do anything for us.</p><p>That’s what we were taught about member initialization. Or at least that’s what I learned.</p><p>Let’s change <code class="language-plaintext highlighter-rouge">main()</code> a little bit.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Oh, now it doesn’t compile. It’s just <a href="https://www.sandordargo.com/blog/2021/12/22/most-vexing-parse">the most vexing parse</a> and we just declared a function. <a href="https://www.sandordargo.com/blog/2021/12/22/most-vexing-parse">Read this</a> if you’re not familiar with this mistake and let’s move on. This is what I intended to do:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="n">S</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
s.m_num: 0, s.m_text: 
*/</span>
</pre></table></code></div></div><p>Now <code class="language-plaintext highlighter-rouge">s.m_num</code> prints <code class="language-plaintext highlighter-rouge">0</code>. What has changed?</p><h2 id="default--vs-value-initialization-vs-zero-initialization">Default- vs value-initialization vs zero-initialization</h2><p>When we created <code class="language-plaintext highlighter-rouge">s</code> by <code class="language-plaintext highlighter-rouge">S s;</code> we’re using <a href="https://en.cppreference.com/w/cpp/language/default_initialization">default-initialization</a>. In that case, all the members of fundamental types will be left uninitialised, while all the class-type members having a default constructor will be initialised through that.</p><blockquote><p>If a member is class-type and is not default constructible, then the compilation fails as <code class="language-plaintext highlighter-rouge">S::S()</code> gets implicitely deleted. (Check it on <a href="https://godbolt.org/z/PT5163f9e">godbolt</a>!)</p></blockquote><p>In the second case (<code class="language-plaintext highlighter-rouge">S s = S()</code>), we perform <a href="https://en.cppreference.com/w/cpp/language/value_initialization">value-initialization</a>. This means that all class-type members which are default-constructible will be default constructed and all the members of fundamental types are <a href="https://en.cppreference.com/w/cpp/language/zero_initialization">zero-initialized</a>. That last part (if simplified) means that the variable is initialized <em>“to the value obtained by explicitly converting the integer literal <code class="language-plaintext highlighter-rouge">0</code></em>”.</p><p>We’d also be in the second case if we replaced <code class="language-plaintext highlighter-rouge">S s = S();</code> by <code class="language-plaintext highlighter-rouge">S s{}</code>. Just by adding <code class="language-plaintext highlighter-rouge">= S()</code> or <code class="language-plaintext highlighter-rouge">{}</code> we made sure that our object is “properly” initialized.</p><blockquote><p>I’d personally argue that this is a great solution. I’d provide an explicit initializer for <code class="language-plaintext highlighter-rouge">m_num</code> to avoid any possibility for undefined behaviour. But for the sake of the example, I haven’t do so.</p></blockquote><p>Let’s add a twist. Let’s say that for some reason you’re compelled to provide a default constructor. Let’s not care about the why. So you end up with this code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="p">{};</span>

    <span class="c1">// Maybe you have some other constructors as well</span>

    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
s.m_num: 1600677166, s.m_text: 
*/</span>
</pre></table></code></div></div><p>Now <code class="language-plaintext highlighter-rouge">s.m_num</code> contains some garbage once again. Instead of <em>zero-initialization</em>, it gets <em>default initialization</em>. The reason is that <code class="language-plaintext highlighter-rouge">S</code> now has a <em>user-provided</em> default constructor.</p><p>Let’s assume that you cannot remove the default constructor, but you still want to benefit from zero-initialization. You have to make sure that the default constructor is not <em>“user-provided”</em>. The rules say that a function is <em>user-provided</em> if it’s <em>user-declared</em> and not explicitely defaulted or deleted on its first declaration.</p><p>This means for us that if we <code class="language-plaintext highlighter-rouge">= default</code> <code class="language-plaintext highlighter-rouge">S()</code> when it’s declared, we’ll benefit from zero-intialization once again.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="n">S</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="c1">// Maybe you have some other constructors as well</span>

    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">{};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
s.m_num: 0, s.m_text: 
*/</span>
</pre></table></code></div></div><p>On the other hand, if for some reason <a href="https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes">we defaulted <code class="language-plaintext highlighter-rouge">S</code> out-of-line</a>, we’d fall back to default-initialization once again.</p><h2 id="a-readable-and-maintainable-initialization">A readable and maintainable initialization</h2><p>Sadly, the compiler hasn’t warned me during the whole quest and not even static code analyzers built-in to Compiler Explorer. Note that I compiled with <code class="language-plaintext highlighter-rouge">-Wall -Wextra -Werror -pedantic -std=c++20 -Wmissing-field-initializers -O3</code> (I wanted to make <code class="language-plaintext highlighter-rouge">-Wmissing-field-initializers</code> very explicit in the shared links). Probably <code class="language-plaintext highlighter-rouge">UBSAN</code> would have helped. But that’s not available there, it’s not turned on in many project and anyways in the situation that inspired me to write this article, there was no undefined behaviour. What I had was a compiler warning.</p><p>Now that we have seen when zero-initialization is applied, let’s get back to that warning.</p><p>When there is absolutely no constructor - user-provided or even user-declared -, you can initialize the member of a struct (or the public members of a class for that matter) when you declare a new variable and you don’t have to provide all the values!</p><p>The below code is valid:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
s.m_num: 42, s.m_text: 
*/</span>
</pre></table></code></div></div><p>But when you turn on <code class="language-plaintext highlighter-rouge">-Wmissing-field-initializers</code> or <code class="language-plaintext highlighter-rouge">-Wextra</code> which includes <code class="language-plaintext highlighter-rouge">-Wmissing-field-initializers</code>, you get a compiler warning which hopefully is treated as an error. In this case, what the compiler just found is only about readability and therefore maintainability.</p><p>Even if there are other fundamental members and you provide a value only for one, the rest will be zero-initialized as you can see:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S2</span> <span class="p">{</span>
    <span class="c1">// S2() = default;</span>

    <span class="c1">// S2(...) {}</span>
    <span class="c1">// Maybe you have some other constructors as well</span>

    <span class="kt">int</span> <span class="n">m_num</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_other_num</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S2</span> <span class="n">s</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_other_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_other_num</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
s.m_num: 42, s.m_other_num: 0
*/</span>
</pre></table></code></div></div><p>While with a bit of C++ experience, it seems evident that the initialization of members will happen from top to bottom, I must agree that it’s misleading and it’s better to be explicit and change the declaration in a way that it passes all the initial values:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">S</span> <span class="n">s</span><span class="p">{</span><span class="mi">42</span><span class="p">,</span> <span class="s">""</span><span class="p">};</span> <span class="c1">// assuming we went back to our original S</span>
</pre></table></code></div></div><p>If we want to avoid that, we should start providing constructors to <code class="language-plaintext highlighter-rouge">S</code>. But we might end up having to provide 4 of them:</p><ul><li>the default constructor<li>one that only takes the initial value of the first member<li>another for the second member<li>and finally one for all the members</ul><p>Quite some code and it can become worse if we have more members. Instead, we should just explicitly enumerate all the starting values.</p><p>There is another way to get rid of the warning as well as the need to pass in default values at construction time. The explicit in-class member initialization.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">S</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">m_num</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_text</span><span class="p">{};</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.m_num: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_num</span> <span class="o">&lt;&lt;</span> <span class="s">", s.m_text: "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">m_text</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
s.m_num: 42, s.m_text: 
*/</span>
</pre></table></code></div></div><p>If you’re saying that well, there are no warnings, but this solution is still as misleading as the original solution, I have to say, you’re partially right. When you look at the declaration of variable <code class="language-plaintext highlighter-rouge">s</code>, you don’t know that there are other members too. But at least when you look up <code class="language-plaintext highlighter-rouge">S</code> you see directly that all members are explicitly initialized. You don’t have to know the rules about default- vs value-initialization.</p><p>Let’s make two remarks:</p><ul><li>changing <code class="language-plaintext highlighter-rouge">std::string m_text;</code> to <code class="language-plaintext highlighter-rouge">std::string m_text{};</code> did not change anything, because object members are initialized with their default constructors anyway in every situation.<li>we got rid of the warning, that’s already something…</ul><p>If you want to make the code not just warning free, but more readable as well, you can use <a href="https://en.cppreference.com/w/cpp/language/aggregate_initialization#Designated_initializers">designated initializers</a> to show explicitly what members you are initializing:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">S</span> <span class="n">s</span><span class="p">{.</span><span class="n">m_num</span> <span class="o">=</span> <span class="mi">42</span><span class="p">};</span>
</pre></table></code></div></div><p>This makes the code way more readable.</p><p>Use it together with in-class member initialization and you’ll get a warning-free and readable solution.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we looked into how member variables are initialized when they are not assigned to a value through a user-provided constructor. We saw the differences between zero- and value-initialization. Then we checked what <code class="language-plaintext highlighter-rouge">-Wmissing-field-initializers</code> is and how to get rid of the warnings while keeping our code both concise and readable. In-class member initialization and designated initializers for structs are great tools for such matters.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/structs/" class="post-tag no-text-decoration" >structs</a> <a href="/tags/initialization/" class="post-tag no-text-decoration" >initialization</a> <a href="/tags/warnings/" class="post-tag no-text-decoration" >warnings</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Struct initialization - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/22/struct-initialization" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Struct initialization - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/22/struct-initialization" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Struct initialization - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/22/struct-initialization" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Struct initialization - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/22/struct-initialization" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/10/initializations-part-1"><div class="card-body"> <span class="timeago small" > Apr 10, 2024 <i class="unloaded">2024-04-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 1</h3><div class="text-muted small"><p> Recently, I shared a story with you about a bug, about a manifestation of undefined behaviour a compiler upgrade uncovered. There we briefly looked into why a member was left uninitialized, but the...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/11/15/most-important-complexities" class="btn btn-outline-primary" prompt="Older"><p>C++: The most important complexities</p></a> <a href="/blog/2023/11/25/nonconform-gergely-boszormenyi" class="btn btn-outline-primary" prompt="Newer"><p>Nonconform by Gergely Böszörményi-Nagy</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Struct initialization'; this.page.url = 'https://www.sandordargo.com/blog/2023/11/22/struct-initialization'; this.page.identifier = '/blog/2023/11/22/struct-initialization'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
