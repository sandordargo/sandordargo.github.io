<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: Growing unicode support" /><meta property="og:locale" content="en_US" /><meta name="description" content="The standardization committee has accepted (at least) four papers which clearly show a growing Unicode support in C++23. Let’s review what those papers cover. C++ Identifier Syntax using Unicode Standard Annex 31 In short, you won’t be able to use emojis in identifiers. Personally, I didn’t even know it was possible. Who on Earth would use such an identifier in production code? 1 int 🕐 = 0; In any case, I read out 3 issues that P1949R7 fixes. First, up until now, you could use certain emojis, but certain others you could not. 1 2 3 4 5 int ⏰ = 0; //not valid int 🕐 = 0; int ☠ = 0; //not valid int 💀 = 0; Second, you could not use gender and skin tone modification. Including those is apparently complex, so the proposal is to remove all emojis. Third, “some words in some scripts, such as Persian, Malayalam, and Sinhala, require the use of zero-width joiners and non-joiners to render properly. These words will no longer be well-formed identifiers.” This change is bad for funny conference slides, but good for everyone else. One less thing to pay attention to in a code review. Remove non-encodable wide character literals and multicharacter wide character literals C++ currently allows writing wide character literals that cannot fit wchar_t. Interestingly these might compile today: 1 2 3 wchar_t a = L&#39;🤦‍♀️&#39;; // \U0001f926 wchar_t b = L&#39;ab&#39;; wchar_t c = L&#39;é&#39;; // \u0065\u0301 On Clang, the first two failed to compile saying that “wide character literals may not contain multiple characters”, Gcc simply emitted a warning indicating that “multi-character literal cannot have an encoding prefix”. As you can already see, until C++23 different interpretations could interpret these differently, now these become ill-formed thanks to P2362R3. Delimited escape sequences P2290R3 brings us a new way to write octal, hexadecimal or universal character name escape sequences. Before C++23, an octal escape sequence accepts 1 to 3 digits as arguments and it’s introduced by a backslash \, from now on you use \o{n...} where inside the braces you use an arbitrary number of octal digits. For hexadecimal characters, it used to be \xn... where n... is replaced by an arbitrary number of hexadecimal digits and also becomes \x{n...}. It’s worth noting that both \x{nnnn} and \o{nnnn} must represent a value that can be represented in a single code unit of the encoding of the string or character literal they are a part of. Similarly, for Unicode characters, you can use \u{n...}. Until now, it was mandatory to specify 4 hexadecimal digits after \u or 8 after \U. That meant that you must specify leading zeros all the time which is a bit cumbersome. It’s not the case anymore with \u{n....}, you can omit the leading zeros. 1 2 3 4 5 6 7 8 9 10 11 constexpr char o1 = &#39;\123&#39;; constexpr char o2 = &#39;\o{123}&#39;; static_assert(o1 == o2); constexpr char h1 = &#39;\x0f&#39;; constexpr char h2 = &#39;\x{0f}&#39;; static_assert(h1 == h2); constexpr char u1 = &#39;\u0023&#39;; constexpr char u2 = &#39;\u{23}&#39;; static_assert(u1 == u2); Named universal character escapes Since C++11 we can use universal character names such as U&#39;\u0100&#39; which stands for the UTF-32 character literal with U+0100 which has the name {LATIN CAPITAL LETTER A WITH MACRON}. We can also use characters in combination such as u8&quot;\u0100\u0300&quot; which combines {LATIN CAPITAL LETTER A WITH MACRON} with {COMBINING GRAVE ACCENT}. Thanks to P2071R2, we will be able to use directly the Unicode-assigned names instead of the Unicode point values. We’ll have to introduce these names after the \N escape sequence: 1 2 U&#39;\N{LATIN CAPITAL LETTER A WITH MACRON}&#39; // Equivalent to U&#39;\u0100&#39; u8&quot;\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}&quot; // Equivalent to u8&quot;\u0100\u0300&quot; This proposal is a relatively long, but at the same time also an interesting read about different considerations and objections regarding this new feature. One of the concerns was the sheer size of the Unicode name database that contains the codes (e.g. U+0100) and the names (e.g. {LATIN CAPITAL LETTER A WITH MACRON}). It’s around 1.5 MiB which can significantly impact the size of compiler distributions. The authors proved that a non-naive implementation can be around 300 KiB or even less. Another open question was how to accept the Unicode-assigned names. Is {latin capital letter a with macron} just as good as {LATIN CAPITAL LETTER A WITH MACRON}? Or what about {LATIN_CAPITAL_LETTER_A_WITH_MACRON}? While the Unicode consortium standardized an algorithm called UAX44-LM2 for that purpose and it’s quite permissive, language implementors barely follow it. C++ is going to require an exact match with the database therefore the answer to the previous question is no, {latin capital letter a with macron} is not the same as {LATIN CAPITAL LETTER A WITH MACRON}. On the other hand, if there will be a strong need, the requirements can be relaxed in a later version. If you want to know more, read P2071R2. Conclusion As we saw today, C++23 made some important steps towards supporting Unicode in a consistent way. We are not going to be able to use emojis in identifiers. From now on, non-encodable wide character literals and multicharacter wide character literals are ill-formed. Delimiter escape sequences will become more readable for octal, hexadecimal and Unicode sequences whose leading zeros might be omitted from now on. And still speaking about universal character escapes, instead of hexadecimal codes, from now on, we can also use the named versions. When I say from now on, of course, I mean C++23 and I assume compiler support that you can always check here on C++ Reference. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="The standardization committee has accepted (at least) four papers which clearly show a growing Unicode support in C++23. Let’s review what those papers cover. C++ Identifier Syntax using Unicode Standard Annex 31 In short, you won’t be able to use emojis in identifiers. Personally, I didn’t even know it was possible. Who on Earth would use such an identifier in production code? 1 int 🕐 = 0; In any case, I read out 3 issues that P1949R7 fixes. First, up until now, you could use certain emojis, but certain others you could not. 1 2 3 4 5 int ⏰ = 0; //not valid int 🕐 = 0; int ☠ = 0; //not valid int 💀 = 0; Second, you could not use gender and skin tone modification. Including those is apparently complex, so the proposal is to remove all emojis. Third, “some words in some scripts, such as Persian, Malayalam, and Sinhala, require the use of zero-width joiners and non-joiners to render properly. These words will no longer be well-formed identifiers.” This change is bad for funny conference slides, but good for everyone else. One less thing to pay attention to in a code review. Remove non-encodable wide character literals and multicharacter wide character literals C++ currently allows writing wide character literals that cannot fit wchar_t. Interestingly these might compile today: 1 2 3 wchar_t a = L&#39;🤦‍♀️&#39;; // \U0001f926 wchar_t b = L&#39;ab&#39;; wchar_t c = L&#39;é&#39;; // \u0065\u0301 On Clang, the first two failed to compile saying that “wide character literals may not contain multiple characters”, Gcc simply emitted a warning indicating that “multi-character literal cannot have an encoding prefix”. As you can already see, until C++23 different interpretations could interpret these differently, now these become ill-formed thanks to P2362R3. Delimited escape sequences P2290R3 brings us a new way to write octal, hexadecimal or universal character name escape sequences. Before C++23, an octal escape sequence accepts 1 to 3 digits as arguments and it’s introduced by a backslash \, from now on you use \o{n...} where inside the braces you use an arbitrary number of octal digits. For hexadecimal characters, it used to be \xn... where n... is replaced by an arbitrary number of hexadecimal digits and also becomes \x{n...}. It’s worth noting that both \x{nnnn} and \o{nnnn} must represent a value that can be represented in a single code unit of the encoding of the string or character literal they are a part of. Similarly, for Unicode characters, you can use \u{n...}. Until now, it was mandatory to specify 4 hexadecimal digits after \u or 8 after \U. That meant that you must specify leading zeros all the time which is a bit cumbersome. It’s not the case anymore with \u{n....}, you can omit the leading zeros. 1 2 3 4 5 6 7 8 9 10 11 constexpr char o1 = &#39;\123&#39;; constexpr char o2 = &#39;\o{123}&#39;; static_assert(o1 == o2); constexpr char h1 = &#39;\x0f&#39;; constexpr char h2 = &#39;\x{0f}&#39;; static_assert(h1 == h2); constexpr char u1 = &#39;\u0023&#39;; constexpr char u2 = &#39;\u{23}&#39;; static_assert(u1 == u2); Named universal character escapes Since C++11 we can use universal character names such as U&#39;\u0100&#39; which stands for the UTF-32 character literal with U+0100 which has the name {LATIN CAPITAL LETTER A WITH MACRON}. We can also use characters in combination such as u8&quot;\u0100\u0300&quot; which combines {LATIN CAPITAL LETTER A WITH MACRON} with {COMBINING GRAVE ACCENT}. Thanks to P2071R2, we will be able to use directly the Unicode-assigned names instead of the Unicode point values. We’ll have to introduce these names after the \N escape sequence: 1 2 U&#39;\N{LATIN CAPITAL LETTER A WITH MACRON}&#39; // Equivalent to U&#39;\u0100&#39; u8&quot;\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}&quot; // Equivalent to u8&quot;\u0100\u0300&quot; This proposal is a relatively long, but at the same time also an interesting read about different considerations and objections regarding this new feature. One of the concerns was the sheer size of the Unicode name database that contains the codes (e.g. U+0100) and the names (e.g. {LATIN CAPITAL LETTER A WITH MACRON}). It’s around 1.5 MiB which can significantly impact the size of compiler distributions. The authors proved that a non-naive implementation can be around 300 KiB or even less. Another open question was how to accept the Unicode-assigned names. Is {latin capital letter a with macron} just as good as {LATIN CAPITAL LETTER A WITH MACRON}? Or what about {LATIN_CAPITAL_LETTER_A_WITH_MACRON}? While the Unicode consortium standardized an algorithm called UAX44-LM2 for that purpose and it’s quite permissive, language implementors barely follow it. C++ is going to require an exact match with the database therefore the answer to the previous question is no, {latin capital letter a with macron} is not the same as {LATIN CAPITAL LETTER A WITH MACRON}. On the other hand, if there will be a strong need, the requirements can be relaxed in a later version. If you want to know more, read P2071R2. Conclusion As we saw today, C++23 made some important steps towards supporting Unicode in a consistent way. We are not going to be able to use emojis in identifiers. From now on, non-encodable wide character literals and multicharacter wide character literals are ill-formed. Delimiter escape sequences will become more readable for octal, hexadecimal and Unicode sequences whose leading zeros might be omitted from now on. And still speaking about universal character escapes, instead of hexadecimal codes, from now on, we can also use the named versions. When I say from now on, of course, I mean C++23 and I assume compiler support that you can always check here on C++ Reference. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-11-29T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: Growing unicode support" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-11-29T00:00:00+01:00","datePublished":"2023-11-29T00:00:00+01:00","description":"The standardization committee has accepted (at least) four papers which clearly show a growing Unicode support in C++23. Let’s review what those papers cover. C++ Identifier Syntax using Unicode Standard Annex 31 In short, you won’t be able to use emojis in identifiers. Personally, I didn’t even know it was possible. Who on Earth would use such an identifier in production code? 1 int 🕐 = 0; In any case, I read out 3 issues that P1949R7 fixes. First, up until now, you could use certain emojis, but certain others you could not. 1 2 3 4 5 int ⏰ = 0; //not valid int 🕐 = 0; int ☠ = 0; //not valid int 💀 = 0; Second, you could not use gender and skin tone modification. Including those is apparently complex, so the proposal is to remove all emojis. Third, “some words in some scripts, such as Persian, Malayalam, and Sinhala, require the use of zero-width joiners and non-joiners to render properly. These words will no longer be well-formed identifiers.” This change is bad for funny conference slides, but good for everyone else. One less thing to pay attention to in a code review. Remove non-encodable wide character literals and multicharacter wide character literals C++ currently allows writing wide character literals that cannot fit wchar_t. Interestingly these might compile today: 1 2 3 wchar_t a = L&#39;🤦‍♀️&#39;; // \\U0001f926 wchar_t b = L&#39;ab&#39;; wchar_t c = L&#39;é&#39;; // \\u0065\\u0301 On Clang, the first two failed to compile saying that “wide character literals may not contain multiple characters”, Gcc simply emitted a warning indicating that “multi-character literal cannot have an encoding prefix”. As you can already see, until C++23 different interpretations could interpret these differently, now these become ill-formed thanks to P2362R3. Delimited escape sequences P2290R3 brings us a new way to write octal, hexadecimal or universal character name escape sequences. Before C++23, an octal escape sequence accepts 1 to 3 digits as arguments and it’s introduced by a backslash \\, from now on you use \\o{n...} where inside the braces you use an arbitrary number of octal digits. For hexadecimal characters, it used to be \\xn... where n... is replaced by an arbitrary number of hexadecimal digits and also becomes \\x{n...}. It’s worth noting that both \\x{nnnn} and \\o{nnnn} must represent a value that can be represented in a single code unit of the encoding of the string or character literal they are a part of. Similarly, for Unicode characters, you can use \\u{n...}. Until now, it was mandatory to specify 4 hexadecimal digits after \\u or 8 after \\U. That meant that you must specify leading zeros all the time which is a bit cumbersome. It’s not the case anymore with \\u{n....}, you can omit the leading zeros. 1 2 3 4 5 6 7 8 9 10 11 constexpr char o1 = &#39;\\123&#39;; constexpr char o2 = &#39;\\o{123}&#39;; static_assert(o1 == o2); constexpr char h1 = &#39;\\x0f&#39;; constexpr char h2 = &#39;\\x{0f}&#39;; static_assert(h1 == h2); constexpr char u1 = &#39;\\u0023&#39;; constexpr char u2 = &#39;\\u{23}&#39;; static_assert(u1 == u2); Named universal character escapes Since C++11 we can use universal character names such as U&#39;\\u0100&#39; which stands for the UTF-32 character literal with U+0100 which has the name {LATIN CAPITAL LETTER A WITH MACRON}. We can also use characters in combination such as u8&quot;\\u0100\\u0300&quot; which combines {LATIN CAPITAL LETTER A WITH MACRON} with {COMBINING GRAVE ACCENT}. Thanks to P2071R2, we will be able to use directly the Unicode-assigned names instead of the Unicode point values. We’ll have to introduce these names after the \\N escape sequence: 1 2 U&#39;\\N{LATIN CAPITAL LETTER A WITH MACRON}&#39; // Equivalent to U&#39;\\u0100&#39; u8&quot;\\N{LATIN CAPITAL LETTER A WITH MACRON}\\N{COMBINING GRAVE ACCENT}&quot; // Equivalent to u8&quot;\\u0100\\u0300&quot; This proposal is a relatively long, but at the same time also an interesting read about different considerations and objections regarding this new feature. One of the concerns was the sheer size of the Unicode name database that contains the codes (e.g. U+0100) and the names (e.g. {LATIN CAPITAL LETTER A WITH MACRON}). It’s around 1.5 MiB which can significantly impact the size of compiler distributions. The authors proved that a non-naive implementation can be around 300 KiB or even less. Another open question was how to accept the Unicode-assigned names. Is {latin capital letter a with macron} just as good as {LATIN CAPITAL LETTER A WITH MACRON}? Or what about {LATIN_CAPITAL_LETTER_A_WITH_MACRON}? While the Unicode consortium standardized an algorithm called UAX44-LM2 for that purpose and it’s quite permissive, language implementors barely follow it. C++ is going to require an exact match with the database therefore the answer to the previous question is no, {latin capital letter a with macron} is not the same as {LATIN CAPITAL LETTER A WITH MACRON}. On the other hand, if there will be a strong need, the requirements can be relaxed in a later version. If you want to know more, read P2071R2. Conclusion As we saw today, C++23 made some important steps towards supporting Unicode in a consistent way. We are not going to be able to use emojis in identifiers. From now on, non-encodable wide character literals and multicharacter wide character literals are ill-formed. Delimiter escape sequences will become more readable for octal, hexadecimal and Unicode sequences whose leading zeros might be omitted from now on. And still speaking about universal character escapes, instead of hexadecimal codes, from now on, we can also use the named versions. When I say from now on, of course, I mean C++23 and I assume compiler support that you can always check here on C++ Reference. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: Growing unicode support","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support"},"url":"https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support"}</script><title>C++23: Growing unicode support | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/29"> 29 </a> </span> <span>C++23: Growing unicode support</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: Growing unicode support</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 29, 2023, 12:00 AM +0100" prep="on" > Nov 29, 2023 <i class="unloaded">2023-11-29T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="952 words">5 min</span></div></div><div class="post-content"><p>The standardization committee has accepted (at least) four papers which clearly show a growing Unicode support in C++23. Let’s review what those papers cover.</p><h2 id="c-identifier-syntax-using-unicode-standard-annex-31">C++ Identifier Syntax using Unicode Standard Annex 31</h2><p>In short, you won’t be able to use emojis in identifiers. Personally, I didn’t even know it was possible. Who on Earth would use such an identifier in production code?</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="err">🕐</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><p>In any case, I read out 3 issues that <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p1949r7.html">P1949R7</a> fixes.</p><p>First, up until now, you could use certain emojis, but certain others you could not.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">int</span> <span class="err">⏰</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//not valid</span>
<span class="kt">int</span> <span class="err">🕐</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="err">☠</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">//not valid</span>
<span class="kt">int</span> <span class="err">💀</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></table></code></div></div><p>Second, you could not use gender and skin tone modification. Including those is apparently complex, so the proposal is to remove all emojis.</p><p>Third, <em>“some words in some scripts, such as Persian, Malayalam, and Sinhala, require the use of zero-width joiners and non-joiners to render properly. These words will no longer be well-formed identifiers.”</em></p><p>This change is bad for funny conference slides, but good for everyone else. One less thing to pay attention to in a <a href="https://www.sandordargo.com/blog/2021/10/06/airy-code-reviews">code review</a>.</p><h2 id="remove-non-encodable-wide-character-literals-and-multicharacter-wide-character-literals">Remove non-encodable wide character literals and multicharacter wide character literals</h2><p>C++ currently allows writing wide character literals that cannot fit <code class="language-plaintext highlighter-rouge">wchar_t</code>. Interestingly these might compile today:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre><span class="kt">wchar_t</span> <span class="n">a</span> <span class="o">=</span> <span class="n">L</span><span class="err">'🤦‍♀️'</span><span class="p">;</span> <span class="c1">// \U0001f926</span>
<span class="kt">wchar_t</span> <span class="n">b</span> <span class="o">=</span> <span class="n">L</span><span class="err">'</span><span class="n">ab</span><span class="err">'</span><span class="p">;</span>
<span class="kt">wchar_t</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">L'é'</span><span class="p">;</span> <span class="c1">// \u0065\u0301</span>
</pre></table></code></div></div><p>On Clang, the first two failed to compile saying that “wide character literals may not contain multiple characters”, Gcc simply emitted a warning indicating that “multi-character literal cannot have an encoding prefix”.</p><p>As you can already see, until C++23 different interpretations could interpret these differently, now these become ill-formed thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2362r3.pdf">P2362R3</a>.</p><h2 id="delimited-escape-sequences">Delimited escape sequences</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2290r3.pdf">P2290R3</a> brings us a new way to write octal, hexadecimal or universal character name escape sequences.</p><p>Before C++23, an octal escape sequence accepts 1 to 3 digits as arguments and it’s introduced by a backslash <code class="language-plaintext highlighter-rouge">\</code>, from now on you use <code class="language-plaintext highlighter-rouge">\o{n...}</code> where inside the braces you use an arbitrary number of octal digits.</p><p>For hexadecimal characters, it used to be <code class="language-plaintext highlighter-rouge">\xn...</code> where <code class="language-plaintext highlighter-rouge">n...</code> is replaced by an arbitrary number of hexadecimal digits and also becomes <code class="language-plaintext highlighter-rouge">\x{n...}</code>.</p><p>It’s worth noting that both <code class="language-plaintext highlighter-rouge">\x{nnnn}</code> and <code class="language-plaintext highlighter-rouge">\o{nnnn}</code> must represent a value that can be represented in a single code unit of the encoding of the string or character literal they are a part of.</p><p>Similarly, for Unicode characters, you can use <code class="language-plaintext highlighter-rouge">\u{n...}</code>. Until now, it was mandatory to specify 4 hexadecimal digits after <code class="language-plaintext highlighter-rouge">\u</code> or 8 after <code class="language-plaintext highlighter-rouge">\U</code>. That meant that you must specify leading zeros all the time which is a bit cumbersome. It’s not the case anymore with <code class="language-plaintext highlighter-rouge">\u{n....}</code>, you can omit the leading zeros.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="kt">char</span> <span class="n">o1</span> <span class="o">=</span> <span class="sc">'\123'</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">char</span> <span class="n">o2</span> <span class="o">=</span> <span class="err">'\</span><span class="n">o</span><span class="p">{</span><span class="mi">123</span><span class="p">}</span><span class="err">'</span><span class="p">;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">o1</span> <span class="o">==</span> <span class="n">o2</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="kt">char</span> <span class="n">h1</span> <span class="o">=</span> <span class="sc">'\x0f'</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">char</span> <span class="n">h2</span> <span class="o">=</span> <span class="err">'\</span><span class="n">x</span><span class="p">{</span><span class="mi">0</span><span class="n">f</span><span class="p">}</span><span class="err">'</span><span class="p">;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">h1</span> <span class="o">==</span> <span class="n">h2</span><span class="p">);</span>

<span class="k">constexpr</span> <span class="kt">char</span> <span class="n">u1</span> <span class="o">=</span> <span class="err">'\</span><span class="n">u0023</span><span class="err">'</span><span class="p">;</span>
<span class="k">constexpr</span> <span class="kt">char</span> <span class="n">u2</span> <span class="o">=</span> <span class="err">'\</span><span class="n">u</span><span class="p">{</span><span class="mi">23</span><span class="p">}</span><span class="err">'</span><span class="p">;</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">u1</span> <span class="o">==</span> <span class="n">u2</span><span class="p">);</span>
</pre></table></code></div></div><h2 id="named-universal-character-escapes">Named universal character escapes</h2><p>Since C++11 we can use universal character names such as <code class="language-plaintext highlighter-rouge">U'\u0100'</code> which stands for the UTF-32 character literal with <code class="language-plaintext highlighter-rouge">U+0100</code> which has the name <code class="language-plaintext highlighter-rouge">{LATIN CAPITAL LETTER A WITH MACRON}</code>. We can also use characters in combination such as <code class="language-plaintext highlighter-rouge">u8"\u0100\u0300"</code> which combines <code class="language-plaintext highlighter-rouge">{LATIN CAPITAL LETTER A WITH MACRON}</code> with <code class="language-plaintext highlighter-rouge">{COMBINING GRAVE ACCENT}</code>.</p><p>Thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2071r2.html">P2071R2</a>, we will be able to use directly the Unicode-assigned names instead of the Unicode point values. We’ll have to introduce these names after the <code class="language-plaintext highlighter-rouge">\N</code> escape sequence:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="n">U</span><span class="err">'\</span><span class="n">N</span><span class="p">{</span><span class="n">LATIN</span> <span class="n">CAPITAL</span> <span class="n">LETTER</span> <span class="n">A</span> <span class="n">WITH</span> <span class="n">MACRON</span><span class="p">}</span><span class="err">'</span> <span class="c1">// Equivalent to U'\u0100'</span>
<span class="s">u8"\N{LATIN CAPITAL LETTER A WITH MACRON}\N{COMBINING GRAVE ACCENT}"</span> <span class="c1">// Equivalent to u8"\u0100\u0300"</span>
</pre></table></code></div></div><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2071r2.html">This proposal</a> is a relatively long, but at the same time also an interesting read about different considerations and objections regarding this new feature. One of the concerns was the sheer size of the Unicode name database that contains the codes (e.g. <code class="language-plaintext highlighter-rouge">U+0100</code>) and the names (e.g. <code class="language-plaintext highlighter-rouge">{LATIN CAPITAL LETTER A WITH MACRON}</code>). It’s around 1.5 MiB which can significantly impact the size of compiler distributions. The authors proved that a non-naive implementation can be around 300 KiB or even less.</p><p>Another open question was how to accept the Unicode-assigned names. Is <code class="language-plaintext highlighter-rouge">{latin capital letter a with macron}</code> just as good as <code class="language-plaintext highlighter-rouge">{LATIN CAPITAL LETTER A WITH MACRON}</code>? Or what about <code class="language-plaintext highlighter-rouge">{LATIN_CAPITAL_LETTER_A_WITH_MACRON}</code>? While the Unicode consortium standardized an algorithm called <a href="https://www.unicode.org/reports/tr44/tr44-24.html#UAX44-LM2">UAX44-LM2</a> for that purpose and it’s quite permissive, language implementors barely follow it. C++ is going to require an exact match with the database therefore the answer to the previous question is no, <code class="language-plaintext highlighter-rouge">{latin capital letter a with macron}</code> is not the same as <code class="language-plaintext highlighter-rouge">{LATIN CAPITAL LETTER A WITH MACRON}</code>. On the other hand, if there will be a strong need, the requirements can be relaxed in a later version.</p><p>If you want to know more, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2071r2.html">read P2071R2</a>.</p><h2 id="conclusion">Conclusion</h2><p>As we saw today, C++23 made some important steps towards supporting Unicode in a consistent way. We are not going to be able to use emojis in identifiers. From now on, non-encodable wide character literals and multicharacter wide character literals are ill-formed. Delimiter escape sequences will become more readable for octal, hexadecimal and Unicode sequences whose leading zeros might be omitted from now on. And still speaking about universal character escapes, instead of hexadecimal codes, from now on, we can also use the named versions. When I say from now on, of course, I mean C++23 and I assume compiler support that you can always check here on <a href="https://en.cppreference.com/w/cpp/compiler_support">C++ Reference</a>.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/unicode/" class="post-tag no-text-decoration" >unicode</a> <a href="/tags/i18n/" class="post-tag no-text-decoration" >i18n</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: Growing unicode support - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: Growing unicode support - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: Growing unicode support - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: Growing unicode support - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/11/25/nonconform-gergely-boszormenyi" class="btn btn-outline-primary" prompt="Older"><p>Nonconform by Gergely Böszörményi-Nagy</p></a> <a href="/blog/2023/12/06/cpp23-strtream-strstream-replacement" class="btn btn-outline-primary" prompt="Newer"><p>C++23: The rise of new streams</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: Growing unicode support'; this.page.url = 'https://www.sandordargo.com/blog/2023/11/29/cpp23-unicode-support'; this.page.identifier = '/blog/2023/11/29/cpp23-unicode-support'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
