<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++: The most important complexities" /><meta property="og:locale" content="en_US" /><meta name="description" content="It’s been about a year since I started to work for Spotify. That time I wrote a few articles about my job search experience. Among others, I shared how much I underestimated the importance of complexity analysis and the big-O notations when it comes to senior roles. My assumption was that knowing the space and time complexities of the different algorithms and operations on different data structures isn’t something important. Dealing with such issues is rare in most jobs. Still, asking about complexities might be an easy way to rate someone’s knowledge when it comes to candidates with no or short experience. On the other hand, when you’re looking for experienced people, there should be many other more meaningful ways to understand someone else’s skills. I still think that this is true, but I also realized that many big (and small) companies just go with the standard questions involving complexity analysis. Therefore, finally, I collected some complexities and some tips to learn them. Communication over end results The end result of your complexity analysis is important. Yet, it’s secondary. It doesn’t differ from other interview questions in this sense. The most important is clear communication. You have to share your thread of thoughts partly because it proves how good a communicator you are and partly because sharing your thoughts is insurance against your mistakes. If you have a mistake in your analysis, you’ll still show that otherwise, your thinking was right. Whereas if you simply share a result and it’s bad, you failed to share anything positive at all. This is even more important if you know that you have holes in your knowledge - just like me. When you start analyzing a problem, tell what you know for sure and share the assumptions you have and start your analysis from there. Most probably you’ll understand how loops are composed, how they (don’t) add up if they are sequential and how they influence the complexity of an algorithm if they are nested. At the same time, most probably there will be some container manipulations - either directly or through some standard functions - within the loops and you might lack some knowledge regarding the complexity of those calls. Sharing your assumptions will at least balance a bit of that lack of knowledge. In the worst case, you’ll have a useful discussion with your interviewer. When I was interviewing for a position at a code analysis company, I clearly failed the interview due to my lack of knowledge in this field, but at least I learned a few tips about how to approach complexity analysis in future interviews, which clearly helped me get an offer from Spotify. How to learn If you want to learn complexity analysis, you might just revisit your CS studies where most probably it was covered in detail. An even better option with less fluff is to take a book such as Cracking the Coding Interview and start reading it thoroughly and solving its exercises on a regular basis. Ideally, you’d spend some time on it every day or at least once or twice a week. Even if you don’t plan to interview in the near future. Or maybe especially if you don’t plan to interview in the near future! I don’t know about you, but I’m not a university student anymore who can pull in one-nighters just to pass an exam and forget about what I learned hoping that I won’t need that crap for the rest of my life. You never know what tomorrow will bring. Maybe you get laid off the next day, or you just realise that it’s time to leave. Then it’ll be a bit late to start preparing. It’s better if you have already started your preparation! But as I said many times, most people are lazy and disorganized. So what to do if you need to improve your complexity analysis skills as soon as possible before a C++ coding interview? identify the most important time/space complexities you should know go on the C++ Reference pages of the identified functions and methods and start memorising the complexities spend some time on this activity every day, consistency will do miracles even better if you revisit your CS basics when you learn about a complexity so that you understand why inserting into a std::map has the complexity of O(log n). This will both make it easier for you to succeed in general complexity analysis tasks and it’ll also make you realize that it’s not so difficult to learn it, you just need some time. In the next sections, I’ll help you collect the most fundamental complexities. Notions Before we get into discussing complexities, let’s remind ourselves about the different notions. O(1) stands for constant complexity, meaning that the complexity doesn’t depend on the input size, it’ll always be about the same. A variation of constant complexity is amortized constant complexity. It means that the runtime will be much slower once in a while, but very rarely, so overall, on average, that slowdown is amortized so we can still talk about a constant complexity. Linear complexity O(n) means that as the input size grows, the necessary amount of operations grows the same way. On the other hand, when we talk about logarithmic complexity O(log n), the number of operations that need to be executed grows much slower than the input size. When it comes to C++ standard containers and algorithms, these are the three notions that we use. Still, it’s good to remind ourselves that there are also quadratic and exponential complexities. When we talk about quadratic complexity O(n^2), the number of required operations is about the squared size of the input. That’s quite bad. But not as bad as the exponential complexity O(2^n) where by each additional input element the necessary time or space doubles. (While there are other complexities, these are the most widely used ones.) Containers and operations First, let’s see what are the most important containers you’ll likely deal with in a coding interview, what are the underlying data structures and what are the related complexities. My goal is not to give you a deep analysis, just to provide you with the most necessary information, then you can do your own research. std::array std::array is a fixed-size array, storing objects in contiguous memory locations. accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) accessing a random element: with at() or with operator[] both have a complexity of O(1) std::list std::list is a container that supports fast insertion and removal, but doesn’t support fast random access. It is usually implemented as a doubly-linked list. std::forward_list is similar, but implemented with a singly-linked list, so it’s more space efficient, but it supports iteration only in one direction accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) (not supported by std::forward_list) accessing a random element: not supported inserting at the front: with push_front() which has a complexity of O(1) inserting at the back: with push_back() which has a complexity of O(1) (not supported by std::forward_list) inserting at a random location: with insert() which has a complexity of O(1) for one element, and complexity of O(n) for multiple elements, where n is the number of elements to be inserted (insert_after for std::forward_list) removing an item from the front: with pop_front() which has a complexity of O(1) removing an item from the back: with pop_back() which has a complexity of O(1) (not supported by std::forward_list) removing an item from a random location: with erase() which has a complexity of O(1) for one element, and a complexity of O(n) for multiple elements, where n is the number of elements to be erased (erase_after for std::forward_list) std::vector std::vector is a dynamically sized sequence container, where the elements are stored contiguously. Random access is cheap, as well as operations at the end, unless reallocation is required. accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) accessing a random element: with at() or with operator[] both have a complexity of O(1) inserting at the front: with insert() which has a complexity of O(n+m) where n is the number of elements to insert and m is the size of the container inserting at the back: with push_back() which has a complexity of amortized O(1) inserting at a random location: with insert() which has a complexity of O(n+m) where n is the number of elements to insert and m is the distance between the elements to insert and the end of the container removing an item from the front: with erase() which has a complexity of O(n+m) where n is the number of elements erased (calls to the destructor) and m is the number of assignments to make - the size of the elements left in the vector removing an item from the back: with pop_back() which has a complexity of O(1) removing an item from a random location: with erase() which has a complexity of O(n+m) where n is the number of elements erased (calls to the destructor) and m is the number of assignments to make - at least the number of elements after the last erased item, worst the size of the whole container left std::map std::map is a sorted associative container providing search, removal and insertion at a logarithmic complexity. They are usually implemented as red-black trees. accessing an element: with at() or with operator[] both have a complexity of O(log n) where n is the size of the container inserting an element at a random location: with insert() or with operator[] both have a complexity of O(log n) where n is the size of the container. With insert() you can insert multiple elements, and then the complexity becomes O(m * log n), where m is the number of elements to insert. insert() can also take a position as a hint where to insert. If the insertion happens there then the complexity is amortized O(1) otherwise O(log n) removing an item: with erase() which has a complexity of amortized O(1) if the erasure happens with an iterator, otherwise it’s O(log(n) + m) where n is the size of the container and m is the number of elements to remove finding an element: with find() which has a complexity of O(log n) where n is the size of the container std::unordered_map std::unordered_map is an unsorted associative container optimized for search, removal and insertion which come at a constant time complexity. std::unordered_map is a hash map internally. accessing an element: with at() or with operator[] both have a complexity of O(1) on average and O(n) at worst where n is the size of the container inserting an element at a random location: with insert() or with operator[] both have a complexity of O(1) on average and O(n) at worst, where n is the size of the map. If m elements are inserted then the average case is O(m) and the worst case is O(m * n + n) removing an item: with erase() which has a complexity of amortized O(1) if the erasure happens with an iterator, otherwise, on average it’s O(m) where m is the number of elements to remove, worst case it’s O(n) where n is the size of the container finding an element: with find() it’s O(1) on average and in the worst case it’s O(n) where n is the size of the container Algorithms If you use raw loops and you understand the containers, you don’t have to deal with these. A surprising “advantage” of using raw loops - please, prefer algorithms! Otherwise, most probably you understand what standard algorithms do. Think about them and you’ll be able to come up with their complexities in most cases. Let’s have a look at some algorithms: all_of/ any_of / none_of have at most O(n) complexity where n is the size of the range the algorithm is applied on count_if has a complexity of O(n) where n is the size of the range the algorithm is applied on find / find_if have a complexity of O(n). They need at most n applications of operator== or a predicate where n is the length of the range passed in replace / replace_if have a complexity of O(n). They need n applications of operator== or of a predicate where n is the length of the range passed in and at most n assignments copy / copy_if have a complexity of O(n). copy does n assignments where n is the length of the passed-in range, for copy_if we also have to think about the application of the predicate, while the number of assignments might be smaller. transform also has a complexity of O(n). It performs exactly n applications of the operation, where n is the length of the passed-in range. generate has a complexity of O(n) as it invokes n times the generator function and also performs the same amount of assignments. remove_if has a complexity of O(n) as it performs n applications of operator== or of a predicate where n is the length of the range passed in. swap has a complexity of O(1) if applied on single values and O(n) if applied on arrays where n is the size of the arrays to be swapped reverse performs exactly half as many swaps as the size of the range to be reversed, therefore the complexity is O(n) rotate also has a complexity of O(n). Quite boring, right? But boredom brings simplicity to your calculations. Conclusion In this article, we talked about the complexity analysis of operations on containers and of algorithms which are so often make important part of a software developer job interview. We discussed some hints on how to approach such questions if you neglected complexity analysis during most of your preparation for interviews. Finally, we quickly went through the most important complexities of C++ containers and standard algorithms so that you can have the most basic characteristics that you’d need at a job interview. Good luck! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="It’s been about a year since I started to work for Spotify. That time I wrote a few articles about my job search experience. Among others, I shared how much I underestimated the importance of complexity analysis and the big-O notations when it comes to senior roles. My assumption was that knowing the space and time complexities of the different algorithms and operations on different data structures isn’t something important. Dealing with such issues is rare in most jobs. Still, asking about complexities might be an easy way to rate someone’s knowledge when it comes to candidates with no or short experience. On the other hand, when you’re looking for experienced people, there should be many other more meaningful ways to understand someone else’s skills. I still think that this is true, but I also realized that many big (and small) companies just go with the standard questions involving complexity analysis. Therefore, finally, I collected some complexities and some tips to learn them. Communication over end results The end result of your complexity analysis is important. Yet, it’s secondary. It doesn’t differ from other interview questions in this sense. The most important is clear communication. You have to share your thread of thoughts partly because it proves how good a communicator you are and partly because sharing your thoughts is insurance against your mistakes. If you have a mistake in your analysis, you’ll still show that otherwise, your thinking was right. Whereas if you simply share a result and it’s bad, you failed to share anything positive at all. This is even more important if you know that you have holes in your knowledge - just like me. When you start analyzing a problem, tell what you know for sure and share the assumptions you have and start your analysis from there. Most probably you’ll understand how loops are composed, how they (don’t) add up if they are sequential and how they influence the complexity of an algorithm if they are nested. At the same time, most probably there will be some container manipulations - either directly or through some standard functions - within the loops and you might lack some knowledge regarding the complexity of those calls. Sharing your assumptions will at least balance a bit of that lack of knowledge. In the worst case, you’ll have a useful discussion with your interviewer. When I was interviewing for a position at a code analysis company, I clearly failed the interview due to my lack of knowledge in this field, but at least I learned a few tips about how to approach complexity analysis in future interviews, which clearly helped me get an offer from Spotify. How to learn If you want to learn complexity analysis, you might just revisit your CS studies where most probably it was covered in detail. An even better option with less fluff is to take a book such as Cracking the Coding Interview and start reading it thoroughly and solving its exercises on a regular basis. Ideally, you’d spend some time on it every day or at least once or twice a week. Even if you don’t plan to interview in the near future. Or maybe especially if you don’t plan to interview in the near future! I don’t know about you, but I’m not a university student anymore who can pull in one-nighters just to pass an exam and forget about what I learned hoping that I won’t need that crap for the rest of my life. You never know what tomorrow will bring. Maybe you get laid off the next day, or you just realise that it’s time to leave. Then it’ll be a bit late to start preparing. It’s better if you have already started your preparation! But as I said many times, most people are lazy and disorganized. So what to do if you need to improve your complexity analysis skills as soon as possible before a C++ coding interview? identify the most important time/space complexities you should know go on the C++ Reference pages of the identified functions and methods and start memorising the complexities spend some time on this activity every day, consistency will do miracles even better if you revisit your CS basics when you learn about a complexity so that you understand why inserting into a std::map has the complexity of O(log n). This will both make it easier for you to succeed in general complexity analysis tasks and it’ll also make you realize that it’s not so difficult to learn it, you just need some time. In the next sections, I’ll help you collect the most fundamental complexities. Notions Before we get into discussing complexities, let’s remind ourselves about the different notions. O(1) stands for constant complexity, meaning that the complexity doesn’t depend on the input size, it’ll always be about the same. A variation of constant complexity is amortized constant complexity. It means that the runtime will be much slower once in a while, but very rarely, so overall, on average, that slowdown is amortized so we can still talk about a constant complexity. Linear complexity O(n) means that as the input size grows, the necessary amount of operations grows the same way. On the other hand, when we talk about logarithmic complexity O(log n), the number of operations that need to be executed grows much slower than the input size. When it comes to C++ standard containers and algorithms, these are the three notions that we use. Still, it’s good to remind ourselves that there are also quadratic and exponential complexities. When we talk about quadratic complexity O(n^2), the number of required operations is about the squared size of the input. That’s quite bad. But not as bad as the exponential complexity O(2^n) where by each additional input element the necessary time or space doubles. (While there are other complexities, these are the most widely used ones.) Containers and operations First, let’s see what are the most important containers you’ll likely deal with in a coding interview, what are the underlying data structures and what are the related complexities. My goal is not to give you a deep analysis, just to provide you with the most necessary information, then you can do your own research. std::array std::array is a fixed-size array, storing objects in contiguous memory locations. accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) accessing a random element: with at() or with operator[] both have a complexity of O(1) std::list std::list is a container that supports fast insertion and removal, but doesn’t support fast random access. It is usually implemented as a doubly-linked list. std::forward_list is similar, but implemented with a singly-linked list, so it’s more space efficient, but it supports iteration only in one direction accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) (not supported by std::forward_list) accessing a random element: not supported inserting at the front: with push_front() which has a complexity of O(1) inserting at the back: with push_back() which has a complexity of O(1) (not supported by std::forward_list) inserting at a random location: with insert() which has a complexity of O(1) for one element, and complexity of O(n) for multiple elements, where n is the number of elements to be inserted (insert_after for std::forward_list) removing an item from the front: with pop_front() which has a complexity of O(1) removing an item from the back: with pop_back() which has a complexity of O(1) (not supported by std::forward_list) removing an item from a random location: with erase() which has a complexity of O(1) for one element, and a complexity of O(n) for multiple elements, where n is the number of elements to be erased (erase_after for std::forward_list) std::vector std::vector is a dynamically sized sequence container, where the elements are stored contiguously. Random access is cheap, as well as operations at the end, unless reallocation is required. accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) accessing a random element: with at() or with operator[] both have a complexity of O(1) inserting at the front: with insert() which has a complexity of O(n+m) where n is the number of elements to insert and m is the size of the container inserting at the back: with push_back() which has a complexity of amortized O(1) inserting at a random location: with insert() which has a complexity of O(n+m) where n is the number of elements to insert and m is the distance between the elements to insert and the end of the container removing an item from the front: with erase() which has a complexity of O(n+m) where n is the number of elements erased (calls to the destructor) and m is the number of assignments to make - the size of the elements left in the vector removing an item from the back: with pop_back() which has a complexity of O(1) removing an item from a random location: with erase() which has a complexity of O(n+m) where n is the number of elements erased (calls to the destructor) and m is the number of assignments to make - at least the number of elements after the last erased item, worst the size of the whole container left std::map std::map is a sorted associative container providing search, removal and insertion at a logarithmic complexity. They are usually implemented as red-black trees. accessing an element: with at() or with operator[] both have a complexity of O(log n) where n is the size of the container inserting an element at a random location: with insert() or with operator[] both have a complexity of O(log n) where n is the size of the container. With insert() you can insert multiple elements, and then the complexity becomes O(m * log n), where m is the number of elements to insert. insert() can also take a position as a hint where to insert. If the insertion happens there then the complexity is amortized O(1) otherwise O(log n) removing an item: with erase() which has a complexity of amortized O(1) if the erasure happens with an iterator, otherwise it’s O(log(n) + m) where n is the size of the container and m is the number of elements to remove finding an element: with find() which has a complexity of O(log n) where n is the size of the container std::unordered_map std::unordered_map is an unsorted associative container optimized for search, removal and insertion which come at a constant time complexity. std::unordered_map is a hash map internally. accessing an element: with at() or with operator[] both have a complexity of O(1) on average and O(n) at worst where n is the size of the container inserting an element at a random location: with insert() or with operator[] both have a complexity of O(1) on average and O(n) at worst, where n is the size of the map. If m elements are inserted then the average case is O(m) and the worst case is O(m * n + n) removing an item: with erase() which has a complexity of amortized O(1) if the erasure happens with an iterator, otherwise, on average it’s O(m) where m is the number of elements to remove, worst case it’s O(n) where n is the size of the container finding an element: with find() it’s O(1) on average and in the worst case it’s O(n) where n is the size of the container Algorithms If you use raw loops and you understand the containers, you don’t have to deal with these. A surprising “advantage” of using raw loops - please, prefer algorithms! Otherwise, most probably you understand what standard algorithms do. Think about them and you’ll be able to come up with their complexities in most cases. Let’s have a look at some algorithms: all_of/ any_of / none_of have at most O(n) complexity where n is the size of the range the algorithm is applied on count_if has a complexity of O(n) where n is the size of the range the algorithm is applied on find / find_if have a complexity of O(n). They need at most n applications of operator== or a predicate where n is the length of the range passed in replace / replace_if have a complexity of O(n). They need n applications of operator== or of a predicate where n is the length of the range passed in and at most n assignments copy / copy_if have a complexity of O(n). copy does n assignments where n is the length of the passed-in range, for copy_if we also have to think about the application of the predicate, while the number of assignments might be smaller. transform also has a complexity of O(n). It performs exactly n applications of the operation, where n is the length of the passed-in range. generate has a complexity of O(n) as it invokes n times the generator function and also performs the same amount of assignments. remove_if has a complexity of O(n) as it performs n applications of operator== or of a predicate where n is the length of the range passed in. swap has a complexity of O(1) if applied on single values and O(n) if applied on arrays where n is the size of the arrays to be swapped reverse performs exactly half as many swaps as the size of the range to be reversed, therefore the complexity is O(n) rotate also has a complexity of O(n). Quite boring, right? But boredom brings simplicity to your calculations. Conclusion In this article, we talked about the complexity analysis of operations on containers and of algorithms which are so often make important part of a software developer job interview. We discussed some hints on how to approach such questions if you neglected complexity analysis during most of your preparation for interviews. Finally, we quickly went through the most important complexities of C++ containers and standard algorithms so that you can have the most basic characteristics that you’d need at a job interview. Good luck! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/11/15/most-important-complexities" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/11/15/most-important-complexities" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-11-15T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++: The most important complexities" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-11-21T23:05:01+01:00","datePublished":"2023-11-15T00:00:00+01:00","description":"It’s been about a year since I started to work for Spotify. That time I wrote a few articles about my job search experience. Among others, I shared how much I underestimated the importance of complexity analysis and the big-O notations when it comes to senior roles. My assumption was that knowing the space and time complexities of the different algorithms and operations on different data structures isn’t something important. Dealing with such issues is rare in most jobs. Still, asking about complexities might be an easy way to rate someone’s knowledge when it comes to candidates with no or short experience. On the other hand, when you’re looking for experienced people, there should be many other more meaningful ways to understand someone else’s skills. I still think that this is true, but I also realized that many big (and small) companies just go with the standard questions involving complexity analysis. Therefore, finally, I collected some complexities and some tips to learn them. Communication over end results The end result of your complexity analysis is important. Yet, it’s secondary. It doesn’t differ from other interview questions in this sense. The most important is clear communication. You have to share your thread of thoughts partly because it proves how good a communicator you are and partly because sharing your thoughts is insurance against your mistakes. If you have a mistake in your analysis, you’ll still show that otherwise, your thinking was right. Whereas if you simply share a result and it’s bad, you failed to share anything positive at all. This is even more important if you know that you have holes in your knowledge - just like me. When you start analyzing a problem, tell what you know for sure and share the assumptions you have and start your analysis from there. Most probably you’ll understand how loops are composed, how they (don’t) add up if they are sequential and how they influence the complexity of an algorithm if they are nested. At the same time, most probably there will be some container manipulations - either directly or through some standard functions - within the loops and you might lack some knowledge regarding the complexity of those calls. Sharing your assumptions will at least balance a bit of that lack of knowledge. In the worst case, you’ll have a useful discussion with your interviewer. When I was interviewing for a position at a code analysis company, I clearly failed the interview due to my lack of knowledge in this field, but at least I learned a few tips about how to approach complexity analysis in future interviews, which clearly helped me get an offer from Spotify. How to learn If you want to learn complexity analysis, you might just revisit your CS studies where most probably it was covered in detail. An even better option with less fluff is to take a book such as Cracking the Coding Interview and start reading it thoroughly and solving its exercises on a regular basis. Ideally, you’d spend some time on it every day or at least once or twice a week. Even if you don’t plan to interview in the near future. Or maybe especially if you don’t plan to interview in the near future! I don’t know about you, but I’m not a university student anymore who can pull in one-nighters just to pass an exam and forget about what I learned hoping that I won’t need that crap for the rest of my life. You never know what tomorrow will bring. Maybe you get laid off the next day, or you just realise that it’s time to leave. Then it’ll be a bit late to start preparing. It’s better if you have already started your preparation! But as I said many times, most people are lazy and disorganized. So what to do if you need to improve your complexity analysis skills as soon as possible before a C++ coding interview? identify the most important time/space complexities you should know go on the C++ Reference pages of the identified functions and methods and start memorising the complexities spend some time on this activity every day, consistency will do miracles even better if you revisit your CS basics when you learn about a complexity so that you understand why inserting into a std::map has the complexity of O(log n). This will both make it easier for you to succeed in general complexity analysis tasks and it’ll also make you realize that it’s not so difficult to learn it, you just need some time. In the next sections, I’ll help you collect the most fundamental complexities. Notions Before we get into discussing complexities, let’s remind ourselves about the different notions. O(1) stands for constant complexity, meaning that the complexity doesn’t depend on the input size, it’ll always be about the same. A variation of constant complexity is amortized constant complexity. It means that the runtime will be much slower once in a while, but very rarely, so overall, on average, that slowdown is amortized so we can still talk about a constant complexity. Linear complexity O(n) means that as the input size grows, the necessary amount of operations grows the same way. On the other hand, when we talk about logarithmic complexity O(log n), the number of operations that need to be executed grows much slower than the input size. When it comes to C++ standard containers and algorithms, these are the three notions that we use. Still, it’s good to remind ourselves that there are also quadratic and exponential complexities. When we talk about quadratic complexity O(n^2), the number of required operations is about the squared size of the input. That’s quite bad. But not as bad as the exponential complexity O(2^n) where by each additional input element the necessary time or space doubles. (While there are other complexities, these are the most widely used ones.) Containers and operations First, let’s see what are the most important containers you’ll likely deal with in a coding interview, what are the underlying data structures and what are the related complexities. My goal is not to give you a deep analysis, just to provide you with the most necessary information, then you can do your own research. std::array std::array is a fixed-size array, storing objects in contiguous memory locations. accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) accessing a random element: with at() or with operator[] both have a complexity of O(1) std::list std::list is a container that supports fast insertion and removal, but doesn’t support fast random access. It is usually implemented as a doubly-linked list. std::forward_list is similar, but implemented with a singly-linked list, so it’s more space efficient, but it supports iteration only in one direction accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) (not supported by std::forward_list) accessing a random element: not supported inserting at the front: with push_front() which has a complexity of O(1) inserting at the back: with push_back() which has a complexity of O(1) (not supported by std::forward_list) inserting at a random location: with insert() which has a complexity of O(1) for one element, and complexity of O(n) for multiple elements, where n is the number of elements to be inserted (insert_after for std::forward_list) removing an item from the front: with pop_front() which has a complexity of O(1) removing an item from the back: with pop_back() which has a complexity of O(1) (not supported by std::forward_list) removing an item from a random location: with erase() which has a complexity of O(1) for one element, and a complexity of O(n) for multiple elements, where n is the number of elements to be erased (erase_after for std::forward_list) std::vector std::vector is a dynamically sized sequence container, where the elements are stored contiguously. Random access is cheap, as well as operations at the end, unless reallocation is required. accessing the first element: with front() which has a complexity of O(1) accessing the last element: with back() which has a complexity of O(1) accessing a random element: with at() or with operator[] both have a complexity of O(1) inserting at the front: with insert() which has a complexity of O(n+m) where n is the number of elements to insert and m is the size of the container inserting at the back: with push_back() which has a complexity of amortized O(1) inserting at a random location: with insert() which has a complexity of O(n+m) where n is the number of elements to insert and m is the distance between the elements to insert and the end of the container removing an item from the front: with erase() which has a complexity of O(n+m) where n is the number of elements erased (calls to the destructor) and m is the number of assignments to make - the size of the elements left in the vector removing an item from the back: with pop_back() which has a complexity of O(1) removing an item from a random location: with erase() which has a complexity of O(n+m) where n is the number of elements erased (calls to the destructor) and m is the number of assignments to make - at least the number of elements after the last erased item, worst the size of the whole container left std::map std::map is a sorted associative container providing search, removal and insertion at a logarithmic complexity. They are usually implemented as red-black trees. accessing an element: with at() or with operator[] both have a complexity of O(log n) where n is the size of the container inserting an element at a random location: with insert() or with operator[] both have a complexity of O(log n) where n is the size of the container. With insert() you can insert multiple elements, and then the complexity becomes O(m * log n), where m is the number of elements to insert. insert() can also take a position as a hint where to insert. If the insertion happens there then the complexity is amortized O(1) otherwise O(log n) removing an item: with erase() which has a complexity of amortized O(1) if the erasure happens with an iterator, otherwise it’s O(log(n) + m) where n is the size of the container and m is the number of elements to remove finding an element: with find() which has a complexity of O(log n) where n is the size of the container std::unordered_map std::unordered_map is an unsorted associative container optimized for search, removal and insertion which come at a constant time complexity. std::unordered_map is a hash map internally. accessing an element: with at() or with operator[] both have a complexity of O(1) on average and O(n) at worst where n is the size of the container inserting an element at a random location: with insert() or with operator[] both have a complexity of O(1) on average and O(n) at worst, where n is the size of the map. If m elements are inserted then the average case is O(m) and the worst case is O(m * n + n) removing an item: with erase() which has a complexity of amortized O(1) if the erasure happens with an iterator, otherwise, on average it’s O(m) where m is the number of elements to remove, worst case it’s O(n) where n is the size of the container finding an element: with find() it’s O(1) on average and in the worst case it’s O(n) where n is the size of the container Algorithms If you use raw loops and you understand the containers, you don’t have to deal with these. A surprising “advantage” of using raw loops - please, prefer algorithms! Otherwise, most probably you understand what standard algorithms do. Think about them and you’ll be able to come up with their complexities in most cases. Let’s have a look at some algorithms: all_of/ any_of / none_of have at most O(n) complexity where n is the size of the range the algorithm is applied on count_if has a complexity of O(n) where n is the size of the range the algorithm is applied on find / find_if have a complexity of O(n). They need at most n applications of operator== or a predicate where n is the length of the range passed in replace / replace_if have a complexity of O(n). They need n applications of operator== or of a predicate where n is the length of the range passed in and at most n assignments copy / copy_if have a complexity of O(n). copy does n assignments where n is the length of the passed-in range, for copy_if we also have to think about the application of the predicate, while the number of assignments might be smaller. transform also has a complexity of O(n). It performs exactly n applications of the operation, where n is the length of the passed-in range. generate has a complexity of O(n) as it invokes n times the generator function and also performs the same amount of assignments. remove_if has a complexity of O(n) as it performs n applications of operator== or of a predicate where n is the length of the range passed in. swap has a complexity of O(1) if applied on single values and O(n) if applied on arrays where n is the size of the arrays to be swapped reverse performs exactly half as many swaps as the size of the range to be reversed, therefore the complexity is O(n) rotate also has a complexity of O(n). Quite boring, right? But boredom brings simplicity to your calculations. Conclusion In this article, we talked about the complexity analysis of operations on containers and of algorithms which are so often make important part of a software developer job interview. We discussed some hints on how to approach such questions if you neglected complexity analysis during most of your preparation for interviews. Finally, we quickly went through the most important complexities of C++ containers and standard algorithms so that you can have the most basic characteristics that you’d need at a job interview. Good luck! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++: The most important complexities","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/11/15/most-important-complexities"},"url":"https://www.sandordargo.com/blog/2023/11/15/most-important-complexities"}</script><title>C++: The most important complexities | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/15"> 15 </a> </span> <span>C++: The most important complexities</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++: The most important complexities</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 15, 2023, 12:00 AM +0100" prep="on" > Nov 15, 2023 <i class="unloaded">2023-11-15T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Tue, Nov 21, 2023, 11:05 PM +0100" prefix="Updated " > Nov 21, 2023 <i class="unloaded">2023-11-21T23:05:01+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2385 words">13 min</span></div></div><div class="post-content"><p>It’s been about a year since I started to work for Spotify. That time <a href="https://www.sandordargo.com/blog/2022/09/28/5-tips-to-find-your-next-job">I wrote a few articles about my job search experience</a>. Among others, I shared <a href="https://www.sandordargo.com/blog/2022/08/31/data-structure-and-algorithms-interviews">how much I underestimated the importance of complexity analysis and the big-O notations</a> when it comes to senior roles.</p><p>My assumption was that knowing the space and time complexities of the different algorithms and operations on different data structures isn’t something important. Dealing with such issues is rare in most jobs. Still, asking about complexities might be an easy way to rate someone’s knowledge when it comes to candidates with no or short experience. On the other hand, when you’re looking for experienced people, there should be many other more meaningful ways to understand someone else’s skills. I still think that this is true, but I also realized that many big (and small) companies just go with the standard questions involving complexity analysis.</p><p>Therefore, finally, I collected some complexities and some tips to learn them.</p><h2 id="communication-over-end-results">Communication over end results</h2><p>The end result of your complexity analysis is important. Yet, it’s secondary. It doesn’t differ from other interview questions in this sense. The most important is clear communication. You have to share your thread of thoughts partly because it proves how good a communicator you are and partly because sharing your thoughts is insurance against your mistakes. If you have a mistake in your analysis, you’ll still show that otherwise, your thinking was right. Whereas if you simply share a result and it’s bad, you failed to share anything positive at all.</p><p>This is even more important if you know that you have holes in your knowledge - just like me. When you start analyzing a problem, tell what you know for sure and share the assumptions you have and start your analysis from there.</p><p>Most probably you’ll understand how loops are composed, how they (don’t) add up if they are sequential and how they influence the complexity of an algorithm if they are nested. At the same time, most probably there will be some container manipulations - either directly or through some standard functions - within the loops and you might lack some knowledge regarding the complexity of those calls. Sharing your assumptions will at least balance a bit of that lack of knowledge. In the worst case, you’ll have a useful discussion with your interviewer.</p><p>When I was interviewing for a position at a code analysis company, I clearly failed the interview due to my lack of knowledge in this field, but at least I learned a few tips about how to approach complexity analysis in future interviews, which clearly helped me get an offer from Spotify.</p><h2 id="how-to-learn">How to learn</h2><p>If you want to learn complexity analysis, you might just revisit your CS studies where most probably it was covered in detail. An even better option with less fluff is to take a book such as <a href="https://www.amazon.com/Cracking-Coding-Interview-Programming-Questions/dp/0984782850?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=57a2bee06dddc5cc8f05aa7e075379f7&amp;camp=1789&amp;creative=9325">Cracking the Coding Interview</a> and start reading it thoroughly and solving its exercises on a regular basis.</p><p>Ideally, you’d spend some time on it every day or at least once or twice a week. Even if you don’t plan to interview in the near future.</p><p>Or maybe especially if you don’t plan to interview in the near future!</p><p>I don’t know about you, but I’m not a university student anymore who can pull in one-nighters just to pass an exam and forget about what I learned hoping that I won’t need that crap for the rest of my life.</p><p>You never know what tomorrow will bring. Maybe you get laid off the next day, or you just realise that it’s time to leave. Then it’ll be a bit late to start preparing. It’s better if you have already started your preparation!</p><p>But as I said many times, most people are lazy and disorganized. So what to do if you need to improve your complexity analysis skills as soon as possible before a C++ coding interview?</p><ul><li>identify the most important time/space complexities you should know<li>go on the <a href="https://en.cppreference.com/w/">C++ Reference</a> pages of the identified functions and methods and start memorising the complexities<li>spend some time on this activity every day, consistency will do miracles<li>even better if you revisit your CS basics when you learn about a complexity so that you understand why inserting into a <code class="language-plaintext highlighter-rouge">std::map</code> has the complexity of <em>O(log n)</em>. This will both make it easier for you to succeed in general complexity analysis tasks and it’ll also make you realize that it’s not so difficult to learn it, you just need some time.</ul><p>In the next sections, I’ll help you collect the most fundamental complexities.</p><h2 id="notions">Notions</h2><p>Before we get into discussing complexities, let’s remind ourselves about the different notions.</p><p><code class="language-plaintext highlighter-rouge">O(1)</code> stands for constant complexity, meaning that the complexity doesn’t depend on the input size, it’ll always be about the same. A variation of constant complexity is <em>amortized</em> constant complexity. It means that the runtime will be much slower once in a while, but very rarely, so overall, on average, that slowdown is amortized so we can still talk about a constant complexity.</p><p>Linear complexity <code class="language-plaintext highlighter-rouge">O(n)</code> means that as the input size grows, the necessary amount of operations grows the same way.</p><p>On the other hand, when we talk about logarithmic complexity <code class="language-plaintext highlighter-rouge">O(log n)</code>, the number of operations that need to be executed grows much slower than the input size.</p><p>When it comes to C++ standard containers and algorithms, these are the three notions that we use. Still, it’s good to remind ourselves that there are also quadratic and exponential complexities. When we talk about quadratic complexity <code class="language-plaintext highlighter-rouge">O(n^2)</code>, the number of required operations is about the squared size of the input. That’s quite bad. But not as bad as the exponential complexity <code class="language-plaintext highlighter-rouge">O(2^n)</code> where by each additional input element the necessary time or space doubles. <em>(While there are other complexities, these are the most widely used ones.)</em></p><h2 id="containers-and-operations">Containers and operations</h2><p>First, let’s see what are the most important containers you’ll likely deal with in a coding interview, what are the underlying data structures and what are the related complexities. My goal is not to give you a deep analysis, just to provide you with the most necessary information, then you can do your own research.</p><h3 id="stdarray"><code class="language-plaintext highlighter-rouge">std::array</code></h3><p><code class="language-plaintext highlighter-rouge">std::array</code> is a fixed-size array, storing objects in contiguous memory locations.</p><ul><li><strong>accessing the first element</strong>: with <code class="language-plaintext highlighter-rouge">front()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>accessing the last element</strong>: with <code class="language-plaintext highlighter-rouge">back()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>accessing a random element</strong>: with <code class="language-plaintext highlighter-rouge">at()</code> or with <code class="language-plaintext highlighter-rouge">operator[]</code> both have a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code></ul><h3 id="stdlist"><code class="language-plaintext highlighter-rouge">std::list</code></h3><p><code class="language-plaintext highlighter-rouge">std::list</code> is a container that supports fast insertion and removal, but doesn’t support fast random access. It is usually implemented as a doubly-linked list. <code class="language-plaintext highlighter-rouge">std::forward_list</code> is similar, but implemented with a singly-linked list, so it’s more space efficient, but it supports iteration only in one direction</p><ul><li><strong>accessing the first element</strong>: with <code class="language-plaintext highlighter-rouge">front()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>accessing the last element</strong>: with <code class="language-plaintext highlighter-rouge">back()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> (not supported by <code class="language-plaintext highlighter-rouge">std::forward_list</code>)<li><p><strong>accessing a random element</strong>: not supported</p><li><strong>inserting at the front</strong>: with <code class="language-plaintext highlighter-rouge">push_front()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>inserting at the back</strong>: with <code class="language-plaintext highlighter-rouge">push_back()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> (not supported by <code class="language-plaintext highlighter-rouge">std::forward_list</code>)<li><p><strong>inserting at a random location</strong>: with <code class="language-plaintext highlighter-rouge">insert()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> for one element, and complexity of <code class="language-plaintext highlighter-rouge">O(n)</code> for multiple elements, where <code class="language-plaintext highlighter-rouge">n</code> is the number of elements to be inserted (<code class="language-plaintext highlighter-rouge">insert_after</code> for <code class="language-plaintext highlighter-rouge">std::forward_list</code>)</p><li><strong>removing an item from the front</strong>: with <code class="language-plaintext highlighter-rouge">pop_front()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>removing an item from the back</strong>: with <code class="language-plaintext highlighter-rouge">pop_back()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> (not supported by <code class="language-plaintext highlighter-rouge">std::forward_list</code>)<li><strong>removing an item from a random location</strong>: with <code class="language-plaintext highlighter-rouge">erase()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> for one element, and a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code> for multiple elements, where <code class="language-plaintext highlighter-rouge">n</code> is the number of elements to be erased (<code class="language-plaintext highlighter-rouge">erase_after</code> for <code class="language-plaintext highlighter-rouge">std::forward_list</code>)</ul><h3 id="stdvector"><code class="language-plaintext highlighter-rouge">std::vector</code></h3><p><code class="language-plaintext highlighter-rouge">std::vector</code> is a dynamically sized sequence container, where the elements are stored contiguously. Random access is cheap, as well as operations at the end, unless reallocation is required.</p><ul><li><strong>accessing the first element</strong>: with <code class="language-plaintext highlighter-rouge">front()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>accessing the last element</strong>: with <code class="language-plaintext highlighter-rouge">back()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><p><strong>accessing a random element</strong>: with <code class="language-plaintext highlighter-rouge">at()</code> or with <code class="language-plaintext highlighter-rouge">operator[]</code> both have a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code></p><li><strong>inserting at the front</strong>: with <code class="language-plaintext highlighter-rouge">insert()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(n+m)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the number of elements to insert and <code class="language-plaintext highlighter-rouge">m</code> is the size of the container<li><strong>inserting at the back</strong>: with <code class="language-plaintext highlighter-rouge">push_back()</code> which has a complexity of amortized <code class="language-plaintext highlighter-rouge">O(1)</code><li><p><strong>inserting at a random location</strong>: with <code class="language-plaintext highlighter-rouge">insert()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(n+m)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the number of elements to insert and <code class="language-plaintext highlighter-rouge">m</code> is the distance between the elements to insert and the end of the container</p><li><strong>removing an item from the front</strong>: with <code class="language-plaintext highlighter-rouge">erase()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(n+m)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the number of elements erased (calls to the destructor) and <code class="language-plaintext highlighter-rouge">m</code> is the number of assignments to make - the size of the elements left in the vector<li><strong>removing an item from the back</strong>: with <code class="language-plaintext highlighter-rouge">pop_back()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code><li><strong>removing an item from a random location</strong>: with <code class="language-plaintext highlighter-rouge">erase()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(n+m)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the number of elements erased (calls to the destructor) and <code class="language-plaintext highlighter-rouge">m</code> is the number of assignments to make - at least the number of elements after the last erased item, worst the size of the whole container left</ul><h3 id="stdmap"><code class="language-plaintext highlighter-rouge">std::map</code></h3><p><code class="language-plaintext highlighter-rouge">std::map</code> is a sorted associative container providing search, removal and insertion at a logarithmic complexity. They are usually implemented as red-black trees.</p><ul><li><p><strong>accessing an element</strong>: with <code class="language-plaintext highlighter-rouge">at()</code> or with <code class="language-plaintext highlighter-rouge">operator[]</code> both have a complexity of <code class="language-plaintext highlighter-rouge">O(log n)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container</p><li><p><strong>inserting an element at a random location</strong>: with <code class="language-plaintext highlighter-rouge">insert()</code> or with <code class="language-plaintext highlighter-rouge">operator[]</code> both have a complexity of <code class="language-plaintext highlighter-rouge">O(log n)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container. With <code class="language-plaintext highlighter-rouge">insert()</code> you can insert multiple elements, and then the complexity becomes <code class="language-plaintext highlighter-rouge">O(m * log n)</code>, where <code class="language-plaintext highlighter-rouge">m</code> is the number of elements to insert. <code class="language-plaintext highlighter-rouge">insert()</code> can also take a position as a hint where to insert. If the insertion happens there then the complexity is amortized <code class="language-plaintext highlighter-rouge">O(1)</code> otherwise <code class="language-plaintext highlighter-rouge">O(log n)</code></p><li><strong>removing an item</strong>: with <code class="language-plaintext highlighter-rouge">erase()</code> which has a complexity of amortized <code class="language-plaintext highlighter-rouge">O(1)</code> if the erasure happens with an iterator, otherwise it’s <code class="language-plaintext highlighter-rouge">O(log(n) + m)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container and <code class="language-plaintext highlighter-rouge">m</code> is the number of elements to remove<li><strong>finding an element</strong>: with <code class="language-plaintext highlighter-rouge">find()</code> which has a complexity of <code class="language-plaintext highlighter-rouge">O(log n)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container</ul><h3 id="stdunordered_map"><code class="language-plaintext highlighter-rouge">std::unordered_map</code></h3><p><code class="language-plaintext highlighter-rouge">std::unordered_map</code> is an unsorted associative container optimized for search, removal and insertion which come at a constant time complexity. <code class="language-plaintext highlighter-rouge">std::unordered_map</code> is a hash map internally.</p><ul><li><p><strong>accessing an element</strong>: with <code class="language-plaintext highlighter-rouge">at()</code> or with <code class="language-plaintext highlighter-rouge">operator[]</code> both have a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> on average and <code class="language-plaintext highlighter-rouge">O(n)</code> at worst where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container</p><li><strong>inserting an element at a random location</strong>: with <code class="language-plaintext highlighter-rouge">insert()</code> or with <code class="language-plaintext highlighter-rouge">operator[]</code> both have a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> on average and <code class="language-plaintext highlighter-rouge">O(n)</code> at worst, where <code class="language-plaintext highlighter-rouge">n</code> is the size of the map. If <code class="language-plaintext highlighter-rouge">m</code> elements are inserted then the average case is <code class="language-plaintext highlighter-rouge">O(m)</code> and the worst case is <code class="language-plaintext highlighter-rouge">O(m * n + n)</code><li><strong>removing an item</strong>: with <code class="language-plaintext highlighter-rouge">erase()</code> which has a complexity of amortized <code class="language-plaintext highlighter-rouge">O(1)</code> if the erasure happens with an iterator, otherwise, on average it’s <code class="language-plaintext highlighter-rouge">O(m)</code> where <code class="language-plaintext highlighter-rouge">m</code> is the number of elements to remove, worst case it’s <code class="language-plaintext highlighter-rouge">O(n)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container<li><strong>finding an element</strong>: with <code class="language-plaintext highlighter-rouge">find()</code> it’s <code class="language-plaintext highlighter-rouge">O(1)</code> on average and in the worst case it’s <code class="language-plaintext highlighter-rouge">O(n)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the container</ul><h2 id="algorithms">Algorithms</h2><p>If you use raw loops and you understand the containers, you don’t have to deal with these. A surprising “advantage” of using raw loops - <a href="https://www.sandordargo.com/blog/2020/05/13/loops-vs-algorithms">please, prefer algorithms</a>!</p><p>Otherwise, most probably you understand what standard algorithms do. Think about them and you’ll be able to come up with their complexities in most cases. Let’s have a look at some algorithms:</p><ul><li><code class="language-plaintext highlighter-rouge">all_of</code>/ <code class="language-plaintext highlighter-rouge">any_of</code> / <code class="language-plaintext highlighter-rouge">none_of</code> have at most <code class="language-plaintext highlighter-rouge">O(n)</code> complexity where <code class="language-plaintext highlighter-rouge">n</code> is the size of the range the algorithm is applied on<li><code class="language-plaintext highlighter-rouge">count_if</code> has a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code> where <code class="language-plaintext highlighter-rouge">n</code> is the size of the range the algorithm is applied on<li><code class="language-plaintext highlighter-rouge">find</code> / <code class="language-plaintext highlighter-rouge">find_if</code> have a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code>. They need at most <code class="language-plaintext highlighter-rouge">n</code> applications of <code class="language-plaintext highlighter-rouge">operator==</code> or a predicate where <code class="language-plaintext highlighter-rouge">n</code> is the length of the range passed in<li><code class="language-plaintext highlighter-rouge">replace</code> / <code class="language-plaintext highlighter-rouge">replace_if</code> have a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code>. They need <code class="language-plaintext highlighter-rouge">n</code> applications of <code class="language-plaintext highlighter-rouge">operator==</code> or of a predicate where <code class="language-plaintext highlighter-rouge">n</code> is the length of the range passed in and at most <code class="language-plaintext highlighter-rouge">n</code> assignments<li><code class="language-plaintext highlighter-rouge">copy</code> / <code class="language-plaintext highlighter-rouge">copy_if</code> have a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code>. <code class="language-plaintext highlighter-rouge">copy</code> does <code class="language-plaintext highlighter-rouge">n</code> assignments where <code class="language-plaintext highlighter-rouge">n</code> is the length of the passed-in range, for <code class="language-plaintext highlighter-rouge">copy_if</code> we also have to think about the application of the predicate, while the number of assignments might be smaller.<li><code class="language-plaintext highlighter-rouge">transform</code> also has a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code>. It performs exactly <code class="language-plaintext highlighter-rouge">n</code> applications of the operation, where <code class="language-plaintext highlighter-rouge">n</code> is the length of the passed-in range.<li><code class="language-plaintext highlighter-rouge">generate</code> has a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code> as it invokes <code class="language-plaintext highlighter-rouge">n</code> times the generator function and also performs the same amount of assignments.<li><code class="language-plaintext highlighter-rouge">remove_if</code> has a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code> as it performs <code class="language-plaintext highlighter-rouge">n</code> applications of <code class="language-plaintext highlighter-rouge">operator==</code> or of a predicate where <code class="language-plaintext highlighter-rouge">n</code> is the length of the range passed in.<li><code class="language-plaintext highlighter-rouge">swap</code> has a complexity of <code class="language-plaintext highlighter-rouge">O(1)</code> if applied on single values and <code class="language-plaintext highlighter-rouge">O(n)</code> if applied on arrays where <code class="language-plaintext highlighter-rouge">n</code> is the size of the arrays to be swapped<li><code class="language-plaintext highlighter-rouge">reverse</code> performs exactly half as many swaps as the size of the range to be reversed, therefore the complexity is <code class="language-plaintext highlighter-rouge">O(n)</code><li><code class="language-plaintext highlighter-rouge">rotate</code> also has a complexity of <code class="language-plaintext highlighter-rouge">O(n)</code>.</ul><p>Quite boring, right? But boredom brings simplicity to your calculations.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we talked about the complexity analysis of operations on containers and of algorithms which are so often make important part of a software developer job interview. We discussed some hints on how to approach such questions if you neglected complexity analysis during most of your preparation for interviews. Finally, we quickly went through the most important complexities of C++ containers and standard algorithms so that you can have the most basic characteristics that you’d need at a job interview. Good luck!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/algorithms/" class="post-tag no-text-decoration" >algorithms</a> <a href="/tags/complexities/" class="post-tag no-text-decoration" >complexities</a> <a href="/tags/jobhunt/" class="post-tag no-text-decoration" >jobhunt</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++: The most important complexities - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/15/most-important-complexities" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++: The most important complexities - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/15/most-important-complexities" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++: The most important complexities - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/15/most-important-complexities" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++: The most important complexities - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/15/most-important-complexities" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2019/01/30/stl-algos-intro"><div class="card-body"> <span class="timeago small" > Jan 30, 2019 <i class="unloaded">2019-01-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: Introduction</h3><div class="text-muted small"><p> I’ve already written quite a few articles about features introduced by C++ 11 and how much it changed how I look at the language. The feature I liked the most is probably the one of lambda expressi...</p></div></div></a></div><div class="card"> <a href="/blog/2019/02/20/stl-algorithm-tutorial-part-1-any-all-none"><div class="card-body"> <span class="timeago small" > Feb 20, 2019 <i class="unloaded">2019-02-20T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: all_of, any_of, none_of</h3><div class="text-muted small"><p> In this first part of the big STL algorithm tutorial, I’ll start with the first chunk of the non-modifying sequence operations. Namely, in this post, you are going to read about all_of, any_of an...</p></div></div></a></div><div class="card"> <a href="/blog/2019/04/03/stl-algorithm-tutorial-part-2-for_each"><div class="card-body"> <span class="timeago small" > Apr 3, 2019 <i class="unloaded">2019-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The big STL Algorithms tutorial: for_each</h3><div class="text-muted small"><p> In this next part of the big STL algorithm tutorial, I’ll explain only one function. The for_each algorithm. What does it do? for_each takes a range and a function to apply on each element of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/11/11/10x-is-easier-than-2x-by-benjamin-hardy" class="btn btn-outline-primary" prompt="Older"><p>10x is easier than 2x by Dr. Benjamin Hardy</p></a> <a href="/blog/2023/11/22/struct-initialization" class="btn btn-outline-primary" prompt="Newer"><p>Struct initialization</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++: The most important complexities'; this.page.url = 'https://www.sandordargo.com/blog/2023/11/15/most-important-complexities'; this.page.identifier = '/blog/2023/11/15/most-important-complexities'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
