<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Extern templates to reduce binary size" /><meta property="og:locale" content="en_US" /><meta name="description" content="In my quest towards a smaller binary size, someone asked me if I considered extern templates. I did not. I didn’t even know about them. But I was more than happy for the suggestion and now here I am to share what learned about extern templates. What are they? You can use the extern keyword with template specializations and it means that no local object code will be generated for the template specialization in the local translation unit. With the extern keyword you show that the code will be generated elsewhere which the linker should find. 1 2 3 4 5 6 7 8 9 10 template &lt;typename T&gt; class Wrapper { public: // ... private: T wrapped; }; // No object code will be generated for Wrapper&lt;int&gt; in this translation unit extern template class Wrapper&lt;int&gt;; This feature was introduced in C++11 and it’s an optimization tool. By default, if you specialize a template in a translation unit, object code will be generated for the specialization. If you specialize the template in 10 different translation units, then object code will be generated in all those translation units, but the linker will only use one. The rest is unused, in other words, they were generated in vain. Therefore, by using extern template you might decrease both compilation time and binary size. Where and how to use extern templates? Let’s say we have 5 translation units, one defines the template and the other four are using it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // wrapper.h #pragma once template &lt;typename T&gt; class Wrapper { public: explicit Wrapper(T t) : wrapped(t) {} T get() const { return wrapped; } void set(T t) { wrapped = t; } private: T wrapped; }; // moduleA, moduleB, moduleC and moduleD are all following the same logic // moduleA.h #pragma once namespace moduleA { void foo(); }; // moduleA.cpp #include &quot;moduleA.h&quot; #include &quot;wrapper.h&quot; #include &lt;iostream&gt; namespace moduleA { void foo() { Wrapper w{42}; w.set(51); std::cout &lt;&lt; w.get() &lt;&lt; &#39;\n&#39;; } } // main.cpp #include &quot;moduleA.h&quot; #include &quot;moduleB.h&quot; #include &quot;moduleC.h&quot; #include &quot;moduleD.h&quot; int main() { moduleA::foo(); moduleB::foo(); moduleC::foo(); moduleD::foo(); } Do we have to put the extern template class Wrapper&lt;int&gt; in all four module headers (you can read only one of them in the above listing) or only one is enough? When I was first thinking about this problem, I could argue (with myself) for putting the extern declaration in each translation unit. After all, if you want to use a template specification in a given translation unit it would be meaningful to tell the compiler that hey, you’ll get it from a different place and it’s also easy to understand for the readers of the code. At the same time, it’s also true that this approach repeats code. You’d have the same extern declaration in every translation unit where you want to use a certain template specialization. If you forget to put it into one translation unit, the template specialization will be generated for that one. Nevertheless, this approach works. But it’s not too much work and easy to miss a few places. Instead, if you want to benefit from extern templates and keep it simple and readable, put extern template class Wrapper&lt;int&gt; right after the template declaration - in our case into wrapper.h - and create an implementation file - wrapper.cpp - in which you include the header plus you put an explicit template specialization such as template class Wrapper&lt;int&gt;. By doing so, by including wrapper.h in any translation unit you also include the extern template declaration and the wrapper.cpp which is a standalone translation unit will provide the specialization and as such the generated code. Do we gain anything? In this case, not really. On the contrary. Originally, we had 5 translation units: moduleA.cpp, moduleB.cpp, moduleC.cpp, moduleD.cpp and main.cpp. With the introduction of the sixth one wrapper.cpp, we didn’t help ourselves anyhow. It’s true that the intermediary object files are smaller when we use extern templates, even if we add up all of them, including wrapper.s, yet overall, the compilation time slightly got bigger and even the executable size. On the other hand, if Wrapper resides in its own translation unit anyway and we have to compile wrapper.cpp anyways, then using extern template declaration might reduce the compilation, but we still don’t gain a byte from our final binary size. But the impacts also depend on the size of the templates, how many times it’s used, how many specializations you can externalize. I’d encourage you to make your own measurements specific to your use case. Use extern template across shared libraries Now let’s explore what happens when we don’t use extern template simply across translation units, but when we go beyond library boundaries. For the next example, I used the very same code as before, but instead of having 6 translation units (wrapper, moduleA to moduleD and main) to generate our executable, I went with translating each file into its own library and linked them together to get an executable. I wanted to see how much space we might gain. On macOS, I used these commands to build the shared libraries and the final executable: 1 2 3 4 5 6 clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include wrapper.h wrapper.cpp -o libwrapper.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleA.h moduleA.cpp -o libmoduleA.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleB.h moduleB.cpp -o libmoduleB.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleC.h moduleC.cpp -o libmoduleC.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleD.h moduleD.cpp -o libmoduleD.dylib clang++ -std=c++20 -stdlib=libc++ -L . -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main As the example code is simple, I don’t use a strong optimization level because that would probably eliminate all the template usages. The size of libwrapper.dylib is not influenced by using extern template declarations or their lack of. On the other hand, each libmodule&lt;X&gt;.dylib’s size was affected. As we talk about shared libraries, which must be kept along with the executable, this gain matters. When not using the extern template, they generated code for Wrapper&lt;int&gt; and their size grew by 64 bytes each. That’s not a lot, I know. But what if you have many extern templates and bigger templates? Or what if you have bigger templates? Just for curiosity, I added Wrapper&lt;double&gt; and used it, and with that, the difference grew from 64 bytes to 112 bytes, so by 48 bytes. At this point, we can question how much this is all worth. We see the potential to gain some space, but considering that libwrapper.dylib grew from 16k to 35k at the moment we introduced the explicit template specialization in it, we could do the math how many times we would have to use Wrapper&lt;int&gt; and Wrapper&lt;double&gt; so that it pays off. But that’s not the end of the story. Then I modified Wrapper, so that it holds also a string as a member. The size difference in libwrapper is essentially the same with or without using extern and providing the definitions as it was without the string member. On the other hand, in each library depending on libwrapper, now the difference is almost 700 bytes. And we are still dealing with a small template. Now we can see the potential how extern template can help us gain space with templates. In general, we can also say that the more machine code the compiler has to generate, the more time it will be, so we don’t only gain space but also time. As a side note, I want to mention, that using extern templates prevents the compiler from inlining and you’ll have to pay for function calls. If you still want to benefit from inlining, think about interprocedural optimization, which you might know as link time optimization. I wrote about IPO/LTO here. You can also learn about this problem in Jason Turner’s C++ Weekly. Conclusion In this article, we learned about another tool we might consider using in order to decrease the binary footprint of our program and that is extern template. By default, each translation unit that uses a certain template specialization compiles that and stores it in the intermediary compiled file. But with extern template, we can tell the compiler that it shouldn’t worry about compiling a certain specialization, because the definition will be provided later at link time. Depending on the complexity of the template and the number of its usages, you might gain both space and compilation time. Don’t forget to measure before you blindly apply. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In my quest towards a smaller binary size, someone asked me if I considered extern templates. I did not. I didn’t even know about them. But I was more than happy for the suggestion and now here I am to share what learned about extern templates. What are they? You can use the extern keyword with template specializations and it means that no local object code will be generated for the template specialization in the local translation unit. With the extern keyword you show that the code will be generated elsewhere which the linker should find. 1 2 3 4 5 6 7 8 9 10 template &lt;typename T&gt; class Wrapper { public: // ... private: T wrapped; }; // No object code will be generated for Wrapper&lt;int&gt; in this translation unit extern template class Wrapper&lt;int&gt;; This feature was introduced in C++11 and it’s an optimization tool. By default, if you specialize a template in a translation unit, object code will be generated for the specialization. If you specialize the template in 10 different translation units, then object code will be generated in all those translation units, but the linker will only use one. The rest is unused, in other words, they were generated in vain. Therefore, by using extern template you might decrease both compilation time and binary size. Where and how to use extern templates? Let’s say we have 5 translation units, one defines the template and the other four are using it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // wrapper.h #pragma once template &lt;typename T&gt; class Wrapper { public: explicit Wrapper(T t) : wrapped(t) {} T get() const { return wrapped; } void set(T t) { wrapped = t; } private: T wrapped; }; // moduleA, moduleB, moduleC and moduleD are all following the same logic // moduleA.h #pragma once namespace moduleA { void foo(); }; // moduleA.cpp #include &quot;moduleA.h&quot; #include &quot;wrapper.h&quot; #include &lt;iostream&gt; namespace moduleA { void foo() { Wrapper w{42}; w.set(51); std::cout &lt;&lt; w.get() &lt;&lt; &#39;\n&#39;; } } // main.cpp #include &quot;moduleA.h&quot; #include &quot;moduleB.h&quot; #include &quot;moduleC.h&quot; #include &quot;moduleD.h&quot; int main() { moduleA::foo(); moduleB::foo(); moduleC::foo(); moduleD::foo(); } Do we have to put the extern template class Wrapper&lt;int&gt; in all four module headers (you can read only one of them in the above listing) or only one is enough? When I was first thinking about this problem, I could argue (with myself) for putting the extern declaration in each translation unit. After all, if you want to use a template specification in a given translation unit it would be meaningful to tell the compiler that hey, you’ll get it from a different place and it’s also easy to understand for the readers of the code. At the same time, it’s also true that this approach repeats code. You’d have the same extern declaration in every translation unit where you want to use a certain template specialization. If you forget to put it into one translation unit, the template specialization will be generated for that one. Nevertheless, this approach works. But it’s not too much work and easy to miss a few places. Instead, if you want to benefit from extern templates and keep it simple and readable, put extern template class Wrapper&lt;int&gt; right after the template declaration - in our case into wrapper.h - and create an implementation file - wrapper.cpp - in which you include the header plus you put an explicit template specialization such as template class Wrapper&lt;int&gt;. By doing so, by including wrapper.h in any translation unit you also include the extern template declaration and the wrapper.cpp which is a standalone translation unit will provide the specialization and as such the generated code. Do we gain anything? In this case, not really. On the contrary. Originally, we had 5 translation units: moduleA.cpp, moduleB.cpp, moduleC.cpp, moduleD.cpp and main.cpp. With the introduction of the sixth one wrapper.cpp, we didn’t help ourselves anyhow. It’s true that the intermediary object files are smaller when we use extern templates, even if we add up all of them, including wrapper.s, yet overall, the compilation time slightly got bigger and even the executable size. On the other hand, if Wrapper resides in its own translation unit anyway and we have to compile wrapper.cpp anyways, then using extern template declaration might reduce the compilation, but we still don’t gain a byte from our final binary size. But the impacts also depend on the size of the templates, how many times it’s used, how many specializations you can externalize. I’d encourage you to make your own measurements specific to your use case. Use extern template across shared libraries Now let’s explore what happens when we don’t use extern template simply across translation units, but when we go beyond library boundaries. For the next example, I used the very same code as before, but instead of having 6 translation units (wrapper, moduleA to moduleD and main) to generate our executable, I went with translating each file into its own library and linked them together to get an executable. I wanted to see how much space we might gain. On macOS, I used these commands to build the shared libraries and the final executable: 1 2 3 4 5 6 clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include wrapper.h wrapper.cpp -o libwrapper.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleA.h moduleA.cpp -o libmoduleA.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleB.h moduleB.cpp -o libmoduleB.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleC.h moduleC.cpp -o libmoduleC.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleD.h moduleD.cpp -o libmoduleD.dylib clang++ -std=c++20 -stdlib=libc++ -L . -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main As the example code is simple, I don’t use a strong optimization level because that would probably eliminate all the template usages. The size of libwrapper.dylib is not influenced by using extern template declarations or their lack of. On the other hand, each libmodule&lt;X&gt;.dylib’s size was affected. As we talk about shared libraries, which must be kept along with the executable, this gain matters. When not using the extern template, they generated code for Wrapper&lt;int&gt; and their size grew by 64 bytes each. That’s not a lot, I know. But what if you have many extern templates and bigger templates? Or what if you have bigger templates? Just for curiosity, I added Wrapper&lt;double&gt; and used it, and with that, the difference grew from 64 bytes to 112 bytes, so by 48 bytes. At this point, we can question how much this is all worth. We see the potential to gain some space, but considering that libwrapper.dylib grew from 16k to 35k at the moment we introduced the explicit template specialization in it, we could do the math how many times we would have to use Wrapper&lt;int&gt; and Wrapper&lt;double&gt; so that it pays off. But that’s not the end of the story. Then I modified Wrapper, so that it holds also a string as a member. The size difference in libwrapper is essentially the same with or without using extern and providing the definitions as it was without the string member. On the other hand, in each library depending on libwrapper, now the difference is almost 700 bytes. And we are still dealing with a small template. Now we can see the potential how extern template can help us gain space with templates. In general, we can also say that the more machine code the compiler has to generate, the more time it will be, so we don’t only gain space but also time. As a side note, I want to mention, that using extern templates prevents the compiler from inlining and you’ll have to pay for function calls. If you still want to benefit from inlining, think about interprocedural optimization, which you might know as link time optimization. I wrote about IPO/LTO here. You can also learn about this problem in Jason Turner’s C++ Weekly. Conclusion In this article, we learned about another tool we might consider using in order to decrease the binary footprint of our program and that is extern template. By default, each translation unit that uses a certain template specialization compiles that and stores it in the intermediary compiled file. But with extern template, we can tell the compiler that it shouldn’t worry about compiling a certain specialization, because the definition will be provided later at link time. Depending on the complexity of the template and the number of its usages, you might gain both space and compilation time. Don’t forget to measure before you blindly apply. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/11/08/extern-templates" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/11/08/extern-templates" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-11-08T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Extern templates to reduce binary size" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-12-05T06:38:47+01:00","datePublished":"2023-11-08T00:00:00+01:00","description":"In my quest towards a smaller binary size, someone asked me if I considered extern templates. I did not. I didn’t even know about them. But I was more than happy for the suggestion and now here I am to share what learned about extern templates. What are they? You can use the extern keyword with template specializations and it means that no local object code will be generated for the template specialization in the local translation unit. With the extern keyword you show that the code will be generated elsewhere which the linker should find. 1 2 3 4 5 6 7 8 9 10 template &lt;typename T&gt; class Wrapper { public: // ... private: T wrapped; }; // No object code will be generated for Wrapper&lt;int&gt; in this translation unit extern template class Wrapper&lt;int&gt;; This feature was introduced in C++11 and it’s an optimization tool. By default, if you specialize a template in a translation unit, object code will be generated for the specialization. If you specialize the template in 10 different translation units, then object code will be generated in all those translation units, but the linker will only use one. The rest is unused, in other words, they were generated in vain. Therefore, by using extern template you might decrease both compilation time and binary size. Where and how to use extern templates? Let’s say we have 5 translation units, one defines the template and the other four are using it. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 // wrapper.h #pragma once template &lt;typename T&gt; class Wrapper { public: explicit Wrapper(T t) : wrapped(t) {} T get() const { return wrapped; } void set(T t) { wrapped = t; } private: T wrapped; }; // moduleA, moduleB, moduleC and moduleD are all following the same logic // moduleA.h #pragma once namespace moduleA { void foo(); }; // moduleA.cpp #include &quot;moduleA.h&quot; #include &quot;wrapper.h&quot; #include &lt;iostream&gt; namespace moduleA { void foo() { Wrapper w{42}; w.set(51); std::cout &lt;&lt; w.get() &lt;&lt; &#39;\\n&#39;; } } // main.cpp #include &quot;moduleA.h&quot; #include &quot;moduleB.h&quot; #include &quot;moduleC.h&quot; #include &quot;moduleD.h&quot; int main() { moduleA::foo(); moduleB::foo(); moduleC::foo(); moduleD::foo(); } Do we have to put the extern template class Wrapper&lt;int&gt; in all four module headers (you can read only one of them in the above listing) or only one is enough? When I was first thinking about this problem, I could argue (with myself) for putting the extern declaration in each translation unit. After all, if you want to use a template specification in a given translation unit it would be meaningful to tell the compiler that hey, you’ll get it from a different place and it’s also easy to understand for the readers of the code. At the same time, it’s also true that this approach repeats code. You’d have the same extern declaration in every translation unit where you want to use a certain template specialization. If you forget to put it into one translation unit, the template specialization will be generated for that one. Nevertheless, this approach works. But it’s not too much work and easy to miss a few places. Instead, if you want to benefit from extern templates and keep it simple and readable, put extern template class Wrapper&lt;int&gt; right after the template declaration - in our case into wrapper.h - and create an implementation file - wrapper.cpp - in which you include the header plus you put an explicit template specialization such as template class Wrapper&lt;int&gt;. By doing so, by including wrapper.h in any translation unit you also include the extern template declaration and the wrapper.cpp which is a standalone translation unit will provide the specialization and as such the generated code. Do we gain anything? In this case, not really. On the contrary. Originally, we had 5 translation units: moduleA.cpp, moduleB.cpp, moduleC.cpp, moduleD.cpp and main.cpp. With the introduction of the sixth one wrapper.cpp, we didn’t help ourselves anyhow. It’s true that the intermediary object files are smaller when we use extern templates, even if we add up all of them, including wrapper.s, yet overall, the compilation time slightly got bigger and even the executable size. On the other hand, if Wrapper resides in its own translation unit anyway and we have to compile wrapper.cpp anyways, then using extern template declaration might reduce the compilation, but we still don’t gain a byte from our final binary size. But the impacts also depend on the size of the templates, how many times it’s used, how many specializations you can externalize. I’d encourage you to make your own measurements specific to your use case. Use extern template across shared libraries Now let’s explore what happens when we don’t use extern template simply across translation units, but when we go beyond library boundaries. For the next example, I used the very same code as before, but instead of having 6 translation units (wrapper, moduleA to moduleD and main) to generate our executable, I went with translating each file into its own library and linked them together to get an executable. I wanted to see how much space we might gain. On macOS, I used these commands to build the shared libraries and the final executable: 1 2 3 4 5 6 clang++ -std=c++20 -stdlib=libc++ -dynamiclib -include wrapper.h wrapper.cpp -o libwrapper.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleA.h moduleA.cpp -o libmoduleA.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleB.h moduleB.cpp -o libmoduleB.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleC.h moduleC.cpp -o libmoduleC.dylib clang++ -std=c++20 -stdlib=libc++ -dynamiclib -L . -lwrapper -include moduleD.h moduleD.cpp -o libmoduleD.dylib clang++ -std=c++20 -stdlib=libc++ -L . -lmoduleA -lmoduleB -lmoduleC -lmoduleD main.cpp -o main As the example code is simple, I don’t use a strong optimization level because that would probably eliminate all the template usages. The size of libwrapper.dylib is not influenced by using extern template declarations or their lack of. On the other hand, each libmodule&lt;X&gt;.dylib’s size was affected. As we talk about shared libraries, which must be kept along with the executable, this gain matters. When not using the extern template, they generated code for Wrapper&lt;int&gt; and their size grew by 64 bytes each. That’s not a lot, I know. But what if you have many extern templates and bigger templates? Or what if you have bigger templates? Just for curiosity, I added Wrapper&lt;double&gt; and used it, and with that, the difference grew from 64 bytes to 112 bytes, so by 48 bytes. At this point, we can question how much this is all worth. We see the potential to gain some space, but considering that libwrapper.dylib grew from 16k to 35k at the moment we introduced the explicit template specialization in it, we could do the math how many times we would have to use Wrapper&lt;int&gt; and Wrapper&lt;double&gt; so that it pays off. But that’s not the end of the story. Then I modified Wrapper, so that it holds also a string as a member. The size difference in libwrapper is essentially the same with or without using extern and providing the definitions as it was without the string member. On the other hand, in each library depending on libwrapper, now the difference is almost 700 bytes. And we are still dealing with a small template. Now we can see the potential how extern template can help us gain space with templates. In general, we can also say that the more machine code the compiler has to generate, the more time it will be, so we don’t only gain space but also time. As a side note, I want to mention, that using extern templates prevents the compiler from inlining and you’ll have to pay for function calls. If you still want to benefit from inlining, think about interprocedural optimization, which you might know as link time optimization. I wrote about IPO/LTO here. You can also learn about this problem in Jason Turner’s C++ Weekly. Conclusion In this article, we learned about another tool we might consider using in order to decrease the binary footprint of our program and that is extern template. By default, each translation unit that uses a certain template specialization compiles that and stores it in the intermediary compiled file. But with extern template, we can tell the compiler that it shouldn’t worry about compiling a certain specialization, because the definition will be provided later at link time. Depending on the complexity of the template and the number of its usages, you might gain both space and compilation time. Don’t forget to measure before you blindly apply. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Extern templates to reduce binary size","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/11/08/extern-templates"},"url":"https://www.sandordargo.com/blog/2023/11/08/extern-templates"}</script><title>Extern templates to reduce binary size | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/11"> 11 </a> </span> <span> <a href="/08"> 08 </a> </span> <span>Extern templates to reduce binary size</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Extern templates to reduce binary size</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Nov 8, 2023, 12:00 AM +0100" prep="on" > Nov 8, 2023 <i class="unloaded">2023-11-08T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Dec 5, 2024, 6:38 AM +0100" prefix="Updated " > Dec 5, 2024 <i class="unloaded">2024-12-05T06:38:47+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1485 words">8 min</span></div></div><div class="post-content"><p>In my quest towards a smaller binary size, someone asked me if I considered extern templates. I did not. I didn’t even know about them. But I was more than happy for the suggestion and now here I am to share what learned about extern templates.</p><h2 id="what-are-they">What are they?</h2><p>You can use the <code class="language-plaintext highlighter-rouge">extern</code> keyword with template specializations and it means that no local object code will be generated for the template specialization in the local translation unit. With the <code class="language-plaintext highlighter-rouge">extern</code> keyword you show that the code will be generated elsewhere which the linker should find.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Wrapper</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="c1">// ...</span>
<span class="nl">private:</span>
	<span class="n">T</span> <span class="n">wrapped</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// No object code will be generated for Wrapper&lt;int&gt; in this translation unit</span>
<span class="k">extern</span> <span class="k">template</span> <span class="k">class</span> <span class="nc">Wrapper</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">&gt;;</span>
</pre></table></code></div></div><p>This feature was introduced in C++11 and it’s an optimization tool. By default, if you specialize a template in a translation unit, object code will be generated for the specialization. If you specialize the template in 10 different translation units, then object code will be generated in all those translation units, but the linker will only use one. The rest is unused, in other words, they were generated in vain.</p><p>Therefore, by using <code class="language-plaintext highlighter-rouge">extern template</code> you <strong>might</strong> decrease both compilation time and binary size.</p><h2 id="where-and-how-to-use-extern-templates">Where and how to use extern templates?</h2><p>Let’s say we have 5 translation units, one defines the template and the other four are using it.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
</pre><td class="rouge-code"><pre><span class="c1">// wrapper.h</span>
<span class="cp">#pragma once
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Wrapper</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="k">explicit</span> <span class="n">Wrapper</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">wrapped</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{}</span>

	<span class="n">T</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">wrapped</span><span class="p">;</span> <span class="p">}</span>

	<span class="kt">void</span> <span class="nf">set</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="n">wrapped</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>


<span class="k">private</span><span class="o">:</span>
	<span class="n">T</span> <span class="n">wrapped</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// moduleA, moduleB, moduleC and moduleD are all following the same logic</span>
<span class="c1">// moduleA.h</span>
<span class="cp">#pragma once
</span>
<span class="k">namespace</span> <span class="n">moduleA</span> <span class="p">{</span>

<span class="kt">void</span> <span class="n">foo</span><span class="p">();</span>

<span class="p">};</span>

<span class="c1">// moduleA.cpp</span>
<span class="cp">#include</span> <span class="cpf">"moduleA.h"</span><span class="cp">
#include</span> <span class="cpf">"wrapper.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">moduleA</span> <span class="p">{</span>
	<span class="kt">void</span> <span class="n">foo</span><span class="p">()</span> <span class="p">{</span>
		<span class="n">Wrapper</span> <span class="n">w</span><span class="p">{</span><span class="mi">42</span><span class="p">};</span>
		<span class="n">w</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="mi">51</span><span class="p">);</span>
		<span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">w</span><span class="p">.</span><span class="n">get</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">"moduleA.h"</span><span class="cp">
#include</span> <span class="cpf">"moduleB.h"</span><span class="cp">
#include</span> <span class="cpf">"moduleC.h"</span><span class="cp">
#include</span> <span class="cpf">"moduleD.h"</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	<span class="n">moduleA</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>
	<span class="n">moduleB</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>
	<span class="n">moduleC</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>
	<span class="n">moduleD</span><span class="o">::</span><span class="n">foo</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Do we have to put the <code class="language-plaintext highlighter-rouge">extern template class Wrapper&lt;int&gt;</code> in all four module headers (you can read only one of them in the above listing) or only one is enough?</p><p>When I was first thinking about this problem, I could argue (with myself) for putting the <code class="language-plaintext highlighter-rouge">extern</code> declaration in each translation unit. After all, if you want to use a template specification in a given translation unit it would be meaningful to tell the compiler that hey, you’ll get it from a different place and it’s also easy to understand for the readers of the code. At the same time, it’s also true that this approach repeats code. You’d have the same <code class="language-plaintext highlighter-rouge">extern</code> declaration in every translation unit where you want to use a certain template specialization. If you forget to put it into one translation unit, the template specialization will be generated for that one.</p><p>Nevertheless, this approach works.</p><p>But it’s not too much work and easy to miss a few places. Instead, if you want to benefit from extern templates and keep it simple and readable, put <code class="language-plaintext highlighter-rouge">extern template class Wrapper&lt;int&gt;</code> right after the template declaration - in our case into <code class="language-plaintext highlighter-rouge">wrapper.h</code> - and create an implementation file - <code class="language-plaintext highlighter-rouge">wrapper.cpp</code> - in which you include the header plus you put an explicit template specialization such as <code class="language-plaintext highlighter-rouge">template class Wrapper&lt;int&gt;</code>.</p><p>By doing so, by including <code class="language-plaintext highlighter-rouge">wrapper.h</code> in any translation unit you also include the <code class="language-plaintext highlighter-rouge">extern template</code> declaration and the <code class="language-plaintext highlighter-rouge">wrapper.cpp</code> which is a standalone translation unit will provide the specialization and as such the generated code.</p><p>Do we gain anything?</p><p>In this case, not really. On the contrary. Originally, we had 5 translation units: <code class="language-plaintext highlighter-rouge">moduleA.cpp</code>, <code class="language-plaintext highlighter-rouge">moduleB.cpp</code>, <code class="language-plaintext highlighter-rouge">moduleC.cpp</code>, <code class="language-plaintext highlighter-rouge">moduleD.cpp</code> and <code class="language-plaintext highlighter-rouge">main.cpp</code>. With the introduction of the sixth one <code class="language-plaintext highlighter-rouge">wrapper.cpp</code>, we didn’t help ourselves anyhow. It’s true that the intermediary object files are smaller when we use extern templates, even if we add up all of them, including <code class="language-plaintext highlighter-rouge">wrapper.s</code>, yet overall, the compilation time slightly got bigger and even the executable size.</p><p>On the other hand, if <code class="language-plaintext highlighter-rouge">Wrapper</code> resides in its own translation unit anyway and we have to compile <code class="language-plaintext highlighter-rouge">wrapper.cpp</code> anyways, then using <code class="language-plaintext highlighter-rouge">extern template</code> declaration might reduce the compilation, but we still don’t gain a byte from our final binary size.</p><p>But the impacts also depend on the size of the templates, how many times it’s used, how many specializations you can externalize. I’d encourage you to make your own measurements specific to your use case.</p><h2 id="use-extern-template-across-shared-libraries">Use <code class="language-plaintext highlighter-rouge">extern template</code> across shared libraries</h2><p>Now let’s explore what happens when we don’t use <code class="language-plaintext highlighter-rouge">extern template</code> simply across translation units, but when we go beyond library boundaries.</p><p>For the next example, I used the very same code as before, but instead of having 6 translation units (<code class="language-plaintext highlighter-rouge">wrapper</code>, <code class="language-plaintext highlighter-rouge">moduleA</code> to <code class="language-plaintext highlighter-rouge">moduleD</code> and <code class="language-plaintext highlighter-rouge">main</code>) to generate our executable, I went with translating each file into its own library and linked them together to get an executable. I wanted to see how much space we might gain.</p><p>On macOS, I used these commands to build the shared libraries and the final executable:</p><div class="language-sh highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre>clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-include</span> wrapper.h wrapper.cpp <span class="nt">-o</span> libwrapper.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lwrapper</span> <span class="nt">-include</span> moduleA.h moduleA.cpp <span class="nt">-o</span> libmoduleA.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lwrapper</span> <span class="nt">-include</span> moduleB.h moduleB.cpp <span class="nt">-o</span> libmoduleB.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lwrapper</span> <span class="nt">-include</span> moduleC.h moduleC.cpp <span class="nt">-o</span> libmoduleC.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-dynamiclib</span> <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lwrapper</span> <span class="nt">-include</span> moduleD.h moduleD.cpp <span class="nt">-o</span> libmoduleD.dylib
clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-stdlib</span><span class="o">=</span>libc++ <span class="nt">-L</span> <span class="nb">.</span> <span class="nt">-lmoduleA</span> <span class="nt">-lmoduleB</span> <span class="nt">-lmoduleC</span> <span class="nt">-lmoduleD</span> main.cpp <span class="nt">-o</span> main  
</pre></table></code></div></div><p><em>As the example code is simple, I don’t use a strong optimization level because that would probably eliminate all the template usages.</em></p><p>The size of <code class="language-plaintext highlighter-rouge">libwrapper.dylib</code> is not influenced by using <code class="language-plaintext highlighter-rouge">extern template</code> declarations or their lack of. On the other hand, each <code class="language-plaintext highlighter-rouge">libmodule&lt;X&gt;.dylib</code>’s size was affected. As we talk about shared libraries, which must be kept along with the executable, this gain matters.</p><p>When <strong>not</strong> using the <code class="language-plaintext highlighter-rouge">extern template</code>, they generated code for <code class="language-plaintext highlighter-rouge">Wrapper&lt;int&gt;</code> and their size grew by 64 bytes each. That’s not a lot, I know. But what if you have many extern templates and bigger templates? Or what if you have bigger templates?</p><p>Just for curiosity, I added <code class="language-plaintext highlighter-rouge">Wrapper&lt;double&gt;</code> and used it, and with that, the difference grew from 64 bytes to 112 bytes, so by 48 bytes. At this point, we can question how much this is all worth. We see the potential to gain some space, but considering that <code class="language-plaintext highlighter-rouge">libwrapper.dylib</code> grew from 16k to 35k at the moment we introduced the explicit template specialization in it, we could do the math how many times we would have to use <code class="language-plaintext highlighter-rouge">Wrapper&lt;int&gt;</code> and <code class="language-plaintext highlighter-rouge">Wrapper&lt;double&gt;</code> so that it pays off.</p><p>But that’s not the end of the story.</p><p>Then I modified <code class="language-plaintext highlighter-rouge">Wrapper</code>, so that it holds also a string as a member. The size difference in libwrapper is essentially the same with or without using extern and providing the definitions as it was without the <code class="language-plaintext highlighter-rouge">string</code> member. On the other hand, in each library depending on libwrapper, now the difference is almost 700 bytes. And we are still dealing with a small template.</p><p>Now we can see the potential how <code class="language-plaintext highlighter-rouge">extern template</code> can help us gain space with templates. In general, we can also say that the more machine code the compiler has to generate, the more time it will be, so we don’t only gain space but also time.</p><p>As a side note, I want to mention, that using <code class="language-plaintext highlighter-rouge">extern template</code>s prevents the compiler from inlining and you’ll have to pay for function calls. If you still want to benefit from inlining, think about <em>interprocedural optimization</em>, which you might know as <em>link time optimization</em>. <a href="https://www.sandordargo.com/blog/2023/07/19/binary-sizes-and-compiler-flags#link-time-optimization">I wrote about IPO/LTO here.</a> You can also learn about this problem in <a href="https://www.youtube.com/watch?v=pyiKhRmvMF4&amp;t=235s">Jason Turner’s C++ Weekly</a>.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we learned about another tool we might consider using in order to decrease the binary footprint of our program and that is <code class="language-plaintext highlighter-rouge">extern template</code>. By default, each translation unit that uses a certain template specialization compiles that and stores it in the intermediary compiled file. But with <code class="language-plaintext highlighter-rouge">extern template</code>, we can tell the compiler that it shouldn’t worry about compiling a certain specialization, because the definition will be provided later at link time. Depending on the complexity of the template and the number of its usages, you might gain both space and compilation time. Don’t forget to measure before you blindly apply.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/extern/" class="post-tag no-text-decoration" >extern</a> <a href="/tags/templates/" class="post-tag no-text-decoration" >templates</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Extern templates to reduce binary size - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/08/extern-templates" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Extern templates to reduce binary size - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/08/extern-templates" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Extern templates to reduce binary size - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/11/08/extern-templates" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Extern templates to reduce binary size - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/11/08/extern-templates" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/04/05/binary-size-and-templates"><div class="card-body"> <span class="timeago small" > Apr 5, 2023 <i class="unloaded">2023-04-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Binary sizes and passing functions to functions</h3><div class="text-muted small"><p> So why templates are interesting for our series on binary sizes? It’s because as mentioned, they do not represent callable code. They represent templates to generate callable code. The more you gen...</p></div></div></a></div><div class="card"> <a href="/blog/2021/04/07/what-are-type-traits"><div class="card-body"> <span class="timeago small" > Apr 7, 2021 <i class="unloaded">2021-04-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What are type traits?</h3><div class="text-muted small"><p> Let’s start with a more generic question, what is a trait? What does the word trait mean? According to the Cambridge Dictionary, a trait is “a particular characteristic that can produce a particu...</p></div></div></a></div><div class="card"> <a href="/blog/2021/06/02/different-ways-to-achieve-SFINAE"><div class="card-body"> <span class="timeago small" > Jun 2, 2021 <i class="unloaded">2021-06-02T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Different ways to achieve SFINAE</h3><div class="text-muted small"><p> Life is a chain of opportunities. Each task you take on will lead you to more doors hiding other opportunities. Some are worth opening, some are not. Proofreading C++20: Get the Details by Rainer...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/11/01/cpp23-garbage-collection" class="btn btn-outline-primary" prompt="Older"><p>C++23: Removing garbage collection support</p></a> <a href="/blog/2023/11/11/10x-is-easier-than-2x-by-benjamin-hardy" class="btn btn-outline-primary" prompt="Newer"><p>10x is easier than 2x by Dr. Benjamin Hardy</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Extern templates to reduce binary size'; this.page.url = 'https://www.sandordargo.com/blog/2023/11/08/extern-templates'; this.page.identifier = '/blog/2023/11/08/extern-templates'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
