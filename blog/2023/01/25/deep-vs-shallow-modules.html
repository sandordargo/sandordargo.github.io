<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Deep vs shallow modules" /><meta property="og:locale" content="en_US" /><meta name="description" content="I keep telling that I don’t post negative book reviews. It’s because no matter how much I dislike a book, I can be pretty sure that the author made a huge effort writing it. I have absolutely no reason to post negative reviews. I’m not afraid of giving constructive criticism in real life and at work when I’m personally involved. When it comes to books, there are just so many good ones I can focus on. I won’t share a negative book review either today, on the other hand, I’d like to share some ideas from a book that goes completely against how I see software development. I recently read A Philosophy of Software Design by John Ousterhout. The author studied at the best universities and is still teaching at Stanford. He received both the Grace Murray Hopper Award and the ACM Software System Award. He obviously has a deep knowledge and based on A Philosophy of Software Design I must tell you that he knows how to write well. He writes mostly about the opposite I’ve been learning during the last couple of years in the software craftsmanship movement. It doesn’t mean that he doesn’t have great points, because he has and it’s a book worth reading. Today, let’s focus on one of the key ideas delivered by this book. Deep modules everywhere Behind all the strange things, there is one notion, one idea. Deep modules. Let’s treat the term module quite vaguely in this case. A component, a class, an interface, a method can all be considered a module. According to Ousterhout, “the best modules are those that provide powerful functionality yet have simple interfaces.” Actually, I think it’s a good point as long as we talk about software components and the public interfaces of whatever modules. APIs should be hard to misuse As the author wrote, you should not have to call many different methods to achieve a simple thing. And even more importantly, the most common cases should be no-brainers. The most common cases should be achieved without additional effort. If you think about a constructor, the most common way of instantiating the class should require the least amount of parameters. Even for the more complex cases, APIs should be well-documented, and hard to misuse. In any case, according to Ousterhout, you should not need to call many different methods in order to achieve a simple thing! As a counterexample, he mentions the Java way of reading serialized objects from a file. To achieve a simple thing, you need to manually instantiate 3 different classes and pass each one to the next. I completely agree with him on this. At the same time, the author recommends that both public and non-public interfaces should be deep. Everything should provide something deep, complex and powerful. Small classes, short methods are not such things. This goes completely against what I learned during the last 10 years. Ousterhout advocates for what I considered evil and barely talks about something I considered one of the most important aspects of writing code… Testing seems difficult The problem with deep modules, deep classes, and deep methods is that they are hard to test. They are designed to perform a lot of things. They probably instantiate lots of objects, they call some other APIs. And you cannot mock those, you cannot replace them with fakes! Or if you can, the APIs become so complex that it goes against what we already discussed. As such, you can’t really have a complete unit test suite. If you’re lucky, you might be able to have some good integration or end-to-end tests, but no good unit tests. On the other hand, if shallow methods are designed well, they will take their dependencies as parameters. They can be set up, and created in a way that unit testing becomes not only possible but even easy. This one benefit already justifies to me why your methods should not be too deep and long. But it’s not the only reason. Comments In deep entities, you’ll end up with huge blocks of code. Long methods that are hard to understand unless they are well commented. In Clean Code, we learned that in a long function there will blocks that are separated by empty lines. They are usually responsible for a specific task. These blocks usually also have a leading comment explaining what that block is responsible for. These blocks serve as good indicators of what can be extracted as a method responsible for one thing and the comments give nice hints to name the new functions. The usually cited problem is that comments are not well maintained so they cannot hold the truth. According to the author, we just need some discipline and reviews should ensure that these comments are well-maintained. I’m not that optimistic, but I agree that even maintaining function names need quite some discipline. We are lazy and we lack discipline. Yet, I think that we sooner update function names than comments lost in a huge function… The cognitive load The topic of deep vs shallow modules reminds me of discussions I had with a former colleague. I have a deep respect towards that guy, a smart and hard-working C++ developer. I think he would probably agree with the author John Ousterhout on so many questions. We also agreed on many things, but we thought in very different ways about the optimal size of a method. While reading code written by me, he always complained about the mental complexity of jumping into yet another function, yet into another class. I heard him, I understood him, but I still don’t agree. I don’t think that short, well-named methods in the implementation increase the cognitive load. Why should I check the implementation of a well-named entity if I don’t have to modify it, if I’m not looking for a bug in that area of code? I simply don’t care and don’t go in. If I don’t need to understand the implemenation details of that piece of code. The same way as normally you don’t check the implementation of the standard library and you don’t check the assembly code generated. Sure, you could gain some deeper insight, but most often there is no need. In my opinion, exactly the contrary happens. Each well-named method or variable hides a bit of complexity and decreases the cognitive load. Conclusion In A Philosophy of Software Design I learned about a different approach to software development. A different from what I learned for long years. The author, John Ousterhout advocates for using deep modules instead of so-called shallow ones. If we follow his recommendations, we’ll end up having entities that are barely short, but they are always responsible for complex meaningful features. That also brings long blocks of code, comments instead well-named short functions and more difficult testing in practice. While I don’t completely agree with all his points, there is definitely one to consider. We should design our public APIs in a way so that the most common functionalities, the most common ways of using those functionalities should be dead simple to use. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I keep telling that I don’t post negative book reviews. It’s because no matter how much I dislike a book, I can be pretty sure that the author made a huge effort writing it. I have absolutely no reason to post negative reviews. I’m not afraid of giving constructive criticism in real life and at work when I’m personally involved. When it comes to books, there are just so many good ones I can focus on. I won’t share a negative book review either today, on the other hand, I’d like to share some ideas from a book that goes completely against how I see software development. I recently read A Philosophy of Software Design by John Ousterhout. The author studied at the best universities and is still teaching at Stanford. He received both the Grace Murray Hopper Award and the ACM Software System Award. He obviously has a deep knowledge and based on A Philosophy of Software Design I must tell you that he knows how to write well. He writes mostly about the opposite I’ve been learning during the last couple of years in the software craftsmanship movement. It doesn’t mean that he doesn’t have great points, because he has and it’s a book worth reading. Today, let’s focus on one of the key ideas delivered by this book. Deep modules everywhere Behind all the strange things, there is one notion, one idea. Deep modules. Let’s treat the term module quite vaguely in this case. A component, a class, an interface, a method can all be considered a module. According to Ousterhout, “the best modules are those that provide powerful functionality yet have simple interfaces.” Actually, I think it’s a good point as long as we talk about software components and the public interfaces of whatever modules. APIs should be hard to misuse As the author wrote, you should not have to call many different methods to achieve a simple thing. And even more importantly, the most common cases should be no-brainers. The most common cases should be achieved without additional effort. If you think about a constructor, the most common way of instantiating the class should require the least amount of parameters. Even for the more complex cases, APIs should be well-documented, and hard to misuse. In any case, according to Ousterhout, you should not need to call many different methods in order to achieve a simple thing! As a counterexample, he mentions the Java way of reading serialized objects from a file. To achieve a simple thing, you need to manually instantiate 3 different classes and pass each one to the next. I completely agree with him on this. At the same time, the author recommends that both public and non-public interfaces should be deep. Everything should provide something deep, complex and powerful. Small classes, short methods are not such things. This goes completely against what I learned during the last 10 years. Ousterhout advocates for what I considered evil and barely talks about something I considered one of the most important aspects of writing code… Testing seems difficult The problem with deep modules, deep classes, and deep methods is that they are hard to test. They are designed to perform a lot of things. They probably instantiate lots of objects, they call some other APIs. And you cannot mock those, you cannot replace them with fakes! Or if you can, the APIs become so complex that it goes against what we already discussed. As such, you can’t really have a complete unit test suite. If you’re lucky, you might be able to have some good integration or end-to-end tests, but no good unit tests. On the other hand, if shallow methods are designed well, they will take their dependencies as parameters. They can be set up, and created in a way that unit testing becomes not only possible but even easy. This one benefit already justifies to me why your methods should not be too deep and long. But it’s not the only reason. Comments In deep entities, you’ll end up with huge blocks of code. Long methods that are hard to understand unless they are well commented. In Clean Code, we learned that in a long function there will blocks that are separated by empty lines. They are usually responsible for a specific task. These blocks usually also have a leading comment explaining what that block is responsible for. These blocks serve as good indicators of what can be extracted as a method responsible for one thing and the comments give nice hints to name the new functions. The usually cited problem is that comments are not well maintained so they cannot hold the truth. According to the author, we just need some discipline and reviews should ensure that these comments are well-maintained. I’m not that optimistic, but I agree that even maintaining function names need quite some discipline. We are lazy and we lack discipline. Yet, I think that we sooner update function names than comments lost in a huge function… The cognitive load The topic of deep vs shallow modules reminds me of discussions I had with a former colleague. I have a deep respect towards that guy, a smart and hard-working C++ developer. I think he would probably agree with the author John Ousterhout on so many questions. We also agreed on many things, but we thought in very different ways about the optimal size of a method. While reading code written by me, he always complained about the mental complexity of jumping into yet another function, yet into another class. I heard him, I understood him, but I still don’t agree. I don’t think that short, well-named methods in the implementation increase the cognitive load. Why should I check the implementation of a well-named entity if I don’t have to modify it, if I’m not looking for a bug in that area of code? I simply don’t care and don’t go in. If I don’t need to understand the implemenation details of that piece of code. The same way as normally you don’t check the implementation of the standard library and you don’t check the assembly code generated. Sure, you could gain some deeper insight, but most often there is no need. In my opinion, exactly the contrary happens. Each well-named method or variable hides a bit of complexity and decreases the cognitive load. Conclusion In A Philosophy of Software Design I learned about a different approach to software development. A different from what I learned for long years. The author, John Ousterhout advocates for using deep modules instead of so-called shallow ones. If we follow his recommendations, we’ll end up having entities that are barely short, but they are always responsible for complex meaningful features. That also brings long blocks of code, comments instead well-named short functions and more difficult testing in practice. While I don’t completely agree with all his points, there is definitely one to consider. We should design our public APIs in a way so that the most common functionalities, the most common ways of using those functionalities should be dead simple to use. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-25T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Deep vs shallow modules" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-25T00:00:00+01:00","datePublished":"2023-01-25T00:00:00+01:00","description":"I keep telling that I don’t post negative book reviews. It’s because no matter how much I dislike a book, I can be pretty sure that the author made a huge effort writing it. I have absolutely no reason to post negative reviews. I’m not afraid of giving constructive criticism in real life and at work when I’m personally involved. When it comes to books, there are just so many good ones I can focus on. I won’t share a negative book review either today, on the other hand, I’d like to share some ideas from a book that goes completely against how I see software development. I recently read A Philosophy of Software Design by John Ousterhout. The author studied at the best universities and is still teaching at Stanford. He received both the Grace Murray Hopper Award and the ACM Software System Award. He obviously has a deep knowledge and based on A Philosophy of Software Design I must tell you that he knows how to write well. He writes mostly about the opposite I’ve been learning during the last couple of years in the software craftsmanship movement. It doesn’t mean that he doesn’t have great points, because he has and it’s a book worth reading. Today, let’s focus on one of the key ideas delivered by this book. Deep modules everywhere Behind all the strange things, there is one notion, one idea. Deep modules. Let’s treat the term module quite vaguely in this case. A component, a class, an interface, a method can all be considered a module. According to Ousterhout, “the best modules are those that provide powerful functionality yet have simple interfaces.” Actually, I think it’s a good point as long as we talk about software components and the public interfaces of whatever modules. APIs should be hard to misuse As the author wrote, you should not have to call many different methods to achieve a simple thing. And even more importantly, the most common cases should be no-brainers. The most common cases should be achieved without additional effort. If you think about a constructor, the most common way of instantiating the class should require the least amount of parameters. Even for the more complex cases, APIs should be well-documented, and hard to misuse. In any case, according to Ousterhout, you should not need to call many different methods in order to achieve a simple thing! As a counterexample, he mentions the Java way of reading serialized objects from a file. To achieve a simple thing, you need to manually instantiate 3 different classes and pass each one to the next. I completely agree with him on this. At the same time, the author recommends that both public and non-public interfaces should be deep. Everything should provide something deep, complex and powerful. Small classes, short methods are not such things. This goes completely against what I learned during the last 10 years. Ousterhout advocates for what I considered evil and barely talks about something I considered one of the most important aspects of writing code… Testing seems difficult The problem with deep modules, deep classes, and deep methods is that they are hard to test. They are designed to perform a lot of things. They probably instantiate lots of objects, they call some other APIs. And you cannot mock those, you cannot replace them with fakes! Or if you can, the APIs become so complex that it goes against what we already discussed. As such, you can’t really have a complete unit test suite. If you’re lucky, you might be able to have some good integration or end-to-end tests, but no good unit tests. On the other hand, if shallow methods are designed well, they will take their dependencies as parameters. They can be set up, and created in a way that unit testing becomes not only possible but even easy. This one benefit already justifies to me why your methods should not be too deep and long. But it’s not the only reason. Comments In deep entities, you’ll end up with huge blocks of code. Long methods that are hard to understand unless they are well commented. In Clean Code, we learned that in a long function there will blocks that are separated by empty lines. They are usually responsible for a specific task. These blocks usually also have a leading comment explaining what that block is responsible for. These blocks serve as good indicators of what can be extracted as a method responsible for one thing and the comments give nice hints to name the new functions. The usually cited problem is that comments are not well maintained so they cannot hold the truth. According to the author, we just need some discipline and reviews should ensure that these comments are well-maintained. I’m not that optimistic, but I agree that even maintaining function names need quite some discipline. We are lazy and we lack discipline. Yet, I think that we sooner update function names than comments lost in a huge function… The cognitive load The topic of deep vs shallow modules reminds me of discussions I had with a former colleague. I have a deep respect towards that guy, a smart and hard-working C++ developer. I think he would probably agree with the author John Ousterhout on so many questions. We also agreed on many things, but we thought in very different ways about the optimal size of a method. While reading code written by me, he always complained about the mental complexity of jumping into yet another function, yet into another class. I heard him, I understood him, but I still don’t agree. I don’t think that short, well-named methods in the implementation increase the cognitive load. Why should I check the implementation of a well-named entity if I don’t have to modify it, if I’m not looking for a bug in that area of code? I simply don’t care and don’t go in. If I don’t need to understand the implemenation details of that piece of code. The same way as normally you don’t check the implementation of the standard library and you don’t check the assembly code generated. Sure, you could gain some deeper insight, but most often there is no need. In my opinion, exactly the contrary happens. Each well-named method or variable hides a bit of complexity and decreases the cognitive load. Conclusion In A Philosophy of Software Design I learned about a different approach to software development. A different from what I learned for long years. The author, John Ousterhout advocates for using deep modules instead of so-called shallow ones. If we follow his recommendations, we’ll end up having entities that are barely short, but they are always responsible for complex meaningful features. That also brings long blocks of code, comments instead well-named short functions and more difficult testing in practice. While I don’t completely agree with all his points, there is definitely one to consider. We should design our public APIs in a way so that the most common functionalities, the most common ways of using those functionalities should be dead simple to use. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Deep vs shallow modules","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules"},"url":"https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules"}</script><title>Deep vs shallow modules | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/25"> 25 </a> </span> <span>Deep vs shallow modules</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Deep vs shallow modules</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 25, 2023, 12:00 AM +0100" prep="on" > Jan 25, 2023 <i class="unloaded">2023-01-25T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1210 words">6 min</span></div></div><div class="post-content"><p>I keep telling that I don’t post negative book reviews. It’s because no matter how much I dislike a book, I can be pretty sure that the author made a huge effort writing it. I have absolutely no reason to post negative reviews.</p><p>I’m not afraid of giving constructive criticism in real life and at work when I’m personally involved. When it comes to books, there are just so many good ones I can focus on.</p><p>I won’t share a negative book review either today, on the other hand, I’d like to share some ideas from a book that goes completely against how I see software development.</p><p>I recently read <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=5e8a182a2cccdd5aaeef828c6cb1ffb4&amp;camp=1789&amp;creative=9325">A Philosophy of Software Design</a> by <a href="https://web.stanford.edu/~ouster/cgi-bin/home.php">John Ousterhout</a>. The author studied at the best universities and is still teaching at Stanford. He received both the Grace Murray Hopper Award and the ACM Software System Award. He obviously has a deep knowledge and based on <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=5e8a182a2cccdd5aaeef828c6cb1ffb4&amp;camp=1789&amp;creative=9325">A Philosophy of Software Design</a> I must tell you that he knows how to write well.</p><p>He writes mostly about the opposite I’ve been learning during the last couple of years in the software craftsmanship movement. It doesn’t mean that he doesn’t have great points, because he has and it’s a book worth reading.</p><p>Today, let’s focus on one of the key ideas delivered by this book.</p><h2 id="deep-modules-everywhere">Deep modules everywhere</h2><p>Behind all the strange things, there is one notion, one idea.</p><p>Deep modules.</p><p>Let’s treat the term module quite vaguely in this case. A component, a class, an interface, a method can all be considered a module.</p><p>According to Ousterhout, <em>“the best modules are those that provide powerful functionality yet have simple interfaces.”</em></p><p>Actually, I think it’s a good point as long as we talk about software components and the public interfaces of whatever modules.</p><h2 id="apis-should-be-hard-to-misuse">APIs should be hard to misuse</h2><p>As the author wrote, you should not have to call many different methods to achieve a simple thing. And even more importantly, the most common cases should be no-brainers. The most common cases should be achieved without additional effort.</p><p>If you think about a constructor, the most common way of instantiating the class should require the least amount of parameters. Even for the more complex cases, APIs should be well-documented, and hard to misuse.</p><p>In any case, according to Ousterhout, you should not need to call many different methods in order to achieve a simple thing! As a counterexample, he mentions the Java way of reading serialized objects from a file. To achieve a simple thing, you need to manually instantiate 3 different classes and pass each one to the next. I completely agree with him on this.</p><p>At the same time, the author recommends that both public and non-public interfaces should be deep. Everything should provide something deep, complex and powerful. Small classes, short methods are not such things.</p><p>This goes completely against what I learned during the last 10 years. Ousterhout advocates for what I considered evil and barely talks about something I considered one of the most important aspects of writing code…</p><h2 id="testing-seems-difficult">Testing seems difficult</h2><p>The problem with deep modules, deep classes, and deep methods is that they are hard to test. They are designed to perform a lot of things. They probably instantiate lots of objects, they call some other APIs. And you cannot mock those, you cannot replace them with fakes! Or if you can, the APIs become so complex that it goes against what we already discussed.</p><p>As such, you can’t really have a complete unit test suite. If you’re lucky, you might be able to have some good integration or end-to-end tests, but no good unit tests.</p><p>On the other hand, if shallow methods are designed well, they will take their dependencies as parameters. They can be set up, and created in a way that unit testing becomes not only possible but even easy.</p><p>This one benefit already justifies to me why your methods should not be too deep and long. But it’s not the only reason.</p><h2 id="comments">Comments</h2><p>In deep entities, you’ll end up with huge blocks of code. Long methods that are hard to understand unless they are well commented. In <a href="https://www.amazon.fr/dp/0132350882/ref=as_li_qf_asin_il_tl?ie=UTF8&amp;linkCode=gs2&amp;linkId=0e9c9c3d84461c60a88af599d18d9d04&amp;creativeASIN=0132350882&amp;tag=sandordargo07-21&amp;creative=9325">Clean Code</a>, we learned that in a long function there will blocks that are separated by empty lines. They are usually responsible for a specific task. These blocks usually also have a leading comment explaining what that block is responsible for.</p><p>These blocks serve as good indicators of what can be extracted as a method responsible for one thing and the comments give nice hints to name the new functions.</p><p>The usually cited problem is that comments are not well maintained so they cannot hold the truth. According to the author, we just need some discipline and reviews should ensure that these comments are well-maintained.</p><p>I’m not that optimistic, but I agree that even maintaining function names need quite some discipline. We are lazy and we lack discipline. Yet, I think that we sooner update function names than comments lost in a huge function…</p><h2 id="the-cognitive-load">The cognitive load</h2><p>The topic of deep vs shallow modules reminds me of discussions I had with a former colleague. I have a deep respect towards that guy, a smart and hard-working C++ developer. I think he would probably agree with the author John Ousterhout on so many questions. We also agreed on many things, but we thought in very different ways about the optimal size of a method.</p><p>While reading code written by me, he always complained about the mental complexity of jumping into yet another function, yet into another class.</p><p>I heard him, I understood him, but I still don’t agree. I don’t think that short, well-named methods in the implementation increase the cognitive load. Why should I check the implementation of a well-named entity if I don’t have to modify it, if I’m not looking for a bug in that area of code? I simply don’t care and don’t go in. If I don’t need to understand the implemenation details of that piece of code. The same way as normally you don’t check the implementation of the standard library and you don’t check the assembly code generated. Sure, you could gain some deeper insight, but most often there is no need.</p><p>In my opinion, exactly the contrary happens. Each well-named method or variable hides a bit of complexity and decreases the cognitive load.</p><h2 id="conclusion">Conclusion</h2><p>In <a href="https://www.amazon.com/Philosophy-Software-Design-John-Ousterhout/dp/1732102201?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=5e8a182a2cccdd5aaeef828c6cb1ffb4&amp;camp=1789&amp;creative=9325">A Philosophy of Software Design</a> I learned about a different approach to software development. A different from what I learned for long years. The author, <a href="https://web.stanford.edu/~ouster/cgi-bin/home.php">John Ousterhout</a> advocates for using deep modules instead of so-called shallow ones.</p><p>If we follow his recommendations, we’ll end up having entities that are barely short, but they are always responsible for complex meaningful features. That also brings long blocks of code, comments instead well-named short functions and more difficult testing in practice.</p><p>While I don’t completely agree with all his points, there is definitely one to consider. We should design our public APIs in a way so that the most common functionalities, the most common ways of using those functionalities should be dead simple to use.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/books/" class="post-tag no-text-decoration" >books</a> <a href="/tags/softwaredesign/" class="post-tag no-text-decoration" >softwaredesign</a> <a href="/tags/cleancode/" class="post-tag no-text-decoration" >cleancode</a> <a href="/tags/watercooler/" class="post-tag no-text-decoration" >watercooler</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Deep vs shallow modules - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Deep vs shallow modules - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Deep vs shallow modules - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Deep vs shallow modules - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2020/01/22/crime-scene-and-x-ray"><div class="card-body"> <span class="timeago small" > Jan 22, 2020 <i class="unloaded">2020-01-22T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Your Code as a Crime Scene and Software Design X-Rays by Adam Tornhill</h3><div class="text-muted small"><p> Usually, I write about one single book in a given article, but this is a peculiar occasion. Last months I read both books written by Adam Tornhill: Your Code as a Crime Scene (YCCS) and Software De...</p></div></div></a></div><div class="card"> <a href="/blog/2024/03/16/tidy-first-by-kent-beck"><div class="card-body"> <span class="timeago small" > Mar 16, 2024 <i class="unloaded">2024-03-16T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Tidy First? by Kent Beck</h3><div class="text-muted small"><p> Let’s start by explaining what tidying means when it comes to software development. Maybe a decade ago, this book would have been called “Refactoring first?”, but the term “refactoring” got inflate...</p></div></div></a></div><div class="card"> <a href="/blog/2024/10/16/cpp-brain-teasers"><div class="card-body"> <span class="timeago small" > Oct 16, 2024 <i class="unloaded">2024-10-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ Brain Teasers by Anders Schau Knatten</h3><div class="text-muted small"><p> I bought C++ Brain Teasers at C++ On Sea where the author also gave a presentation and made a few references to his book. I couldn’t wait to read it. Now that I finally did it, I’d like to share my...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/01/18/object-initialization-and-binary-sizes" class="btn btn-outline-primary" prompt="Older"><p>Object initialization and binary sizes</p></a> <a href="/blog/2023/02/01/special-functions-and-binary-sizes" class="btn btn-outline-primary" prompt="Newer"><p>Special functions and binary sizes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Deep vs shallow modules'; this.page.url = 'https://www.sandordargo.com/blog/2023/01/25/deep-vs-shallow-modules'; this.page.identifier = '/blog/2023/01/25/deep-vs-shallow-modules'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
