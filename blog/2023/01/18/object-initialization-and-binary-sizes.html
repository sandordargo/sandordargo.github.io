<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Object initialization and binary sizes" /><meta property="og:locale" content="en_US" /><meta name="description" content="Let’s have this piece of code that generates a big binary. 1 2 3 4 5 6 7 8 9 #include &lt;array&gt; struct Node { int a = 1, b = 1; }; std::array &lt;Node, 10&#39;000&gt; a; int main() {} If you compile this piece of code, you’ll get quite a big binary. Of course, the exact size depends on your platform, compiler, etc. On my computer, its size is around 99 KB. 1 2 3 clang++ -std=c++20 -O3 -stdlib=libc++ array-global-10k.cpp -o array-global-10k printf &quot;%&#39;d\n&quot; $(wc -c &lt; &quot;$1&quot;) # 99,437 That makes sense as the size of Node is 8 bytes and the a array contains 10,000 of them, that’s already 80K. In any case, that binary is big considering what the program does. Let’s take it apart and see what goes on. The choice of container First of all, the binary became so big, because we have declared a big container with static storage duration. We can easily decrease the size of the binary if we use a different type of container or if we declare it with a different storage duration. Container type Anything that requires dynamic memory allocation will not make your binary huge as dynamic memory allocations cannot happen compile-time. Okay, now a vector can be constexpr, but only if it’s deallocated by the end of a consteval function. It cannot survive, you cannot have it as a member. So in practice, c-style arrays and std::arrays can significantly increase your binary sizes, but others with dynamic memory allocation, such as std::vector or std::list or different kinds of associative containers cannot. Let’s see a few examples of binary sizes and compile times. The above code with std::array generated a binary of 99K and it took 2.8 seconds to compile it 100 times. The same with a std::vector generated a binary of 33-40K depending on the optimization settings (it made no difference for std::array) and the compile time was roughly the same. The runtime for this very simple code doubled. Running it a 100 times took 0.75 seconds instead of 0.39. It makes sense as the initialization is now completely part of the runtime. Using a c-style array resulted in the very same binary size and had essentially the same runtime, but the compile time is much faster than with the other two options. My assumption is that it’s basically because we don’t have to include and link any headers. So what took 2.8 seconds with std::array and with std::vector, it only took 0.75 with a c-style array. It’s interesting, but I wouldn’t replace std::array with c-style arrays. Container Binary size Compile-time Run-time std::array 99K 2.8 0.39 c-style array 99K 0.75 0.39 std::vector 33-40K 2.8 0.75 Storage duration If the variable is declared as global or static, it will have a static storage duration and it’ll be part of the binary. Depending on whether it’s const or not, initialized or not, it might go into different parts of the TEXT or DATA segment. If you declare the std::array as a local variable, it’ll be created on the go. Even if it’s const. constexpr locals might be initialized at compile-time and therefore be part of the binary. Let’s see some numbers. Container Binary size Compile-time Run-time global 99K 2.2 0.25 local 33K 2.2 0.87 local static 16-99K 2.2 0.89 local static const 16-82K 2.2 0.84 local constexpr 16-99K 2.8 0.93 The initialization I found this a particularly interesting point. We saw that depending on the storage duration and the container type we can have executables with completely different sizes and characteristics. But there is one more thing you can do with this simple piece of code in order shrink the size of the executable. You can change how it’s initialized. Both members are initialized to non-default values. On the other hand, if you choose to default initialize them, the size will shrink. To see what is behind, we should rather check the assembly code that we can get with the -S flag, e.g., with the command clang++ -std=c++20 -stdlib=libc++ -S array-global-arbitrary.cpp. When we initialize members with an arbitrary value (such as 1 in the above example), we will see this pattern in our assembly code in a great length: 1 2 3 4 5 6 7 8 9 .section __DATA,__data .globl _a ; @a .p2align 2 _a: .long 1 ; 0x1 .long 1 ; 0x1 .long 1 ; 0x1 // ... .long 1 ; 0x1 However, when we initialize our member ints with a default value, we’ll only see one line: .zerofill __DATA,__common,_segtree,3`200`000,2 This explains why the binary bloats in the function of the size of the array that we have to initialize. But when we zero-initialize the values, it doesn’t matter anymore. What was also interesting to see is that if I add another member, such as a std::string, this doesn’t matter anymore, the size stays small(er) no matter how I initialize variables. I think the reason behind this is that std::strings involves dynamic memory allocations, so we cannot completely initialize our array at compile-time anymore. Looking at the assembly code we observe that lots of code is now in the TEXT segment. On the other hand, if we add a third member that is of another type that doesn’t require dynamic allocations, such as a float or a new class, such as struct NoDynamic {int c=0; int d=0;};, we can still observe the same difference. We end up with a very small assembly and binary with a nice .zerofill command. Essentially, this is the same observation we made for containers. Wherever there is dynamic memory allocation, there is no initialization at compile-time, so our binary remains relatively small. Conclusion Today we saw different factors that influence how much space an object takes up in our binary. It depends on how we store it, them. If we allocate on the heap (either directly or through a container such as a vector), it doesn’t change our binary size a lot. But if we allocate through c-style or a std::array involving no dynamic allocations, the size will grow as the number of objects allocated grows. But it’s not as simple as that, it also depends on the storage duration of the variable. Only variables with static storage duration will be initialized at compile time. Last but not least, it also depends on the class itself, what kind of members it has. If initializing an instance of a type requires dynamic memory allocation, it cannot be done at compile time. But as we also saw, as the size changes, compilation- and run-times might also change but so far we haven’t seen strong correlations. Next time, we’ll still deal with very basic features of C++, we’ll have a look at special functions of a class. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Let’s have this piece of code that generates a big binary. 1 2 3 4 5 6 7 8 9 #include &lt;array&gt; struct Node { int a = 1, b = 1; }; std::array &lt;Node, 10&#39;000&gt; a; int main() {} If you compile this piece of code, you’ll get quite a big binary. Of course, the exact size depends on your platform, compiler, etc. On my computer, its size is around 99 KB. 1 2 3 clang++ -std=c++20 -O3 -stdlib=libc++ array-global-10k.cpp -o array-global-10k printf &quot;%&#39;d\n&quot; $(wc -c &lt; &quot;$1&quot;) # 99,437 That makes sense as the size of Node is 8 bytes and the a array contains 10,000 of them, that’s already 80K. In any case, that binary is big considering what the program does. Let’s take it apart and see what goes on. The choice of container First of all, the binary became so big, because we have declared a big container with static storage duration. We can easily decrease the size of the binary if we use a different type of container or if we declare it with a different storage duration. Container type Anything that requires dynamic memory allocation will not make your binary huge as dynamic memory allocations cannot happen compile-time. Okay, now a vector can be constexpr, but only if it’s deallocated by the end of a consteval function. It cannot survive, you cannot have it as a member. So in practice, c-style arrays and std::arrays can significantly increase your binary sizes, but others with dynamic memory allocation, such as std::vector or std::list or different kinds of associative containers cannot. Let’s see a few examples of binary sizes and compile times. The above code with std::array generated a binary of 99K and it took 2.8 seconds to compile it 100 times. The same with a std::vector generated a binary of 33-40K depending on the optimization settings (it made no difference for std::array) and the compile time was roughly the same. The runtime for this very simple code doubled. Running it a 100 times took 0.75 seconds instead of 0.39. It makes sense as the initialization is now completely part of the runtime. Using a c-style array resulted in the very same binary size and had essentially the same runtime, but the compile time is much faster than with the other two options. My assumption is that it’s basically because we don’t have to include and link any headers. So what took 2.8 seconds with std::array and with std::vector, it only took 0.75 with a c-style array. It’s interesting, but I wouldn’t replace std::array with c-style arrays. Container Binary size Compile-time Run-time std::array 99K 2.8 0.39 c-style array 99K 0.75 0.39 std::vector 33-40K 2.8 0.75 Storage duration If the variable is declared as global or static, it will have a static storage duration and it’ll be part of the binary. Depending on whether it’s const or not, initialized or not, it might go into different parts of the TEXT or DATA segment. If you declare the std::array as a local variable, it’ll be created on the go. Even if it’s const. constexpr locals might be initialized at compile-time and therefore be part of the binary. Let’s see some numbers. Container Binary size Compile-time Run-time global 99K 2.2 0.25 local 33K 2.2 0.87 local static 16-99K 2.2 0.89 local static const 16-82K 2.2 0.84 local constexpr 16-99K 2.8 0.93 The initialization I found this a particularly interesting point. We saw that depending on the storage duration and the container type we can have executables with completely different sizes and characteristics. But there is one more thing you can do with this simple piece of code in order shrink the size of the executable. You can change how it’s initialized. Both members are initialized to non-default values. On the other hand, if you choose to default initialize them, the size will shrink. To see what is behind, we should rather check the assembly code that we can get with the -S flag, e.g., with the command clang++ -std=c++20 -stdlib=libc++ -S array-global-arbitrary.cpp. When we initialize members with an arbitrary value (such as 1 in the above example), we will see this pattern in our assembly code in a great length: 1 2 3 4 5 6 7 8 9 .section __DATA,__data .globl _a ; @a .p2align 2 _a: .long 1 ; 0x1 .long 1 ; 0x1 .long 1 ; 0x1 // ... .long 1 ; 0x1 However, when we initialize our member ints with a default value, we’ll only see one line: .zerofill __DATA,__common,_segtree,3`200`000,2 This explains why the binary bloats in the function of the size of the array that we have to initialize. But when we zero-initialize the values, it doesn’t matter anymore. What was also interesting to see is that if I add another member, such as a std::string, this doesn’t matter anymore, the size stays small(er) no matter how I initialize variables. I think the reason behind this is that std::strings involves dynamic memory allocations, so we cannot completely initialize our array at compile-time anymore. Looking at the assembly code we observe that lots of code is now in the TEXT segment. On the other hand, if we add a third member that is of another type that doesn’t require dynamic allocations, such as a float or a new class, such as struct NoDynamic {int c=0; int d=0;};, we can still observe the same difference. We end up with a very small assembly and binary with a nice .zerofill command. Essentially, this is the same observation we made for containers. Wherever there is dynamic memory allocation, there is no initialization at compile-time, so our binary remains relatively small. Conclusion Today we saw different factors that influence how much space an object takes up in our binary. It depends on how we store it, them. If we allocate on the heap (either directly or through a container such as a vector), it doesn’t change our binary size a lot. But if we allocate through c-style or a std::array involving no dynamic allocations, the size will grow as the number of objects allocated grows. But it’s not as simple as that, it also depends on the storage duration of the variable. Only variables with static storage duration will be initialized at compile time. Last but not least, it also depends on the class itself, what kind of members it has. If initializing an instance of a type requires dynamic memory allocation, it cannot be done at compile time. But as we also saw, as the size changes, compilation- and run-times might also change but so far we haven’t seen strong correlations. Next time, we’ll still deal with very basic features of C++, we’ll have a look at special functions of a class. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-18T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Object initialization and binary sizes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-01-25T06:57:29+01:00","datePublished":"2023-01-18T00:00:00+01:00","description":"Let’s have this piece of code that generates a big binary. 1 2 3 4 5 6 7 8 9 #include &lt;array&gt; struct Node { int a = 1, b = 1; }; std::array &lt;Node, 10&#39;000&gt; a; int main() {} If you compile this piece of code, you’ll get quite a big binary. Of course, the exact size depends on your platform, compiler, etc. On my computer, its size is around 99 KB. 1 2 3 clang++ -std=c++20 -O3 -stdlib=libc++ array-global-10k.cpp -o array-global-10k printf &quot;%&#39;d\\n&quot; $(wc -c &lt; &quot;$1&quot;) # 99,437 That makes sense as the size of Node is 8 bytes and the a array contains 10,000 of them, that’s already 80K. In any case, that binary is big considering what the program does. Let’s take it apart and see what goes on. The choice of container First of all, the binary became so big, because we have declared a big container with static storage duration. We can easily decrease the size of the binary if we use a different type of container or if we declare it with a different storage duration. Container type Anything that requires dynamic memory allocation will not make your binary huge as dynamic memory allocations cannot happen compile-time. Okay, now a vector can be constexpr, but only if it’s deallocated by the end of a consteval function. It cannot survive, you cannot have it as a member. So in practice, c-style arrays and std::arrays can significantly increase your binary sizes, but others with dynamic memory allocation, such as std::vector or std::list or different kinds of associative containers cannot. Let’s see a few examples of binary sizes and compile times. The above code with std::array generated a binary of 99K and it took 2.8 seconds to compile it 100 times. The same with a std::vector generated a binary of 33-40K depending on the optimization settings (it made no difference for std::array) and the compile time was roughly the same. The runtime for this very simple code doubled. Running it a 100 times took 0.75 seconds instead of 0.39. It makes sense as the initialization is now completely part of the runtime. Using a c-style array resulted in the very same binary size and had essentially the same runtime, but the compile time is much faster than with the other two options. My assumption is that it’s basically because we don’t have to include and link any headers. So what took 2.8 seconds with std::array and with std::vector, it only took 0.75 with a c-style array. It’s interesting, but I wouldn’t replace std::array with c-style arrays. Container Binary size Compile-time Run-time std::array 99K 2.8 0.39 c-style array 99K 0.75 0.39 std::vector 33-40K 2.8 0.75 Storage duration If the variable is declared as global or static, it will have a static storage duration and it’ll be part of the binary. Depending on whether it’s const or not, initialized or not, it might go into different parts of the TEXT or DATA segment. If you declare the std::array as a local variable, it’ll be created on the go. Even if it’s const. constexpr locals might be initialized at compile-time and therefore be part of the binary. Let’s see some numbers. Container Binary size Compile-time Run-time global 99K 2.2 0.25 local 33K 2.2 0.87 local static 16-99K 2.2 0.89 local static const 16-82K 2.2 0.84 local constexpr 16-99K 2.8 0.93 The initialization I found this a particularly interesting point. We saw that depending on the storage duration and the container type we can have executables with completely different sizes and characteristics. But there is one more thing you can do with this simple piece of code in order shrink the size of the executable. You can change how it’s initialized. Both members are initialized to non-default values. On the other hand, if you choose to default initialize them, the size will shrink. To see what is behind, we should rather check the assembly code that we can get with the -S flag, e.g., with the command clang++ -std=c++20 -stdlib=libc++ -S array-global-arbitrary.cpp. When we initialize members with an arbitrary value (such as 1 in the above example), we will see this pattern in our assembly code in a great length: 1 2 3 4 5 6 7 8 9 .section __DATA,__data .globl _a ; @a .p2align 2 _a: .long 1 ; 0x1 .long 1 ; 0x1 .long 1 ; 0x1 // ... .long 1 ; 0x1 However, when we initialize our member ints with a default value, we’ll only see one line: .zerofill __DATA,__common,_segtree,3`200`000,2 This explains why the binary bloats in the function of the size of the array that we have to initialize. But when we zero-initialize the values, it doesn’t matter anymore. What was also interesting to see is that if I add another member, such as a std::string, this doesn’t matter anymore, the size stays small(er) no matter how I initialize variables. I think the reason behind this is that std::strings involves dynamic memory allocations, so we cannot completely initialize our array at compile-time anymore. Looking at the assembly code we observe that lots of code is now in the TEXT segment. On the other hand, if we add a third member that is of another type that doesn’t require dynamic allocations, such as a float or a new class, such as struct NoDynamic {int c=0; int d=0;};, we can still observe the same difference. We end up with a very small assembly and binary with a nice .zerofill command. Essentially, this is the same observation we made for containers. Wherever there is dynamic memory allocation, there is no initialization at compile-time, so our binary remains relatively small. Conclusion Today we saw different factors that influence how much space an object takes up in our binary. It depends on how we store it, them. If we allocate on the heap (either directly or through a container such as a vector), it doesn’t change our binary size a lot. But if we allocate through c-style or a std::array involving no dynamic allocations, the size will grow as the number of objects allocated grows. But it’s not as simple as that, it also depends on the storage duration of the variable. Only variables with static storage duration will be initialized at compile time. Last but not least, it also depends on the class itself, what kind of members it has. If initializing an instance of a type requires dynamic memory allocation, it cannot be done at compile time. But as we also saw, as the size changes, compilation- and run-times might also change but so far we haven’t seen strong correlations. Next time, we’ll still deal with very basic features of C++, we’ll have a look at special functions of a class. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Object initialization and binary sizes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes"},"url":"https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes"}</script><title>Object initialization and binary sizes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/18"> 18 </a> </span> <span>Object initialization and binary sizes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Object initialization and binary sizes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 18, 2023, 12:00 AM +0100" prep="on" > Jan 18, 2023 <i class="unloaded">2023-01-18T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 25, 2023, 6:57 AM +0100" prefix="Updated " > Jan 25, 2023 <i class="unloaded">2023-01-25T06:57:29+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1146 words">6 min</span></div></div><div class="post-content"><p>Let’s have this piece of code that generates a big binary.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span> <span class="o">&lt;</span><span class="n">Node</span><span class="p">,</span> <span class="mi">10'000</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{}</span>
</pre></table></code></div></div><p>If you compile this piece of code, you’ll get quite a big binary. Of course, the exact size depends on your platform, compiler, etc. On my computer, its size is around 99 KB.</p><div class="language-bash highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>clang++ <span class="nt">-std</span><span class="o">=</span>c++20 <span class="nt">-O3</span> <span class="nt">-stdlib</span><span class="o">=</span>libc++ array-global-10k.cpp <span class="nt">-o</span> array-global-10k
<span class="nb">printf</span> <span class="s2">"%'d</span><span class="se">\n</span><span class="s2">"</span> <span class="si">$(</span><span class="nb">wc</span> <span class="nt">-c</span> &lt; <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span><span class="si">)</span>
<span class="c"># 99,437</span>
</pre></table></code></div></div><p>That makes sense as the size of <code class="language-plaintext highlighter-rouge">Node</code> is 8 bytes and the <code class="language-plaintext highlighter-rouge">a</code> array contains <em>10,000</em> of them, that’s already 80K.</p><p>In any case, that binary is big considering what the program does. Let’s take it apart and see what goes on.</p><h2 id="the-choice-of-container">The choice of container</h2><p>First of all, the binary became so big, because we have declared a big container with <a href="https://www.sandordargo.com/blog/2022/05/18/scope-linkage-name">static storage duration</a>.</p><p>We can easily decrease the size of the binary if we use a different type of container or if we declare it with a different storage duration.</p><h3 id="container-type">Container type</h3><p>Anything that requires dynamic memory allocation will <strong>not</strong> make your binary huge as dynamic memory allocations cannot happen compile-time. Okay, now a <code class="language-plaintext highlighter-rouge">vector</code> can be <code class="language-plaintext highlighter-rouge">constexpr</code>, but only if it’s deallocated by the end of a <code class="language-plaintext highlighter-rouge">consteval</code> function. It cannot survive, you cannot have it as a member.</p><p>So in practice, c-style arrays and <code class="language-plaintext highlighter-rouge">std::array</code>s can significantly increase your binary sizes, but others with dynamic memory allocation, such as <code class="language-plaintext highlighter-rouge">std::vector</code> or <code class="language-plaintext highlighter-rouge">std::list</code> or different kinds of associative containers cannot.</p><p>Let’s see a few examples of binary sizes and compile times.</p><p>The above code with <code class="language-plaintext highlighter-rouge">std::array</code> generated a binary of 99K and it took 2.8 seconds to compile it 100 times. The same with a <code class="language-plaintext highlighter-rouge">std::vector</code> generated a binary of 33-40K depending on the optimization settings (it made no difference for <code class="language-plaintext highlighter-rouge">std::array</code>) and the compile time was roughly the same. The runtime for this very simple code doubled. Running it a 100 times took 0.75 seconds instead of 0.39. It makes sense as the initialization is now completely part of the runtime.</p><p>Using a c-style array resulted in the very same binary size and had essentially the same runtime, but the compile time is much faster than with the other two options. My assumption is that it’s basically because we don’t have to include and link any headers. So what took 2.8 seconds with <code class="language-plaintext highlighter-rouge">std::array</code> and with <code class="language-plaintext highlighter-rouge">std::vector</code>, it only took 0.75 with a c-style array.</p><p>It’s interesting, but I wouldn’t replace <code class="language-plaintext highlighter-rouge">std::array</code> with c-style arrays.</p><div class="table-wrapper"><table><thead><tr><th>Container<th>Binary size<th>Compile-time<th>Run-time<tbody><tr><td>std::array<td>99K<td>2.8<td>0.39<tr><td>c-style array<td>99K<td>0.75<td>0.39<tr><td>std::vector<td>33-40K<td>2.8<td>0.75</table></div><h3 id="storage-duration">Storage duration</h3><p>If the variable is declared as global or <code class="language-plaintext highlighter-rouge">static</code>, it will have a static storage duration and it’ll be part of the binary. Depending on whether it’s <code class="language-plaintext highlighter-rouge">const</code> or not, initialized or not, it might go into different parts of the TEXT or DATA segment.</p><p>If you declare the <code class="language-plaintext highlighter-rouge">std::array</code> as a local variable, it’ll be created on the go. Even if it’s <code class="language-plaintext highlighter-rouge">const</code>. <code class="language-plaintext highlighter-rouge">constexpr</code> locals might be initialized at compile-time and therefore be part of the binary.</p><p>Let’s see some numbers.</p><div class="table-wrapper"><table><thead><tr><th>Container<th>Binary size<th>Compile-time<th>Run-time<tbody><tr><td>global<td>99K<td>2.2<td>0.25<tr><td>local<td>33K<td>2.2<td>0.87<tr><td>local static<td>16-99K<td>2.2<td>0.89<tr><td>local static const<td>16-82K<td>2.2<td>0.84<tr><td>local constexpr<td>16-99K<td>2.8<td>0.93</table></div><h2 id="the-initialization">The initialization</h2><p>I found this a particularly interesting point. We saw that depending on the storage duration and the container type we can have executables with completely different sizes and characteristics. But there is one more thing you can do with this simple piece of code in order shrink the size of the executable.</p><p>You can change how it’s initialized. Both members are initialized to non-default values. On the other hand, if you choose to default initialize them, the size will shrink.</p><p>To see what is behind, we should rather check the assembly code that we can get with the <code class="language-plaintext highlighter-rouge">-S</code> flag, e.g., with the command <code class="language-plaintext highlighter-rouge">clang++ -std=c++20 -stdlib=libc++ -S array-global-arbitrary.cpp</code>. When we initialize members with an arbitrary value (such as <code class="language-plaintext highlighter-rouge">1</code> in the above example), we will see this pattern in our assembly code in a great length:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre>    .section    __DATA,__data
    .globl  _a                              ; @a
    .p2align    2
_a:
    .long   1                               ; 0x1
    .long   1                               ; 0x1
    .long   1                               ; 0x1
    // ...
    .long   1                               ; 0x1
</pre></table></code></div></div><p>However, when we initialize our member <code class="language-plaintext highlighter-rouge">int</code>s with a default value, we’ll only see one line:</p><pre><code class="language-asm">.zerofill __DATA,__common,_segtree,3`200`000,2
</code></pre><p>This explains why the binary bloats in the function of the size of the array that we have to initialize. But when we zero-initialize the values, it doesn’t matter anymore.</p><p>What was also interesting to see is that if I add another member, such as a <code class="language-plaintext highlighter-rouge">std::string</code>, this doesn’t matter anymore, the size stays small(er) no matter how I initialize variables. I think the reason behind this is that <code class="language-plaintext highlighter-rouge">std::string</code>s involves dynamic memory allocations, so we cannot completely initialize our array at compile-time anymore. Looking at the assembly code we observe that lots of code is now in the TEXT segment.</p><p>On the other hand, if we add a third member that is of another type that doesn’t require dynamic allocations, such as a <code class="language-plaintext highlighter-rouge">float</code> or a new class, such as <code class="language-plaintext highlighter-rouge">struct NoDynamic {int c=0; int d=0;};</code>, we can still observe the same difference. We end up with a very small assembly and binary with a nice <code class="language-plaintext highlighter-rouge">.zerofill</code> command.</p><p>Essentially, this is the same observation we made for containers. Wherever there is dynamic memory allocation, there is no initialization at compile-time, so our binary remains relatively small.</p><h2 id="conclusion">Conclusion</h2><p>Today we saw different factors that influence how much space an object takes up in our binary.</p><p>It depends on how we store it, them. If we allocate on the heap (either directly or through a container such as a vector), it doesn’t change our binary size a lot. But if we allocate through c-style or a <code class="language-plaintext highlighter-rouge">std::array</code> involving no dynamic allocations, the size will grow as the number of objects allocated grows.</p><p>But it’s not as simple as that, it also depends on the storage duration of the variable. Only variables with static storage duration will be initialized at compile time.</p><p>Last but not least, it also depends on the class itself, what kind of members it has. If initializing an instance of a type requires dynamic memory allocation, it cannot be done at compile time.</p><p>But as we also saw, as the size changes, compilation- and run-times might also change but so far we haven’t seen strong correlations.</p><p>Next time, we’ll still deal with very basic features of C++, we’ll have a look at special functions of a class.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/executables/" class="post-tag no-text-decoration" >executables</a> <a href="/tags/compilation/" class="post-tag no-text-decoration" >compilation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Object initialization and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Object initialization and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Object initialization and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Object initialization and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/01/11/executable-and-its-structure"><div class="card-body"> <span class="timeago small" > Jan 11, 2023 <i class="unloaded">2023-01-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What's an executable and how is it structured</h3><div class="text-muted small"><p> In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured. How executables are generated? In this section let’s ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/01/special-functions-and-binary-sizes"><div class="card-body"> <span class="timeago small" > Feb 1, 2023 <i class="unloaded">2023-02-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Special functions and binary sizes</h3><div class="text-muted small"><p> These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/08/binary-sizes-and-virtual"><div class="card-body"> <span class="timeago small" > Feb 8, 2023 <i class="unloaded">2023-02-08T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtual functions and binary sizes</h3><div class="text-muted small"><p> In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary. Our conclusion was that...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/01/11/executable-and-its-structure" class="btn btn-outline-primary" prompt="Older"><p>What's an executable and how is it structured</p></a> <a href="/blog/2023/01/25/deep-vs-shallow-modules" class="btn btn-outline-primary" prompt="Newer"><p>Deep vs shallow modules</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Object initialization and binary sizes'; this.page.url = 'https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes'; this.page.identifier = '/blog/2023/01/18/object-initialization-and-binary-sizes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
