<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="What’s an executable and how is it structured" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured. How executables are generated? In this section let’s briefly talk about how the C++ code will be transformed into an executable program. Let’s have a look at the below diagram. First, the preprocessor will go through your files and will expand all the preprocessor macros. This mostly means textual copies. #include statements will be replaced by the included files, and macros will be replaced according to the macro definitions. But of course, there are also the #if et al. preprocessor directives which might result in actually removing code. At the end of this step, there is a temporary file that is passed to the compiler. Based on its platform, the compiler generates the corresponding assembly code. The next step is for the assembler. It takes the assembler code and generates the object code according to the platform. At this point, we almost have an executable, but the references to external code and data must be taken care of. That’s the role of the linker, it will resolve all the links to other headers and libraries. And at the end, you get an executable file. An overview of the different executable formats So at the end of the compilation and linking process, we get an executable file. An executable, or binary file might be of different types, of different formats depending on your operating system and compiler settings. Let’s have a look at a few of them. a.out You still find in many beginner C or C++ examples the notion of a.out for an executable. They mostly refer to a file name, but in reality, it is also an executable format. It stands for assembler output and it was developed in the 70s. It became a standard format for executables but it’s not widely used anymore, though it’s still supported on some Unix-like platforms. As it’s simple, let’s have a very brief look at it. It consists of: a header describing the size of the file and the location of the different sections and the symbol table. the executable code, a.k.a. the text segment the data segment It had to be replaced as it only had limited support for shared libraries as well as for position-independent code. Partly because of these limitations and its structure, it doesn’t support large programs well. Common Object File Format A replacement for a.out was COFF (Common Object File Format). While it was originally developed for Unix-like operating systems, some versions of Windows also used it. In its format, it’s similar to other formats, that we are going to discuss. It has a header, a table of contents, text and data segments. Unlike a.out, COFF supports large programs and debug information, but by today it’s been replaced by other formats, such as ELF, PE and Mach-O. Executable and Linkable Format ELF (Executable and Linkable Format) is mostly used on Linux, PE (Portable Executable) on Windows and Mach-O on Apple systems. Their structures are quite similar overall, but the implementation, and how the executable is organized is different. They support a different set of features depending on their target systems, and architectures. ELF is supported on Linux, Solaris and many other Unix-like systems so it’s a convenient choice for cross-platform projects. ELF supports shared libraries, and position-independent code, so it’s well suited to use in dynamic environments when you have to run multiple instances of a program at the same time. It also supports debug information. ELF is designed both for performance and extensibility. It can be loaded quickly and it runs fast. Its extensible design makes it possible to add new features with relative ease so it can adapt and evolve following the new requirements over time. Portable Executable format Portable Executable format was developed for Windows systems. It was designed to be compact so that it’s efficient to store it on disk and transmit over a network. It’s also efficient to load the PE format into memory. Just like ELF it has also an extensible design and supports positivon independent code. Mach Object Mach Object or Mach-O in short, is a format used mainly by macOS and iOS. Just like PE, Mach-O is also designed to be compact and to be loaded quickly. In fact, these modern formats are quite similar in features, Mach-O is also easily extensible and it supports positional independent code. The Mach-O format expanded As I’m developing on a Mac these days, I decided to have a deeper look at the Mach-O file format. It consists of the following most important parts: Header: it describes the file including the number of load commands and the size of each. Load commands: they contain information about how to load the file into memory; the locations of code and data and the dependencies on other libraries. We can differentiate among different load commands, depending on whether they describe the entry point of the program or the symbols or locations of shared libraries. Segments: one can contain either code or data that are loaded into the memory. A segment always has a name and it can be either read-only, read-write or execute-only. Symbols: a symbol is essentially a name that can identify a piece of code or data. These can be either local or global symbols, Relocations: they specify how addresses of symbols should be adjusted once the file is loaded into memory. These are the pieces that let a program be loaded at any memory address without conflicting with another program running at the same time. Strings: these are typically stored in a separate section of the file and are references by their offsets within the section. They represent names, messages and other text parts within the file. You might ask what’s the difference between symbols and strings. One key difference between symbols and strings is that symbols are used to represent the names of entities within a program, while strings are used to represent arbitrary sequences of characters. Symbols are typically used to reference specific entities within the program, while strings are simply data that is stored in the file and can be accessed by the program. Another difference is that symbols are typically used to represent the names of code and data entities within the program, while strings are used to represent arbitrary text that may be displayed or used by the program in some other way. More on the TEXT segment Now let’s see what are the different sections in a Mach-O file’s TEXT segment. This is going to be important in order to understand what kind of code ends up where. The first segment is the so-called __PAGEZERO. Any access to this nulled page results in a crash. The following segment is the __TEXT. It’s a read-only segment that contains both executable code and constant data. Each program must have at least one of these segments and usually, this is the biggest one. But just like a molecule is composed of atoms, a segment is composed of sections. Let’s see what are the sections of the __TEXT segment. The __text section (mind the case!), contains the actual machine code of the program and usually, this section is the biggest of the biggest segment. The __stub and __stub_helper sections contain the pieces of code that are used for calling and referring to external functions and symbols. The __const section contains all the constant data used by the program. Let’s remind us again that the __TEXT segment is read-only and also that casting away the constness of a piece of data is undefined behaviour. The __cstring section contains all the C-style, null-terminated strings. It should contain no duplicates! The __picsymbol_stub section contains position-independent symbol stubs, allowing the dynamic linker to load the region of code at non-fixed virtual memory addresses. The DATA segment Unlike the TEXT segment which contains only read-only data, the DATA segment is a read/write segment. While the read-only text segment can be shared between different processes running the same program, the data segment must be copied by each process as it’s writeable. Among the most important sections you will find the __data, __const, __bss and __common sections. The __data section contains all the initialized variables with static storage duration. In the __bss section, you can find also the variables with static storage duration, but only the uninitialized ones. The __common section contains also the uninitialized globals, but only the external ones. The __const section contains constant data that needs a relocation such as char * const p = &quot;foo&quot;;. Conclusion Today we had a brief look at the evolution of executable formats, and a deeper look at the Mach-O format that is mostly used on macOS and iOS. Still, what we saw is mostly applicable to other formats too as modern formats are not that much different in their basic attributes. The most important characteristic we saw is that the TEXT segment is read-only and the data segment is read/write. The latter cannot be shared between processes so if you have multiple processes running the same program it’s worth writing code that tries to minimize the usage of the data segment. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured. How executables are generated? In this section let’s briefly talk about how the C++ code will be transformed into an executable program. Let’s have a look at the below diagram. First, the preprocessor will go through your files and will expand all the preprocessor macros. This mostly means textual copies. #include statements will be replaced by the included files, and macros will be replaced according to the macro definitions. But of course, there are also the #if et al. preprocessor directives which might result in actually removing code. At the end of this step, there is a temporary file that is passed to the compiler. Based on its platform, the compiler generates the corresponding assembly code. The next step is for the assembler. It takes the assembler code and generates the object code according to the platform. At this point, we almost have an executable, but the references to external code and data must be taken care of. That’s the role of the linker, it will resolve all the links to other headers and libraries. And at the end, you get an executable file. An overview of the different executable formats So at the end of the compilation and linking process, we get an executable file. An executable, or binary file might be of different types, of different formats depending on your operating system and compiler settings. Let’s have a look at a few of them. a.out You still find in many beginner C or C++ examples the notion of a.out for an executable. They mostly refer to a file name, but in reality, it is also an executable format. It stands for assembler output and it was developed in the 70s. It became a standard format for executables but it’s not widely used anymore, though it’s still supported on some Unix-like platforms. As it’s simple, let’s have a very brief look at it. It consists of: a header describing the size of the file and the location of the different sections and the symbol table. the executable code, a.k.a. the text segment the data segment It had to be replaced as it only had limited support for shared libraries as well as for position-independent code. Partly because of these limitations and its structure, it doesn’t support large programs well. Common Object File Format A replacement for a.out was COFF (Common Object File Format). While it was originally developed for Unix-like operating systems, some versions of Windows also used it. In its format, it’s similar to other formats, that we are going to discuss. It has a header, a table of contents, text and data segments. Unlike a.out, COFF supports large programs and debug information, but by today it’s been replaced by other formats, such as ELF, PE and Mach-O. Executable and Linkable Format ELF (Executable and Linkable Format) is mostly used on Linux, PE (Portable Executable) on Windows and Mach-O on Apple systems. Their structures are quite similar overall, but the implementation, and how the executable is organized is different. They support a different set of features depending on their target systems, and architectures. ELF is supported on Linux, Solaris and many other Unix-like systems so it’s a convenient choice for cross-platform projects. ELF supports shared libraries, and position-independent code, so it’s well suited to use in dynamic environments when you have to run multiple instances of a program at the same time. It also supports debug information. ELF is designed both for performance and extensibility. It can be loaded quickly and it runs fast. Its extensible design makes it possible to add new features with relative ease so it can adapt and evolve following the new requirements over time. Portable Executable format Portable Executable format was developed for Windows systems. It was designed to be compact so that it’s efficient to store it on disk and transmit over a network. It’s also efficient to load the PE format into memory. Just like ELF it has also an extensible design and supports positivon independent code. Mach Object Mach Object or Mach-O in short, is a format used mainly by macOS and iOS. Just like PE, Mach-O is also designed to be compact and to be loaded quickly. In fact, these modern formats are quite similar in features, Mach-O is also easily extensible and it supports positional independent code. The Mach-O format expanded As I’m developing on a Mac these days, I decided to have a deeper look at the Mach-O file format. It consists of the following most important parts: Header: it describes the file including the number of load commands and the size of each. Load commands: they contain information about how to load the file into memory; the locations of code and data and the dependencies on other libraries. We can differentiate among different load commands, depending on whether they describe the entry point of the program or the symbols or locations of shared libraries. Segments: one can contain either code or data that are loaded into the memory. A segment always has a name and it can be either read-only, read-write or execute-only. Symbols: a symbol is essentially a name that can identify a piece of code or data. These can be either local or global symbols, Relocations: they specify how addresses of symbols should be adjusted once the file is loaded into memory. These are the pieces that let a program be loaded at any memory address without conflicting with another program running at the same time. Strings: these are typically stored in a separate section of the file and are references by their offsets within the section. They represent names, messages and other text parts within the file. You might ask what’s the difference between symbols and strings. One key difference between symbols and strings is that symbols are used to represent the names of entities within a program, while strings are used to represent arbitrary sequences of characters. Symbols are typically used to reference specific entities within the program, while strings are simply data that is stored in the file and can be accessed by the program. Another difference is that symbols are typically used to represent the names of code and data entities within the program, while strings are used to represent arbitrary text that may be displayed or used by the program in some other way. More on the TEXT segment Now let’s see what are the different sections in a Mach-O file’s TEXT segment. This is going to be important in order to understand what kind of code ends up where. The first segment is the so-called __PAGEZERO. Any access to this nulled page results in a crash. The following segment is the __TEXT. It’s a read-only segment that contains both executable code and constant data. Each program must have at least one of these segments and usually, this is the biggest one. But just like a molecule is composed of atoms, a segment is composed of sections. Let’s see what are the sections of the __TEXT segment. The __text section (mind the case!), contains the actual machine code of the program and usually, this section is the biggest of the biggest segment. The __stub and __stub_helper sections contain the pieces of code that are used for calling and referring to external functions and symbols. The __const section contains all the constant data used by the program. Let’s remind us again that the __TEXT segment is read-only and also that casting away the constness of a piece of data is undefined behaviour. The __cstring section contains all the C-style, null-terminated strings. It should contain no duplicates! The __picsymbol_stub section contains position-independent symbol stubs, allowing the dynamic linker to load the region of code at non-fixed virtual memory addresses. The DATA segment Unlike the TEXT segment which contains only read-only data, the DATA segment is a read/write segment. While the read-only text segment can be shared between different processes running the same program, the data segment must be copied by each process as it’s writeable. Among the most important sections you will find the __data, __const, __bss and __common sections. The __data section contains all the initialized variables with static storage duration. In the __bss section, you can find also the variables with static storage duration, but only the uninitialized ones. The __common section contains also the uninitialized globals, but only the external ones. The __const section contains constant data that needs a relocation such as char * const p = &quot;foo&quot;;. Conclusion Today we had a brief look at the evolution of executable formats, and a deeper look at the Mach-O format that is mostly used on macOS and iOS. Still, what we saw is mostly applicable to other formats too as modern formats are not that much different in their basic attributes. The most important characteristic we saw is that the TEXT segment is read-only and the data segment is read/write. The latter cannot be shared between processes so if you have multiple processes running the same program it’s worth writing code that tries to minimize the usage of the data segment. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-01-11T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="What’s an executable and how is it structured" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-07-19T10:09:53+02:00","datePublished":"2023-01-11T00:00:00+01:00","description":"In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured. How executables are generated? In this section let’s briefly talk about how the C++ code will be transformed into an executable program. Let’s have a look at the below diagram. First, the preprocessor will go through your files and will expand all the preprocessor macros. This mostly means textual copies. #include statements will be replaced by the included files, and macros will be replaced according to the macro definitions. But of course, there are also the #if et al. preprocessor directives which might result in actually removing code. At the end of this step, there is a temporary file that is passed to the compiler. Based on its platform, the compiler generates the corresponding assembly code. The next step is for the assembler. It takes the assembler code and generates the object code according to the platform. At this point, we almost have an executable, but the references to external code and data must be taken care of. That’s the role of the linker, it will resolve all the links to other headers and libraries. And at the end, you get an executable file. An overview of the different executable formats So at the end of the compilation and linking process, we get an executable file. An executable, or binary file might be of different types, of different formats depending on your operating system and compiler settings. Let’s have a look at a few of them. a.out You still find in many beginner C or C++ examples the notion of a.out for an executable. They mostly refer to a file name, but in reality, it is also an executable format. It stands for assembler output and it was developed in the 70s. It became a standard format for executables but it’s not widely used anymore, though it’s still supported on some Unix-like platforms. As it’s simple, let’s have a very brief look at it. It consists of: a header describing the size of the file and the location of the different sections and the symbol table. the executable code, a.k.a. the text segment the data segment It had to be replaced as it only had limited support for shared libraries as well as for position-independent code. Partly because of these limitations and its structure, it doesn’t support large programs well. Common Object File Format A replacement for a.out was COFF (Common Object File Format). While it was originally developed for Unix-like operating systems, some versions of Windows also used it. In its format, it’s similar to other formats, that we are going to discuss. It has a header, a table of contents, text and data segments. Unlike a.out, COFF supports large programs and debug information, but by today it’s been replaced by other formats, such as ELF, PE and Mach-O. Executable and Linkable Format ELF (Executable and Linkable Format) is mostly used on Linux, PE (Portable Executable) on Windows and Mach-O on Apple systems. Their structures are quite similar overall, but the implementation, and how the executable is organized is different. They support a different set of features depending on their target systems, and architectures. ELF is supported on Linux, Solaris and many other Unix-like systems so it’s a convenient choice for cross-platform projects. ELF supports shared libraries, and position-independent code, so it’s well suited to use in dynamic environments when you have to run multiple instances of a program at the same time. It also supports debug information. ELF is designed both for performance and extensibility. It can be loaded quickly and it runs fast. Its extensible design makes it possible to add new features with relative ease so it can adapt and evolve following the new requirements over time. Portable Executable format Portable Executable format was developed for Windows systems. It was designed to be compact so that it’s efficient to store it on disk and transmit over a network. It’s also efficient to load the PE format into memory. Just like ELF it has also an extensible design and supports positivon independent code. Mach Object Mach Object or Mach-O in short, is a format used mainly by macOS and iOS. Just like PE, Mach-O is also designed to be compact and to be loaded quickly. In fact, these modern formats are quite similar in features, Mach-O is also easily extensible and it supports positional independent code. The Mach-O format expanded As I’m developing on a Mac these days, I decided to have a deeper look at the Mach-O file format. It consists of the following most important parts: Header: it describes the file including the number of load commands and the size of each. Load commands: they contain information about how to load the file into memory; the locations of code and data and the dependencies on other libraries. We can differentiate among different load commands, depending on whether they describe the entry point of the program or the symbols or locations of shared libraries. Segments: one can contain either code or data that are loaded into the memory. A segment always has a name and it can be either read-only, read-write or execute-only. Symbols: a symbol is essentially a name that can identify a piece of code or data. These can be either local or global symbols, Relocations: they specify how addresses of symbols should be adjusted once the file is loaded into memory. These are the pieces that let a program be loaded at any memory address without conflicting with another program running at the same time. Strings: these are typically stored in a separate section of the file and are references by their offsets within the section. They represent names, messages and other text parts within the file. You might ask what’s the difference between symbols and strings. One key difference between symbols and strings is that symbols are used to represent the names of entities within a program, while strings are used to represent arbitrary sequences of characters. Symbols are typically used to reference specific entities within the program, while strings are simply data that is stored in the file and can be accessed by the program. Another difference is that symbols are typically used to represent the names of code and data entities within the program, while strings are used to represent arbitrary text that may be displayed or used by the program in some other way. More on the TEXT segment Now let’s see what are the different sections in a Mach-O file’s TEXT segment. This is going to be important in order to understand what kind of code ends up where. The first segment is the so-called __PAGEZERO. Any access to this nulled page results in a crash. The following segment is the __TEXT. It’s a read-only segment that contains both executable code and constant data. Each program must have at least one of these segments and usually, this is the biggest one. But just like a molecule is composed of atoms, a segment is composed of sections. Let’s see what are the sections of the __TEXT segment. The __text section (mind the case!), contains the actual machine code of the program and usually, this section is the biggest of the biggest segment. The __stub and __stub_helper sections contain the pieces of code that are used for calling and referring to external functions and symbols. The __const section contains all the constant data used by the program. Let’s remind us again that the __TEXT segment is read-only and also that casting away the constness of a piece of data is undefined behaviour. The __cstring section contains all the C-style, null-terminated strings. It should contain no duplicates! The __picsymbol_stub section contains position-independent symbol stubs, allowing the dynamic linker to load the region of code at non-fixed virtual memory addresses. The DATA segment Unlike the TEXT segment which contains only read-only data, the DATA segment is a read/write segment. While the read-only text segment can be shared between different processes running the same program, the data segment must be copied by each process as it’s writeable. Among the most important sections you will find the __data, __const, __bss and __common sections. The __data section contains all the initialized variables with static storage duration. In the __bss section, you can find also the variables with static storage duration, but only the uninitialized ones. The __common section contains also the uninitialized globals, but only the external ones. The __const section contains constant data that needs a relocation such as char * const p = &quot;foo&quot;;. Conclusion Today we had a brief look at the evolution of executable formats, and a deeper look at the Mach-O format that is mostly used on macOS and iOS. Still, what we saw is mostly applicable to other formats too as modern formats are not that much different in their basic attributes. The most important characteristic we saw is that the TEXT segment is read-only and the data segment is read/write. The latter cannot be shared between processes so if you have multiple processes running the same program it’s worth writing code that tries to minimize the usage of the data segment. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"What’s an executable and how is it structured","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure"},"url":"https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure"}</script><title>What's an executable and how is it structured | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/01"> 01 </a> </span> <span> <a href="/11"> 11 </a> </span> <span>What's an executable and how is it structured</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>What's an executable and how is it structured</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Jan 11, 2023, 12:00 AM +0100" prep="on" > Jan 11, 2023 <i class="unloaded">2023-01-11T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 19, 2023, 10:09 AM +0200" prefix="Updated " > Jul 19, 2023 <i class="unloaded">2023-07-19T10:09:53+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1559 words">8 min</span></div></div><div class="post-content"><p>In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured.</p><h2 id="how-executables-are-generated">How executables are generated?</h2><p>In this section let’s briefly talk about how the C++ code will be transformed into an executable program.</p><p>Let’s have a look at the below diagram.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/compilation_white_bg.drawio.png" alt="The compilation process" /></p><p>First, the preprocessor will go through your files and will expand all the preprocessor macros. This mostly means textual copies. <code class="language-plaintext highlighter-rouge">#include</code> statements will be replaced by the included files, and macros will be replaced according to the macro definitions. But of course, there are also the <a href="https://www.sandordargo.com/blog/2022/09/07/prepocessive-directive-changes-in-cpp23"><code class="language-plaintext highlighter-rouge">#if</code> et al. preprocessor directives</a> which might result in actually removing code.</p><p>At the end of this step, there is a temporary file that is passed to the compiler. Based on its platform, the compiler generates the corresponding assembly code.</p><p>The next step is for the assembler. It takes the assembler code and generates the object code according to the platform. At this point, we almost have an executable, but the references to external code and data must be taken care of. That’s the role of the linker, it will resolve all the links to other headers and libraries. And at the end, you get an executable file.</p><h2 id="an-overview-of-the-different-executable-formats">An overview of the different executable formats</h2><p>So at the end of the compilation and linking process, we get an executable file. An executable, or binary file might be of different types, of different formats depending on your operating system and compiler settings. Let’s have a look at a few of them.</p><h3 id="aout">a.out</h3><p>You still find in many beginner C or C++ examples the notion of <code class="language-plaintext highlighter-rouge">a.out</code> for an executable. They mostly refer to a file name, but in reality, it is also an executable format. It stands for assembler output and it was developed in the 70s. It became a standard format for executables but it’s not widely used anymore, though it’s still supported on some Unix-like platforms.</p><p>As it’s simple, let’s have a very brief look at it. It consists of:</p><ul><li>a header describing the size of the file and the location of the different sections and the symbol table.<li>the executable code, a.k.a. the text segment<li>the data segment</ul><p>It had to be replaced as it only had limited support for shared libraries as well as for position-independent code. Partly because of these limitations and its structure, it doesn’t support large programs well.</p><h3 id="common-object-file-format">Common Object File Format</h3><p>A replacement for <code class="language-plaintext highlighter-rouge">a.out</code> was <em>COFF</em> (Common Object File Format). While it was originally developed for Unix-like operating systems, some versions of Windows also used it. In its format, it’s similar to other formats, that we are going to discuss. It has a header, a table of contents, text and data segments.</p><p>Unlike <code class="language-plaintext highlighter-rouge">a.out</code>, <em>COFF</em> supports large programs and debug information, but by today it’s been replaced by other formats, such as <em>ELF</em>, <em>PE</em> and <em>Mach-O</em>.</p><h3 id="executable-and-linkable-format">Executable and Linkable Format</h3><p><em>ELF</em> (Executable and Linkable Format) is mostly used on Linux, <em>PE</em> (Portable Executable) on Windows and <em>Mach-O</em> on Apple systems. Their structures are quite similar overall, but the implementation, and how the executable is organized is different. They support a different set of features depending on their target systems, and architectures.</p><p><em>ELF</em> is supported on Linux, Solaris and many other Unix-like systems so it’s a convenient choice for cross-platform projects. <em>ELF</em> supports shared libraries, and position-independent code, so it’s well suited to use in dynamic environments when you have to run multiple instances of a program at the same time. It also supports debug information. <em>ELF</em> is designed both for performance and extensibility. It can be loaded quickly and it runs fast. Its extensible design makes it possible to add new features with relative ease so it can adapt and evolve following the new requirements over time.</p><h3 id="portable-executable-format">Portable Executable format</h3><p><em>Portable Executable</em> format was developed for Windows systems. It was designed to be compact so that it’s efficient to store it on disk and transmit over a network. It’s also efficient to load the <em>PE</em> format into memory. Just like <em>ELF</em> it has also an extensible design and supports positivon independent code.</p><h3 id="mach-object">Mach Object</h3><p><em>Mach Object</em> or <em>Mach-O</em> in short, is a format used mainly by macOS and iOS. Just like <em>PE</em>, <em>Mach-O</em> is also designed to be compact and to be loaded quickly. In fact, these modern formats are quite similar in features, <em>Mach-O</em> is also easily extensible and it supports positional independent code.</p><h2 id="the-mach-o-format-expanded">The Mach-O format expanded</h2><p>As I’m developing on a Mac these days, I decided to have a deeper look at the <em>Mach-O</em> file format. It consists of the following most important parts:</p><ul><li>Header: it describes the file including the number of load commands and the size of each.<li>Load commands: they contain information about how to load the file into memory; the locations of code and data and the dependencies on other libraries. We can differentiate among different load commands, depending on whether they describe the entry point of the program or the symbols or locations of shared libraries.<li>Segments: one can contain either code or data that are loaded into the memory. A segment always has a name and it can be either read-only, read-write or execute-only.<li>Symbols: a symbol is essentially a name that can identify a piece of code or data. These can be either local or global symbols,<li>Relocations: they specify how addresses of symbols should be adjusted once the file is loaded into memory. These are the pieces that let a program be loaded at any memory address without conflicting with another program running at the same time.<li>Strings: these are typically stored in a separate section of the file and are references by their offsets within the section. They represent names, messages and other text parts within the file.</ul><p>You might ask what’s the difference between symbols and strings. One key difference between symbols and strings is that symbols are used to represent the names of entities within a program, while strings are used to represent arbitrary sequences of characters. Symbols are typically used to reference specific entities within the program, while strings are simply data that is stored in the file and can be accessed by the program.</p><p>Another difference is that symbols are typically used to represent the names of code and data entities within the program, while strings are used to represent arbitrary text that may be displayed or used by the program in some other way.</p><h2 id="more-on-the-text-segment">More on the TEXT segment</h2><p>Now let’s see what are the different sections in a <em>Mach-O</em> file’s TEXT segment. This is going to be important in order to understand what kind of code ends up where.</p><p>The first segment is the so-called <code class="language-plaintext highlighter-rouge">__PAGEZERO</code>. Any access to this nulled page results in a crash.</p><p>The following segment is the <code class="language-plaintext highlighter-rouge">__TEXT</code>. It’s a read-only segment that contains both executable code and constant data. Each program must have at least one of these segments and usually, this is the biggest one.</p><p>But just like a molecule is composed of atoms, a segment is composed of sections. Let’s see what are the sections of the <code class="language-plaintext highlighter-rouge">__TEXT</code> segment.</p><p>The <code class="language-plaintext highlighter-rouge">__text</code> section (mind the case!), contains the actual machine code of the program and usually, this section is the biggest of the biggest segment.</p><p>The <code class="language-plaintext highlighter-rouge">__stub</code> and <code class="language-plaintext highlighter-rouge">__stub_helper</code> sections contain the pieces of code that are used for calling and referring to external functions and symbols.</p><p>The <code class="language-plaintext highlighter-rouge">__const</code> section contains all the constant data used by the program. Let’s remind us again that the <code class="language-plaintext highlighter-rouge">__TEXT</code> segment is read-only and also that <a href="https://www.sandordargo.com/blog/2020/11/11/when-use-const-2-member-variables">casting away the constness of a piece of data is undefined behaviour</a>.</p><p>The <code class="language-plaintext highlighter-rouge">__cstring</code> section contains all the C-style, null-terminated strings. It should contain no duplicates!</p><p>The <code class="language-plaintext highlighter-rouge">__picsymbol_stub</code> section contains position-independent symbol stubs, allowing the dynamic linker to load the region of code at non-fixed virtual memory addresses.</p><h2 id="the-data-segment">The DATA segment</h2><p>Unlike the TEXT segment which contains only read-only data, the DATA segment is a read/write segment. While the read-only text segment can be shared between different processes running the same program, the data segment must be copied by each process as it’s writeable.</p><p>Among the most important sections you will find the <code class="language-plaintext highlighter-rouge">__data</code>, <code class="language-plaintext highlighter-rouge">__const</code>, <code class="language-plaintext highlighter-rouge">__bss</code> and <code class="language-plaintext highlighter-rouge">__common</code> sections.</p><p>The <code class="language-plaintext highlighter-rouge">__data</code> section contains all the initialized variables with static storage duration. In the <code class="language-plaintext highlighter-rouge">__bss</code> section, you can find also the variables with static storage duration, but only the uninitialized ones. The <code class="language-plaintext highlighter-rouge">__common</code> section contains also the uninitialized globals, but only the external ones.</p><p>The <code class="language-plaintext highlighter-rouge">__const</code> section contains constant data that needs a relocation such as <code class="language-plaintext highlighter-rouge">char * const p = "foo";</code>.</p><h2 id="conclusion">Conclusion</h2><p>Today we had a brief look at the evolution of executable formats, and a deeper look at the Mach-O format that is mostly used on macOS and iOS. Still, what we saw is mostly applicable to other formats too as modern formats are not that much different in their basic attributes. The most important characteristic we saw is that the TEXT segment is read-only and the data segment is read/write. The latter cannot be shared between processes so if you have multiple processes running the same program it’s worth writing code that tries to minimize the usage of the data segment.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/executables/" class="post-tag no-text-decoration" >executables</a> <a href="/tags/compilation/" class="post-tag no-text-decoration" >compilation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=What's an executable and how is it structured - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=What's an executable and how is it structured - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=What's an executable and how is it structured - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=What's an executable and how is it structured - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/01/18/object-initialization-and-binary-sizes"><div class="card-body"> <span class="timeago small" > Jan 18, 2023 <i class="unloaded">2023-01-18T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Object initialization and binary sizes</h3><div class="text-muted small"><p> Let’s have this piece of code that generates a big binary. 1 2 3 4 5 6 7 8 9 #include &lt;array&gt; struct Node { int a = 1, b = 1; }; std::array &lt;Node, 10'000&gt; a; int main() {} If ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/01/special-functions-and-binary-sizes"><div class="card-body"> <span class="timeago small" > Feb 1, 2023 <i class="unloaded">2023-02-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Special functions and binary sizes</h3><div class="text-muted small"><p> These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/08/binary-sizes-and-virtual"><div class="card-body"> <span class="timeago small" > Feb 8, 2023 <i class="unloaded">2023-02-08T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtual functions and binary sizes</h3><div class="text-muted small"><p> In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary. Our conclusion was that...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/01/04/runtime-compiletime-binarysize" class="btn btn-outline-primary" prompt="Older"><p>The run-time, compile-time, binary size triangle</p></a> <a href="/blog/2023/01/18/object-initialization-and-binary-sizes" class="btn btn-outline-primary" prompt="Newer"><p>Object initialization and binary sizes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'What's an executable and how is it structured'; this.page.url = 'https://www.sandordargo.com/blog/2023/01/11/executable-and-its-structure'; this.page.identifier = '/blog/2023/01/11/executable-and-its-structure'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
