<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: some changes related to templates" /><meta property="og:locale" content="en_US" /><meta name="description" content="I know the above title is a bit vague. As we move forward with the introduction of C++23 features, there are going to be some articles like that. At the same time, there are more than two features that are related to templates in C++23. But some of them were already presented, such as if consteval or the explicit object parameter (a.k.a. deducing this). Today, we are going talk about something related to and needed by deducing this, and the other topic is going to be class template argument deduction (CTAD). CTAD for inherited constructors P2582R1 is about class template argument deduction (CTAD) from inherited constructors. If you check the paper and you don’t speak standardese well (and I don’t), it’ll be difficult to understand what it is about as it only contains the proposed wording. Luckily, it refers to another document (P1021R6), that contains the rationale behind this and many other changes. From P1021R6, we can learn that CTAD that was introduced in C++17 had and still has some limitations in its usability. Some were already fixed in C++20, but obviously, the inherited constructors use case. Let’s take the example from the paper to demonstrate this shortcoming. Let’s assume that we have these two classes (we talked about C++17 so far, but we are potentially using C++20 here if we uncomment the requires clause): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;memory&gt; #include &lt;concepts&gt; #include &lt;iostream&gt; template &lt;typename T&gt; /* requires std::invocable&lt;T&gt; */ struct CallObserver { CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {} virtual void observeCall() { t(); } T t; }; template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { using CallObserver&lt;T&gt;::CallObserver; virtual void observeCall() override { std::cout &lt;&lt; &quot;calling&quot;; CallObserver&lt;T&gt;::t(); } }; int main() { CallObserver observer([]() { /* ... */ }); // OK CallLogger logger([]() { /* ... */ }); } In C++17 you can use CallObserver without passing any type as a template parameter and CTAD will just work fine. 1 CallObserver observer([]() { /* ... */ }); // OK CallLoger inherits the constructors of CallObserver, but still CallLogger logger([]() { /* ... */ }); would fail as there is no viable constructor or deduction guide available. According to P2582R1, this is going to be fixed in C++23 and CallLogger will inherit the deduction guidelines too. At the moment, no compiler has implemented it yet. Until then, we have to define an explicit deduction guideline if we want to make it work: 1 template &lt;typename T&gt; CallLogger(T) -&gt; CallLogger&lt;T&gt;; Here is the full example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;memory&gt; #include &lt;concepts&gt; #include &lt;iostream&gt; template &lt;typename T&gt; /* requires std::invocable&lt;T&gt; */ struct CallObserver { CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {} virtual void observeCall() { t(); } T t; }; template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { using CallObserver&lt;T&gt;::CallObserver; virtual void observeCall() override { std::cout &lt;&lt; &quot;calling&quot;; CallObserver&lt;T&gt;::t(); } }; /* In C++23 this will not needed anymore */ template &lt;typename T&gt; CallLogger(T) -&gt; CallLogger&lt;T&gt;; int main() { CallObserver observer([]() { /* ... */ }); // OK in C++17 CallLogger logger([]() { /* ... */ }); // OK only with the explicit deduction guideline untill C++23 } std::forward_like The implementation of Deducing this used a hypothetical std::forward_like&lt;decltype(self)&gt;(variable) facility. (It was not referenced in the aforementioned article). P2445R1 contains the necessary proposal for this utility. std::forward_like is (going to be) part of the &lt;utility&gt; header. As std::forward, it is also a type cast that only influences the value category of an expression. It forwards the value category of an object expression based on the value category of the owning object expression. If we talk about an owning object (o), member object (m) relationship, thus when o.m is valid, it would be spelt as std::forward&lt;decltype(o)&gt;(o).m up until C++20. But - for example with members of lambda closures - o.m is not always a valid expression and that’s when this new facility comes in handy. The authors considered three different models for the implementation. According to the language model, the behaviour of forward_like would have followed what std::forward&lt;decltype(Owner)&gt;(o).m does. According to the tuple, we would have got what std::get&lt;0&gt;(tuple&lt;Member&gt; Owner) does. However, the authors decided to go with a so-called merge model in which the const qualifiers of the owner and the member are merged and the value category of the Owner is adopted. There are some nice tables representing the common parts and the differences of the different approaches in the 8. section of the paper. There are 4 different use cases mentioned in the proposal for std::forward_like. The first one is a lambda that forwards its capture. Notice that it also uses deducing this, even though here we don’t talk about a recursive lambda, only the value type of the enclosing lambda is needed. 1 2 3 4 5 auto callback = [m=get_message(), &amp;scheduler](this auto &amp;&amp;self) -&gt; bool { return scheduler.submit(std::forward_like&lt;decltype(self)&gt;(m)); }; callback(); // retry(callback) std::move(callback)(); // try-or-fail(rvalue) In the second use case, a member is forwarded that is owned by the Owner, but not directly contained by it. Look at this example below to understand what it means. The value stored in m_ptr is owned by the struct Owner, but it’s not directly contained in it, because there is a unique pointer (m_ptr in fact) in between. 1 2 3 4 5 6 7 8 9 10 struct Owner { std::unique_ptr&lt;std::string&gt; m_ptr; auto getPtr(this auto&amp;&amp; self) -&gt; std::string { if (m_ptr) { return std::forward_like&lt;decltype(self)&gt;(*ptr); } return &quot;&quot;; } }; In the paper, you’ll find the third use case showing why it’s good to merge const qualifiers and also that forward_like can be useful even without deducing this. Conclusion In this article, we reviewed how class template argument deduction is extended in C++23 in order to support inherited constructors. We also learned about std::forward_like which is a feature needed by deducing this. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I know the above title is a bit vague. As we move forward with the introduction of C++23 features, there are going to be some articles like that. At the same time, there are more than two features that are related to templates in C++23. But some of them were already presented, such as if consteval or the explicit object parameter (a.k.a. deducing this). Today, we are going talk about something related to and needed by deducing this, and the other topic is going to be class template argument deduction (CTAD). CTAD for inherited constructors P2582R1 is about class template argument deduction (CTAD) from inherited constructors. If you check the paper and you don’t speak standardese well (and I don’t), it’ll be difficult to understand what it is about as it only contains the proposed wording. Luckily, it refers to another document (P1021R6), that contains the rationale behind this and many other changes. From P1021R6, we can learn that CTAD that was introduced in C++17 had and still has some limitations in its usability. Some were already fixed in C++20, but obviously, the inherited constructors use case. Let’s take the example from the paper to demonstrate this shortcoming. Let’s assume that we have these two classes (we talked about C++17 so far, but we are potentially using C++20 here if we uncomment the requires clause): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;memory&gt; #include &lt;concepts&gt; #include &lt;iostream&gt; template &lt;typename T&gt; /* requires std::invocable&lt;T&gt; */ struct CallObserver { CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {} virtual void observeCall() { t(); } T t; }; template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { using CallObserver&lt;T&gt;::CallObserver; virtual void observeCall() override { std::cout &lt;&lt; &quot;calling&quot;; CallObserver&lt;T&gt;::t(); } }; int main() { CallObserver observer([]() { /* ... */ }); // OK CallLogger logger([]() { /* ... */ }); } In C++17 you can use CallObserver without passing any type as a template parameter and CTAD will just work fine. 1 CallObserver observer([]() { /* ... */ }); // OK CallLoger inherits the constructors of CallObserver, but still CallLogger logger([]() { /* ... */ }); would fail as there is no viable constructor or deduction guide available. According to P2582R1, this is going to be fixed in C++23 and CallLogger will inherit the deduction guidelines too. At the moment, no compiler has implemented it yet. Until then, we have to define an explicit deduction guideline if we want to make it work: 1 template &lt;typename T&gt; CallLogger(T) -&gt; CallLogger&lt;T&gt;; Here is the full example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;memory&gt; #include &lt;concepts&gt; #include &lt;iostream&gt; template &lt;typename T&gt; /* requires std::invocable&lt;T&gt; */ struct CallObserver { CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {} virtual void observeCall() { t(); } T t; }; template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { using CallObserver&lt;T&gt;::CallObserver; virtual void observeCall() override { std::cout &lt;&lt; &quot;calling&quot;; CallObserver&lt;T&gt;::t(); } }; /* In C++23 this will not needed anymore */ template &lt;typename T&gt; CallLogger(T) -&gt; CallLogger&lt;T&gt;; int main() { CallObserver observer([]() { /* ... */ }); // OK in C++17 CallLogger logger([]() { /* ... */ }); // OK only with the explicit deduction guideline untill C++23 } std::forward_like The implementation of Deducing this used a hypothetical std::forward_like&lt;decltype(self)&gt;(variable) facility. (It was not referenced in the aforementioned article). P2445R1 contains the necessary proposal for this utility. std::forward_like is (going to be) part of the &lt;utility&gt; header. As std::forward, it is also a type cast that only influences the value category of an expression. It forwards the value category of an object expression based on the value category of the owning object expression. If we talk about an owning object (o), member object (m) relationship, thus when o.m is valid, it would be spelt as std::forward&lt;decltype(o)&gt;(o).m up until C++20. But - for example with members of lambda closures - o.m is not always a valid expression and that’s when this new facility comes in handy. The authors considered three different models for the implementation. According to the language model, the behaviour of forward_like would have followed what std::forward&lt;decltype(Owner)&gt;(o).m does. According to the tuple, we would have got what std::get&lt;0&gt;(tuple&lt;Member&gt; Owner) does. However, the authors decided to go with a so-called merge model in which the const qualifiers of the owner and the member are merged and the value category of the Owner is adopted. There are some nice tables representing the common parts and the differences of the different approaches in the 8. section of the paper. There are 4 different use cases mentioned in the proposal for std::forward_like. The first one is a lambda that forwards its capture. Notice that it also uses deducing this, even though here we don’t talk about a recursive lambda, only the value type of the enclosing lambda is needed. 1 2 3 4 5 auto callback = [m=get_message(), &amp;scheduler](this auto &amp;&amp;self) -&gt; bool { return scheduler.submit(std::forward_like&lt;decltype(self)&gt;(m)); }; callback(); // retry(callback) std::move(callback)(); // try-or-fail(rvalue) In the second use case, a member is forwarded that is owned by the Owner, but not directly contained by it. Look at this example below to understand what it means. The value stored in m_ptr is owned by the struct Owner, but it’s not directly contained in it, because there is a unique pointer (m_ptr in fact) in between. 1 2 3 4 5 6 7 8 9 10 struct Owner { std::unique_ptr&lt;std::string&gt; m_ptr; auto getPtr(this auto&amp;&amp; self) -&gt; std::string { if (m_ptr) { return std::forward_like&lt;decltype(self)&gt;(*ptr); } return &quot;&quot;; } }; In the paper, you’ll find the third use case showing why it’s good to merge const qualifiers and also that forward_like can be useful even without deducing this. Conclusion In this article, we reviewed how class template argument deduction is extended in C++23 in order to support inherited constructors. We also learned about std::forward_like which is a feature needed by deducing this. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/09/06/cpp23-templates" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/09/06/cpp23-templates" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-09-06T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: some changes related to templates" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-09-06T00:00:00+02:00","datePublished":"2023-09-06T00:00:00+02:00","description":"I know the above title is a bit vague. As we move forward with the introduction of C++23 features, there are going to be some articles like that. At the same time, there are more than two features that are related to templates in C++23. But some of them were already presented, such as if consteval or the explicit object parameter (a.k.a. deducing this). Today, we are going talk about something related to and needed by deducing this, and the other topic is going to be class template argument deduction (CTAD). CTAD for inherited constructors P2582R1 is about class template argument deduction (CTAD) from inherited constructors. If you check the paper and you don’t speak standardese well (and I don’t), it’ll be difficult to understand what it is about as it only contains the proposed wording. Luckily, it refers to another document (P1021R6), that contains the rationale behind this and many other changes. From P1021R6, we can learn that CTAD that was introduced in C++17 had and still has some limitations in its usability. Some were already fixed in C++20, but obviously, the inherited constructors use case. Let’s take the example from the paper to demonstrate this shortcoming. Let’s assume that we have these two classes (we talked about C++17 so far, but we are potentially using C++20 here if we uncomment the requires clause): 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 #include &lt;memory&gt; #include &lt;concepts&gt; #include &lt;iostream&gt; template &lt;typename T&gt; /* requires std::invocable&lt;T&gt; */ struct CallObserver { CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {} virtual void observeCall() { t(); } T t; }; template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { using CallObserver&lt;T&gt;::CallObserver; virtual void observeCall() override { std::cout &lt;&lt; &quot;calling&quot;; CallObserver&lt;T&gt;::t(); } }; int main() { CallObserver observer([]() { /* ... */ }); // OK CallLogger logger([]() { /* ... */ }); } In C++17 you can use CallObserver without passing any type as a template parameter and CTAD will just work fine. 1 CallObserver observer([]() { /* ... */ }); // OK CallLoger inherits the constructors of CallObserver, but still CallLogger logger([]() { /* ... */ }); would fail as there is no viable constructor or deduction guide available. According to P2582R1, this is going to be fixed in C++23 and CallLogger will inherit the deduction guidelines too. At the moment, no compiler has implemented it yet. Until then, we have to define an explicit deduction guideline if we want to make it work: 1 template &lt;typename T&gt; CallLogger(T) -&gt; CallLogger&lt;T&gt;; Here is the full example: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;memory&gt; #include &lt;concepts&gt; #include &lt;iostream&gt; template &lt;typename T&gt; /* requires std::invocable&lt;T&gt; */ struct CallObserver { CallObserver(T &amp;&amp;) : t(std::forward&lt;T&gt;(t)) {} virtual void observeCall() { t(); } T t; }; template &lt;typename T&gt; struct CallLogger : public CallObserver&lt;T&gt; { using CallObserver&lt;T&gt;::CallObserver; virtual void observeCall() override { std::cout &lt;&lt; &quot;calling&quot;; CallObserver&lt;T&gt;::t(); } }; /* In C++23 this will not needed anymore */ template &lt;typename T&gt; CallLogger(T) -&gt; CallLogger&lt;T&gt;; int main() { CallObserver observer([]() { /* ... */ }); // OK in C++17 CallLogger logger([]() { /* ... */ }); // OK only with the explicit deduction guideline untill C++23 } std::forward_like The implementation of Deducing this used a hypothetical std::forward_like&lt;decltype(self)&gt;(variable) facility. (It was not referenced in the aforementioned article). P2445R1 contains the necessary proposal for this utility. std::forward_like is (going to be) part of the &lt;utility&gt; header. As std::forward, it is also a type cast that only influences the value category of an expression. It forwards the value category of an object expression based on the value category of the owning object expression. If we talk about an owning object (o), member object (m) relationship, thus when o.m is valid, it would be spelt as std::forward&lt;decltype(o)&gt;(o).m up until C++20. But - for example with members of lambda closures - o.m is not always a valid expression and that’s when this new facility comes in handy. The authors considered three different models for the implementation. According to the language model, the behaviour of forward_like would have followed what std::forward&lt;decltype(Owner)&gt;(o).m does. According to the tuple, we would have got what std::get&lt;0&gt;(tuple&lt;Member&gt; Owner) does. However, the authors decided to go with a so-called merge model in which the const qualifiers of the owner and the member are merged and the value category of the Owner is adopted. There are some nice tables representing the common parts and the differences of the different approaches in the 8. section of the paper. There are 4 different use cases mentioned in the proposal for std::forward_like. The first one is a lambda that forwards its capture. Notice that it also uses deducing this, even though here we don’t talk about a recursive lambda, only the value type of the enclosing lambda is needed. 1 2 3 4 5 auto callback = [m=get_message(), &amp;scheduler](this auto &amp;&amp;self) -&gt; bool { return scheduler.submit(std::forward_like&lt;decltype(self)&gt;(m)); }; callback(); // retry(callback) std::move(callback)(); // try-or-fail(rvalue) In the second use case, a member is forwarded that is owned by the Owner, but not directly contained by it. Look at this example below to understand what it means. The value stored in m_ptr is owned by the struct Owner, but it’s not directly contained in it, because there is a unique pointer (m_ptr in fact) in between. 1 2 3 4 5 6 7 8 9 10 struct Owner { std::unique_ptr&lt;std::string&gt; m_ptr; auto getPtr(this auto&amp;&amp; self) -&gt; std::string { if (m_ptr) { return std::forward_like&lt;decltype(self)&gt;(*ptr); } return &quot;&quot;; } }; In the paper, you’ll find the third use case showing why it’s good to merge const qualifiers and also that forward_like can be useful even without deducing this. Conclusion In this article, we reviewed how class template argument deduction is extended in C++23 in order to support inherited constructors. We also learned about std::forward_like which is a feature needed by deducing this. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: some changes related to templates","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/09/06/cpp23-templates"},"url":"https://www.sandordargo.com/blog/2023/09/06/cpp23-templates"}</script><title>C++23: some changes related to templates | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/09"> 09 </a> </span> <span> <a href="/06"> 06 </a> </span> <span>C++23: some changes related to templates</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: some changes related to templates</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 6, 2023, 12:00 AM +0200" prep="on" > Sep 6, 2023 <i class="unloaded">2023-09-06T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1031 words">5 min</span></div></div><div class="post-content"><p>I know the above title is a bit vague. As we move forward with the introduction of C++23 features, there are going to be some articles like that. At the same time, there are more than two features that are related to templates in C++23. But some of them were already presented, such as <a href="https://www.sandordargo.com/blog/2022/06/01/cpp23-if-consteval"><code class="language-plaintext highlighter-rouge">if consteval</code></a> or <a href="https://www.sandordargo.com/blog/2022/02/16/deducing-this-cpp23">the explicit object parameter (a.k.a. deducing this)</a>.</p><p>Today, we are going talk about something related to and needed by deducing this, and the other topic is going to be class template argument deduction (<em>CTAD</em>).</p><h2 id="ctad-for-inherited-constructors">CTAD for inherited constructors</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2582r1.pdf">P2582R1</a> is about class template argument deduction (CTAD) from inherited constructors. If you check the paper and you don’t speak standardese well (and I don’t), it’ll be difficult to understand what it is about as it only contains the proposed wording.</p><p>Luckily, it refers to another document (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1021r6.html">P1021R6</a>), that contains the rationale behind this and many other changes.</p><p>From <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p1021r6.html">P1021R6</a>, we can learn that CTAD that was introduced in C++17 had and still has some limitations in its usability. Some were already fixed in C++20, but obviously, the inherited constructors use case.</p><p>Let’s take the example from the paper to demonstrate this shortcoming.</p><p>Let’s assume that we have these two classes (we talked about C++17 so far, but we are potentially using C++20 here if we uncomment the requires clause):</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="cm">/* requires std::invocable&lt;T&gt; */</span> <span class="k">struct</span> <span class="nc">CallObserver</span> <span class="p">{</span> 
  <span class="n">CallObserver</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">observeCall</span><span class="p">()</span> <span class="p">{</span> <span class="n">t</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
<span class="p">};</span>
 
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">CallLogger</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CallObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> 
  <span class="k">using</span> <span class="n">CallObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">CallObserver</span><span class="p">;</span> 
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">observeCall</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"calling"</span><span class="p">;</span>
    <span class="n">CallObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">t</span><span class="p">();</span>  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>


<span class="p">{</span>

   <span class="n">CallObserver</span> <span class="n">observer</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span> <span class="c1">// OK</span>
   <span class="n">CallLogger</span> <span class="nf">logger</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span>

<span class="p">}</span>

</pre></table></code></div></div><p>In C++17 you can use <code class="language-plaintext highlighter-rouge">CallObserver</code> without passing any type as a template parameter and CTAD will just work fine.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="n">CallObserver</span> <span class="nf">observer</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span> <span class="c1">// OK</span>
</pre></table></code></div></div><p>CallLoger inherits the constructors of CallObserver, but still <code class="language-plaintext highlighter-rouge">CallLogger logger([]() { /* ... */ });</code> would fail as there is no viable constructor or deduction guide available.</p><p>According to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2582r1.pdf">P2582R1</a>, this is going to be fixed in C++23 and <code class="language-plaintext highlighter-rouge">CallLogger</code> will inherit the deduction guidelines too. At the moment, no compiler has implemented it yet.</p><p>Until then, we have to define an explicit deduction guideline if we want to make it work:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CallLogger</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>
</pre></table></code></div></div><p>Here is the full example:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>  <span class="cm">/* requires std::invocable&lt;T&gt; */</span> <span class="k">struct</span> <span class="nc">CallObserver</span> <span class="p">{</span> 
  <span class="n">CallObserver</span><span class="p">(</span><span class="n">T</span> <span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">))</span> <span class="p">{}</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">observeCall</span><span class="p">()</span> <span class="p">{</span> <span class="n">t</span><span class="p">();</span> <span class="p">}</span>
  <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
<span class="p">};</span>
 
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">struct</span> <span class="nc">CallLogger</span> <span class="o">:</span> <span class="k">public</span> <span class="n">CallObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span> 
  <span class="k">using</span> <span class="n">CallObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">CallObserver</span><span class="p">;</span> 
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">observeCall</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> 
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"calling"</span><span class="p">;</span>
    <span class="n">CallObserver</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;::</span><span class="n">t</span><span class="p">();</span>  <span class="p">}</span>
<span class="p">};</span>


<span class="cm">/*
In C++23 this will not needed anymore
*/</span> 
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="n">CallLogger</span><span class="p">(</span><span class="n">T</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">CallLogger</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

   <span class="n">CallObserver</span> <span class="n">observer</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span> <span class="c1">// OK in C++17</span>
   <span class="n">CallLogger</span> <span class="nf">logger</span><span class="p">([]()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">});</span> <span class="c1">// OK only with the explicit deduction guideline untill C++23</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="stdforward_like"><code class="language-plaintext highlighter-rouge">std::forward_like</code></h2><p>The implementation of <a href="https://www.sandordargo.com/blog/2022/02/16/deducing-this-cpp23">Deducing this</a> used a hypothetical <code class="language-plaintext highlighter-rouge">std::forward_like&lt;decltype(self)&gt;(variable)</code> facility. (It was not referenced in the aforementioned article). <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2445r1.pdf">P2445R1</a> contains the necessary proposal for this utility.</p><p><code class="language-plaintext highlighter-rouge">std::forward_like</code> is (going to be) part of the <code class="language-plaintext highlighter-rouge">&lt;utility&gt;</code> header. As <code class="language-plaintext highlighter-rouge">std::forward</code>, it is also a type cast that only influences the value category of an expression. It forwards the value category of an object expression based on the value category of the owning object expression.</p><p>If we talk about an owning object (<code class="language-plaintext highlighter-rouge">o</code>), member object (<code class="language-plaintext highlighter-rouge">m</code>) relationship, thus when <code class="language-plaintext highlighter-rouge">o.m</code> is valid, it would be spelt as <code class="language-plaintext highlighter-rouge">std::forward&lt;decltype(o)&gt;(o).m</code> up until C++20.</p><p>But - for example with members of lambda closures - <code class="language-plaintext highlighter-rouge">o.m</code> is not always a valid expression and that’s when this new facility comes in handy.</p><p>The authors considered three different models for the implementation. According to the language model, the behaviour of <code class="language-plaintext highlighter-rouge">forward_like</code> would have followed what <code class="language-plaintext highlighter-rouge">std::forward&lt;decltype(Owner)&gt;(o).m</code> does. According to the tuple, we would have got what <code class="language-plaintext highlighter-rouge">std::get&lt;0&gt;(tuple&lt;Member&gt; Owner)</code> does. However, the authors decided to go with a so-called <code class="language-plaintext highlighter-rouge">merge</code> model in which the <code class="language-plaintext highlighter-rouge">const</code> qualifiers of the owner and the member are merged and the value category of the Owner is adopted.</p><p>There are some nice tables representing the common parts and the differences of the different approaches in the <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2445r1.pdf">8. section of the paper</a>.</p><p>There are 4 different use cases mentioned in the proposal for <code class="language-plaintext highlighter-rouge">std::forward_like</code>. The first one is a lambda that forwards its capture. Notice that it also uses deducing this, even though here we don’t talk about a recursive lambda, only the value type of the enclosing lambda is needed.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">auto</span> <span class="n">callback</span> <span class="o">=</span> <span class="p">[</span><span class="n">m</span><span class="o">=</span><span class="n">get_message</span><span class="p">(),</span> <span class="o">&amp;</span><span class="n">scheduler</span><span class="p">](</span><span class="k">this</span> <span class="k">auto</span> <span class="o">&amp;&amp;</span><span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kt">bool</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">scheduler</span><span class="p">.</span><span class="n">submit</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward_like</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="n">m</span><span class="p">));</span>
<span class="p">};</span>
<span class="n">callback</span><span class="p">();</span> <span class="c1">// retry(callback)</span>
<span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">callback</span><span class="p">)();</span> <span class="c1">// try-or-fail(rvalue)</span>
</pre></table></code></div></div><p>In the second use case, a member is forwarded that is owned by the Owner, but not directly contained by it. Look at this example below to understand what it means. The value stored in <code class="language-plaintext highlighter-rouge">m_ptr</code> is owned by the struct <code class="language-plaintext highlighter-rouge">Owner</code>, but it’s not directly contained in it, because there is a unique pointer (<code class="language-plaintext highlighter-rouge">m_ptr</code> in fact) in between.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Owner</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">m_ptr</span><span class="p">;</span>

  <span class="k">auto</span> <span class="n">getPtr</span><span class="p">(</span><span class="k">this</span> <span class="k">auto</span><span class="o">&amp;&amp;</span> <span class="n">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">m_ptr</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">forward_like</span><span class="o">&lt;</span><span class="k">decltype</span><span class="p">(</span><span class="n">self</span><span class="p">)</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">ptr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In the paper, you’ll find the third use case showing why it’s good to merge <code class="language-plaintext highlighter-rouge">const</code> qualifiers and also that <code class="language-plaintext highlighter-rouge">forward_like</code> can be useful even without deducing this.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed how class template argument deduction is extended in C++23 in order to support inherited constructors. We also learned about <code class="language-plaintext highlighter-rouge">std::forward_like</code> which is a feature needed by <a href="https://www.sandordargo.com/blog/2022/02/16/deducing-this-cpp23">deducing this</a>.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/constexpr/" class="post-tag no-text-decoration" >constexpr</a> <a href="/tags/compiletime/" class="post-tag no-text-decoration" >compiletime</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: some changes related to templates - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/09/06/cpp23-templates" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: some changes related to templates - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/09/06/cpp23-templates" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: some changes related to templates - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/09/06/cpp23-templates" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: some changes related to templates - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/09/06/cpp23-templates" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/05/24/cpp23-constexpr"><div class="card-body"> <span class="timeago small" > May 24, 2023 <i class="unloaded">2023-05-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: Even more constexpr</h3><div class="text-muted small"><p> Ever since C++ introduced the constexpr keyword in C++11, each new standard brought us more and more opportunities to make our code increasingly constexpr, in other words, compile-time execution fr...</p></div></div></a></div><div class="card"> <a href="/blog/2023/11/01/cpp23-garbage-collection"><div class="card-body"> <span class="timeago small" > Nov 1, 2023 <i class="unloaded">2023-11-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: Removing garbage collection support</h3><div class="text-muted small"><p> If we go through the list of C++23 features, we can stumble upon the notion of garbage collection twice. Once among the language and once among the library features. Both entries refer to the same ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/08/30/the-value-of-boring-tasks" class="btn btn-outline-primary" prompt="Older"><p>The value of boring tasks</p></a> <a href="/blog/2023/09/13/constexpr-and-binary-sizes" class="btn btn-outline-primary" prompt="Newer"><p>Constexpr functions for smaller binary size?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: some changes related to templates'; this.page.url = 'https://www.sandordargo.com/blog/2023/09/06/cpp23-templates'; this.page.identifier = '/blog/2023/09/06/cpp23-templates'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
