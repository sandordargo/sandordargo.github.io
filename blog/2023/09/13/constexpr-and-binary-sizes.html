<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Constexpr functions for smaller binary size?" /><meta property="og:locale" content="en_US" /><meta name="description" content="I read recently “constexpr functions: optimization vs guarantee” by Andreas Fertig. I was a bit surprised by some of his claims about constexpr functions regarding binary size so I decided to go after those and check their validity. I don’t want to raise the suspense, he was more right than not. When I read his article, I overlooked certain details. Let’s get into the details. Section header Let me share some details from Andreas’ article. What you see here is still an optimization. Yes, if you are interested in a small binary footprint, you can be happy. But, constexpr can give you more! You can get guarantees from constexpr. Let’s explore that. At this point, I was a little bit surprised. I remember when we talked about object initializtion and we found that if an object can be created and initialized during compile-time, then our binary might become bigger as the variable - depending on its storage duration - might be part of the binary file. And here I read something contrary. You might say that I cited my experience about object initialization but the article is about constexpr functions. You’re right about that. Let’s go further. The reason is that constexpr implies inline! Try for yourself, make Fun inline, and you will see exactly the same assembly output as when the function was constexpr. Because of the implicit inline, the compiler understands that Fun never escapes the current compilation unit. By knowing that there is no reason to keep the definition around. Then, Fun itself is reasonably simple to the compiler, and the parameter is known at compile-time. An invitation for the optimizer, which it happily accepts. At this point, I really started to scratch my head. We move special member function definitions to the .cpp file, we use different compiler and linker flags to limit inlining so that we can get a smaller binary. And here I read that inlining Fun can help. I decided to measure the size in different scenarios. Using constexpr will either not matter or help Let’s measure the implications of constexpr functions in three different scenarios. We are going to use the utility in one single place, then in multiple translation units and finally, we’ll consume it through a dynamic library. In a local scope it won’t matter First, I took the original example and measured the size of the generated binary. 1 2 3 4 5 6 7 8 9 10 11 constexpr auto Fun(int v) // tried also without constexpr and only with inline { return 42 / v; } int main() { const auto f = Fun(6); return f; } The differences were not big, but they proved Andreas’ point. Version Binary size in bytes constexpr 16,856 inline 16,856 no modifiers 16,904 It’s probably worth noting that when you measure binaries with so little difference in size, the filename of the binary file also matters, so I made sure that they are of the same length. Indeed, the inline and constexpr versions are a bit smaller. If we have a look at the assembly, we’ll see a bigger difference in size and we can observe that the version without constexpr and inline contains the necessary code for Fun, while the other two do not. The necessary calculations happened during compile time, yet the gain in binary size is insignificant. Fair enough, but we rarely use our functions only once in a constexpr environment. Let’s have a look at a more elaborate example. Binary sizes are barely affected by multiple translation units It clearly contradicts my experience what Andreas wrote about inline, so I went further and extended his example. I defined a utility header containing the Fun function and created three .h/.cpp pairs where the utility is included and used by each implementation file. The results were surprising. Without optimization, the non-constexpr version resulted in a smaller binary. When the optimization was turned on, the constexpr version was the smaller one. But the difference was below a hundred bytes. In this case that was below even 0.3%. Version Binary size in bytes constexpr -O0 39,761 non-constexpr -00 39,681 constexpr -03 39,425 non-constexpr -03 39,475 What made this result more interesting was that when I compiled with the -S flag to get the intermediary assembly code, the .s files of the constexpr version were never bigger than those of the non-constexpr version. But when they are compiled together, the relation slightly changes. At this point, the body of Fun was a simple return of a division. When I replaced it with 5 different additions to the parameter before returning it, nothing changed. In the end, we didn’t gain anything in terms of binary size. constexpr functions matter when distributed via a shared library What we saw in the previous section was probably a bit more realistic usage of a utility function than the original example of a single usage. Even though I think that one single usage can already justify the existence of a function in the name clean code and readability. The next step is taking the previous example and compiling each .h / .cpp pair into its own shared library and then linking them together. This way the constexpr version has a clear and significant advantage! The executable has the exact same size in both cases. Even the libutils.so that contains (only) Fun has the same size regardless of Fun being constexpr or not. But all the other shared objects that depend on libutils.so are about twice as small if Fun is constexpr (16,778 bytes vs 33,370 bytes compiled with -O3). As such, the constexpr version is overall 119,329 bytes vs. 185,697 bytes of the non-constexpr version. My reasonings about this is the following: libutils.so has no difference in size as the implementation of Fun has to be distributed there is a difference in size for the consumers as the computation is done - in our use-case - at compile-time, no code has to be kept for run-time the main executable is just calling the intermediary shared objects, their size makes no difference to it. Conclusion Using constexpr might matter and according to my measurements, it will never hurt the binary size. In a bigger codebase, when code is distributed through libraries it can significantly help you reduce the binary size. We also have to keep in mind that using constexpr is not only about limiting the binary size. We cannot forget about how much it helps with compile-time evaluation and with template metaprogramming in general. Besides, as Andreas pointed out constexpr also detects undefined behaviour. Its potential help with binary sizes is only an addition. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I read recently “constexpr functions: optimization vs guarantee” by Andreas Fertig. I was a bit surprised by some of his claims about constexpr functions regarding binary size so I decided to go after those and check their validity. I don’t want to raise the suspense, he was more right than not. When I read his article, I overlooked certain details. Let’s get into the details. Section header Let me share some details from Andreas’ article. What you see here is still an optimization. Yes, if you are interested in a small binary footprint, you can be happy. But, constexpr can give you more! You can get guarantees from constexpr. Let’s explore that. At this point, I was a little bit surprised. I remember when we talked about object initializtion and we found that if an object can be created and initialized during compile-time, then our binary might become bigger as the variable - depending on its storage duration - might be part of the binary file. And here I read something contrary. You might say that I cited my experience about object initialization but the article is about constexpr functions. You’re right about that. Let’s go further. The reason is that constexpr implies inline! Try for yourself, make Fun inline, and you will see exactly the same assembly output as when the function was constexpr. Because of the implicit inline, the compiler understands that Fun never escapes the current compilation unit. By knowing that there is no reason to keep the definition around. Then, Fun itself is reasonably simple to the compiler, and the parameter is known at compile-time. An invitation for the optimizer, which it happily accepts. At this point, I really started to scratch my head. We move special member function definitions to the .cpp file, we use different compiler and linker flags to limit inlining so that we can get a smaller binary. And here I read that inlining Fun can help. I decided to measure the size in different scenarios. Using constexpr will either not matter or help Let’s measure the implications of constexpr functions in three different scenarios. We are going to use the utility in one single place, then in multiple translation units and finally, we’ll consume it through a dynamic library. In a local scope it won’t matter First, I took the original example and measured the size of the generated binary. 1 2 3 4 5 6 7 8 9 10 11 constexpr auto Fun(int v) // tried also without constexpr and only with inline { return 42 / v; } int main() { const auto f = Fun(6); return f; } The differences were not big, but they proved Andreas’ point. Version Binary size in bytes constexpr 16,856 inline 16,856 no modifiers 16,904 It’s probably worth noting that when you measure binaries with so little difference in size, the filename of the binary file also matters, so I made sure that they are of the same length. Indeed, the inline and constexpr versions are a bit smaller. If we have a look at the assembly, we’ll see a bigger difference in size and we can observe that the version without constexpr and inline contains the necessary code for Fun, while the other two do not. The necessary calculations happened during compile time, yet the gain in binary size is insignificant. Fair enough, but we rarely use our functions only once in a constexpr environment. Let’s have a look at a more elaborate example. Binary sizes are barely affected by multiple translation units It clearly contradicts my experience what Andreas wrote about inline, so I went further and extended his example. I defined a utility header containing the Fun function and created three .h/.cpp pairs where the utility is included and used by each implementation file. The results were surprising. Without optimization, the non-constexpr version resulted in a smaller binary. When the optimization was turned on, the constexpr version was the smaller one. But the difference was below a hundred bytes. In this case that was below even 0.3%. Version Binary size in bytes constexpr -O0 39,761 non-constexpr -00 39,681 constexpr -03 39,425 non-constexpr -03 39,475 What made this result more interesting was that when I compiled with the -S flag to get the intermediary assembly code, the .s files of the constexpr version were never bigger than those of the non-constexpr version. But when they are compiled together, the relation slightly changes. At this point, the body of Fun was a simple return of a division. When I replaced it with 5 different additions to the parameter before returning it, nothing changed. In the end, we didn’t gain anything in terms of binary size. constexpr functions matter when distributed via a shared library What we saw in the previous section was probably a bit more realistic usage of a utility function than the original example of a single usage. Even though I think that one single usage can already justify the existence of a function in the name clean code and readability. The next step is taking the previous example and compiling each .h / .cpp pair into its own shared library and then linking them together. This way the constexpr version has a clear and significant advantage! The executable has the exact same size in both cases. Even the libutils.so that contains (only) Fun has the same size regardless of Fun being constexpr or not. But all the other shared objects that depend on libutils.so are about twice as small if Fun is constexpr (16,778 bytes vs 33,370 bytes compiled with -O3). As such, the constexpr version is overall 119,329 bytes vs. 185,697 bytes of the non-constexpr version. My reasonings about this is the following: libutils.so has no difference in size as the implementation of Fun has to be distributed there is a difference in size for the consumers as the computation is done - in our use-case - at compile-time, no code has to be kept for run-time the main executable is just calling the intermediary shared objects, their size makes no difference to it. Conclusion Using constexpr might matter and according to my measurements, it will never hurt the binary size. In a bigger codebase, when code is distributed through libraries it can significantly help you reduce the binary size. We also have to keep in mind that using constexpr is not only about limiting the binary size. We cannot forget about how much it helps with compile-time evaluation and with template metaprogramming in general. Besides, as Andreas pointed out constexpr also detects undefined behaviour. Its potential help with binary sizes is only an addition. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-09-13T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Constexpr functions for smaller binary size?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-09-13T00:00:00+02:00","datePublished":"2023-09-13T00:00:00+02:00","description":"I read recently “constexpr functions: optimization vs guarantee” by Andreas Fertig. I was a bit surprised by some of his claims about constexpr functions regarding binary size so I decided to go after those and check their validity. I don’t want to raise the suspense, he was more right than not. When I read his article, I overlooked certain details. Let’s get into the details. Section header Let me share some details from Andreas’ article. What you see here is still an optimization. Yes, if you are interested in a small binary footprint, you can be happy. But, constexpr can give you more! You can get guarantees from constexpr. Let’s explore that. At this point, I was a little bit surprised. I remember when we talked about object initializtion and we found that if an object can be created and initialized during compile-time, then our binary might become bigger as the variable - depending on its storage duration - might be part of the binary file. And here I read something contrary. You might say that I cited my experience about object initialization but the article is about constexpr functions. You’re right about that. Let’s go further. The reason is that constexpr implies inline! Try for yourself, make Fun inline, and you will see exactly the same assembly output as when the function was constexpr. Because of the implicit inline, the compiler understands that Fun never escapes the current compilation unit. By knowing that there is no reason to keep the definition around. Then, Fun itself is reasonably simple to the compiler, and the parameter is known at compile-time. An invitation for the optimizer, which it happily accepts. At this point, I really started to scratch my head. We move special member function definitions to the .cpp file, we use different compiler and linker flags to limit inlining so that we can get a smaller binary. And here I read that inlining Fun can help. I decided to measure the size in different scenarios. Using constexpr will either not matter or help Let’s measure the implications of constexpr functions in three different scenarios. We are going to use the utility in one single place, then in multiple translation units and finally, we’ll consume it through a dynamic library. In a local scope it won’t matter First, I took the original example and measured the size of the generated binary. 1 2 3 4 5 6 7 8 9 10 11 constexpr auto Fun(int v) // tried also without constexpr and only with inline { return 42 / v; } int main() { const auto f = Fun(6); return f; } The differences were not big, but they proved Andreas’ point. Version Binary size in bytes constexpr 16,856 inline 16,856 no modifiers 16,904 It’s probably worth noting that when you measure binaries with so little difference in size, the filename of the binary file also matters, so I made sure that they are of the same length. Indeed, the inline and constexpr versions are a bit smaller. If we have a look at the assembly, we’ll see a bigger difference in size and we can observe that the version without constexpr and inline contains the necessary code for Fun, while the other two do not. The necessary calculations happened during compile time, yet the gain in binary size is insignificant. Fair enough, but we rarely use our functions only once in a constexpr environment. Let’s have a look at a more elaborate example. Binary sizes are barely affected by multiple translation units It clearly contradicts my experience what Andreas wrote about inline, so I went further and extended his example. I defined a utility header containing the Fun function and created three .h/.cpp pairs where the utility is included and used by each implementation file. The results were surprising. Without optimization, the non-constexpr version resulted in a smaller binary. When the optimization was turned on, the constexpr version was the smaller one. But the difference was below a hundred bytes. In this case that was below even 0.3%. Version Binary size in bytes constexpr -O0 39,761 non-constexpr -00 39,681 constexpr -03 39,425 non-constexpr -03 39,475 What made this result more interesting was that when I compiled with the -S flag to get the intermediary assembly code, the .s files of the constexpr version were never bigger than those of the non-constexpr version. But when they are compiled together, the relation slightly changes. At this point, the body of Fun was a simple return of a division. When I replaced it with 5 different additions to the parameter before returning it, nothing changed. In the end, we didn’t gain anything in terms of binary size. constexpr functions matter when distributed via a shared library What we saw in the previous section was probably a bit more realistic usage of a utility function than the original example of a single usage. Even though I think that one single usage can already justify the existence of a function in the name clean code and readability. The next step is taking the previous example and compiling each .h / .cpp pair into its own shared library and then linking them together. This way the constexpr version has a clear and significant advantage! The executable has the exact same size in both cases. Even the libutils.so that contains (only) Fun has the same size regardless of Fun being constexpr or not. But all the other shared objects that depend on libutils.so are about twice as small if Fun is constexpr (16,778 bytes vs 33,370 bytes compiled with -O3). As such, the constexpr version is overall 119,329 bytes vs. 185,697 bytes of the non-constexpr version. My reasonings about this is the following: libutils.so has no difference in size as the implementation of Fun has to be distributed there is a difference in size for the consumers as the computation is done - in our use-case - at compile-time, no code has to be kept for run-time the main executable is just calling the intermediary shared objects, their size makes no difference to it. Conclusion Using constexpr might matter and according to my measurements, it will never hurt the binary size. In a bigger codebase, when code is distributed through libraries it can significantly help you reduce the binary size. We also have to keep in mind that using constexpr is not only about limiting the binary size. We cannot forget about how much it helps with compile-time evaluation and with template metaprogramming in general. Besides, as Andreas pointed out constexpr also detects undefined behaviour. Its potential help with binary sizes is only an addition. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Constexpr functions for smaller binary size?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes"},"url":"https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes"}</script><title>Constexpr functions for smaller binary size? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/09"> 09 </a> </span> <span> <a href="/13"> 13 </a> </span> <span>Constexpr functions for smaller binary size?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Constexpr functions for smaller binary size?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Sep 13, 2023, 12:00 AM +0200" prep="on" > Sep 13, 2023 <i class="unloaded">2023-09-13T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1129 words">6 min</span></div></div><div class="post-content"><p>I read recently <a href="https://andreasfertig.blog/2023/06/constexpr-functions-optimization-vs-guarantee/">“constexpr functions: optimization vs guarantee”</a> by Andreas Fertig. I was a bit surprised by some of his claims about <code class="language-plaintext highlighter-rouge">constexpr</code> functions regarding binary size so I decided to go after those and check their validity. I don’t want to raise the suspense, he was more right than not. When I read his article, I overlooked certain details. Let’s get into the details.</p><h2 id="section-header">Section header</h2><p>Let me share some details from <a href="https://andreasfertig.blog/2023/06/constexpr-functions-optimization-vs-guarantee/">Andreas’ article</a>.</p><blockquote><p>What you see here is still an optimization. Yes, if you are interested in a small binary footprint, you can be happy. But, <code class="language-plaintext highlighter-rouge">constexpr</code> can give you more! You can get guarantees from <code class="language-plaintext highlighter-rouge">constexpr</code>. Let’s explore that.</p></blockquote><p>At this point, I was a little bit surprised. I remember when <a href="https://www.sandordargo.com/blog/2023/01/18/object-initialization-and-binary-sizes">we talked about object initializtion</a> and we found that if an object can be created and initialized during compile-time, then our binary might become bigger as the variable - depending on its storage duration - might be part of the binary file.</p><p>And here I read something contrary.</p><p>You might say that I cited my experience about object initialization but the article is about <code class="language-plaintext highlighter-rouge">constexpr</code> functions. You’re right about that. Let’s go further.</p><blockquote><p>The reason is that <code class="language-plaintext highlighter-rouge">constexpr</code> implies inline! Try for yourself, make <code class="language-plaintext highlighter-rouge">Fun</code> <code class="language-plaintext highlighter-rouge">inline</code>, and you will see exactly the same assembly output as when the function was <code class="language-plaintext highlighter-rouge">constexpr</code>.</p><p>Because of the implicit <code class="language-plaintext highlighter-rouge">inline</code>, the compiler understands that <code class="language-plaintext highlighter-rouge">Fun</code> never escapes the current compilation unit. By knowing that there is no reason to keep the definition around. Then, <code class="language-plaintext highlighter-rouge">Fun</code> itself is reasonably simple to the compiler, and the parameter is known at compile-time. An invitation for the optimizer, which it happily accepts.</p></blockquote><p>At this point, I really started to scratch my head. <a href="https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes">We move special member function definitions to the <code class="language-plaintext highlighter-rouge">.cpp</code> file</a>, we use different <a href="https://www.sandordargo.com/blog/2023/07/19/binary-sizes-and-compiler-flags">compiler and linker flags</a> to limit inlining so that we can get a smaller binary. And here I read that inlining <code class="language-plaintext highlighter-rouge">Fun</code> can help.</p><p>I decided to measure the size in different scenarios.</p><h2 id="using-constexpr-will-either-not-matter-or-help">Using <code class="language-plaintext highlighter-rouge">constexpr</code> will either not matter or help</h2><p>Let’s measure the implications of <code class="language-plaintext highlighter-rouge">constexpr</code> functions in three different scenarios. We are going to use the utility in one single place, then in multiple translation units and finally, we’ll consume it through a dynamic library.</p><h3 id="in-a-local-scope-it-wont-matter">In a local scope it won’t matter</h3><p>First, I took the original example and measured the size of the generated binary.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="k">auto</span> <span class="nf">Fun</span><span class="p">(</span><span class="kt">int</span> <span class="n">v</span><span class="p">)</span> <span class="c1">// tried also without constexpr and only with inline</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="mi">42</span> <span class="o">/</span> <span class="n">v</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="n">Fun</span><span class="p">(</span><span class="mi">6</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">f</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The differences were not big, but they proved Andreas’ point.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size in bytes<tbody><tr><td>constexpr<td>16,856<tr><td>inline<td>16,856<tr><td>no modifiers<td>16,904</table></div><p>It’s probably worth noting that when you measure binaries with so little difference in size, the filename of the binary file also matters, so I made sure that they are of the same length.</p><p>Indeed, the <code class="language-plaintext highlighter-rouge">inline</code> and <code class="language-plaintext highlighter-rouge">constexpr</code> versions are a bit smaller. If we have a look at the assembly, we’ll see a bigger difference in size and we can observe that the version without <code class="language-plaintext highlighter-rouge">constexpr</code> and <code class="language-plaintext highlighter-rouge">inline</code> contains the necessary code for <code class="language-plaintext highlighter-rouge">Fun</code>, while the other two do not. The necessary calculations happened during compile time, yet the gain in binary size is insignificant.</p><p>Fair enough, but we rarely use our functions only once in a <code class="language-plaintext highlighter-rouge">constexpr</code> environment.</p><p>Let’s have a look at a more elaborate example.</p><h3 id="binary-sizes-are-barely-affected-by-multiple-translation-units">Binary sizes are barely affected by multiple translation units</h3><p>It clearly contradicts my experience what Andreas wrote about <code class="language-plaintext highlighter-rouge">inline</code>, so I went further and extended his example. I defined a utility header containing the <code class="language-plaintext highlighter-rouge">Fun</code> function and created three <code class="language-plaintext highlighter-rouge">.h/.cpp</code> pairs where the utility is included and used by each implementation file.</p><p>The results were surprising. Without optimization, the non-<code class="language-plaintext highlighter-rouge">constexpr</code> version resulted in a smaller binary. When the optimization was turned on, the <code class="language-plaintext highlighter-rouge">constexpr</code> version was the smaller one. But the difference was below a hundred bytes. In this case that was below even <code class="language-plaintext highlighter-rouge">0.3%</code>.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size in bytes<tbody><tr><td>constexpr -O0<td>39,761<tr><td>non-constexpr -00<td>39,681<tr><td>constexpr -03<td>39,425<tr><td>non-constexpr -03<td>39,475</table></div><p>What made this result more interesting was that when I compiled with the <code class="language-plaintext highlighter-rouge">-S</code> flag to get the intermediary assembly code, the <code class="language-plaintext highlighter-rouge">.s</code> files of the <code class="language-plaintext highlighter-rouge">constexpr</code> version were never bigger than those of the non-<code class="language-plaintext highlighter-rouge">constexpr</code> version.</p><p>But when they are compiled together, the relation slightly changes.</p><p>At this point, the body of <code class="language-plaintext highlighter-rouge">Fun</code> was a simple <code class="language-plaintext highlighter-rouge">return</code> of a division. When I replaced it with 5 different additions to the parameter before returning it, nothing changed.</p><p>In the end, we didn’t gain anything in terms of binary size.</p><h3 id="constexpr-functions-matter-when-distributed-via-a-shared-library"><code class="language-plaintext highlighter-rouge">constexpr</code> functions matter when distributed via a shared library</h3><p>What we saw in the previous section was probably a bit more realistic usage of a utility function than the original example of a single usage. Even though I think that one single usage can already justify the existence of a function in the name clean code and readability.</p><p>The next step is taking the previous example and compiling each <code class="language-plaintext highlighter-rouge">.h</code> / <code class="language-plaintext highlighter-rouge">.cpp</code> pair into its own shared library and then linking them together.</p><p>This way the <code class="language-plaintext highlighter-rouge">constexpr</code> version has a clear and significant advantage!</p><p>The executable has the exact same size in both cases. Even the <code class="language-plaintext highlighter-rouge">libutils.so</code> that contains (only) <code class="language-plaintext highlighter-rouge">Fun</code> has the same size regardless of <code class="language-plaintext highlighter-rouge">Fun</code> being <code class="language-plaintext highlighter-rouge">constexpr</code> or not. But all the other shared objects that depend on <code class="language-plaintext highlighter-rouge">libutils.so</code> are about twice as small if <code class="language-plaintext highlighter-rouge">Fun</code> is <code class="language-plaintext highlighter-rouge">constexpr</code> (16,778 bytes vs 33,370 bytes compiled with -O3). As such, the <code class="language-plaintext highlighter-rouge">constexpr</code> version is overall 119,329 bytes vs. 185,697 bytes of the non-<code class="language-plaintext highlighter-rouge">constexpr</code> version.</p><p>My reasonings about this is the following:</p><ul><li><code class="language-plaintext highlighter-rouge">libutils.so</code> has no difference in size as the implementation of <code class="language-plaintext highlighter-rouge">Fun</code> has to be distributed<li>there is a difference in size for the consumers as the computation is done - in our use-case - at compile-time, no code has to be kept for run-time<li>the main executable is just calling the intermediary shared objects, their size makes no difference to it.</ul><h2 id="conclusion">Conclusion</h2><p>Using <code class="language-plaintext highlighter-rouge">constexpr</code> might matter and according to my measurements, it will never hurt the binary size. In a bigger codebase, when code is distributed through libraries it can significantly help you reduce the binary size.</p><p>We also have to keep in mind that using <code class="language-plaintext highlighter-rouge">constexpr</code> is not only about limiting the binary size. We cannot forget about how much it helps with compile-time evaluation and with template metaprogramming in general. Besides, as <a href="https://andreasfertig.blog/2023/06/constexpr-functions-optimization-vs-guarantee/">Andreas pointed out</a> <code class="language-plaintext highlighter-rouge">constexpr</code> also detects undefined behaviour.</p><p>Its potential help with binary sizes is only an addition.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/constexpr/" class="post-tag no-text-decoration" >constexpr</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/undefinedbehaviour/" class="post-tag no-text-decoration" >undefinedbehaviour</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Constexpr functions for smaller binary size? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Constexpr functions for smaller binary size? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Constexpr functions for smaller binary size? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Constexpr functions for smaller binary size? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/04/03/upgrading-the-compiler-and-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Apr 3, 2024 <i class="unloaded">2024-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Upgrading the compiler: undefined behaviour uncovered</h3><div class="text-muted small"><p> Not so long time ago, I already mentioned the differences between the different kinds of initializations in my article, Struct Initialization. In the coming weeks, I’m going to revisit the topic. ...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/17/initializations-part-2"><div class="card-body"> <span class="timeago small" > Apr 17, 2024 <i class="unloaded">2024-04-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 2</h3><div class="text-muted small"><p> During the last two weeks, we saw a bug related to uninitialized values and undefined behaviour, we listed the different kinds of initializations in C++ and we started to more detailed discovery wi...</p></div></div></a></div><div class="card"> <a href="/blog/2024/04/24/initializations-part-3"><div class="card-body"> <span class="timeago small" > Apr 24, 2024 <i class="unloaded">2024-04-24T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>When and how variables are initialized? - Part 3</h3><div class="text-muted small"><p> For the last couple of weeks, we’ve been learning about the different forms of initializations in C++. This quest is motivated by a bug I discovered after a compiler update in a code base that I ma...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/09/06/cpp23-templates" class="btn btn-outline-primary" prompt="Older"><p>C++23: some changes related to templates</p></a> <a href="/blog/2023/09/20/once-more-about-clean-code" class="btn btn-outline-primary" prompt="Newer"><p>Once more about clean code</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Constexpr functions for smaller binary size?'; this.page.url = 'https://www.sandordargo.com/blog/2023/09/13/constexpr-and-binary-sizes'; this.page.identifier = '/blog/2023/09/13/constexpr-and-binary-sizes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
