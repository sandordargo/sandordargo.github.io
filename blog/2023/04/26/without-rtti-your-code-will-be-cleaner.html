<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Without RTTI your code will be cleaner" /><meta property="og:locale" content="en_US" /><meta name="description" content="Recently, in the binary sizes series, we discussed how run-time type information affects RTTI. I also mentioned that in my opinion the lack of RTTI leads to better practices and you’ll end up with a more readable, more maintainable code. It’s time to delve into this topic and see why. What is RTTI again? But first of all, let’s quickly recap what is run-time type information. RTTI let us have information on the dynamic type of reference/pointer types. It lets us use dyanamic_casts and also call the typeid() function and query the returned instance of std::type_info. I think that not having access to these tools will let you write better code. Why so? Let’s start with probably the less controversial tool. Don’t rely on typeid() Inexperienced programmers might want to automatically use typeid().name() to see what’s the dynamic type of something during development and testing. It’s usually not kept because often the output is not that readable. I mean for int, you might simply get i. That’s something easily recognizable, but not something you’d want to see in the logs. The bigger problem is that the output is implementation-defined, so you really shouldn’t count on it if you want code that is portable. (Even though there is a fair chance that they will be the same on GCC and clang). Let’s see a couple of examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; int main() { std::cout &lt;&lt; typeid(5).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(5u).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(5.0).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(true).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(&#39;5&#39;).name() &lt;&lt; &#39;\n&#39;; return 0; } /* gcc: i j d b c clang: i j d b c */ Different outputs among compilers do not mean that you cannot use them consistently. You can still use typeid().name() or typeid.hash() to compare types against each other in your code and branch the execution based on those comparisons… On the other hand, you don’t have many reasons to do that. If you have to deal with, if you have to compare unrelated types, probably you should extract the type-dependent code and use different overloads. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;vector&gt; class Wine { public: virtual ~Wine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is wine\n&quot;; } }; class WhiteWine { public: virtual ~WhiteWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is white wine\n&quot;; } }; class RedWine { public: virtual ~RedWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is red wine\n&quot;; } }; class RoseWine { public: virtual ~RoseWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is rose wine\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Wine&gt;&gt; wines; auto wine1 = std::make_unique&lt;WhiteWine&gt;(); auto wine2 = std::make_unique&lt;RedWine&gt;(); auto wine3 = std::make_unique&lt;RoseWine&gt;(); } If the types are from the same inheritance tree, then you should either use dynamic_casts or even better, you should benefit from dynamic dispatching. dynamic_cast is slightly better, but still should be avoided dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type. In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } Many would say that this is a code smell. I’m among them. Many would go further and say that using dynamic_cast in general is a code smell. As mentioned earlier, this is almost always better than relying on typeid(), but behind dyanimc_casts you’ll only find bad inheritance trees and messed up APIs. Rather than having different public interfaces, we should have a unified one. There is a convenient reason for that. If the interface is unified, we don’t need to cast our objects, we can simply rely on runtime dispatching of our function calls. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; virtual void doSomeFun() = 0; }; class OffRoader: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\n&quot;; } }; class Van: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;attach third seatrow in a van\n&quot;; } }; class Roadster: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { car-&gt;doSomeFun(); } return 0; } When typeid is still better? As I mentioned earlier, while dynamic_cast is not a good solution, it’s almost always better than using typeid(). Why not always? There is a not-so-subtle difference between these 2 RTTI tools. dynamic_cast checks whether an object “is kind of” another class. But typeid() will look for an exact match. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class A { public: virtual ~A() = default; }; class B: public A { }; class C: public B { }; int main() { std::unique_ptr&lt;A&gt; p1 = std::make_unique&lt;C&gt;(); B* p2 = dynamic_cast&lt;B*&gt;(p1.get()); C* p3 = dynamic_cast&lt;C*&gt;(p1.get()); if (p2) { std::cout &lt;&lt; &quot;p1 is like B*. it&#39;s convertible to B\n&quot;; } else if (p3) { // we won&#39;t reach this branch due to bad ordering of if/else branches std::cout &lt;&lt; &quot;p1 is like C*. it&#39;s convertible to C\n&quot;; } if (typeid(*p1) == typeid(B{})) { std::cout &lt;&lt; &quot;*p1 is B\n&quot;; } else if (typeid(*p1) == typeid(C{})) { std::cout &lt;&lt; &quot;*p1 is C\n&quot;; } return 0; } /* p1 is like B*. it&#39;s convertible to B *p1 is C */ As such, typeid() is both simpler and faster. Even though we had to construct an extra instance of B and C in the above example to be able to compare the type information. If that’s costly and/or we must do this several times, we could create a map of std::type_index objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // ... const std::map&lt;std::string, std::type_index&gt; typeMap = { {&quot;A&quot;, std::type_index(typeid(A{}))}, {&quot;B&quot;, std::type_index(typeid(B{}))}, {&quot;C&quot;, std::type_index(typeid(C{}))} }; if (p2) { std::cout &lt;&lt; &quot;p1 is like B*. it&#39;s convertible to B\n&quot;; } else if (p3) { // we won&#39;t reach this branch due to bad ordering of if/else branches std::cout &lt;&lt; &quot;p1 is like C*. it&#39;s convertible to C\n&quot;; } if (typeid(*p1) == typeMap.at(&quot;B&quot;)) { std::cout &lt;&lt; &quot;*p1 is B\n&quot;; } else if (typeid(*p1) == typeMap.at(&quot;C&quot;)) { std::cout &lt;&lt; &quot;*p1 is C\n&quot;; } // ... There is a couple of things to note: - typeMap is const. It’s necessary, because std::type_index is a copyable wrapper around the non-copyable std::type_info. It is not default constructible. In other words, if the map is not const, then the code wouldn’t compile as a mutable map’s value type must be default constructible. std::type_index is a copyable wrapper around the non-copyable std::type_info. As std::type_index does not have a default constructor, you cannot use operator=() to add new items to the map. You either initialize it at declaration (which is preferable), or you use the insert() method. We use map::at() and cannot use map::operator[]. The reason is that map::operator[] is not const whereas map::at() has a const overload. Overall, the best is still avoiding both using typeid and dynamic_cast. When to still use dyanmic_cast? The C++ core guidelines explain well the differences between casting to a pointer or a reference type and when you should refer which (C.147 and C.148), but it doesn’t mean that you should use any. In fact, even C.153 says that you should prefer using virtual functions to casting. Casting is error-prone and you can make mess it up easily. Virtual functions are safe and when you call virtual functions it’s guaranteed that you’ll reach the most derived function. On the other hand, we saw with dynamic_cast that you might end up calling an intermediary function. As we saw earlier, with virtual functions your code will be cleaner and speed is not an issue because dynamic_cast is (also) slow. Conclusion With Run-time Type Information, we get access to typeid() and dynamic_cast. They help us query the dynamic types of polymorphic objects. In other words, they help us identify which derived objects are held by base class pointers. With great power, we also get great responsibility. Sadly, experience shows that responsibility is often abused. These tools are often overused and result in messy code. Using virtual functions and relying on dynamic dispatching is almost always better. Besides having cleaner code, you can also benefit from shorter compile times and smaller binaries as the type information doesn’t have to be generated and stored. To me, turning RTTI off is a great option to consider. Do you rely on it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Recently, in the binary sizes series, we discussed how run-time type information affects RTTI. I also mentioned that in my opinion the lack of RTTI leads to better practices and you’ll end up with a more readable, more maintainable code. It’s time to delve into this topic and see why. What is RTTI again? But first of all, let’s quickly recap what is run-time type information. RTTI let us have information on the dynamic type of reference/pointer types. It lets us use dyanamic_casts and also call the typeid() function and query the returned instance of std::type_info. I think that not having access to these tools will let you write better code. Why so? Let’s start with probably the less controversial tool. Don’t rely on typeid() Inexperienced programmers might want to automatically use typeid().name() to see what’s the dynamic type of something during development and testing. It’s usually not kept because often the output is not that readable. I mean for int, you might simply get i. That’s something easily recognizable, but not something you’d want to see in the logs. The bigger problem is that the output is implementation-defined, so you really shouldn’t count on it if you want code that is portable. (Even though there is a fair chance that they will be the same on GCC and clang). Let’s see a couple of examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; int main() { std::cout &lt;&lt; typeid(5).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(5u).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(5.0).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(true).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(&#39;5&#39;).name() &lt;&lt; &#39;\n&#39;; return 0; } /* gcc: i j d b c clang: i j d b c */ Different outputs among compilers do not mean that you cannot use them consistently. You can still use typeid().name() or typeid.hash() to compare types against each other in your code and branch the execution based on those comparisons… On the other hand, you don’t have many reasons to do that. If you have to deal with, if you have to compare unrelated types, probably you should extract the type-dependent code and use different overloads. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;vector&gt; class Wine { public: virtual ~Wine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is wine\n&quot;; } }; class WhiteWine { public: virtual ~WhiteWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is white wine\n&quot;; } }; class RedWine { public: virtual ~RedWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is red wine\n&quot;; } }; class RoseWine { public: virtual ~RoseWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is rose wine\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Wine&gt;&gt; wines; auto wine1 = std::make_unique&lt;WhiteWine&gt;(); auto wine2 = std::make_unique&lt;RedWine&gt;(); auto wine3 = std::make_unique&lt;RoseWine&gt;(); } If the types are from the same inheritance tree, then you should either use dynamic_casts or even better, you should benefit from dynamic dispatching. dynamic_cast is slightly better, but still should be avoided dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type. In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } Many would say that this is a code smell. I’m among them. Many would go further and say that using dynamic_cast in general is a code smell. As mentioned earlier, this is almost always better than relying on typeid(), but behind dyanimc_casts you’ll only find bad inheritance trees and messed up APIs. Rather than having different public interfaces, we should have a unified one. There is a convenient reason for that. If the interface is unified, we don’t need to cast our objects, we can simply rely on runtime dispatching of our function calls. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; virtual void doSomeFun() = 0; }; class OffRoader: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\n&quot;; } }; class Van: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;attach third seatrow in a van\n&quot;; } }; class Roadster: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { car-&gt;doSomeFun(); } return 0; } When typeid is still better? As I mentioned earlier, while dynamic_cast is not a good solution, it’s almost always better than using typeid(). Why not always? There is a not-so-subtle difference between these 2 RTTI tools. dynamic_cast checks whether an object “is kind of” another class. But typeid() will look for an exact match. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class A { public: virtual ~A() = default; }; class B: public A { }; class C: public B { }; int main() { std::unique_ptr&lt;A&gt; p1 = std::make_unique&lt;C&gt;(); B* p2 = dynamic_cast&lt;B*&gt;(p1.get()); C* p3 = dynamic_cast&lt;C*&gt;(p1.get()); if (p2) { std::cout &lt;&lt; &quot;p1 is like B*. it&#39;s convertible to B\n&quot;; } else if (p3) { // we won&#39;t reach this branch due to bad ordering of if/else branches std::cout &lt;&lt; &quot;p1 is like C*. it&#39;s convertible to C\n&quot;; } if (typeid(*p1) == typeid(B{})) { std::cout &lt;&lt; &quot;*p1 is B\n&quot;; } else if (typeid(*p1) == typeid(C{})) { std::cout &lt;&lt; &quot;*p1 is C\n&quot;; } return 0; } /* p1 is like B*. it&#39;s convertible to B *p1 is C */ As such, typeid() is both simpler and faster. Even though we had to construct an extra instance of B and C in the above example to be able to compare the type information. If that’s costly and/or we must do this several times, we could create a map of std::type_index objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // ... const std::map&lt;std::string, std::type_index&gt; typeMap = { {&quot;A&quot;, std::type_index(typeid(A{}))}, {&quot;B&quot;, std::type_index(typeid(B{}))}, {&quot;C&quot;, std::type_index(typeid(C{}))} }; if (p2) { std::cout &lt;&lt; &quot;p1 is like B*. it&#39;s convertible to B\n&quot;; } else if (p3) { // we won&#39;t reach this branch due to bad ordering of if/else branches std::cout &lt;&lt; &quot;p1 is like C*. it&#39;s convertible to C\n&quot;; } if (typeid(*p1) == typeMap.at(&quot;B&quot;)) { std::cout &lt;&lt; &quot;*p1 is B\n&quot;; } else if (typeid(*p1) == typeMap.at(&quot;C&quot;)) { std::cout &lt;&lt; &quot;*p1 is C\n&quot;; } // ... There is a couple of things to note: - typeMap is const. It’s necessary, because std::type_index is a copyable wrapper around the non-copyable std::type_info. It is not default constructible. In other words, if the map is not const, then the code wouldn’t compile as a mutable map’s value type must be default constructible. std::type_index is a copyable wrapper around the non-copyable std::type_info. As std::type_index does not have a default constructor, you cannot use operator=() to add new items to the map. You either initialize it at declaration (which is preferable), or you use the insert() method. We use map::at() and cannot use map::operator[]. The reason is that map::operator[] is not const whereas map::at() has a const overload. Overall, the best is still avoiding both using typeid and dynamic_cast. When to still use dyanmic_cast? The C++ core guidelines explain well the differences between casting to a pointer or a reference type and when you should refer which (C.147 and C.148), but it doesn’t mean that you should use any. In fact, even C.153 says that you should prefer using virtual functions to casting. Casting is error-prone and you can make mess it up easily. Virtual functions are safe and when you call virtual functions it’s guaranteed that you’ll reach the most derived function. On the other hand, we saw with dynamic_cast that you might end up calling an intermediary function. As we saw earlier, with virtual functions your code will be cleaner and speed is not an issue because dynamic_cast is (also) slow. Conclusion With Run-time Type Information, we get access to typeid() and dynamic_cast. They help us query the dynamic types of polymorphic objects. In other words, they help us identify which derived objects are held by base class pointers. With great power, we also get great responsibility. Sadly, experience shows that responsibility is often abused. These tools are often overused and result in messy code. Using virtual functions and relying on dynamic dispatching is almost always better. Besides having cleaner code, you can also benefit from shorter compile times and smaller binaries as the type information doesn’t have to be generated and stored. To me, turning RTTI off is a great option to consider. Do you rely on it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-26T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Without RTTI your code will be cleaner" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-05T23:32:16+02:00","datePublished":"2023-04-26T00:00:00+02:00","description":"Recently, in the binary sizes series, we discussed how run-time type information affects RTTI. I also mentioned that in my opinion the lack of RTTI leads to better practices and you’ll end up with a more readable, more maintainable code. It’s time to delve into this topic and see why. What is RTTI again? But first of all, let’s quickly recap what is run-time type information. RTTI let us have information on the dynamic type of reference/pointer types. It lets us use dyanamic_casts and also call the typeid() function and query the returned instance of std::type_info. I think that not having access to these tools will let you write better code. Why so? Let’s start with probably the less controversial tool. Don’t rely on typeid() Inexperienced programmers might want to automatically use typeid().name() to see what’s the dynamic type of something during development and testing. It’s usually not kept because often the output is not that readable. I mean for int, you might simply get i. That’s something easily recognizable, but not something you’d want to see in the logs. The bigger problem is that the output is implementation-defined, so you really shouldn’t count on it if you want code that is portable. (Even though there is a fair chance that they will be the same on GCC and clang). Let’s see a couple of examples. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; int main() { std::cout &lt;&lt; typeid(5).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(5u).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(5.0).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(true).name() &lt;&lt; &#39; &#39;; std::cout &lt;&lt; typeid(&#39;5&#39;).name() &lt;&lt; &#39;\\n&#39;; return 0; } /* gcc: i j d b c clang: i j d b c */ Different outputs among compilers do not mean that you cannot use them consistently. You can still use typeid().name() or typeid.hash() to compare types against each other in your code and branch the execution based on those comparisons… On the other hand, you don’t have many reasons to do that. If you have to deal with, if you have to compare unrelated types, probably you should extract the type-dependent code and use different overloads. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;memory&gt; #include &lt;iostream&gt; #include &lt;vector&gt; class Wine { public: virtual ~Wine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is wine\\n&quot;; } }; class WhiteWine { public: virtual ~WhiteWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is white wine\\n&quot;; } }; class RedWine { public: virtual ~RedWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is red wine\\n&quot;; } }; class RoseWine { public: virtual ~RoseWine() = default; virtual void print() { std::cout &lt;&lt; &quot;this is rose wine\\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Wine&gt;&gt; wines; auto wine1 = std::make_unique&lt;WhiteWine&gt;(); auto wine2 = std::make_unique&lt;RedWine&gt;(); auto wine3 = std::make_unique&lt;RoseWine&gt;(); } If the types are from the same inheritance tree, then you should either use dynamic_casts or even better, you should benefit from dynamic dispatching. dynamic_cast is slightly better, but still should be avoided dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type. In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } Many would say that this is a code smell. I’m among them. Many would go further and say that using dynamic_cast in general is a code smell. As mentioned earlier, this is almost always better than relying on typeid(), but behind dyanimc_casts you’ll only find bad inheritance trees and messed up APIs. Rather than having different public interfaces, we should have a unified one. There is a convenient reason for that. If the interface is unified, we don’t need to cast our objects, we can simply rely on runtime dispatching of our function calls. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; virtual void doSomeFun() = 0; }; class OffRoader: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\\n&quot;; } }; class Van: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;attach third seatrow in a van\\n&quot;; } }; class Roadster: public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { car-&gt;doSomeFun(); } return 0; } When typeid is still better? As I mentioned earlier, while dynamic_cast is not a good solution, it’s almost always better than using typeid(). Why not always? There is a not-so-subtle difference between these 2 RTTI tools. dynamic_cast checks whether an object “is kind of” another class. But typeid() will look for an exact match. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class A { public: virtual ~A() = default; }; class B: public A { }; class C: public B { }; int main() { std::unique_ptr&lt;A&gt; p1 = std::make_unique&lt;C&gt;(); B* p2 = dynamic_cast&lt;B*&gt;(p1.get()); C* p3 = dynamic_cast&lt;C*&gt;(p1.get()); if (p2) { std::cout &lt;&lt; &quot;p1 is like B*. it&#39;s convertible to B\\n&quot;; } else if (p3) { // we won&#39;t reach this branch due to bad ordering of if/else branches std::cout &lt;&lt; &quot;p1 is like C*. it&#39;s convertible to C\\n&quot;; } if (typeid(*p1) == typeid(B{})) { std::cout &lt;&lt; &quot;*p1 is B\\n&quot;; } else if (typeid(*p1) == typeid(C{})) { std::cout &lt;&lt; &quot;*p1 is C\\n&quot;; } return 0; } /* p1 is like B*. it&#39;s convertible to B *p1 is C */ As such, typeid() is both simpler and faster. Even though we had to construct an extra instance of B and C in the above example to be able to compare the type information. If that’s costly and/or we must do this several times, we could create a map of std::type_index objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // ... const std::map&lt;std::string, std::type_index&gt; typeMap = { {&quot;A&quot;, std::type_index(typeid(A{}))}, {&quot;B&quot;, std::type_index(typeid(B{}))}, {&quot;C&quot;, std::type_index(typeid(C{}))} }; if (p2) { std::cout &lt;&lt; &quot;p1 is like B*. it&#39;s convertible to B\\n&quot;; } else if (p3) { // we won&#39;t reach this branch due to bad ordering of if/else branches std::cout &lt;&lt; &quot;p1 is like C*. it&#39;s convertible to C\\n&quot;; } if (typeid(*p1) == typeMap.at(&quot;B&quot;)) { std::cout &lt;&lt; &quot;*p1 is B\\n&quot;; } else if (typeid(*p1) == typeMap.at(&quot;C&quot;)) { std::cout &lt;&lt; &quot;*p1 is C\\n&quot;; } // ... There is a couple of things to note: - typeMap is const. It’s necessary, because std::type_index is a copyable wrapper around the non-copyable std::type_info. It is not default constructible. In other words, if the map is not const, then the code wouldn’t compile as a mutable map’s value type must be default constructible. std::type_index is a copyable wrapper around the non-copyable std::type_info. As std::type_index does not have a default constructor, you cannot use operator=() to add new items to the map. You either initialize it at declaration (which is preferable), or you use the insert() method. We use map::at() and cannot use map::operator[]. The reason is that map::operator[] is not const whereas map::at() has a const overload. Overall, the best is still avoiding both using typeid and dynamic_cast. When to still use dyanmic_cast? The C++ core guidelines explain well the differences between casting to a pointer or a reference type and when you should refer which (C.147 and C.148), but it doesn’t mean that you should use any. In fact, even C.153 says that you should prefer using virtual functions to casting. Casting is error-prone and you can make mess it up easily. Virtual functions are safe and when you call virtual functions it’s guaranteed that you’ll reach the most derived function. On the other hand, we saw with dynamic_cast that you might end up calling an intermediary function. As we saw earlier, with virtual functions your code will be cleaner and speed is not an issue because dynamic_cast is (also) slow. Conclusion With Run-time Type Information, we get access to typeid() and dynamic_cast. They help us query the dynamic types of polymorphic objects. In other words, they help us identify which derived objects are held by base class pointers. With great power, we also get great responsibility. Sadly, experience shows that responsibility is often abused. These tools are often overused and result in messy code. Using virtual functions and relying on dynamic dispatching is almost always better. Besides having cleaner code, you can also benefit from shorter compile times and smaller binaries as the type information doesn’t have to be generated and stored. To me, turning RTTI off is a great option to consider. Do you rely on it? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Without RTTI your code will be cleaner","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner"},"url":"https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner"}</script><title>Without RTTI your code will be cleaner | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/26"> 26 </a> </span> <span>Without RTTI your code will be cleaner</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Without RTTI your code will be cleaner</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 26, 2023, 12:00 AM +0200" prep="on" > Apr 26, 2023 <i class="unloaded">2023-04-26T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Fri, May 5, 2023, 11:32 PM +0200" prefix="Updated " > May 5, 2023 <i class="unloaded">2023-05-05T23:32:16+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1654 words">9 min</span></div></div><div class="post-content"><p>Recently, in the binary sizes series, we discussed <a href="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti">how run-time type information affects RTTI</a>. I also mentioned that in my opinion the lack of RTTI leads to better practices and you’ll end up with a more readable, more maintainable code.</p><p>It’s time to delve into this topic and see why.</p><h2 id="what-is-rtti-again">What is RTTI again?</h2><p>But first of all, let’s quickly recap what is run-time type information. RTTI let us have information on the dynamic type of reference/pointer types. It lets us use <code class="language-plaintext highlighter-rouge">dyanamic_cast</code>s and also call the <code class="language-plaintext highlighter-rouge">typeid()</code> function and query the returned instance of <code class="language-plaintext highlighter-rouge">std::type_info</code>.</p><p>I think that not having access to these tools will let you write better code. Why so?</p><p>Let’s start with probably the less controversial tool.</p><h2 id="dont-rely-on-typeid">Don’t rely on <code class="language-plaintext highlighter-rouge">typeid()</code></h2><p>Inexperienced programmers might want to automatically use <code class="language-plaintext highlighter-rouge">typeid().name()</code> to see what’s the dynamic type of something during development and testing. It’s usually not kept because often the output is not that readable. I mean for <code class="language-plaintext highlighter-rouge">int</code>, you might simply get <code class="language-plaintext highlighter-rouge">i</code>. That’s something easily recognizable, but not something you’d want to see in the logs.</p><p>The bigger problem is that the output is implementation-defined, so you really shouldn’t count on it if you want code that is portable. (Even though there is a fair chance that they will be the same on GCC and clang).</p><p>Let’s see a couple of examples.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="mi">5</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="mi">5u</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="mf">5.0</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="nb">true</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="sc">'5'</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
gcc:   i j d b c
clang: i j d b c
*/</span>
</pre></table></code></div></div><p>Different outputs among compilers do not mean that you cannot use them consistently. You can still use <code class="language-plaintext highlighter-rouge">typeid().name()</code> or <code class="language-plaintext highlighter-rouge">typeid.hash()</code> to compare types against each other in your code and branch the execution based on those comparisons…</p><p>On the other hand, you don’t have many reasons to do that. If you have to deal with, if you have to compare unrelated types, probably you should extract the type-dependent code and use different overloads.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Wine</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Wine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is wine</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">WhiteWine</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">WhiteWine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is white wine</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RedWine</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">RedWine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is red wine</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">RoseWine</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">RoseWine</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">()</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"this is rose wine</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Wine</span><span class="o">&gt;&gt;</span> <span class="n">wines</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">wine1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">WhiteWine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">wine2</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RedWine</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">auto</span> <span class="n">wine3</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">RoseWine</span><span class="o">&gt;</span><span class="p">();</span>
<span class="p">}</span>

</pre></table></code></div></div><p>If the types are from the same inheritance tree, then you should either use <code class="language-plaintext highlighter-rouge">dynamic_cast</code>s or even better, you should benefit from dynamic dispatching.</p><h2 id="dynamic_cast-is-slightly-better-but-still-should-be-avoided"><code class="language-plaintext highlighter-rouge">dynamic_cast</code> is slightly better, but still should be avoided</h2><p><em><code class="language-plaintext highlighter-rouge">dynamic_cast</code> safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy</em> - according to <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast">CppReference</a>. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type.</p><p>In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">OffRoader</span><span class="o">*</span> <span class="n">offroader</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">OffRoader</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">offroader</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">offroader</span><span class="o">-&gt;</span><span class="n">turnOnAllWheelDrive</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Van</span><span class="o">*</span> <span class="n">van</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Van</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">van</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">van</span><span class="o">-&gt;</span><span class="n">attachThirdSeatRow</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Roadster</span><span class="o">*</span> <span class="n">roadster</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Roadster</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">roadster</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">roadster</span><span class="o">-&gt;</span><span class="n">removeRoof</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Many would say that this is a code smell. I’m among them. Many would go further and say that using <code class="language-plaintext highlighter-rouge">dynamic_cast</code> in general is a code smell.</p><p>As mentioned earlier, this is almost always better than relying on <code class="language-plaintext highlighter-rouge">typeid()</code>, but behind <code class="language-plaintext highlighter-rouge">dyanimc_cast</code>s you’ll only find bad inheritance trees and messed up APIs.</p><p>Rather than having different public interfaces, we should have a unified one.</p><p>There is a convenient reason for that. If the interface is unified, we don’t need to cast our objects, we can simply rely on runtime dispatching of our function calls.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">OffRoader</span><span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"use all wheel drive on OffRoader</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Van</span><span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"attach third seatrow in a van</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Roadster</span><span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"remove roadster's roof</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&gt;</span> <span class="n">myCars</span><span class="p">;</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OffRoader</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Van</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Roadster</span><span class="o">&gt;</span><span class="p">());</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span><span class="o">:</span> <span class="n">myCars</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">car</span><span class="o">-&gt;</span><span class="n">doSomeFun</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="when-typeid-is-still-better">When <code class="language-plaintext highlighter-rouge">typeid</code> is still better?</h2><p>As I mentioned earlier, while <code class="language-plaintext highlighter-rouge">dynamic_cast</code> is not a good solution, it’s almost always better than using <code class="language-plaintext highlighter-rouge">typeid()</code>. Why not always?</p><p>There is a not-so-subtle difference between these 2 RTTI tools. <code class="language-plaintext highlighter-rouge">dynamic_cast</code> checks whether an object “is kind of” another class. But <code class="language-plaintext highlighter-rouge">typeid()</code> will look for an exact match.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">A</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">B</span><span class="o">:</span> <span class="k">public</span> <span class="n">A</span> <span class="p">{</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">C</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>

<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">C</span><span class="o">&gt;</span><span class="p">();</span>
    
    <span class="n">B</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="n">C</span><span class="o">*</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">C</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">p1</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 is like B*. it's convertible to B</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">p3</span><span class="p">)</span> <span class="p">{</span>
        <span class="c1">// we won't reach this branch due to bad ordering of if/else branches</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 is like C*. it's convertible to C</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">B</span><span class="p">{}))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p1 is B</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)</span> <span class="o">==</span> <span class="k">typeid</span><span class="p">(</span><span class="n">C</span><span class="p">{}))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p1 is C</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
p1 is like B*. it's convertible to B
*p1 is C
*/</span>
</pre></table></code></div></div><p>As such, <code class="language-plaintext highlighter-rouge">typeid()</code> is both simpler and faster. Even though we had to construct an extra instance of <code class="language-plaintext highlighter-rouge">B</code> and <code class="language-plaintext highlighter-rouge">C</code> in the above example to be able to compare the type information. If that’s costly and/or we must do this several times, we could create a map of <code class="language-plaintext highlighter-rouge">std::type_index</code> objects.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="c1">// ...</span>
<span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">map</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="o">&gt;</span> <span class="n">typeMap</span> <span class="o">=</span> <span class="p">{</span>
    <span class="p">{</span><span class="s">"A"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">A</span><span class="p">{}))},</span>
    <span class="p">{</span><span class="s">"B"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">B</span><span class="p">{}))},</span>
    <span class="p">{</span><span class="s">"C"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">type_index</span><span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="n">C</span><span class="p">{}))}</span>
<span class="p">};</span>


<span class="k">if</span> <span class="p">(</span><span class="n">p2</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 is like B*. it's convertible to B</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">p3</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// we won't reach this branch due to bad ordering of if/else branches</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"p1 is like C*. it's convertible to C</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)</span> <span class="o">==</span> <span class="n">typeMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"B"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p1 is B</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span> <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">)</span> <span class="o">==</span> <span class="n">typeMap</span><span class="p">.</span><span class="n">at</span><span class="p">(</span><span class="s">"C"</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"*p1 is C</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
<span class="p">}</span>
<span class="c1">// ...</span>
</pre></table></code></div></div><p>There is a couple of things to note: <del>- <code class="language-plaintext highlighter-rouge">typeMap</code> is <code class="language-plaintext highlighter-rouge">const</code>. It’s necessary, because <code class="language-plaintext highlighter-rouge">std::type_index</code> is a copyable wrapper around the non-copyable <code class="language-plaintext highlighter-rouge">std::type_info</code>. It is not default constructible. In other words, if the <code class="language-plaintext highlighter-rouge">map</code> is not <code class="language-plaintext highlighter-rouge">const</code>, then the code wouldn’t compile as a mutable map’s value type must be default constructible.</del></p><ul><li><code class="language-plaintext highlighter-rouge">std::type_index</code> is a copyable wrapper around the non-copyable <code class="language-plaintext highlighter-rouge">std::type_info</code>. As <code class="language-plaintext highlighter-rouge">std::type_index</code> does not have a default constructor, you cannot use <code class="language-plaintext highlighter-rouge">operator=()</code> to add new items to the map. You either initialize it at declaration (which is preferable), or you use the <code class="language-plaintext highlighter-rouge">insert()</code> method.<li>We use <code class="language-plaintext highlighter-rouge">map::at()</code> and cannot use <code class="language-plaintext highlighter-rouge">map::operator[]</code>. The reason is that <code class="language-plaintext highlighter-rouge">map::operator[]</code> is not <code class="language-plaintext highlighter-rouge">const</code> whereas <code class="language-plaintext highlighter-rouge">map::at()</code> has a <code class="language-plaintext highlighter-rouge">const</code> overload.</ul><p>Overall, the best is still avoiding both using <code class="language-plaintext highlighter-rouge">typeid</code> and <code class="language-plaintext highlighter-rouge">dynamic_cast</code>.</p><h2 id="when-to-still-use-dyanmic_cast">When to still use <code class="language-plaintext highlighter-rouge">dyanmic_cast</code>?</h2><p>The C++ core guidelines explain well the differences between casting to a pointer or a reference type and when you should refer which (<a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c147-use-dynamic_cast-to-a-reference-type-when-failure-to-find-the-required-class-is-considered-an-error">C.147</a> and <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c148-use-dynamic_cast-to-a-pointer-type-when-failure-to-find-the-required-class-is-considered-a-valid-alternative">C.148</a>), but it doesn’t mean that you should use any.</p><p>In fact, even <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c153-prefer-virtual-function-to-casting">C.153</a> says that you should prefer using virtual functions to casting. Casting is error-prone and you can make mess it up easily. Virtual functions are safe and when you call virtual functions it’s guaranteed that you’ll reach the most derived function. On the other hand, we saw with <code class="language-plaintext highlighter-rouge">dynamic_cast</code> that you might end up calling an intermediary function.</p><p>As we saw earlier, with virtual functions your code will be cleaner and speed is not an issue because <code class="language-plaintext highlighter-rouge">dynamic_cast</code> is (also) slow.</p><h2 id="conclusion">Conclusion</h2><p>With Run-time Type Information, we get access to <code class="language-plaintext highlighter-rouge">typeid()</code> and <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. They help us query the dynamic types of polymorphic objects. In other words, they help us identify which derived objects are held by base class pointers.</p><p>With great power, we also get great responsibility. Sadly, experience shows that responsibility is often abused. These tools are often overused and result in messy code. Using <code class="language-plaintext highlighter-rouge">virtual</code> functions and relying on dynamic dispatching is almost always better.</p><p>Besides having cleaner code, you can also benefit from shorter compile times and smaller binaries as the type information doesn’t have to be generated and stored. To me, turning RTTI off is a great option to consider.</p><p>Do you rely on it?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/rtti/" class="post-tag no-text-decoration" >rtti</a> <a href="/tags/virtual/" class="post-tag no-text-decoration" >virtual</a> <a href="/tags/dynamic-cast/" class="post-tag no-text-decoration" >dynamic_cast</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Without RTTI your code will be cleaner - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Without RTTI your code will be cleaner - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Without RTTI your code will be cleaner - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Without RTTI your code will be cleaner - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2018/07/05/cpp-override"><div class="card-body"> <span class="timeago small" > Jul 5, 2018 <i class="unloaded">2018-07-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Why to use the override specifier in C++ 11?</h3><div class="text-muted small"><p> The override specifier was introduced to the language with C++11 and it is one of the easiest tool to significantly improve the maintainability of our codebases. override tells both the reader an...</p></div></div></a></div><div class="card"> <a href="/blog/2021/11/24/production-issues-part-i-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Nov 24, 2021 <i class="unloaded">2021-11-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>I broke production 3 times in 3 weeks - Part I</h3><div class="text-muted small"><p> Are you a careful coder who barely introduces errors? How do you feel when still manage to bring production down? You might feel horrible, but I think you should take it as an opportunity. You can...</p></div></div></a></div><div class="card"> <a href="/blog/2021/12/01/production-issues-part-ii"><div class="card-body"> <span class="timeago small" > Dec 1, 2021 <i class="unloaded">2021-12-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>I broke production 3 times in 3 weeks - Part II</h3><div class="text-muted small"><p> Last week I shared with you that despite that I consider myself a careful coder, I managed to break production several times in a row. It can happen to anyone, though one shouldn’t forget about hi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/04/19/we-are-always-late" class="btn btn-outline-primary" prompt="Older"><p>We are always late</p></a> <a href="/blog/2023/05/03/variadic-functions-vs-variadic-templates" class="btn btn-outline-primary" prompt="Newer"><p>Variadic functions vs variadic templates</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Without RTTI your code will be cleaner'; this.page.url = 'https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner'; this.page.identifier = '/blog/2023/04/26/without-rtti-your-code-will-be-cleaner'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
