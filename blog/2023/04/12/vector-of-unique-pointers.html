<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Vectors and unique pointers" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this post, I want to share some struggles I had twice during the last few months. For one of my examples, I wanted to initialize a std::vector with std::unique_ptr. It didn’t compile and I had little time, I didn’t even think about it. I waved my hand and changed my example. Then I ran into the same issue at work, while we were pairing over an issue. I couldn’t just wave anymore, and luckily we also had the time to go a bit deeper. What we wanted was a little bit different and more complex though. We wanted to return a vector of unique pointers to a struct that holds - among others - a unique pointer. This is a simplified version of what we wanted: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Resource { // unimportant }; struct Wrapper { std::string name; std::unique_ptr&lt;Resource&gt; resource; }; // somewhere in a function std::vector&lt;std::unique_ptr&lt;Wrapper&gt;&gt; v{ std::make_unique&lt;Wrapper&gt;(std::move(aName), std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(std::move(anotherName), std::make_unique&lt;Resource&gt;()) }; That’s a bit too complex to start with, so let’s dissect the issue into two parts. No compiler-generated copy constructor Let’s first omit the external unique pointer and try to brace-initialize a vector of Wrapper objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{Wrapper{aName, std::make_unique&lt;Resource&gt;()}}; } The first part of the problem is that we cannot {}-initialize this vector of Wrappers. Even though it seems alright at a first glance. Wrapper is a struct with public members and no explicitly defined special functions. Our {}-initialization follows the right syntax and the parameters are passed in the right order. Still, the compiler says stop! Here is a part of the error messages. As vector is a template we cannot expect a concise message. 1 2 /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type 90 | static_assert(is_constructible&lt;_ValueType, _Tp&gt;::value, If we scroll up in the errors we’ll find a more explanatory line: 1 In instantiation of &#39;constexpr bool std::__check_constructible() [with _ValueType = Wrapper; _Tp = const Wrapper&amp;]&#39;: So the problem is Wrapper cannot be constructed from const Wrapper&amp;, in other words, Wrapper cannot be copy constructed. That makes sense! It has a move-only member, std::unique_ptr&lt;Resource&gt; m_resource! Because of this move-only member, the compiler cannot automatically generate a copy constructor. A std::vector always copies its std::initializer_list That’s all fine but why do we need a copy constructor? Why cannot we benefit from move semantics? We can spot the answer on C++ Reference! std::vector has only one constructor involving a std::initializer_list and there the initializer_list is taken by value. In other words, vector copies its initializer_list. Always. As the passed in initializer_list is going to be copied, the contained type must be copy-constructible. That’s clearly not the case for Wrapper which we can easily assert. 1 2 3 4 5 6 7 8 9 10 11 struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; }; static_assert(std::is_copy_constructible&lt;Wrapper&gt;()); /* main.cpp:18:20: error: static assertion failed 18 | static_assert(std::is_copy_constructible&lt;Wrapper&gt;()); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ Let’s make contained types copy constructible That’s quite easy to fix, we need to provide a user-defined copy constructor, such as Wrapper(const Wrapper&amp; other): m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {}. At the same time, let’s not forget about the rules of 0/3/5, so we should provide all the special functions. Now we don’t have the problem anymore, we can easily use the brace initialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() = default; ~Wrapper() = default; Wrapper(std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) {} Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {} Wrapper(Wrapper&amp;&amp; other) = default; Wrapper&amp; operator=(const Wrapper&amp; other) { m_name = other.m_name; m_resource = std::make_unique&lt;Resource&gt;(); return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) = default; }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{Wrapper{aName, std::make_unique&lt;Resource&gt;()}}; } But what if we cannot or do not want to modify Wrapper? Do we have any other options? Of course! We can also extract vector initialization If we have to avoid the brace-initialization of the vector, we can simply default initialize it, probably reserving then enough space for the items we want to add, and use either vector’s emplace_back() or push_back() methods. There is not a big difference in this case between emplace_back() and push_back(). push_back() will call the appropriate constructor first and then the move constructor. emplace_back() will only make one constructor call. At least that’s the theory. Let’s see if we’re right. I amended Wrapper so that each of its special functions prints. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() { std::cout &lt;&lt; &quot;Wrapper()\n&quot;; } ~Wrapper() { std::cout &lt;&lt; &quot;~Wrapper()\n&quot;; } Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) { std::cout &lt;&lt; &quot;Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource)\n&quot;; } Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;(*other.m_resource)) { std::cout &lt;&lt; &quot;Wrapper (const Wrapper&amp; other)\n&quot;; } Wrapper(Wrapper&amp;&amp; other) { std::cout &lt;&lt; &quot;Wrapper (Wrapper&amp;&amp; other)\n&quot;; } Wrapper&amp; operator=(const Wrapper&amp; other) { std::cout &lt;&lt; &quot;Wrapper&amp; operator=(const Wrapper&amp; other)\n&quot;; return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) { std::cout &lt;&lt; &quot;Wrapper&amp; operator=(Wrapper&amp;&amp; other)\n&quot;; return *this; } }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{}; v.emplace_back(aName, std::make_unique&lt;Resource&gt;()); // v.push_back(Wrapper(aName, std::make_unique&lt;Resource&gt;())); } /* output with emplace_back: Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) ~Wrapper() */ /* output with push_back Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) Wrapper (Wrapper&amp;&amp; other) ~Wrapper() ~Wrapper() */ Our assumption was right, except that I forgot to note the extra destructor call on a moved-from object. While these extra calls would be often negligible, we have no reason not to use emplace_back(). It’s not more difficult to write it and it’s better for the performance. With that, we’ve seen why we couldn’t {}-initialize a vector of Wrappers following the rule of zero, where Wrapper is a type that allocates on the heap. Now let’s move over to the other issue. The same issue with initializer_list once again Actually, by answering the first question, we also learned why we cannot {}-initialize a vector of unique_ptrs. It’s the problem of an initializer_list taken by value instead of reference and the fact that unique_ptrs cannot be copied. Can we do anything to improve the situation? We can extract the creation and population of the vector to a separate method so that we don’t have the visual noise of vector insertions along with the rest of the code. 1 2 3 4 5 6 7 8 9 10 11 12 13 std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; createResources() { std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; vec; vec.push_back(std::make_unique&lt;Resource&gt;()); vec.push_back(std::make_unique&lt;Resource&gt;()); vec.push_back(std::make_unique&lt;Resource&gt;()); return vec; } int main() { std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; resources = createResources(); // ... } But can we do something better? We can make a better, generalized function that makes us a vector of unique_ptrs, but the idea behind is essentially the same: the pointers are added one by one after the construction of the vector. Let me borrow an implementation by Bartek. I take this piece of code from C++ Storties and I encourage you to read the whole article on initializer_list: 1 2 3 4 5 6 7 template&lt;typename T, typename... Args&gt; auto makeVector(Args&amp;&amp;... args) { std::vector&lt;T&gt; vec; vec.reserve(sizeof...(Args)); (vec.emplace_back(std::forward&lt;Args&gt;(args)), ...); return vec; } Now we can update our original example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() = default; ~Wrapper() = default; Wrapper(std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) {} Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {} Wrapper(Wrapper&amp;&amp; other) = default; Wrapper&amp; operator=(const Wrapper&amp; other) { m_name = other.m_name; m_resource = std::make_unique&lt;Resource&gt;(); return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) = default; }; // this is from Bartek: https://www.cppstories.com/2023/initializer_list_improvements/ template&lt;typename T, typename... Args&gt; auto makeVector(Args&amp;&amp;... args) { std::vector&lt;T&gt; vec; vec.reserve(sizeof...(Args)); (vec.emplace_back(std::forward&lt;Args&gt;(args)), ...); return vec; } int main() { [[maybe_unused]] std::vector&lt;std::unique_ptr&lt;Wrapper&gt;&gt; v = makeVector&lt;std::unique_ptr&lt;Wrapper&gt;&gt;( std::make_unique&lt;Wrapper&gt;(&quot;keyboard&quot;, std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(&quot;mouse&quot;, std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(&quot;screen&quot;, std::make_unique&lt;Resource&gt;()) ); return 0; } Conclusion Today, I shared with you a problem I faced lately. I wanted to {}-initialize a vector of unique pointers, but it didn’t work. A std::vector takes an initializer_list by value, so it makes a copy of it. Hence, the compilation will fail if you try to use an initializer_list with move-only types. If you want to use the {}-initializer for a vector, you need to implement the move constructor. If that’s not an option and you want to separate the creation of the vector, you have no other option than move the related code to a separate function. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this post, I want to share some struggles I had twice during the last few months. For one of my examples, I wanted to initialize a std::vector with std::unique_ptr. It didn’t compile and I had little time, I didn’t even think about it. I waved my hand and changed my example. Then I ran into the same issue at work, while we were pairing over an issue. I couldn’t just wave anymore, and luckily we also had the time to go a bit deeper. What we wanted was a little bit different and more complex though. We wanted to return a vector of unique pointers to a struct that holds - among others - a unique pointer. This is a simplified version of what we wanted: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Resource { // unimportant }; struct Wrapper { std::string name; std::unique_ptr&lt;Resource&gt; resource; }; // somewhere in a function std::vector&lt;std::unique_ptr&lt;Wrapper&gt;&gt; v{ std::make_unique&lt;Wrapper&gt;(std::move(aName), std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(std::move(anotherName), std::make_unique&lt;Resource&gt;()) }; That’s a bit too complex to start with, so let’s dissect the issue into two parts. No compiler-generated copy constructor Let’s first omit the external unique pointer and try to brace-initialize a vector of Wrapper objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{Wrapper{aName, std::make_unique&lt;Resource&gt;()}}; } The first part of the problem is that we cannot {}-initialize this vector of Wrappers. Even though it seems alright at a first glance. Wrapper is a struct with public members and no explicitly defined special functions. Our {}-initialization follows the right syntax and the parameters are passed in the right order. Still, the compiler says stop! Here is a part of the error messages. As vector is a template we cannot expect a concise message. 1 2 /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type 90 | static_assert(is_constructible&lt;_ValueType, _Tp&gt;::value, If we scroll up in the errors we’ll find a more explanatory line: 1 In instantiation of &#39;constexpr bool std::__check_constructible() [with _ValueType = Wrapper; _Tp = const Wrapper&amp;]&#39;: So the problem is Wrapper cannot be constructed from const Wrapper&amp;, in other words, Wrapper cannot be copy constructed. That makes sense! It has a move-only member, std::unique_ptr&lt;Resource&gt; m_resource! Because of this move-only member, the compiler cannot automatically generate a copy constructor. A std::vector always copies its std::initializer_list That’s all fine but why do we need a copy constructor? Why cannot we benefit from move semantics? We can spot the answer on C++ Reference! std::vector has only one constructor involving a std::initializer_list and there the initializer_list is taken by value. In other words, vector copies its initializer_list. Always. As the passed in initializer_list is going to be copied, the contained type must be copy-constructible. That’s clearly not the case for Wrapper which we can easily assert. 1 2 3 4 5 6 7 8 9 10 11 struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; }; static_assert(std::is_copy_constructible&lt;Wrapper&gt;()); /* main.cpp:18:20: error: static assertion failed 18 | static_assert(std::is_copy_constructible&lt;Wrapper&gt;()); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ Let’s make contained types copy constructible That’s quite easy to fix, we need to provide a user-defined copy constructor, such as Wrapper(const Wrapper&amp; other): m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {}. At the same time, let’s not forget about the rules of 0/3/5, so we should provide all the special functions. Now we don’t have the problem anymore, we can easily use the brace initialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() = default; ~Wrapper() = default; Wrapper(std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) {} Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {} Wrapper(Wrapper&amp;&amp; other) = default; Wrapper&amp; operator=(const Wrapper&amp; other) { m_name = other.m_name; m_resource = std::make_unique&lt;Resource&gt;(); return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) = default; }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{Wrapper{aName, std::make_unique&lt;Resource&gt;()}}; } But what if we cannot or do not want to modify Wrapper? Do we have any other options? Of course! We can also extract vector initialization If we have to avoid the brace-initialization of the vector, we can simply default initialize it, probably reserving then enough space for the items we want to add, and use either vector’s emplace_back() or push_back() methods. There is not a big difference in this case between emplace_back() and push_back(). push_back() will call the appropriate constructor first and then the move constructor. emplace_back() will only make one constructor call. At least that’s the theory. Let’s see if we’re right. I amended Wrapper so that each of its special functions prints. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() { std::cout &lt;&lt; &quot;Wrapper()\n&quot;; } ~Wrapper() { std::cout &lt;&lt; &quot;~Wrapper()\n&quot;; } Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) { std::cout &lt;&lt; &quot;Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource)\n&quot;; } Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;(*other.m_resource)) { std::cout &lt;&lt; &quot;Wrapper (const Wrapper&amp; other)\n&quot;; } Wrapper(Wrapper&amp;&amp; other) { std::cout &lt;&lt; &quot;Wrapper (Wrapper&amp;&amp; other)\n&quot;; } Wrapper&amp; operator=(const Wrapper&amp; other) { std::cout &lt;&lt; &quot;Wrapper&amp; operator=(const Wrapper&amp; other)\n&quot;; return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) { std::cout &lt;&lt; &quot;Wrapper&amp; operator=(Wrapper&amp;&amp; other)\n&quot;; return *this; } }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{}; v.emplace_back(aName, std::make_unique&lt;Resource&gt;()); // v.push_back(Wrapper(aName, std::make_unique&lt;Resource&gt;())); } /* output with emplace_back: Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) ~Wrapper() */ /* output with push_back Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) Wrapper (Wrapper&amp;&amp; other) ~Wrapper() ~Wrapper() */ Our assumption was right, except that I forgot to note the extra destructor call on a moved-from object. While these extra calls would be often negligible, we have no reason not to use emplace_back(). It’s not more difficult to write it and it’s better for the performance. With that, we’ve seen why we couldn’t {}-initialize a vector of Wrappers following the rule of zero, where Wrapper is a type that allocates on the heap. Now let’s move over to the other issue. The same issue with initializer_list once again Actually, by answering the first question, we also learned why we cannot {}-initialize a vector of unique_ptrs. It’s the problem of an initializer_list taken by value instead of reference and the fact that unique_ptrs cannot be copied. Can we do anything to improve the situation? We can extract the creation and population of the vector to a separate method so that we don’t have the visual noise of vector insertions along with the rest of the code. 1 2 3 4 5 6 7 8 9 10 11 12 13 std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; createResources() { std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; vec; vec.push_back(std::make_unique&lt;Resource&gt;()); vec.push_back(std::make_unique&lt;Resource&gt;()); vec.push_back(std::make_unique&lt;Resource&gt;()); return vec; } int main() { std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; resources = createResources(); // ... } But can we do something better? We can make a better, generalized function that makes us a vector of unique_ptrs, but the idea behind is essentially the same: the pointers are added one by one after the construction of the vector. Let me borrow an implementation by Bartek. I take this piece of code from C++ Storties and I encourage you to read the whole article on initializer_list: 1 2 3 4 5 6 7 template&lt;typename T, typename... Args&gt; auto makeVector(Args&amp;&amp;... args) { std::vector&lt;T&gt; vec; vec.reserve(sizeof...(Args)); (vec.emplace_back(std::forward&lt;Args&gt;(args)), ...); return vec; } Now we can update our original example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() = default; ~Wrapper() = default; Wrapper(std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) {} Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {} Wrapper(Wrapper&amp;&amp; other) = default; Wrapper&amp; operator=(const Wrapper&amp; other) { m_name = other.m_name; m_resource = std::make_unique&lt;Resource&gt;(); return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) = default; }; // this is from Bartek: https://www.cppstories.com/2023/initializer_list_improvements/ template&lt;typename T, typename... Args&gt; auto makeVector(Args&amp;&amp;... args) { std::vector&lt;T&gt; vec; vec.reserve(sizeof...(Args)); (vec.emplace_back(std::forward&lt;Args&gt;(args)), ...); return vec; } int main() { [[maybe_unused]] std::vector&lt;std::unique_ptr&lt;Wrapper&gt;&gt; v = makeVector&lt;std::unique_ptr&lt;Wrapper&gt;&gt;( std::make_unique&lt;Wrapper&gt;(&quot;keyboard&quot;, std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(&quot;mouse&quot;, std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(&quot;screen&quot;, std::make_unique&lt;Resource&gt;()) ); return 0; } Conclusion Today, I shared with you a problem I faced lately. I wanted to {}-initialize a vector of unique pointers, but it didn’t work. A std::vector takes an initializer_list by value, so it makes a copy of it. Hence, the compilation will fail if you try to use an initializer_list with move-only types. If you want to use the {}-initializer for a vector, you need to implement the move constructor. If that’s not an option and you want to separate the creation of the vector, you have no other option than move the related code to a separate function. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-12T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Vectors and unique pointers" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-09-24T23:19:08+02:00","datePublished":"2023-04-12T00:00:00+02:00","description":"In this post, I want to share some struggles I had twice during the last few months. For one of my examples, I wanted to initialize a std::vector with std::unique_ptr. It didn’t compile and I had little time, I didn’t even think about it. I waved my hand and changed my example. Then I ran into the same issue at work, while we were pairing over an issue. I couldn’t just wave anymore, and luckily we also had the time to go a bit deeper. What we wanted was a little bit different and more complex though. We wanted to return a vector of unique pointers to a struct that holds - among others - a unique pointer. This is a simplified version of what we wanted: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 class Resource { // unimportant }; struct Wrapper { std::string name; std::unique_ptr&lt;Resource&gt; resource; }; // somewhere in a function std::vector&lt;std::unique_ptr&lt;Wrapper&gt;&gt; v{ std::make_unique&lt;Wrapper&gt;(std::move(aName), std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(std::move(anotherName), std::make_unique&lt;Resource&gt;()) }; That’s a bit too complex to start with, so let’s dissect the issue into two parts. No compiler-generated copy constructor Let’s first omit the external unique pointer and try to brace-initialize a vector of Wrapper objects. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{Wrapper{aName, std::make_unique&lt;Resource&gt;()}}; } The first part of the problem is that we cannot {}-initialize this vector of Wrappers. Even though it seems alright at a first glance. Wrapper is a struct with public members and no explicitly defined special functions. Our {}-initialization follows the right syntax and the parameters are passed in the right order. Still, the compiler says stop! Here is a part of the error messages. As vector is a template we cannot expect a concise message. 1 2 /opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type 90 | static_assert(is_constructible&lt;_ValueType, _Tp&gt;::value, If we scroll up in the errors we’ll find a more explanatory line: 1 In instantiation of &#39;constexpr bool std::__check_constructible() [with _ValueType = Wrapper; _Tp = const Wrapper&amp;]&#39;: So the problem is Wrapper cannot be constructed from const Wrapper&amp;, in other words, Wrapper cannot be copy constructed. That makes sense! It has a move-only member, std::unique_ptr&lt;Resource&gt; m_resource! Because of this move-only member, the compiler cannot automatically generate a copy constructor. A std::vector always copies its std::initializer_list That’s all fine but why do we need a copy constructor? Why cannot we benefit from move semantics? We can spot the answer on C++ Reference! std::vector has only one constructor involving a std::initializer_list and there the initializer_list is taken by value. In other words, vector copies its initializer_list. Always. As the passed in initializer_list is going to be copied, the contained type must be copy-constructible. That’s clearly not the case for Wrapper which we can easily assert. 1 2 3 4 5 6 7 8 9 10 11 struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; }; static_assert(std::is_copy_constructible&lt;Wrapper&gt;()); /* main.cpp:18:20: error: static assertion failed 18 | static_assert(std::is_copy_constructible&lt;Wrapper&gt;()); | ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ */ Let’s make contained types copy constructible That’s quite easy to fix, we need to provide a user-defined copy constructor, such as Wrapper(const Wrapper&amp; other): m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {}. At the same time, let’s not forget about the rules of 0/3/5, so we should provide all the special functions. Now we don’t have the problem anymore, we can easily use the brace initialization. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() = default; ~Wrapper() = default; Wrapper(std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) {} Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {} Wrapper(Wrapper&amp;&amp; other) = default; Wrapper&amp; operator=(const Wrapper&amp; other) { m_name = other.m_name; m_resource = std::make_unique&lt;Resource&gt;(); return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) = default; }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{Wrapper{aName, std::make_unique&lt;Resource&gt;()}}; } But what if we cannot or do not want to modify Wrapper? Do we have any other options? Of course! We can also extract vector initialization If we have to avoid the brace-initialization of the vector, we can simply default initialize it, probably reserving then enough space for the items we want to add, and use either vector’s emplace_back() or push_back() methods. There is not a big difference in this case between emplace_back() and push_back(). push_back() will call the appropriate constructor first and then the move constructor. emplace_back() will only make one constructor call. At least that’s the theory. Let’s see if we’re right. I amended Wrapper so that each of its special functions prints. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() { std::cout &lt;&lt; &quot;Wrapper()\\n&quot;; } ~Wrapper() { std::cout &lt;&lt; &quot;~Wrapper()\\n&quot;; } Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) { std::cout &lt;&lt; &quot;Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource)\\n&quot;; } Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;(*other.m_resource)) { std::cout &lt;&lt; &quot;Wrapper (const Wrapper&amp; other)\\n&quot;; } Wrapper(Wrapper&amp;&amp; other) { std::cout &lt;&lt; &quot;Wrapper (Wrapper&amp;&amp; other)\\n&quot;; } Wrapper&amp; operator=(const Wrapper&amp; other) { std::cout &lt;&lt; &quot;Wrapper&amp; operator=(const Wrapper&amp; other)\\n&quot;; return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) { std::cout &lt;&lt; &quot;Wrapper&amp; operator=(Wrapper&amp;&amp; other)\\n&quot;; return *this; } }; int main() { std::string aName = &quot;bla&quot;; std::vector&lt;Wrapper&gt; v{}; v.emplace_back(aName, std::make_unique&lt;Resource&gt;()); // v.push_back(Wrapper(aName, std::make_unique&lt;Resource&gt;())); } /* output with emplace_back: Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) ~Wrapper() */ /* output with push_back Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource) Wrapper (Wrapper&amp;&amp; other) ~Wrapper() ~Wrapper() */ Our assumption was right, except that I forgot to note the extra destructor call on a moved-from object. While these extra calls would be often negligible, we have no reason not to use emplace_back(). It’s not more difficult to write it and it’s better for the performance. With that, we’ve seen why we couldn’t {}-initialize a vector of Wrappers following the rule of zero, where Wrapper is a type that allocates on the heap. Now let’s move over to the other issue. The same issue with initializer_list once again Actually, by answering the first question, we also learned why we cannot {}-initialize a vector of unique_ptrs. It’s the problem of an initializer_list taken by value instead of reference and the fact that unique_ptrs cannot be copied. Can we do anything to improve the situation? We can extract the creation and population of the vector to a separate method so that we don’t have the visual noise of vector insertions along with the rest of the code. 1 2 3 4 5 6 7 8 9 10 11 12 13 std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; createResources() { std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; vec; vec.push_back(std::make_unique&lt;Resource&gt;()); vec.push_back(std::make_unique&lt;Resource&gt;()); vec.push_back(std::make_unique&lt;Resource&gt;()); return vec; } int main() { std::vector&lt;std::unique_ptr&lt;Resource&gt;&gt; resources = createResources(); // ... } But can we do something better? We can make a better, generalized function that makes us a vector of unique_ptrs, but the idea behind is essentially the same: the pointers are added one by one after the construction of the vector. Let me borrow an implementation by Bartek. I take this piece of code from C++ Storties and I encourage you to read the whole article on initializer_list: 1 2 3 4 5 6 7 template&lt;typename T, typename... Args&gt; auto makeVector(Args&amp;&amp;... args) { std::vector&lt;T&gt; vec; vec.reserve(sizeof...(Args)); (vec.emplace_back(std::forward&lt;Args&gt;(args)), ...); return vec; } Now we can update our original example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 #include &lt;memory&gt; #include &lt;string&gt; #include &lt;vector&gt; #include &lt;iostream&gt; class Resource { // unimportant }; struct Wrapper { std::string m_name; std::unique_ptr&lt;Resource&gt; m_resource; Wrapper() = default; ~Wrapper() = default; Wrapper(std::string name, std::unique_ptr&lt;Resource&gt; resource) : m_name(std::move(name)), m_resource(std::move(resource)) {} Wrapper(const Wrapper&amp; other) : m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {} Wrapper(Wrapper&amp;&amp; other) = default; Wrapper&amp; operator=(const Wrapper&amp; other) { m_name = other.m_name; m_resource = std::make_unique&lt;Resource&gt;(); return *this; } Wrapper&amp; operator=(Wrapper&amp;&amp; other) = default; }; // this is from Bartek: https://www.cppstories.com/2023/initializer_list_improvements/ template&lt;typename T, typename... Args&gt; auto makeVector(Args&amp;&amp;... args) { std::vector&lt;T&gt; vec; vec.reserve(sizeof...(Args)); (vec.emplace_back(std::forward&lt;Args&gt;(args)), ...); return vec; } int main() { [[maybe_unused]] std::vector&lt;std::unique_ptr&lt;Wrapper&gt;&gt; v = makeVector&lt;std::unique_ptr&lt;Wrapper&gt;&gt;( std::make_unique&lt;Wrapper&gt;(&quot;keyboard&quot;, std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(&quot;mouse&quot;, std::make_unique&lt;Resource&gt;()), std::make_unique&lt;Wrapper&gt;(&quot;screen&quot;, std::make_unique&lt;Resource&gt;()) ); return 0; } Conclusion Today, I shared with you a problem I faced lately. I wanted to {}-initialize a vector of unique pointers, but it didn’t work. A std::vector takes an initializer_list by value, so it makes a copy of it. Hence, the compilation will fail if you try to use an initializer_list with move-only types. If you want to use the {}-initializer for a vector, you need to implement the move constructor. If that’s not an option and you want to separate the creation of the vector, you have no other option than move the related code to a separate function. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Vectors and unique pointers","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers"},"url":"https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers"}</script><title>Vectors and unique pointers | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/12"> 12 </a> </span> <span>Vectors and unique pointers</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Vectors and unique pointers</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 12, 2023, 12:00 AM +0200" prep="on" > Apr 12, 2023 <i class="unloaded">2023-04-12T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sun, Sep 24, 2023, 11:19 PM +0200" prefix="Updated " > Sep 24, 2023 <i class="unloaded">2023-09-24T23:19:08+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1594 words">8 min</span></div></div><div class="post-content"><p>In this post, I want to share some struggles I had twice during the last few months. For one of my examples, I wanted to initialize a <code class="language-plaintext highlighter-rouge">std::vector</code> with <code class="language-plaintext highlighter-rouge">std::unique_ptr</code>. It didn’t compile and I had little time, I didn’t even think about it. I waved my hand and changed my example.</p><p>Then I ran into the same issue at work, while we were pairing over an issue. I couldn’t just wave anymore, and luckily we also had the time to go a bit deeper.</p><p>What we wanted was a little bit different and more complex though. We wanted to return a vector of unique pointers to a struct that holds - among others - a unique pointer.</p><p>This is a simplified version of what we wanted:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
  <span class="c1">// unimportant</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">resource</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// somewhere in a function</span>
<span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">aName</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">()),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">anotherName</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">())</span>
<span class="p">};</span>
</pre></table></code></div></div><p>That’s a bit too complex to start with, so let’s dissect the issue into two parts.</p><h2 id="no-compiler-generated-copy-constructor">No compiler-generated copy constructor</h2><p>Let’s first omit the external unique pointer and try to brace-initialize a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">Wrapper</code> objects.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
  <span class="c1">// unimportant</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">m_resource</span><span class="p">;</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aName</span> <span class="o">=</span> <span class="s">"bla"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="n">Wrapper</span><span class="p">{</span><span class="n">aName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">()}};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The first part of the problem is that we cannot <code class="language-plaintext highlighter-rouge">{}</code>-initialize this <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">Wrapper</code>s. Even though it seems alright at a first glance. <code class="language-plaintext highlighter-rouge">Wrapper</code> is a <code class="language-plaintext highlighter-rouge">struct</code> with public members and no explicitly defined special functions. Our <code class="language-plaintext highlighter-rouge">{}</code>-initialization follows the right syntax and the parameters are passed in the right order.</p><p>Still, the compiler says stop! Here is a part of the error messages. As <code class="language-plaintext highlighter-rouge">vector</code> is a template we cannot expect a concise message.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre>/opt/compiler-explorer/gcc-12.2.0/include/c++/12.2.0/bits/stl_uninitialized.h:90:56: error: static assertion failed: result type must be constructible from input type
   90 |       static_assert(is_constructible&lt;_ValueType, _Tp&gt;::value,
</pre></table></code></div></div><p>If we scroll up in the errors we’ll find a more explanatory line:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>In instantiation of 'constexpr bool std::__check_constructible() [with _ValueType = Wrapper; _Tp = const Wrapper&amp;]':
</pre></table></code></div></div><p>So the problem is <code class="language-plaintext highlighter-rouge">Wrapper</code> cannot be constructed from <code class="language-plaintext highlighter-rouge">const Wrapper&amp;</code>, in other words, <code class="language-plaintext highlighter-rouge">Wrapper</code> cannot be copy constructed. That makes sense! It has a <em>move-only</em> member, <code class="language-plaintext highlighter-rouge">std::unique_ptr&lt;Resource&gt; m_resource</code>! Because of this <em>move-only</em> member, the compiler cannot automatically generate a copy constructor.</p><h2 id="a-stdvector-always-copies-its-stdinitializer_list">A <code class="language-plaintext highlighter-rouge">std::vector</code> always copies its <code class="language-plaintext highlighter-rouge">std::initializer_list</code></h2><p>That’s all fine but why do we need a copy constructor? Why cannot we benefit from move semantics?</p><p>We can spot the answer on <a href="https://en.cppreference.com/w/cpp/container/vector/vector">C++ Reference</a>! <code class="language-plaintext highlighter-rouge">std::vector</code> has only one constructor involving a <code class="language-plaintext highlighter-rouge">std::initializer_list</code> and there the <code class="language-plaintext highlighter-rouge">initializer_list</code> is taken by value. In other words, <code class="language-plaintext highlighter-rouge">vector</code> copies its <code class="language-plaintext highlighter-rouge">initializer_list</code>. Always.</p><p>As the passed in <code class="language-plaintext highlighter-rouge">initializer_list</code> is going to be copied, the contained type must be copy-constructible. That’s clearly not the case for <code class="language-plaintext highlighter-rouge">Wrapper</code> which we can easily assert.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">m_resource</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">static_assert</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_copy_constructible</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">());</span>
<span class="cm">/*
main.cpp:18:20: error: static assertion failed
   18 | static_assert(std::is_copy_constructible&lt;Wrapper&gt;());
      |                    ^~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
*/</span>
</pre></table></code></div></div><h3 id="lets-make-contained-types-copy-constructible">Let’s make contained types copy constructible</h3><p>That’s quite easy to fix, we need to provide a user-defined copy constructor, such as <code class="language-plaintext highlighter-rouge">Wrapper(const Wrapper&amp; other): m_name(other.m_name), m_resource(std::make_unique&lt;Resource&gt;()) {}</code>. At the same time, let’s not forget about <a href="https://en.cppreference.com/w/cpp/language/rule_of_three">the rules of 0/3/5</a>, so we should provide all the special functions.</p><p>Now we don’t have the problem anymore, we can easily use the brace initialization.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
  <span class="c1">// unimportant</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">m_resource</span><span class="p">;</span>
  <span class="n">Wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="o">~</span><span class="n">Wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Wrapper</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">resource</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="n">m_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">resource</span><span class="p">))</span> <span class="p">{}</span>
	
  <span class="n">Wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_name</span><span class="p">),</span> <span class="n">m_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>
  <span class="n">Wrapper</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	
  <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_name</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_name</span><span class="p">;</span>
    <span class="n">m_resource</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
	    
  <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aName</span> <span class="o">=</span> <span class="s">"bla"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{</span><span class="n">Wrapper</span><span class="p">{</span><span class="n">aName</span><span class="p">,</span> 
  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">()}};</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But what if we cannot or do not want to modify <code class="language-plaintext highlighter-rouge">Wrapper</code>? Do we have any other options?</p><p>Of course!</p><h3 id="we-can-also-extract-vector-initialization">We can also extract <code class="language-plaintext highlighter-rouge">vector</code> initialization</h3><p>If we have to avoid the brace-initialization of the vector, we can simply default initialize it, probably reserving then enough space for the items we want to add, and use either <code class="language-plaintext highlighter-rouge">vector</code>’s <code class="language-plaintext highlighter-rouge">emplace_back()</code> or <code class="language-plaintext highlighter-rouge">push_back()</code> methods.</p><p>There is not a big difference in this case between <code class="language-plaintext highlighter-rouge">emplace_back()</code> and <code class="language-plaintext highlighter-rouge">push_back()</code>. <code class="language-plaintext highlighter-rouge">push_back()</code> will call the appropriate constructor first and then the move constructor. <code class="language-plaintext highlighter-rouge">emplace_back()</code> will only make one constructor call. At least that’s the theory. Let’s see if we’re right. I amended <code class="language-plaintext highlighter-rouge">Wrapper</code> so that each of its special functions prints.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
  <span class="c1">// unimportant</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">m_resource</span><span class="p">;</span>

  <span class="n">Wrapper</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wrapper()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="o">~</span><span class="n">Wrapper</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"~Wrapper()</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
	
  <span class="n">Wrapper</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">resource</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="n">m_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">resource</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_name</span><span class="p">),</span> <span class="n">m_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">other</span><span class="p">.</span><span class="n">m_resource</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wrapper (const Wrapper&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Wrapper</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wrapper (Wrapper&amp;&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wrapper&amp; operator=(const Wrapper&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
	
  <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"Wrapper&amp; operator=(Wrapper&amp;&amp; other)</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">aName</span> <span class="o">=</span> <span class="s">"bla"</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">{};</span>
  <span class="n">v</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">aName</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="c1">// v.push_back(Wrapper(aName, std::make_unique&lt;Resource&gt;()));</span>
<span class="p">}</span>

<span class="cm">/*
output with emplace_back:
Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource)
~Wrapper()
*/</span>

<span class="cm">/*
output with push_back
Wrapper (std::string name, std::unique_ptr&lt;Resource&gt; resource)
Wrapper (Wrapper&amp;&amp; other)
~Wrapper()
~Wrapper()
*/</span>
</pre></table></code></div></div><p>Our assumption was right, except that I forgot to note the extra destructor call on a moved-from object. While these extra calls would be often negligible, we have no reason not to use <code class="language-plaintext highlighter-rouge">emplace_back()</code>. It’s not more difficult to write it and it’s better for the performance.</p><p>With that, we’ve seen why we couldn’t <code class="language-plaintext highlighter-rouge">{}</code>-initialize a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">Wrapper</code>s following the <a href="https://en.cppreference.com/w/cpp/language/rule_of_three#Rule_of_zero">rule of zero</a>, where <code class="language-plaintext highlighter-rouge">Wrapper</code> is a type that allocates on the heap.</p><p>Now let’s move over to the other issue.</p><h2 id="the-same-issue-with-initializer_list-once-again">The same issue with <code class="language-plaintext highlighter-rouge">initializer_list</code> once again</h2><p>Actually, by answering the first question, we also learned why we cannot <code class="language-plaintext highlighter-rouge">{}</code>-initialize a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">unique_ptr</code>s. It’s the problem of an <code class="language-plaintext highlighter-rouge">initializer_list</code> taken by value instead of reference and the fact that <code class="language-plaintext highlighter-rouge">unique_ptr</code>s cannot be copied.</p><p>Can we do anything to improve the situation?</p><p>We can extract the creation and population of the <code class="language-plaintext highlighter-rouge">vector</code> to a separate method so that we don’t have the visual noise of <code class="language-plaintext highlighter-rouge">vector</code> insertions along with the rest of the code.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;&gt;</span> <span class="n">createResources</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">());</span>
  <span class="k">return</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;&gt;</span> <span class="n">resources</span> <span class="o">=</span> <span class="n">createResources</span><span class="p">();</span>
  <span class="c1">// ...</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But can we do something better?</p><p>We can make a better, generalized function that makes us a <code class="language-plaintext highlighter-rouge">vector</code> of <code class="language-plaintext highlighter-rouge">unique_ptr</code>s, but the idea behind is essentially the same: the pointers are added one by one after the construction of the vector.</p><p><a href="https://www.cppstories.com/2023/initializer_list_improvements/">Let me borrow an implementation by Bartek</a>. I take this piece of code from <a href="https://www.cppstories.com/2023/initializer_list_improvements/">C++ Storties</a> and I encourage you to read the whole article on <code class="language-plaintext highlighter-rouge">initializer_list</code>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">makeVector</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">));</span> 
  <span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
  <span class="k">return</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now we can update our original example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Resource</span> <span class="p">{</span>
  <span class="c1">// unimportant</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">m_name</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">m_resource</span><span class="p">;</span>
  <span class="n">Wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="o">~</span><span class="n">Wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="n">Wrapper</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span> <span class="n">resource</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)),</span> <span class="n">m_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">resource</span><span class="p">))</span> <span class="p">{}</span>
	
  <span class="n">Wrapper</span><span class="p">(</span><span class="k">const</span> <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_name</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">m_name</span><span class="p">),</span> <span class="n">m_resource</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>
    <span class="n">Wrapper</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	
  <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">m_name</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">m_name</span><span class="p">;</span>
    <span class="n">m_resource</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
  <span class="p">}</span>
	    
  <span class="n">Wrapper</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">&amp;&amp;</span> <span class="n">other</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// this is from Bartek: https://www.cppstories.com/2023/initializer_list_improvements/</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="k">auto</span> <span class="nf">makeVector</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
  <span class="n">vec</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="k">sizeof</span><span class="p">...(</span><span class="n">Args</span><span class="p">));</span> 
  <span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)),</span> <span class="p">...);</span>
  <span class="k">return</span> <span class="n">vec</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="n">makeVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;&gt;</span><span class="p">(</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"keyboard"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">()),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"mouse"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">()),</span>
  <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Wrapper</span><span class="o">&gt;</span><span class="p">(</span><span class="s">"screen"</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Resource</span><span class="o">&gt;</span><span class="p">())</span>
  <span class="p">);</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>Today, I shared with you a problem I faced lately. I wanted to <code class="language-plaintext highlighter-rouge">{}</code>-initialize a <code class="language-plaintext highlighter-rouge">vector</code> of unique pointers, but it didn’t work. A <code class="language-plaintext highlighter-rouge">std::vector</code> takes an <code class="language-plaintext highlighter-rouge">initializer_list</code> by value, so it makes a copy of it. Hence, the compilation will fail if you try to use an <code class="language-plaintext highlighter-rouge">initializer_list</code> with move-only types.</p><p>If you want to use the <code class="language-plaintext highlighter-rouge">{}</code>-initializer for a vector, you need to implement the move constructor. If that’s not an option and you want to separate the creation of the <code class="language-plaintext highlighter-rouge">vector</code>, you have no other option than move the related code to a separate function.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/vector/" class="post-tag no-text-decoration" >vector</a> <a href="/tags/movesemantics/" class="post-tag no-text-decoration" >movesemantics</a> <a href="/tags/unqiueptr/" class="post-tag no-text-decoration" >unqiueptr</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Vectors and unique pointers - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Vectors and unique pointers - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Vectors and unique pointers - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Vectors and unique pointers - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/01/31/cpp23-likes-to-move-it"><div class="card-body"> <span class="timeago small" > Jan 31, 2024 <i class="unloaded">2024-01-31T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23 likes to move it!</h3><div class="text-muted small"><p> C++23 is going to bring us a few changes regarding move operations. It mostly means extended support in the standard library, but there is also one change directly in the language. Let’s start with...</p></div></div></a></div><div class="card"> <a href="/blog/2024/03/27/move-from-funtamental"><div class="card-body"> <span class="timeago small" > Mar 27, 2024 <i class="unloaded">2024-03-27T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Should we move from fundamental types?</h3><div class="text-muted small"><p> In this blog post, we are going to discuss the intersection of move semantics and fundamental types. Should we move values of fundamental types? Or can we even move them in the first place? Let’s d...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/10/cpponsea2024-trip-report"><div class="card-body"> <span class="timeago small" > Jul 10, 2024 <i class="unloaded">2024-07-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Trip report: C++ On Sea 2024</h3><div class="text-muted small"><p> Last week, between the 3rd and 5th of July, I had the privilege to attend and present at C++ on Sea 2024 for the 5th time in a row! I’m grateful that the organizers accepted me not simply as a spe...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/04/05/binary-size-and-templates" class="btn btn-outline-primary" prompt="Older"><p>Binary sizes and passing functions to functions</p></a> <a href="/blog/2023/04/19/we-are-always-late" class="btn btn-outline-primary" prompt="Newer"><p>We are always late</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Vectors and unique pointers'; this.page.url = 'https://www.sandordargo.com/blog/2023/04/12/vector-of-unique-pointers'; this.page.identifier = '/blog/2023/04/12/vector-of-unique-pointers'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
