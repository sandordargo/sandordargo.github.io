<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Binary sizes and passing functions to functions" /><meta property="og:locale" content="en_US" /><meta name="description" content="So why templates are interesting for our series on binary sizes? It’s because as mentioned, they do not represent callable code. They represent templates to generate callable code. The more you generate, the more different input sets you use with them, the bigger binary you get. If you want to learn about templates more I’d advise you to read Template Metaprogramming with C++ by Marius Bancila. I’m not telling you not to use templates. Not at all. They are a useful tool in your belt, if used properly. I simply want to contribute to that needed understanding, so that you don’t shoot yourself in the leg. Now let’s see what we can do to minimise the harm. Use minimal templates In Clean Code, we learned that we should write small functions and those small functions should build up small classes. What is small? It depends, and I don’t want to get into a numbers game here. Then in A Philosophy of Software Design John Ousterhout wrote that we should write deep methods and classes and not be afraid of having long entities. You might tend to one or the other opinion, but when it comes to templates, you should really consider having some classes. Let’s have a look at an example. As I’m learning nowadays about wine tasting and plan to get a certification in the next few months, I’m using wine bottling as an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;vector&gt; class Wine {}; class Bottle {}; void storeTemporarily(Bottle bottle) {} void moveToCellar(Bottle bottle) {} void uploadToStore(Bottle bottle) {} template &lt;typename Callable&gt; void prepareWineForSell(Callable bottlerFunction, Wine wine) { auto bottles = bottlerFunction(wine); for (const auto&amp; bottle: bottles) { storeTemporarily(bottle); moveToCellar(bottle); uploadToStore(bottle); } } int main() { auto bottleWithScrewlock = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithSyntethicCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithWirehood = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; Wine wine; prepareWineForSell(bottleWithScrewlock, wine); prepareWineForSell(bottleWithCork, wine); prepareWineForSell(bottleWithSyntethicCork, wine); prepareWineForSell(bottleWithWirehood, wine); } In the above example, we can see that prepareWineForSell is a function template that takes a callable. It only uses it in the first line of the function body, no more. But if you instantiate this template with different callables, the compiler has to generate the code for the rest of the function that doesn’t use the callable 4 different times. This we can easily optimize, by extracting the part that doesn’t depend on the callable into a separate function. As such, those lines don’t have to be included in the function 4 different times but the function exists only once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;vector&gt; class Wine {}; class Bottle{}; void storeTemporarily(Bottle bottle) {} void moveToCellar(Bottle bottle) {} void uploadToStore(Bottle bottle) {} void postProcessBottles(const std::vector&lt;Bottle&gt;&amp; bottles) { for (const auto&amp; bottle: bottles) { storeTemporarily(bottle); moveToCellar(bottle); uploadToStore(bottle); } } template &lt;typename Callable&gt; void prepareWineForSell(Callable bottlerFunction, Wine wine) { auto bottles = bottlerFunction(wine); postProcessBottles(bottles); } int main() { auto bottleWithScrewlock = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithSyntethicCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithWirehood = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; Wine wine; prepareWineForSell(bottleWithScrewlock, wine); prepareWineForSell(bottleWithCork, wine); prepareWineForSell(bottleWithSyntethicCork, wine); prepareWineForSell(bottleWithWirehood, wine); } If we check the generated assembly in compiler explorer, we can see that there is more than a 10% difference between the two versions and the one with the smaller template function is also the smaller at the end, just as expected. In this example, we could go even further and make prepareForSell return std::vector&lt;Bottle&gt; and call postProcessBottles right with these results. Or we could probably even remove postProcessBottles completely. On the one hand, I wanted to showcase when and how to reduce your templates. But on the other hand, you should indeed have a look into going even further if you can. Not only to reduce your binary size but mainly to reduce the complexity of your code. Realize when you are using templates My next point is a small, yet important one. Often when you ask inexperienced C++ programmers if they use templates, many will say no. But it’s almost 100% sure that they do. The standard library is full of templates. There is a reason why people often mix up the notions of the standard library and the standard template library. Even a std::string is a template! It’s just an alias for std::basic_string&lt;char&gt; where std::basic_string is template&lt;class CharT, class Traits = std::char_traits&lt;CharT&gt;, class Allocator = std::allocator&lt;CharT&gt;&gt; class basic_string;. So keep in mind that instantiating templates has a cost. How much? It depends on your use case. But there are two more things I want you not to forget. Whenever you see auto in the function parameter list, don’t forget that you’re dealing with a template with all its advantages and costs. For example auto add(auto, int) is a template. And it’s worth mentioning that std::function is also a template and a costly one as we saw in The observer pattern and binary sizes . Let’s discuss this one more time! std::function vs function pointers vs templates If you have a function that takes another function (or function object or lambda) as a parameter, how should you do it? One option is to take it as a std::function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; int performOperation(std::function&lt;int(int, int)&gt; op, int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\n&#39;; return 0; } A std::function is a type-erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. std::function has quite some overhead, but it provides flexibility. If we want flexibility, we can also take a template. While it might be too wide for us and we want to avoid too late template instantiation error messages, since C++20 we can and should use concepts to constrain the accepted arguments. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;concepts&gt; template &lt;std::invocable&lt;int, int&gt; Callable&gt; int performOperation(Callable op, int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\n&#39;; return 0; } This version doesn’t check the return type, so let’s refine it a bit more. We should create a new concept that takes into consideration both the arguments and the return type and use only that concept. 1 2 3 4 5 6 7 8 9 10 template &lt;typename Callable&gt; concept RestrictedCallable = std::invocable&lt;Callable, int, int&gt; &amp;&amp; requires ( Callable callable, int lhs, int rhs) { { callable(lhs, rhs) } -&gt; std::same_as&lt;int&gt;; }; template &lt;RestrictedCallable Callable&gt; int performOperation(Callable op, int lhs, int rhs) { return op(lhs, rhs); } This above version doesn’t even allow implicit conversions on the returned type, if you wanted to allow that, you could use std::convertible_to. If you want to learn more about concepts, check this series. Then there is the third option which is just taking a good old function pointer. If we don’t need the feature of a capture list then it should be a good enough option. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; int performOperation(int(* op)(int, int), int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\n&#39;; return 0; } My biggest take against function pointers is the readability. I find it extremely inconvenient that the parameter name is buried somewhere in the function pointer signature. Let’s use a typedef to improve the situation. 1 2 3 4 5 using MyFunctionPtr = int(*)(int, int); int performOperation(MyFunctionPtr op, int lhs, int rhs) { return op(lhs, rhs); } It’s better like that. Now let’s compare how these three solutions compare against each other. Version Binary size std::function -O3 40,189 templates -O3 35,259 function pointer -O3 35,341 As we could expect, std::function resulted in a slightly bigger binary, the difference compared to the other two variants was above 10%. On the other hand, templates and function pointers had a similar result. We cannot yet infer a long-term conclusion. What we see is that when you have a minimal template and few instantiations, then templates and function pointers have similar results. But we can expect that the template solution will scale worse. Each additional type of callable will add its own instantiation, and in addition, the longer the template is, the more space each generated function will take. You have to keep those in mind. But if your templates are small and the number of instantiations is limited, probably the template version offers better readability. In particular, if you can use C++20’s concepts. Conclusion In this article, we discussed about how templates might bloat the size of a binary. It’s worth keeping in mind that each template instantiation adds to our binary. It’s also important to remember that we use more templates than we’d often think to. Containers are templates, including strings! Don’t forget, if you see auto in function parameter list, you see a function template! Speaking about functions, let’s not forget that std::function is also a template, one of the more costliers! If you want to pass a callable and amy kind of efficieny matter for you, think about other options such creating a constrained template or just using function pointers! If the function template that has to be instantiated each time is big, then probably a function pointer will be a good enough option despite it’s limited readability. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="So why templates are interesting for our series on binary sizes? It’s because as mentioned, they do not represent callable code. They represent templates to generate callable code. The more you generate, the more different input sets you use with them, the bigger binary you get. If you want to learn about templates more I’d advise you to read Template Metaprogramming with C++ by Marius Bancila. I’m not telling you not to use templates. Not at all. They are a useful tool in your belt, if used properly. I simply want to contribute to that needed understanding, so that you don’t shoot yourself in the leg. Now let’s see what we can do to minimise the harm. Use minimal templates In Clean Code, we learned that we should write small functions and those small functions should build up small classes. What is small? It depends, and I don’t want to get into a numbers game here. Then in A Philosophy of Software Design John Ousterhout wrote that we should write deep methods and classes and not be afraid of having long entities. You might tend to one or the other opinion, but when it comes to templates, you should really consider having some classes. Let’s have a look at an example. As I’m learning nowadays about wine tasting and plan to get a certification in the next few months, I’m using wine bottling as an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;vector&gt; class Wine {}; class Bottle {}; void storeTemporarily(Bottle bottle) {} void moveToCellar(Bottle bottle) {} void uploadToStore(Bottle bottle) {} template &lt;typename Callable&gt; void prepareWineForSell(Callable bottlerFunction, Wine wine) { auto bottles = bottlerFunction(wine); for (const auto&amp; bottle: bottles) { storeTemporarily(bottle); moveToCellar(bottle); uploadToStore(bottle); } } int main() { auto bottleWithScrewlock = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithSyntethicCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithWirehood = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; Wine wine; prepareWineForSell(bottleWithScrewlock, wine); prepareWineForSell(bottleWithCork, wine); prepareWineForSell(bottleWithSyntethicCork, wine); prepareWineForSell(bottleWithWirehood, wine); } In the above example, we can see that prepareWineForSell is a function template that takes a callable. It only uses it in the first line of the function body, no more. But if you instantiate this template with different callables, the compiler has to generate the code for the rest of the function that doesn’t use the callable 4 different times. This we can easily optimize, by extracting the part that doesn’t depend on the callable into a separate function. As such, those lines don’t have to be included in the function 4 different times but the function exists only once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;vector&gt; class Wine {}; class Bottle{}; void storeTemporarily(Bottle bottle) {} void moveToCellar(Bottle bottle) {} void uploadToStore(Bottle bottle) {} void postProcessBottles(const std::vector&lt;Bottle&gt;&amp; bottles) { for (const auto&amp; bottle: bottles) { storeTemporarily(bottle); moveToCellar(bottle); uploadToStore(bottle); } } template &lt;typename Callable&gt; void prepareWineForSell(Callable bottlerFunction, Wine wine) { auto bottles = bottlerFunction(wine); postProcessBottles(bottles); } int main() { auto bottleWithScrewlock = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithSyntethicCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithWirehood = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; Wine wine; prepareWineForSell(bottleWithScrewlock, wine); prepareWineForSell(bottleWithCork, wine); prepareWineForSell(bottleWithSyntethicCork, wine); prepareWineForSell(bottleWithWirehood, wine); } If we check the generated assembly in compiler explorer, we can see that there is more than a 10% difference between the two versions and the one with the smaller template function is also the smaller at the end, just as expected. In this example, we could go even further and make prepareForSell return std::vector&lt;Bottle&gt; and call postProcessBottles right with these results. Or we could probably even remove postProcessBottles completely. On the one hand, I wanted to showcase when and how to reduce your templates. But on the other hand, you should indeed have a look into going even further if you can. Not only to reduce your binary size but mainly to reduce the complexity of your code. Realize when you are using templates My next point is a small, yet important one. Often when you ask inexperienced C++ programmers if they use templates, many will say no. But it’s almost 100% sure that they do. The standard library is full of templates. There is a reason why people often mix up the notions of the standard library and the standard template library. Even a std::string is a template! It’s just an alias for std::basic_string&lt;char&gt; where std::basic_string is template&lt;class CharT, class Traits = std::char_traits&lt;CharT&gt;, class Allocator = std::allocator&lt;CharT&gt;&gt; class basic_string;. So keep in mind that instantiating templates has a cost. How much? It depends on your use case. But there are two more things I want you not to forget. Whenever you see auto in the function parameter list, don’t forget that you’re dealing with a template with all its advantages and costs. For example auto add(auto, int) is a template. And it’s worth mentioning that std::function is also a template and a costly one as we saw in The observer pattern and binary sizes . Let’s discuss this one more time! std::function vs function pointers vs templates If you have a function that takes another function (or function object or lambda) as a parameter, how should you do it? One option is to take it as a std::function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; int performOperation(std::function&lt;int(int, int)&gt; op, int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\n&#39;; return 0; } A std::function is a type-erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. std::function has quite some overhead, but it provides flexibility. If we want flexibility, we can also take a template. While it might be too wide for us and we want to avoid too late template instantiation error messages, since C++20 we can and should use concepts to constrain the accepted arguments. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;concepts&gt; template &lt;std::invocable&lt;int, int&gt; Callable&gt; int performOperation(Callable op, int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\n&#39;; return 0; } This version doesn’t check the return type, so let’s refine it a bit more. We should create a new concept that takes into consideration both the arguments and the return type and use only that concept. 1 2 3 4 5 6 7 8 9 10 template &lt;typename Callable&gt; concept RestrictedCallable = std::invocable&lt;Callable, int, int&gt; &amp;&amp; requires ( Callable callable, int lhs, int rhs) { { callable(lhs, rhs) } -&gt; std::same_as&lt;int&gt;; }; template &lt;RestrictedCallable Callable&gt; int performOperation(Callable op, int lhs, int rhs) { return op(lhs, rhs); } This above version doesn’t even allow implicit conversions on the returned type, if you wanted to allow that, you could use std::convertible_to. If you want to learn more about concepts, check this series. Then there is the third option which is just taking a good old function pointer. If we don’t need the feature of a capture list then it should be a good enough option. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; int performOperation(int(* op)(int, int), int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\n&#39;; return 0; } My biggest take against function pointers is the readability. I find it extremely inconvenient that the parameter name is buried somewhere in the function pointer signature. Let’s use a typedef to improve the situation. 1 2 3 4 5 using MyFunctionPtr = int(*)(int, int); int performOperation(MyFunctionPtr op, int lhs, int rhs) { return op(lhs, rhs); } It’s better like that. Now let’s compare how these three solutions compare against each other. Version Binary size std::function -O3 40,189 templates -O3 35,259 function pointer -O3 35,341 As we could expect, std::function resulted in a slightly bigger binary, the difference compared to the other two variants was above 10%. On the other hand, templates and function pointers had a similar result. We cannot yet infer a long-term conclusion. What we see is that when you have a minimal template and few instantiations, then templates and function pointers have similar results. But we can expect that the template solution will scale worse. Each additional type of callable will add its own instantiation, and in addition, the longer the template is, the more space each generated function will take. You have to keep those in mind. But if your templates are small and the number of instantiations is limited, probably the template version offers better readability. In particular, if you can use C++20’s concepts. Conclusion In this article, we discussed about how templates might bloat the size of a binary. It’s worth keeping in mind that each template instantiation adds to our binary. It’s also important to remember that we use more templates than we’d often think to. Containers are templates, including strings! Don’t forget, if you see auto in function parameter list, you see a function template! Speaking about functions, let’s not forget that std::function is also a template, one of the more costliers! If you want to pass a callable and amy kind of efficieny matter for you, think about other options such creating a constrained template or just using function pointers! If the function template that has to be instantiated each time is big, then probably a function pointer will be a good enough option despite it’s limited readability. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-04-05T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Binary sizes and passing functions to functions" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-04-13T22:30:37+02:00","datePublished":"2023-04-05T00:00:00+02:00","description":"So why templates are interesting for our series on binary sizes? It’s because as mentioned, they do not represent callable code. They represent templates to generate callable code. The more you generate, the more different input sets you use with them, the bigger binary you get. If you want to learn about templates more I’d advise you to read Template Metaprogramming with C++ by Marius Bancila. I’m not telling you not to use templates. Not at all. They are a useful tool in your belt, if used properly. I simply want to contribute to that needed understanding, so that you don’t shoot yourself in the leg. Now let’s see what we can do to minimise the harm. Use minimal templates In Clean Code, we learned that we should write small functions and those small functions should build up small classes. What is small? It depends, and I don’t want to get into a numbers game here. Then in A Philosophy of Software Design John Ousterhout wrote that we should write deep methods and classes and not be afraid of having long entities. You might tend to one or the other opinion, but when it comes to templates, you should really consider having some classes. Let’s have a look at an example. As I’m learning nowadays about wine tasting and plan to get a certification in the next few months, I’m using wine bottling as an example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 #include &lt;vector&gt; class Wine {}; class Bottle {}; void storeTemporarily(Bottle bottle) {} void moveToCellar(Bottle bottle) {} void uploadToStore(Bottle bottle) {} template &lt;typename Callable&gt; void prepareWineForSell(Callable bottlerFunction, Wine wine) { auto bottles = bottlerFunction(wine); for (const auto&amp; bottle: bottles) { storeTemporarily(bottle); moveToCellar(bottle); uploadToStore(bottle); } } int main() { auto bottleWithScrewlock = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithSyntethicCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithWirehood = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; Wine wine; prepareWineForSell(bottleWithScrewlock, wine); prepareWineForSell(bottleWithCork, wine); prepareWineForSell(bottleWithSyntethicCork, wine); prepareWineForSell(bottleWithWirehood, wine); } In the above example, we can see that prepareWineForSell is a function template that takes a callable. It only uses it in the first line of the function body, no more. But if you instantiate this template with different callables, the compiler has to generate the code for the rest of the function that doesn’t use the callable 4 different times. This we can easily optimize, by extracting the part that doesn’t depend on the callable into a separate function. As such, those lines don’t have to be included in the function 4 different times but the function exists only once. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #include &lt;vector&gt; class Wine {}; class Bottle{}; void storeTemporarily(Bottle bottle) {} void moveToCellar(Bottle bottle) {} void uploadToStore(Bottle bottle) {} void postProcessBottles(const std::vector&lt;Bottle&gt;&amp; bottles) { for (const auto&amp; bottle: bottles) { storeTemporarily(bottle); moveToCellar(bottle); uploadToStore(bottle); } } template &lt;typename Callable&gt; void prepareWineForSell(Callable bottlerFunction, Wine wine) { auto bottles = bottlerFunction(wine); postProcessBottles(bottles); } int main() { auto bottleWithScrewlock = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithSyntethicCork = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; auto bottleWithWirehood = [](const Wine&amp; wine) { return std::vector&lt;Bottle&gt;(10);}; Wine wine; prepareWineForSell(bottleWithScrewlock, wine); prepareWineForSell(bottleWithCork, wine); prepareWineForSell(bottleWithSyntethicCork, wine); prepareWineForSell(bottleWithWirehood, wine); } If we check the generated assembly in compiler explorer, we can see that there is more than a 10% difference between the two versions and the one with the smaller template function is also the smaller at the end, just as expected. In this example, we could go even further and make prepareForSell return std::vector&lt;Bottle&gt; and call postProcessBottles right with these results. Or we could probably even remove postProcessBottles completely. On the one hand, I wanted to showcase when and how to reduce your templates. But on the other hand, you should indeed have a look into going even further if you can. Not only to reduce your binary size but mainly to reduce the complexity of your code. Realize when you are using templates My next point is a small, yet important one. Often when you ask inexperienced C++ programmers if they use templates, many will say no. But it’s almost 100% sure that they do. The standard library is full of templates. There is a reason why people often mix up the notions of the standard library and the standard template library. Even a std::string is a template! It’s just an alias for std::basic_string&lt;char&gt; where std::basic_string is template&lt;class CharT, class Traits = std::char_traits&lt;CharT&gt;, class Allocator = std::allocator&lt;CharT&gt;&gt; class basic_string;. So keep in mind that instantiating templates has a cost. How much? It depends on your use case. But there are two more things I want you not to forget. Whenever you see auto in the function parameter list, don’t forget that you’re dealing with a template with all its advantages and costs. For example auto add(auto, int) is a template. And it’s worth mentioning that std::function is also a template and a costly one as we saw in The observer pattern and binary sizes . Let’s discuss this one more time! std::function vs function pointers vs templates If you have a function that takes another function (or function object or lambda) as a parameter, how should you do it? One option is to take it as a std::function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 #include &lt;iostream&gt; #include &lt;functional&gt; int performOperation(std::function&lt;int(int, int)&gt; op, int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\\n&#39;; return 0; } A std::function is a type-erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. std::function has quite some overhead, but it provides flexibility. If we want flexibility, we can also take a template. While it might be too wide for us and we want to avoid too late template instantiation error messages, since C++20 we can and should use concepts to constrain the accepted arguments. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;concepts&gt; template &lt;std::invocable&lt;int, int&gt; Callable&gt; int performOperation(Callable op, int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\\n&#39;; return 0; } This version doesn’t check the return type, so let’s refine it a bit more. We should create a new concept that takes into consideration both the arguments and the return type and use only that concept. 1 2 3 4 5 6 7 8 9 10 template &lt;typename Callable&gt; concept RestrictedCallable = std::invocable&lt;Callable, int, int&gt; &amp;&amp; requires ( Callable callable, int lhs, int rhs) { { callable(lhs, rhs) } -&gt; std::same_as&lt;int&gt;; }; template &lt;RestrictedCallable Callable&gt; int performOperation(Callable op, int lhs, int rhs) { return op(lhs, rhs); } This above version doesn’t even allow implicit conversions on the returned type, if you wanted to allow that, you could use std::convertible_to. If you want to learn more about concepts, check this series. Then there is the third option which is just taking a good old function pointer. If we don’t need the feature of a capture list then it should be a good enough option. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; int performOperation(int(* op)(int, int), int lhs, int rhs) { return op(lhs, rhs); } int main() { auto add = [](int lhs, int rhs) {return lhs + rhs;}; auto subtract = [](int lhs, int rhs) {return lhs - rhs;}; auto multiply = [](int lhs, int rhs) {return lhs * rhs;}; std::cout &lt;&lt; performOperation(add, 42, 51) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; performOperation(subtract, 42, 51) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; performOperation(multiply, 42, 51) &lt;&lt; &#39;\\n&#39;; return 0; } My biggest take against function pointers is the readability. I find it extremely inconvenient that the parameter name is buried somewhere in the function pointer signature. Let’s use a typedef to improve the situation. 1 2 3 4 5 using MyFunctionPtr = int(*)(int, int); int performOperation(MyFunctionPtr op, int lhs, int rhs) { return op(lhs, rhs); } It’s better like that. Now let’s compare how these three solutions compare against each other. Version Binary size std::function -O3 40,189 templates -O3 35,259 function pointer -O3 35,341 As we could expect, std::function resulted in a slightly bigger binary, the difference compared to the other two variants was above 10%. On the other hand, templates and function pointers had a similar result. We cannot yet infer a long-term conclusion. What we see is that when you have a minimal template and few instantiations, then templates and function pointers have similar results. But we can expect that the template solution will scale worse. Each additional type of callable will add its own instantiation, and in addition, the longer the template is, the more space each generated function will take. You have to keep those in mind. But if your templates are small and the number of instantiations is limited, probably the template version offers better readability. In particular, if you can use C++20’s concepts. Conclusion In this article, we discussed about how templates might bloat the size of a binary. It’s worth keeping in mind that each template instantiation adds to our binary. It’s also important to remember that we use more templates than we’d often think to. Containers are templates, including strings! Don’t forget, if you see auto in function parameter list, you see a function template! Speaking about functions, let’s not forget that std::function is also a template, one of the more costliers! If you want to pass a callable and amy kind of efficieny matter for you, think about other options such creating a constrained template or just using function pointers! If the function template that has to be instantiated each time is big, then probably a function pointer will be a good enough option despite it’s limited readability. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Binary sizes and passing functions to functions","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates"},"url":"https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates"}</script><title>Binary sizes and passing functions to functions | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/04"> 04 </a> </span> <span> <a href="/05"> 05 </a> </span> <span>Binary sizes and passing functions to functions</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Binary sizes and passing functions to functions</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 5, 2023, 12:00 AM +0200" prep="on" > Apr 5, 2023 <i class="unloaded">2023-04-05T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Apr 13, 2023, 10:30 PM +0200" prefix="Updated " > Apr 13, 2023 <i class="unloaded">2023-04-13T22:30:37+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1835 words">10 min</span></div></div><div class="post-content"><p>So why templates are interesting for our series on binary sizes? It’s because as mentioned, they do not represent callable code. They represent templates to generate callable code. The more you generate, the more different input sets you use with them, the bigger binary you get.</p><blockquote><p><em>If you want to learn about templates more I’d advise you to read <a href="https://www.sandordargo.com/blog/2022/10/28/template-metaprogramming-with-cpp-by-marius-bancila">Template Metaprogramming with C++ by Marius Bancila</a>.</em></p></blockquote><p>I’m not telling you not to use templates. Not at all. They are a useful tool in your belt, if used properly. I simply want to contribute to that needed understanding, so that you don’t shoot yourself in the leg. Now let’s see what we can do to minimise the harm.</p><h2 id="use-minimal-templates">Use minimal templates</h2><p>In <a href="http://amzn.to/2Fj14wo">Clean Code</a>, we learned that we should write small functions and those small functions should build up small classes. What is small? It depends, and I don’t want to get into a numbers game here. Then in <a href="https://dev.to/sandordargo/deep-vs-shallow-modules-5fj3">A Philosophy of Software Design</a> John Ousterhout wrote that we should write deep methods and classes and not be afraid of having long entities. You might tend to one or the other opinion, but when it comes to templates, you should really consider having some classes.</p><p>Let’s have a look at an example. As I’m learning nowadays about wine tasting and plan to get a certification in the next few months, I’m using wine bottling as an example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Wine</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Bottle</span> <span class="p">{};</span>
<span class="kt">void</span> <span class="nf">storeTemporarily</span><span class="p">(</span><span class="n">Bottle</span> <span class="n">bottle</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">moveToCellar</span><span class="p">(</span><span class="n">Bottle</span> <span class="n">bottle</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">uploadToStore</span><span class="p">(</span><span class="n">Bottle</span> <span class="n">bottle</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prepareWineForSell</span><span class="p">(</span><span class="n">Callable</span> <span class="n">bottlerFunction</span><span class="p">,</span> <span class="n">Wine</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">bottles</span> <span class="o">=</span> <span class="n">bottlerFunction</span><span class="p">(</span><span class="n">wine</span><span class="p">);</span>
  
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">bottle</span><span class="o">:</span> <span class="n">bottles</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">storeTemporarily</span><span class="p">(</span><span class="n">bottle</span><span class="p">);</span>
    <span class="n">moveToCellar</span><span class="p">(</span><span class="n">bottle</span><span class="p">);</span>
    <span class="n">uploadToStore</span><span class="p">(</span><span class="n">bottle</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">bottleWithScrewlock</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>
    <span class="k">auto</span> <span class="n">bottleWithCork</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>
    <span class="k">auto</span> <span class="n">bottleWithSyntethicCork</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>
    <span class="k">auto</span> <span class="n">bottleWithWirehood</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>

    <span class="n">Wine</span> <span class="n">wine</span><span class="p">;</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithScrewlock</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithCork</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithSyntethicCork</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithWirehood</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>   
<span class="p">}</span>
</pre></table></code></div></div><p>In the above example, we can see that <code class="language-plaintext highlighter-rouge">prepareWineForSell</code> is a function template that takes a callable. It only uses it in the first line of the function body, no more. But if you instantiate this template with different callables, the compiler has to generate the code for the rest of the function that doesn’t use the callable 4 different times.</p><p>This we can easily optimize, by extracting the part that doesn’t depend on the callable into a separate function. As such, those lines don’t have to be included in the function 4 different times but the function exists only once.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Wine</span> <span class="p">{};</span>
<span class="k">class</span> <span class="nc">Bottle</span><span class="p">{};</span>
<span class="kt">void</span> <span class="nf">storeTemporarily</span><span class="p">(</span><span class="n">Bottle</span> <span class="n">bottle</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">moveToCellar</span><span class="p">(</span><span class="n">Bottle</span> <span class="n">bottle</span><span class="p">)</span> <span class="p">{}</span>
<span class="kt">void</span> <span class="nf">uploadToStore</span><span class="p">(</span><span class="n">Bottle</span> <span class="n">bottle</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="nf">postProcessBottles</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;&amp;</span> <span class="n">bottles</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">bottle</span><span class="o">:</span> <span class="n">bottles</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">storeTemporarily</span><span class="p">(</span><span class="n">bottle</span><span class="p">);</span>
    <span class="n">moveToCellar</span><span class="p">(</span><span class="n">bottle</span><span class="p">);</span>
    <span class="n">uploadToStore</span><span class="p">(</span><span class="n">bottle</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">prepareWineForSell</span><span class="p">(</span><span class="n">Callable</span> <span class="n">bottlerFunction</span><span class="p">,</span> <span class="n">Wine</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">bottles</span> <span class="o">=</span> <span class="n">bottlerFunction</span><span class="p">(</span><span class="n">wine</span><span class="p">);</span>
  
  <span class="n">postProcessBottles</span><span class="p">(</span><span class="n">bottles</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">bottleWithScrewlock</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>
    <span class="k">auto</span> <span class="n">bottleWithCork</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>
    <span class="k">auto</span> <span class="n">bottleWithSyntethicCork</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>
    <span class="k">auto</span> <span class="n">bottleWithWirehood</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="n">Wine</span><span class="o">&amp;</span> <span class="n">wine</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">Bottle</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">10</span><span class="p">);};</span>

    <span class="n">Wine</span> <span class="n">wine</span><span class="p">;</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithScrewlock</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithCork</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithSyntethicCork</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>
    <span class="n">prepareWineForSell</span><span class="p">(</span><span class="n">bottleWithWirehood</span><span class="p">,</span> <span class="n">wine</span><span class="p">);</span>   
<span class="p">}</span>
</pre></table></code></div></div><p>If we check the generated assembly in compiler explorer, we can see that there is more than a 10% difference between the two versions and the one with the smaller template function is also the smaller at the end, just as expected.</p><p>In this example, we could go even further and make <code class="language-plaintext highlighter-rouge">prepareForSell</code> return <code class="language-plaintext highlighter-rouge">std::vector&lt;Bottle&gt;</code> and call <code class="language-plaintext highlighter-rouge">postProcessBottles</code> right with these results. Or we could probably even remove <code class="language-plaintext highlighter-rouge">postProcessBottles</code> completely. On the one hand, I wanted to showcase when and how to reduce your templates. But on the other hand, you should indeed have a look into going even further if you can. Not only to reduce your binary size but mainly to reduce the complexity of your code.</p><h2 id="realize-when-you-are-using-templates">Realize when you are using templates</h2><p>My next point is a small, yet important one. Often when you ask inexperienced C++ programmers if they use templates, many will say no. But it’s almost 100% sure that they do. The standard library is full of templates. There is a reason why people often mix up the notions of the standard library and the standard template library.</p><p>Even a <code class="language-plaintext highlighter-rouge">std::string</code> is a template! It’s just an alias for <code class="language-plaintext highlighter-rouge">std::basic_string&lt;char&gt;</code> where <code class="language-plaintext highlighter-rouge">std::basic_string</code> is <code class="language-plaintext highlighter-rouge">template&lt;class CharT, class Traits = std::char_traits&lt;CharT&gt;, class Allocator = std::allocator&lt;CharT&gt;&gt; class basic_string;</code>. So keep in mind that instantiating templates has a cost. How much? It depends on your use case.</p><p>But there are two more things I want you not to forget. Whenever you see <code class="language-plaintext highlighter-rouge">auto</code> in the function parameter list, don’t forget that you’re dealing with a template with all its advantages and costs. For example <code class="language-plaintext highlighter-rouge">auto add(auto, int)</code> is a template.</p><p>And it’s worth mentioning that <code class="language-plaintext highlighter-rouge">std::function</code> is also a template and a costly one as we saw in <a href="https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern#in-comparison">The observer pattern and binary sizes </a>.</p><p>Let’s discuss this one more time!</p><h2 id="stdfunction-vs-function-pointers-vs-templates"><code class="language-plaintext highlighter-rouge">std::function</code> vs function pointers vs templates</h2><p>If you have a function that takes another function (or function object or lambda) as a parameter, how should you do it? One option is to take it as a <code class="language-plaintext highlighter-rouge">std::function</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">performOperation</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="k">auto</span> <span class="n">subtract</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="k">auto</span> <span class="n">multiply</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">subtract</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>A <code class="language-plaintext highlighter-rouge">std::function</code> is a type-erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. <code class="language-plaintext highlighter-rouge">std::function</code> has quite some overhead, but it provides flexibility.</p><p>If we want flexibility, we can also take a template. While it might be too wide for us and we want to avoid too late template instantiation error messages, since C++20 we can and should use concepts to constrain the accepted arguments.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">invocable</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">Callable</span><span class="o">&gt;</span>
<span class="kt">int</span> <span class="nf">performOperation</span><span class="p">(</span><span class="n">Callable</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="k">auto</span> <span class="n">subtract</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="k">auto</span> <span class="n">multiply</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">subtract</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This version doesn’t check the return type, so let’s refine it a bit more. We should create a new concept that takes into consideration both the arguments and the return type and use only that concept.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">Callable</span><span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">RestrictedCallable</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">invocable</span><span class="o">&lt;</span><span class="n">Callable</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="o">&amp;&amp;</span> <span class="k">requires</span> <span class="p">(</span>
    <span class="n">Callable</span> <span class="n">callable</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
        <span class="p">{</span> <span class="n">callable</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="n">RestrictedCallable</span> <span class="n">Callable</span><span class="p">&gt;</span>
<span class="kt">int</span> <span class="nf">performOperation</span><span class="p">(</span><span class="n">Callable</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>This above version doesn’t even allow implicit conversions on the returned type, if you wanted to allow that, you could use <code class="language-plaintext highlighter-rouge">std::convertible_to</code>. If you want to learn more about concepts, <a href="https://www.sandordargo.com/blog/2021/02/10/cpp-concepts-motivations">check this series</a>.</p><p>Then there is the third option which is just taking a good old function pointer. If we don’t need the feature of a capture list then it should be a good enough option.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">performOperation</span><span class="p">(</span><span class="kt">int</span><span class="p">(</span><span class="o">*</span> <span class="n">op</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">),</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">add</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="k">auto</span> <span class="n">subtract</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">-</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="k">auto</span> <span class="n">multiply</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span><span class="k">return</span> <span class="n">lhs</span> <span class="o">*</span> <span class="n">rhs</span><span class="p">;};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">add</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">subtract</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">performOperation</span><span class="p">(</span><span class="n">multiply</span><span class="p">,</span> <span class="mi">42</span><span class="p">,</span> <span class="mi">51</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>My biggest take against function pointers is the readability. I find it extremely inconvenient that the parameter name is buried somewhere in the function pointer signature. Let’s use a <code class="language-plaintext highlighter-rouge">typedef</code> to improve the situation.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">using</span> <span class="n">MyFunctionPtr</span> <span class="o">=</span> <span class="kt">int</span><span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">performOperation</span><span class="p">(</span><span class="n">MyFunctionPtr</span> <span class="n">op</span><span class="p">,</span> <span class="kt">int</span> <span class="n">lhs</span><span class="p">,</span> <span class="kt">int</span> <span class="n">rhs</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">op</span><span class="p">(</span><span class="n">lhs</span><span class="p">,</span> <span class="n">rhs</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s better like that.</p><p>Now let’s compare how these three solutions compare against each other.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>std::function -O3<td>40,189<tr><td>templates -O3<td>35,259<tr><td>function pointer -O3<td>35,341</table></div><p>As we could expect, <code class="language-plaintext highlighter-rouge">std::function</code> resulted in a slightly bigger binary, the difference compared to the other two variants was above 10%. On the other hand, templates and function pointers had a similar result.</p><p>We cannot yet infer a long-term conclusion. What we see is that when you have a minimal template and few instantiations, then templates and function pointers have similar results. But we can expect that the template solution will scale worse. Each additional type of callable will add its own instantiation, and in addition, the longer the template is, the more space each generated function will take.</p><p>You have to keep those in mind. But if your templates are small and the number of instantiations is limited, probably the template version offers better readability. In particular, if you can use C++20’s concepts.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we discussed about how templates might bloat the size of a binary. It’s worth keeping in mind that each template instantiation adds to our binary. It’s also important to remember that we use more templates than we’d often think to. Containers are templates, including strings! Don’t forget, if you see <code class="language-plaintext highlighter-rouge">auto</code> in function parameter list, you see a function template!</p><p>Speaking about functions, let’s not forget that <code class="language-plaintext highlighter-rouge">std::function</code> is also a template, one of the more costliers! If you want to pass a callable and amy kind of efficieny matter for you, think about other options such creating a constrained template or just using function pointers!</p><p>If the function template that has to be instantiated each time is big, then probably a function pointer will be a good enough option despite it’s limited readability.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/functions/" class="post-tag no-text-decoration" >functions</a> <a href="/tags/templates/" class="post-tag no-text-decoration" >templates</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Binary sizes and passing functions to functions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Binary sizes and passing functions to functions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Binary sizes and passing functions to functions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Binary sizes and passing functions to functions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/11/08/extern-templates"><div class="card-body"> <span class="timeago small" > Nov 8, 2023 <i class="unloaded">2023-11-08T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Extern templates to reduce binary size</h3><div class="text-muted small"><p> In my quest towards a smaller binary size, someone asked me if I considered extern templates. I did not. I didn’t even know about them. But I was more than happy for the suggestion and now here I a...</p></div></div></a></div><div class="card"> <a href="/blog/2021/04/07/what-are-type-traits"><div class="card-body"> <span class="timeago small" > Apr 7, 2021 <i class="unloaded">2021-04-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What are type traits?</h3><div class="text-muted small"><p> Let’s start with a more generic question, what is a trait? What does the word trait mean? According to the Cambridge Dictionary, a trait is “a particular characteristic that can produce a particu...</p></div></div></a></div><div class="card"> <a href="/blog/2021/06/02/different-ways-to-achieve-SFINAE"><div class="card-body"> <span class="timeago small" > Jun 2, 2021 <i class="unloaded">2021-06-02T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Different ways to achieve SFINAE</h3><div class="text-muted small"><p> Life is a chain of opportunities. Each task you take on will lead you to more doors hiding other opportunities. Some are worth opening, some are not. Proofreading C++20: Get the Details by Rainer...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/03/29/binary-size-and-exceptions" class="btn btn-outline-primary" prompt="Older"><p>Binary size and exceptions</p></a> <a href="/blog/2023/04/12/vector-of-unique-pointers" class="btn btn-outline-primary" prompt="Newer"><p>Vectors and unique pointers</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Binary sizes and passing functions to functions'; this.page.url = 'https://www.sandordargo.com/blog/2023/04/05/binary-size-and-templates'; this.page.identifier = '/blog/2023/04/05/binary-size-and-templates'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
