<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Binary sizes and RTTI" /><meta property="og:locale" content="en_US" /><meta name="description" content="What is RTTI? What does it have to do with the size of your executables? Let’s start with answering the first one. RTTI stands for run-time type information. It’s available for every class that has at least one virtual function. With the help of such information, you can determine the type of an object during execution and use it for different purposes. Let’s see the two different ways to use it. typeid() and std::type_info With the help of typeid() we can query some information about a runtime object. In fact, it returns an object of the type std::type_info that you can find in the &lt;type_info&gt; header. In most cases, the type_info class is used in 2 ways: either to use its comparison operator to decide if two objects refer to the same type or to query the name of a type. Beware the name is implementation-defined. (int num; typeid(num).name() might return i as a name) Nevertheless, you can also query type_info for a hash_code() that will be identical for each type_info object referring to the same type. Also, you have before() which can help you decide whether type precedes the other in the given implementation’s collation order. What is a collation order? I’ve never heard about it before, but apparently in this case, it’s just a fancy word for operator&lt; and it comes in handy when you want to store type_infos in a map. As I wrote earlier, RTTI is only available to classes that have at least one virtual function. You can still use typeid with non-polymorphic types, but you might not get what you expect if you are looking for the dynamic type of an object. What else would you look for, right? Well, I can imagine that when you have a function template returning auto, you want to debug with typeid. That will work. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; auto fun(auto t, auto u) { return t + u; } int main() { std::cout &lt;&lt; typeid(fun(4.3, true)).name() &lt;&lt; &#39;\n&#39;; }; /* d */ But if you are using typeid with a non-polymorphic class hierarchy, it won’t work as it normally should. Instead of returning the derived type for *p declared as Base* p = new Derived(); it would return the static type, which is Base. Don’t forget to dereference the pointer if you want to know what type is behind the polymorphic base. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; class NonPolyBase {}; class NonPolyDerived : public NonPolyBase {}; class PolyBase { public: virtual ~PolyBase() = default; }; class PolyDerived : public PolyBase {}; int main() { NonPolyBase* p1 = new NonPolyDerived{}; PolyBase* p2 = new PolyDerived{}; std::cout &lt;&lt; typeid(*p1).name() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; typeid(*p2).name() &lt;&lt; &#39;\n&#39;; return 0; } /* 11NonPolyBase 11PolyDerived */ But beware, if you turn RTTI off at compile time, no matter how you use it, you’ll get a compilation error: error: cannot use &#39;typeid&#39; with &#39;-fno-rtti&#39;! No more dynamic_casts If you turn RTTI off, there is no more dynamic casting available to you either. In case you attempt to use it, you’ll get a similar message: error: &#39;dynamic_cast&#39; not permitted with &#39;-fno-rtti&#39;. But what is dynamic_cast and is it a problem if we have no access to it? dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type. In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } Many would say that this is a code smell. I’m among them. Many would go further and say that using dynamic_cast in general is a code smell. For sure, with proper architecture, by using the good patterns of coding, they can be easily avoided. In a sense, turning RTTI off can make your code much cleaner. It’s out of the scope for this article to discuss the different ways. What will you gain with RTTI? Speed? Not necessarily. Getting rid of dynamic_casts does not mean that you don’t cast, it just means you don’t do it explicitely, the compiler gets to figure out what’s the run-time type on its own without you telling it what to try. Probably it’s faster. Let’s have a quick example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // Ugly RTTI way using dynamic casts #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; }; class OffRoader : public Car { public: void turnOnAllWheelDrive() { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\n&quot;; } }; class Van : public Car { public: void attachThirdSeatRow() { std::cout &lt;&lt; &quot;attach third seatrow in a van\n&quot;; } }; class Roadster : public Car { public: void removeRoof() { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\n&quot;; } }; void prepareCarForFun(Car* car) { OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } } int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { prepareCarForFun(car.get()); } return 0; } // using no RTTI, no dynamic casts #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; virtual void doSomeFun() = 0; }; class OffRoader : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\n&quot;; } }; class Van : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;attach third seatrow in a van\n&quot;; } }; class Roadster : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { car-&gt;doSomeFun(); } return 0; } For sure you get clarity. Just look at the previous example! The second implementation without dynamic_casts is much more readable and it’s also shorter. There is one more major thing you gain by not having run-time type information available, and that’s space. To get such information during run-time, all the necessary names have to be stored somewhere and that’s your binary. By cutting it, your binary becomes smaller and also faster to write. Let’s take the previous example. I separated the classes into their own files and compile both with and without RTTI. Here are the results. Case Binary size Dynamic casts O0 88.7k Dynamic casts O3 37.3k No-Dynamic casts RTTI on O0 88.8k No-Dynamic casts RTTI on O3 37.2k No-Dynamic casts RTTI off O0 88.6k No-Dynamic casts RTTI off O3 37.0k Getting rid of dynamic casts with optimizations turned on decreased the binary size a little bit and the decrease was a bit more when RTTI was turned off. The differences in run-time and compile-time were a bit flaky, but it seems that they also decreased. It seems to me that unless you have a very good reason and limited space, the bytes you can gain might not be motivational enough. But keep in mind that getting rid of those dynamic casts will likely result also in more readable code. If you can commit to running your project without runtime type info, I think you should definitely do it. Not (only) for the size gain, but more for the cleaner code. So how to use it? That’s simple, you need to specify a compiler flag: For gcc and clang it’s -fno-rtti For MSVC, it’s /GR- Conclusion In this article, we saw that run-time type information is needed in order to use some language features such as typeid and dynamic_cast. We also saw that their usage is not necessarily considered best practice in the community. By forcing you not to rely on RTTI, you might not only get better code, but you’ll also end up having a smaller binary. In my opinion, it’s totally worth it - unless you have such a legacy that you cannot easily get rid of your dependence on RTTI. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="What is RTTI? What does it have to do with the size of your executables? Let’s start with answering the first one. RTTI stands for run-time type information. It’s available for every class that has at least one virtual function. With the help of such information, you can determine the type of an object during execution and use it for different purposes. Let’s see the two different ways to use it. typeid() and std::type_info With the help of typeid() we can query some information about a runtime object. In fact, it returns an object of the type std::type_info that you can find in the &lt;type_info&gt; header. In most cases, the type_info class is used in 2 ways: either to use its comparison operator to decide if two objects refer to the same type or to query the name of a type. Beware the name is implementation-defined. (int num; typeid(num).name() might return i as a name) Nevertheless, you can also query type_info for a hash_code() that will be identical for each type_info object referring to the same type. Also, you have before() which can help you decide whether type precedes the other in the given implementation’s collation order. What is a collation order? I’ve never heard about it before, but apparently in this case, it’s just a fancy word for operator&lt; and it comes in handy when you want to store type_infos in a map. As I wrote earlier, RTTI is only available to classes that have at least one virtual function. You can still use typeid with non-polymorphic types, but you might not get what you expect if you are looking for the dynamic type of an object. What else would you look for, right? Well, I can imagine that when you have a function template returning auto, you want to debug with typeid. That will work. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; auto fun(auto t, auto u) { return t + u; } int main() { std::cout &lt;&lt; typeid(fun(4.3, true)).name() &lt;&lt; &#39;\n&#39;; }; /* d */ But if you are using typeid with a non-polymorphic class hierarchy, it won’t work as it normally should. Instead of returning the derived type for *p declared as Base* p = new Derived(); it would return the static type, which is Base. Don’t forget to dereference the pointer if you want to know what type is behind the polymorphic base. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; class NonPolyBase {}; class NonPolyDerived : public NonPolyBase {}; class PolyBase { public: virtual ~PolyBase() = default; }; class PolyDerived : public PolyBase {}; int main() { NonPolyBase* p1 = new NonPolyDerived{}; PolyBase* p2 = new PolyDerived{}; std::cout &lt;&lt; typeid(*p1).name() &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; typeid(*p2).name() &lt;&lt; &#39;\n&#39;; return 0; } /* 11NonPolyBase 11PolyDerived */ But beware, if you turn RTTI off at compile time, no matter how you use it, you’ll get a compilation error: error: cannot use &#39;typeid&#39; with &#39;-fno-rtti&#39;! No more dynamic_casts If you turn RTTI off, there is no more dynamic casting available to you either. In case you attempt to use it, you’ll get a similar message: error: &#39;dynamic_cast&#39; not permitted with &#39;-fno-rtti&#39;. But what is dynamic_cast and is it a problem if we have no access to it? dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type. In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } Many would say that this is a code smell. I’m among them. Many would go further and say that using dynamic_cast in general is a code smell. For sure, with proper architecture, by using the good patterns of coding, they can be easily avoided. In a sense, turning RTTI off can make your code much cleaner. It’s out of the scope for this article to discuss the different ways. What will you gain with RTTI? Speed? Not necessarily. Getting rid of dynamic_casts does not mean that you don’t cast, it just means you don’t do it explicitely, the compiler gets to figure out what’s the run-time type on its own without you telling it what to try. Probably it’s faster. Let’s have a quick example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // Ugly RTTI way using dynamic casts #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; }; class OffRoader : public Car { public: void turnOnAllWheelDrive() { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\n&quot;; } }; class Van : public Car { public: void attachThirdSeatRow() { std::cout &lt;&lt; &quot;attach third seatrow in a van\n&quot;; } }; class Roadster : public Car { public: void removeRoof() { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\n&quot;; } }; void prepareCarForFun(Car* car) { OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } } int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { prepareCarForFun(car.get()); } return 0; } // using no RTTI, no dynamic casts #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; virtual void doSomeFun() = 0; }; class OffRoader : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\n&quot;; } }; class Van : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;attach third seatrow in a van\n&quot;; } }; class Roadster : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { car-&gt;doSomeFun(); } return 0; } For sure you get clarity. Just look at the previous example! The second implementation without dynamic_casts is much more readable and it’s also shorter. There is one more major thing you gain by not having run-time type information available, and that’s space. To get such information during run-time, all the necessary names have to be stored somewhere and that’s your binary. By cutting it, your binary becomes smaller and also faster to write. Let’s take the previous example. I separated the classes into their own files and compile both with and without RTTI. Here are the results. Case Binary size Dynamic casts O0 88.7k Dynamic casts O3 37.3k No-Dynamic casts RTTI on O0 88.8k No-Dynamic casts RTTI on O3 37.2k No-Dynamic casts RTTI off O0 88.6k No-Dynamic casts RTTI off O3 37.0k Getting rid of dynamic casts with optimizations turned on decreased the binary size a little bit and the decrease was a bit more when RTTI was turned off. The differences in run-time and compile-time were a bit flaky, but it seems that they also decreased. It seems to me that unless you have a very good reason and limited space, the bytes you can gain might not be motivational enough. But keep in mind that getting rid of those dynamic casts will likely result also in more readable code. If you can commit to running your project without runtime type info, I think you should definitely do it. Not (only) for the size gain, but more for the cleaner code. So how to use it? That’s simple, you need to specify a compiler flag: For gcc and clang it’s -fno-rtti For MSVC, it’s /GR- Conclusion In this article, we saw that run-time type information is needed in order to use some language features such as typeid and dynamic_cast. We also saw that their usage is not necessarily considered best practice in the community. By forcing you not to rely on RTTI, you might not only get better code, but you’ll also end up having a smaller binary. In my opinion, it’s totally worth it - unless you have such a legacy that you cannot easily get rid of your dependence on RTTI. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-01T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Binary sizes and RTTI" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-01T00:00:00+01:00","datePublished":"2023-03-01T00:00:00+01:00","description":"What is RTTI? What does it have to do with the size of your executables? Let’s start with answering the first one. RTTI stands for run-time type information. It’s available for every class that has at least one virtual function. With the help of such information, you can determine the type of an object during execution and use it for different purposes. Let’s see the two different ways to use it. typeid() and std::type_info With the help of typeid() we can query some information about a runtime object. In fact, it returns an object of the type std::type_info that you can find in the &lt;type_info&gt; header. In most cases, the type_info class is used in 2 ways: either to use its comparison operator to decide if two objects refer to the same type or to query the name of a type. Beware the name is implementation-defined. (int num; typeid(num).name() might return i as a name) Nevertheless, you can also query type_info for a hash_code() that will be identical for each type_info object referring to the same type. Also, you have before() which can help you decide whether type precedes the other in the given implementation’s collation order. What is a collation order? I’ve never heard about it before, but apparently in this case, it’s just a fancy word for operator&lt; and it comes in handy when you want to store type_infos in a map. As I wrote earlier, RTTI is only available to classes that have at least one virtual function. You can still use typeid with non-polymorphic types, but you might not get what you expect if you are looking for the dynamic type of an object. What else would you look for, right? Well, I can imagine that when you have a function template returning auto, you want to debug with typeid. That will work. 1 2 3 4 5 6 7 8 9 10 11 12 #include &lt;iostream&gt; auto fun(auto t, auto u) { return t + u; } int main() { std::cout &lt;&lt; typeid(fun(4.3, true)).name() &lt;&lt; &#39;\\n&#39;; }; /* d */ But if you are using typeid with a non-polymorphic class hierarchy, it won’t work as it normally should. Instead of returning the derived type for *p declared as Base* p = new Derived(); it would return the static type, which is Base. Don’t forget to dereference the pointer if you want to know what type is behind the polymorphic base. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; class NonPolyBase {}; class NonPolyDerived : public NonPolyBase {}; class PolyBase { public: virtual ~PolyBase() = default; }; class PolyDerived : public PolyBase {}; int main() { NonPolyBase* p1 = new NonPolyDerived{}; PolyBase* p2 = new PolyDerived{}; std::cout &lt;&lt; typeid(*p1).name() &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; typeid(*p2).name() &lt;&lt; &#39;\\n&#39;; return 0; } /* 11NonPolyBase 11PolyDerived */ But beware, if you turn RTTI off at compile time, no matter how you use it, you’ll get a compilation error: error: cannot use &#39;typeid&#39; with &#39;-fno-rtti&#39;! No more dynamic_casts If you turn RTTI off, there is no more dynamic casting available to you either. In case you attempt to use it, you’ll get a similar message: error: &#39;dynamic_cast&#39; not permitted with &#39;-fno-rtti&#39;. But what is dynamic_cast and is it a problem if we have no access to it? dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type. In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } Many would say that this is a code smell. I’m among them. Many would go further and say that using dynamic_cast in general is a code smell. For sure, with proper architecture, by using the good patterns of coding, they can be easily avoided. In a sense, turning RTTI off can make your code much cleaner. It’s out of the scope for this article to discuss the different ways. What will you gain with RTTI? Speed? Not necessarily. Getting rid of dynamic_casts does not mean that you don’t cast, it just means you don’t do it explicitely, the compiler gets to figure out what’s the run-time type on its own without you telling it what to try. Probably it’s faster. Let’s have a quick example. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 // Ugly RTTI way using dynamic casts #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; }; class OffRoader : public Car { public: void turnOnAllWheelDrive() { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\\n&quot;; } }; class Van : public Car { public: void attachThirdSeatRow() { std::cout &lt;&lt; &quot;attach third seatrow in a van\\n&quot;; } }; class Roadster : public Car { public: void removeRoof() { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\\n&quot;; } }; void prepareCarForFun(Car* car) { OffRoader* offroader = dynamic_cast&lt;OffRoader*&gt;(car); if (offroader) { offroader-&gt;turnOnAllWheelDrive(); } Van* van = dynamic_cast&lt;Van*&gt;(car); if (van) { van-&gt;attachThirdSeatRow(); } Roadster* roadster = dynamic_cast&lt;Roadster*&gt;(car); if (roadster) { roadster-&gt;removeRoof(); } } int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { prepareCarForFun(car.get()); } return 0; } // using no RTTI, no dynamic casts #include &lt;iostream&gt; #include &lt;memory&gt; #include &lt;vector&gt; class Car { public: virtual ~Car() = default; virtual void doSomeFun() = 0; }; class OffRoader : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;use all wheel drive on OffRoader\\n&quot;; } }; class Van : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;attach third seatrow in a van\\n&quot;; } }; class Roadster : public Car { public: void doSomeFun() override { std::cout &lt;&lt; &quot;remove roadster&#39;s roof\\n&quot;; } }; int main() { std::vector&lt;std::unique_ptr&lt;Car&gt;&gt; myCars; myCars.push_back(std::make_unique&lt;OffRoader&gt;()); myCars.push_back(std::make_unique&lt;Van&gt;()); myCars.push_back(std::make_unique&lt;Roadster&gt;()); for (auto&amp; car: myCars) { car-&gt;doSomeFun(); } return 0; } For sure you get clarity. Just look at the previous example! The second implementation without dynamic_casts is much more readable and it’s also shorter. There is one more major thing you gain by not having run-time type information available, and that’s space. To get such information during run-time, all the necessary names have to be stored somewhere and that’s your binary. By cutting it, your binary becomes smaller and also faster to write. Let’s take the previous example. I separated the classes into their own files and compile both with and without RTTI. Here are the results. Case Binary size Dynamic casts O0 88.7k Dynamic casts O3 37.3k No-Dynamic casts RTTI on O0 88.8k No-Dynamic casts RTTI on O3 37.2k No-Dynamic casts RTTI off O0 88.6k No-Dynamic casts RTTI off O3 37.0k Getting rid of dynamic casts with optimizations turned on decreased the binary size a little bit and the decrease was a bit more when RTTI was turned off. The differences in run-time and compile-time were a bit flaky, but it seems that they also decreased. It seems to me that unless you have a very good reason and limited space, the bytes you can gain might not be motivational enough. But keep in mind that getting rid of those dynamic casts will likely result also in more readable code. If you can commit to running your project without runtime type info, I think you should definitely do it. Not (only) for the size gain, but more for the cleaner code. So how to use it? That’s simple, you need to specify a compiler flag: For gcc and clang it’s -fno-rtti For MSVC, it’s /GR- Conclusion In this article, we saw that run-time type information is needed in order to use some language features such as typeid and dynamic_cast. We also saw that their usage is not necessarily considered best practice in the community. By forcing you not to rely on RTTI, you might not only get better code, but you’ll also end up having a smaller binary. In my opinion, it’s totally worth it - unless you have such a legacy that you cannot easily get rid of your dependence on RTTI. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Binary sizes and RTTI","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti"},"url":"https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti"}</script><title>Binary sizes and RTTI | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/01"> 01 </a> </span> <span>Binary sizes and RTTI</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Binary sizes and RTTI</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 1, 2023, 12:00 AM +0100" prep="on" > Mar 1, 2023 <i class="unloaded">2023-03-01T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1541 words">8 min</span></div></div><div class="post-content"><p>What is RTTI? What does it have to do with the size of your executables?</p><p>Let’s start with answering the first one.</p><p>RTTI stands for <em>run-time type information</em>. It’s available for every class that has at least one <code class="language-plaintext highlighter-rouge">virtual</code> function. With the help of such information, you can determine the type of an object during execution and use it for different purposes.</p><p>Let’s see the two different ways to use it.</p><h2 id="typeid-and-stdtype_info"><code class="language-plaintext highlighter-rouge">typeid()</code> and <code class="language-plaintext highlighter-rouge">std::type_info</code></h2><p>With the help of <code class="language-plaintext highlighter-rouge">typeid()</code> we can query some information about a runtime object. In fact, it returns an object of the type <code class="language-plaintext highlighter-rouge">std::type_info</code> that you can find in the <code class="language-plaintext highlighter-rouge">&lt;type_info&gt;</code> header.</p><p>In most cases, the <code class="language-plaintext highlighter-rouge">type_info</code> class is used in 2 ways:</p><ul><li>either to use its comparison operator to decide if two objects refer to the same type<li>or to query the name of a type. Beware the name is implementation-defined. (<code class="language-plaintext highlighter-rouge">int num; typeid(num).name()</code> might return <code class="language-plaintext highlighter-rouge">i</code> as a name)</ul><p>Nevertheless, you can also query <code class="language-plaintext highlighter-rouge">type_info</code> for a <code class="language-plaintext highlighter-rouge">hash_code()</code> that will be identical for each type_info object referring to the same type. Also, you have <code class="language-plaintext highlighter-rouge">before()</code> which can help you decide whether type precedes the other in the given implementation’s collation order. What is a collation order? I’ve never heard about it before, but <a href="https://stackoverflow.com/questions/8682582/what-is-type-infobefore-useful-for">apparently in this case</a>, it’s just a fancy word for <code class="language-plaintext highlighter-rouge">operator&lt;</code> and it comes in handy when you want to store <code class="language-plaintext highlighter-rouge">type_infos</code> in a <code class="language-plaintext highlighter-rouge">map</code>.</p><p>As I wrote earlier, RTTI is only available to classes that have at least one <code class="language-plaintext highlighter-rouge">virtual</code> function.</p><p>You can still use <code class="language-plaintext highlighter-rouge">typeid</code> with non-polymorphic types, but you might not get what you expect if you are looking for the dynamic type of an object. What else would you look for, right?</p><p>Well, I can imagine that when you have a function template returning <code class="language-plaintext highlighter-rouge">auto</code>, you want to debug with <code class="language-plaintext highlighter-rouge">typeid</code>. That will work.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">auto</span> <span class="nf">fun</span><span class="p">(</span><span class="k">auto</span> <span class="n">t</span><span class="p">,</span> <span class="k">auto</span> <span class="n">u</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">t</span> <span class="o">+</span> <span class="n">u</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="n">fun</span><span class="p">(</span><span class="mf">4.3</span><span class="p">,</span> <span class="nb">true</span><span class="p">)).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">};</span>
<span class="cm">/*
d
*/</span>
</pre></table></code></div></div><p>But if you are using typeid with a non-polymorphic class hierarchy, it won’t work as it normally should. Instead of returning the derived type for <code class="language-plaintext highlighter-rouge">*p</code> declared as <code class="language-plaintext highlighter-rouge">Base* p = new Derived();</code> it would return the static type, which is <code class="language-plaintext highlighter-rouge">Base</code>. Don’t forget to dereference the pointer if you want to know what type is behind the polymorphic base.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">NonPolyBase</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">NonPolyDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">NonPolyBase</span> <span class="p">{};</span>

<span class="k">class</span> <span class="nc">PolyBase</span> <span class="p">{</span>
 <span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">PolyBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">PolyDerived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">PolyBase</span> <span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">NonPolyBase</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">NonPolyDerived</span><span class="p">{};</span>
    <span class="n">PolyBase</span><span class="o">*</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">PolyDerived</span><span class="p">{};</span>
    
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">p1</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="k">typeid</span><span class="p">(</span><span class="o">*</span><span class="n">p2</span><span class="p">).</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
11NonPolyBase
11PolyDerived
*/</span>
</pre></table></code></div></div><p>But beware, if you turn RTTI off at compile time, no matter how you use it, you’ll get a compilation error: <code class="language-plaintext highlighter-rouge">error: cannot use 'typeid' with '-fno-rtti'</code>!</p><h2 id="no-more-dynamic_casts">No more <code class="language-plaintext highlighter-rouge">dynamic_cast</code>s</h2><p>If you turn RTTI off, there is no more dynamic casting available to you either. In case you attempt to use it, you’ll get a similar message: <code class="language-plaintext highlighter-rouge">error: 'dynamic_cast' not permitted with '-fno-rtti'</code>.</p><p>But what is <code class="language-plaintext highlighter-rouge">dynamic_cast</code> and is it a problem if we have no access to it?</p><p><em><code class="language-plaintext highlighter-rouge">dynamic_cast</code> safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy</em> - according to <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast">CppReference</a>. Often when you have a collection of pointers to the base class, you’ll try to cast it to different derived classes and if the case is successful you do whatever you want with that type.</p><p>In other words, when you have no idea what types you have, you can start casting things. You might even have a series of casts like this:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="n">OffRoader</span><span class="o">*</span> <span class="n">offroader</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">OffRoader</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">offroader</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">offroader</span><span class="o">-&gt;</span><span class="n">turnOnAllWheelDrive</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Van</span><span class="o">*</span> <span class="n">van</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Van</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">van</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">van</span><span class="o">-&gt;</span><span class="n">attachThirdSeatRow</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">Roadster</span><span class="o">*</span> <span class="n">roadster</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Roadster</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">roadster</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">roadster</span><span class="o">-&gt;</span><span class="n">removeRoof</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Many would say that this is a code smell. I’m among them. Many would go further and say that using <code class="language-plaintext highlighter-rouge">dynamic_cast</code> in general is a code smell.</p><p>For sure, with proper architecture, by using the good patterns of coding, they can be easily avoided.</p><p>In a sense, turning RTTI off can make your code much cleaner. It’s out of the scope for this article to discuss the different ways.</p><h2 id="what-will-you-gain-with-rtti">What will you gain with RTTI?</h2><p>Speed? Not necessarily. Getting rid of <code class="language-plaintext highlighter-rouge">dynamic_cast</code>s does not mean that you don’t cast, it just means you don’t do it explicitely, the compiler gets to figure out what’s the run-time type on its own without you telling it what to try. Probably it’s faster.</p><p>Let’s have a quick example.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
</pre><td class="rouge-code"><pre><span class="c1">// Ugly RTTI way using dynamic casts</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">OffRoader</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">turnOnAllWheelDrive</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"use all wheel drive on OffRoader</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Van</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">attachThirdSeatRow</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"attach third seatrow in a van</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Roadster</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">removeRoof</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"remove roadster's roof</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="nf">prepareCarForFun</span><span class="p">(</span><span class="n">Car</span><span class="o">*</span> <span class="n">car</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">OffRoader</span><span class="o">*</span> <span class="n">offroader</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">OffRoader</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">offroader</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">offroader</span><span class="o">-&gt;</span><span class="n">turnOnAllWheelDrive</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="n">Van</span><span class="o">*</span> <span class="n">van</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Van</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">van</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">van</span><span class="o">-&gt;</span><span class="n">attachThirdSeatRow</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="n">Roadster</span><span class="o">*</span> <span class="n">roadster</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Roadster</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">car</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">roadster</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">roadster</span><span class="o">-&gt;</span><span class="n">removeRoof</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&gt;</span> <span class="n">myCars</span><span class="p">;</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OffRoader</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Van</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Roadster</span><span class="o">&gt;</span><span class="p">());</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span><span class="o">:</span> <span class="n">myCars</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">prepareCarForFun</span><span class="p">(</span><span class="n">car</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// using no RTTI, no dynamic casts</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;vector&gt;</span><span class="cp">
</span>

<span class="k">class</span> <span class="nc">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">virtual</span> <span class="o">~</span><span class="n">Car</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">OffRoader</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"use all wheel drive on OffRoader</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Van</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"attach third seatrow in a van</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Roadster</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Car</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="n">doSomeFun</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"remove roadster's roof</span><span class="se">\n</span><span class="s">"</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Car</span><span class="o">&gt;&gt;</span> <span class="n">myCars</span><span class="p">;</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">OffRoader</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Van</span><span class="o">&gt;</span><span class="p">());</span>
    <span class="n">myCars</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Roadster</span><span class="o">&gt;</span><span class="p">());</span>
    
    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="n">car</span><span class="o">:</span> <span class="n">myCars</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">car</span><span class="o">-&gt;</span><span class="n">doSomeFun</span><span class="p">();</span>
    <span class="p">}</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>For sure you get clarity. Just look at the previous example! The second implementation without <code class="language-plaintext highlighter-rouge">dynamic_cast</code>s is much more readable and it’s also shorter.</p><p>There is one more major thing you gain by not having run-time type information available, and that’s space.</p><p>To get such information during run-time, all the necessary names have to be stored somewhere and that’s your binary. By cutting it, your binary becomes smaller and also faster to write.</p><p>Let’s take the previous example. I separated the classes into their own files and compile both with and without RTTI.</p><p>Here are the results.</p><div class="table-wrapper"><table><thead><tr><th>Case<th>Binary size<tbody><tr><td>Dynamic casts O0<td>88.7k<tr><td>Dynamic casts O3<td>37.3k<tr><td>No-Dynamic casts RTTI on O0<td>88.8k<tr><td>No-Dynamic casts RTTI on O3<td>37.2k<tr><td>No-Dynamic casts RTTI off O0<td>88.6k<tr><td>No-Dynamic casts RTTI off O3<td>37.0k</table></div><p>Getting rid of dynamic casts with optimizations turned on decreased the binary size a little bit and the decrease was a bit more when RTTI was turned off. The differences in run-time and compile-time were a bit flaky, but it seems that they also decreased.</p><p>It seems to me that unless you have a very good reason and limited space, the bytes you can gain might not be motivational enough. But keep in mind that getting rid of those dynamic casts will likely result also in more readable code.</p><p>If you can commit to running your project without runtime type info, I think you should definitely do it. Not (only) for the size gain, but more for the cleaner code.</p><h2 id="so-how-to-use-it">So how to use it?</h2><p>That’s simple, you need to specify a compiler flag:</p><ul><li>For gcc and clang it’s <code class="language-plaintext highlighter-rouge">-fno-rtti</code><li>For MSVC, it’s <code class="language-plaintext highlighter-rouge">/GR-</code></ul><h2 id="conclusion">Conclusion</h2><p>In this article, we saw that run-time type information is needed in order to use some language features such as <code class="language-plaintext highlighter-rouge">typeid</code> and <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. We also saw that their usage is not necessarily considered best practice in the community. By forcing you not to rely on RTTI, you might not only get better code, but you’ll also end up having a smaller binary.</p><p>In my opinion, it’s totally worth it - unless you have such a legacy that you cannot easily get rid of your dependence on RTTI.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/rtti/" class="post-tag no-text-decoration" >rtti</a> <a href="/tags/cleancode/" class="post-tag no-text-decoration" >cleancode</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Binary sizes and RTTI - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Binary sizes and RTTI - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Binary sizes and RTTI - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Binary sizes and RTTI - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/31/rule-of-5-once-again"><div class="card-body"> <span class="timeago small" > Jul 31, 2024 <i class="unloaded">2024-07-31T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Once more about the rule of 5</h3><div class="text-muted small"><p> Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/07/rule-of-five-and-base-classes"><div class="card-body"> <span class="timeago small" > Aug 7, 2024 <i class="unloaded">2024-08-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The rule of 5 and inheritance</h3><div class="text-muted small"><p> Last week, we talked about the rule of five and we discovered what it means for move operations if we only declare a destructor and not the rest of the special member functions. In that case, move ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/02/27/easiest-way-to-add-custom-code-to-your-wordpress-site" class="btn btn-outline-primary" prompt="Older"><p>What's the easiest way to add custom code to your WordPress site without breaking it?</p></a> <a href="/blog/2023/03/08/binary-sizes-and-decorator-pattern" class="btn btn-outline-primary" prompt="Newer"><p>The decorator pattern and binary sizes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Binary sizes and RTTI'; this.page.url = 'https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti'; this.page.identifier = '/blog/2023/03/01/binary-sizes-and-rtti'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
