<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The observer pattern and binary sizes" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the previous article on binary sizes, we discussed how the decorator pattern’s classic and modern implementation fares in terms of binary size. We saw that the modern implementation had a smaller size, but the difference was not great and it’s not always evident how it scales. Today, let’s talk about a different pattern, the observer. Once again, I borrow the examples from Klaus Igleberger’s book, C++ Software Design. The Observer pattern The observer pattern is thoroughly explained in the famous GoF book. With the help of this pattern, you define a convenient way to notify objects about any event that happens to the observed object. I borrowed Klaus’ example, in which there are Person objects being observed for changes in their names, addresses, etc. How much more convenient it is get a notification instead of querying it all the time and tracking if the returned value means a change or not! In his book, Klaus offers two solutions, a classic and the modern one. The classic observer Let’s have a look at the classic first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 // observer.h #pragma once template&lt; typename Subject, typename StateTag &gt; class Observer { public: virtual ~Observer() = default; virtual void update( Subject const&amp; subject, StateTag property ) = 0; }; // name_observer.h #pragma once #include &quot;observer.h&quot; #include &quot;person.h&quot; class NameObserver : public Observer&lt;Person,Person::StateChange&gt; { public: void update( Person const&amp; person, Person::StateChange property ) override; }; // name_observer.cpp #include &quot;name_observer.h&quot; void NameObserver::update( Person const&amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... Respond to changed name } } // address_observer.h #pragma once #include &quot;observer.h&quot; #include &quot;person.h&quot; class AddressObserver : public Observer&lt;Person,Person::StateChange&gt; { public: void update( Person const&amp; person, Person::StateChange property ) override; }; // address_observer.cpp #include &quot;address_observer.h&quot; void AddressObserver::update( Person const&amp; person, Person::StateChange property ) { if( property == Person::addressChanged ) { // ... Respond to changed address } } // person.h #pragma once #include &quot;observer.h&quot; #include &lt;string&gt; #include &lt;set&gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer&lt;Person,StateChange&gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const&amp; forename() const { return forename_; } std::string const&amp; surname () const { return surname_; } std::string const&amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set&lt;PersonObserver*&gt; observers_; }; // person.cpp #include &quot;person.h&quot; void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) &gt; 0U ); } void Person::notify( StateChange property ) { // This formulation makes sure detach() operations // can be detected during the iteration for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-&gt;update(*this,property); } } // main.cpp #include &quot;address_observer.h&quot; #include &quot;name_observer.h&quot; #include &quot;person.h&quot; #include &lt;cstdlib&gt; int main() { NameObserver nameObserver; AddressObserver addressObserver; Person homer( &quot;Homer&quot; , &quot;Simpson&quot; ); Person marge( &quot;Marge&quot; , &quot;Simpson&quot; ); Person monty( &quot;Montgomery&quot;, &quot;Burns&quot; ); // Attaching observers homer.attach( &amp;nameObserver ); marge.attach( &amp;addressObserver ); monty.attach( &amp;addressObserver ); // Updating information on Homer Simpson homer.forename( &quot;Homer Jay&quot; ); // Adding his middle name // Updating information on Marge Simpson marge.address( &quot;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&quot; ); // Updating information on Montgomery Burns monty.address( &quot;Springfield Nuclear Power Plant&quot; ); // Detaching observers homer.detach( &amp;nameObserver ); return EXIT_SUCCESS; } As you can see, the observers constitute an object hierarchy, but templates are also involved. Templates often (can) contribute to a bigger binary size. Having polymorphic classes both contribute to higher binary sizes and worse run-time performance. The modern observer Now let’s look at the much more slim modern version of this pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 // observer.h #pragma once #include &lt;functional&gt; template&lt; typename Subject, typename StateTag &gt; class Observer { public: // using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;; // typedef void (*OnUpdate)(Subject const&amp;,StateTag); using OnUpdate = void (*)(Subject const&amp;,StateTag); // No virtual destructor necessary explicit Observer( OnUpdate onUpdate ) : onUpdate_{ std::move(onUpdate) } { // Possibly respond on an invalid/empty std::function instance } // Non-virtual update function void update( Subject const&amp; subject, StateTag property ) { onUpdate_( subject, property ); } private: OnUpdate onUpdate_; }; // person.h #pragma once #include &quot;observer.h&quot; #include &lt;string&gt; #include &lt;set&gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer&lt;Person,StateChange&gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const&amp; forename() const { return forename_; } std::string const&amp; surname () const { return surname_; } std::string const&amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set&lt;PersonObserver*&gt; observers_; }; // person.cpp #include &quot;person.h&quot; void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) &gt; 0U ); } void Person::notify( StateChange property ) { // This formulation makes sure detach() operations // can be detected during the iteration for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-&gt;update(*this,property); } } // main.cpp #include &quot;observer.h&quot; #include &quot;person.h&quot; #include &lt;cstdlib&gt; void propertyChanged( Person const&amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... Respond to changed name } } int main() { using PersonObserver = Observer&lt;Person,Person::StateChange&gt;; PersonObserver nameObserver( propertyChanged ); PersonObserver addressObserver( [/*captured state*/]( Person const&amp; person, Person::StateChange property ){ if( property == Person::addressChanged ) { // ... Respond to changed address } } ); Person homer( &quot;Homer&quot; , &quot;Simpson&quot; ); Person marge( &quot;Marge&quot; , &quot;Simpson&quot; ); Person monty( &quot;Montgomery&quot;, &quot;Burns&quot; ); // Attaching observers homer.attach( &amp;nameObserver ); marge.attach( &amp;addressObserver ); monty.attach( &amp;addressObserver ); // Updating information on Homer Simpson homer.forename( &quot;Homer Jay&quot; ); // Adding his middle name // Updating information on Marge Simpson marge.address( &quot;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&quot; ); // Updating information on Montgomery Burns monty.address( &quot;Springfield Nuclear Power Plant&quot; ); // Detaching observers homer.detach( &amp;nameObserver ); return EXIT_SUCCESS; } In comparison The Observer uses the same template parameters, but instead of providing a virtual function as a customization point, it takes a std::function object. The Person object is the very same as in the classic example. The modern version seems easier to implement, our assumption is that it’s faster due to the lack of virtual functions, but what about the binary size? A surprising result Interestingly, the modern version produces a binary that is about 10% bigger when optimized, otherwise, with -O0 the difference is about 70%! Still, it compiled considerably faster than the classic version! Version Binary size Compile time classical observer -O0 85.5K 9.04s classical observer -O3 35.9K 9.84s classical observer -Os 47.1K 9.91s modern observer -O0 142K 7.56s modern observer -O3 39.5K 8.34s modern observer -Os 40.9K 8.2s But what can be behind this size difference? And how do they scale? Let’s focus on the -O3 version as most probably you’ll use that for your releases! I used a new observer as simple as the above ones. Adding a new observer to the classic solution adds about 400 bytes. For the modern, we have two possibilities: adding a new observer with a lambda added an extra 1500 bytes. That scales up almost 4 times as fast as the classic solution! but implementing the new observer with a free function only added a hundred extra bytes which 4 times less as for the classic one. Turning the results around At a first glance, it seems that if we want to shave off some of the binary, we should rely on free functions. Modifying the original example, to use only functions still left us with a 2k bigger binary than the classic solution. Templates can significantly increase the size of the binary. And I realized that it’s the case here too. std::function is a function template. While all our free function observers have the same type (void (*)(Subject const&amp;, StateTag)), each lambda is compiled into a different object and therefore a new function template instantiation is necessary! So what if we replace std::function with a good old function pointer? A std::function is a type erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. std::function has quite some overhead, but it provides flexibility. Watch this video on C++ Weekly to learn more. Let’s replace one line in the Observer class: 1 2 // using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;; using OnUpdate = void (*)(Subject const&amp;,StateTag); Now we have a smaller binary and even the lambdas are not problematic anymore! And we still have the compile-time advantage too! Version Binary size Compile time classical observer -O0 85.5K 9.04s classical observer -O3 35.9K 9.84s modern observer with free functions -O0 84.4K 7.0s modern observer with free functions -O0 35K 7.48s modern observer with a free function and a lambda -O3 84.6K 7.1s modern observer with a free function and a lambda -O3 35.1K 7.5s If you focus on the binary, you can win big by replacing std::function and some additional bytes by using free functions instead of lambdas. Conclusion Today, we compared classic and modern implementations of the observer design patterns in terms of binary sizes. First, we saw that the classic version of the observer pattern was smaller and scaled sometimes better than the modern implementation. Then we found that, if we don’t need the features of std::function, but you can use a function pointer to take your observers, you can win big and end up with a nicely scaling implementation that is faster and smaller than the classic version. Next time we’ll look into binary sizes and templates as we already partially discussed this topic. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In the previous article on binary sizes, we discussed how the decorator pattern’s classic and modern implementation fares in terms of binary size. We saw that the modern implementation had a smaller size, but the difference was not great and it’s not always evident how it scales. Today, let’s talk about a different pattern, the observer. Once again, I borrow the examples from Klaus Igleberger’s book, C++ Software Design. The Observer pattern The observer pattern is thoroughly explained in the famous GoF book. With the help of this pattern, you define a convenient way to notify objects about any event that happens to the observed object. I borrowed Klaus’ example, in which there are Person objects being observed for changes in their names, addresses, etc. How much more convenient it is get a notification instead of querying it all the time and tracking if the returned value means a change or not! In his book, Klaus offers two solutions, a classic and the modern one. The classic observer Let’s have a look at the classic first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 // observer.h #pragma once template&lt; typename Subject, typename StateTag &gt; class Observer { public: virtual ~Observer() = default; virtual void update( Subject const&amp; subject, StateTag property ) = 0; }; // name_observer.h #pragma once #include &quot;observer.h&quot; #include &quot;person.h&quot; class NameObserver : public Observer&lt;Person,Person::StateChange&gt; { public: void update( Person const&amp; person, Person::StateChange property ) override; }; // name_observer.cpp #include &quot;name_observer.h&quot; void NameObserver::update( Person const&amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... Respond to changed name } } // address_observer.h #pragma once #include &quot;observer.h&quot; #include &quot;person.h&quot; class AddressObserver : public Observer&lt;Person,Person::StateChange&gt; { public: void update( Person const&amp; person, Person::StateChange property ) override; }; // address_observer.cpp #include &quot;address_observer.h&quot; void AddressObserver::update( Person const&amp; person, Person::StateChange property ) { if( property == Person::addressChanged ) { // ... Respond to changed address } } // person.h #pragma once #include &quot;observer.h&quot; #include &lt;string&gt; #include &lt;set&gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer&lt;Person,StateChange&gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const&amp; forename() const { return forename_; } std::string const&amp; surname () const { return surname_; } std::string const&amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set&lt;PersonObserver*&gt; observers_; }; // person.cpp #include &quot;person.h&quot; void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) &gt; 0U ); } void Person::notify( StateChange property ) { // This formulation makes sure detach() operations // can be detected during the iteration for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-&gt;update(*this,property); } } // main.cpp #include &quot;address_observer.h&quot; #include &quot;name_observer.h&quot; #include &quot;person.h&quot; #include &lt;cstdlib&gt; int main() { NameObserver nameObserver; AddressObserver addressObserver; Person homer( &quot;Homer&quot; , &quot;Simpson&quot; ); Person marge( &quot;Marge&quot; , &quot;Simpson&quot; ); Person monty( &quot;Montgomery&quot;, &quot;Burns&quot; ); // Attaching observers homer.attach( &amp;nameObserver ); marge.attach( &amp;addressObserver ); monty.attach( &amp;addressObserver ); // Updating information on Homer Simpson homer.forename( &quot;Homer Jay&quot; ); // Adding his middle name // Updating information on Marge Simpson marge.address( &quot;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&quot; ); // Updating information on Montgomery Burns monty.address( &quot;Springfield Nuclear Power Plant&quot; ); // Detaching observers homer.detach( &amp;nameObserver ); return EXIT_SUCCESS; } As you can see, the observers constitute an object hierarchy, but templates are also involved. Templates often (can) contribute to a bigger binary size. Having polymorphic classes both contribute to higher binary sizes and worse run-time performance. The modern observer Now let’s look at the much more slim modern version of this pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 // observer.h #pragma once #include &lt;functional&gt; template&lt; typename Subject, typename StateTag &gt; class Observer { public: // using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;; // typedef void (*OnUpdate)(Subject const&amp;,StateTag); using OnUpdate = void (*)(Subject const&amp;,StateTag); // No virtual destructor necessary explicit Observer( OnUpdate onUpdate ) : onUpdate_{ std::move(onUpdate) } { // Possibly respond on an invalid/empty std::function instance } // Non-virtual update function void update( Subject const&amp; subject, StateTag property ) { onUpdate_( subject, property ); } private: OnUpdate onUpdate_; }; // person.h #pragma once #include &quot;observer.h&quot; #include &lt;string&gt; #include &lt;set&gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer&lt;Person,StateChange&gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const&amp; forename() const { return forename_; } std::string const&amp; surname () const { return surname_; } std::string const&amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set&lt;PersonObserver*&gt; observers_; }; // person.cpp #include &quot;person.h&quot; void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) &gt; 0U ); } void Person::notify( StateChange property ) { // This formulation makes sure detach() operations // can be detected during the iteration for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-&gt;update(*this,property); } } // main.cpp #include &quot;observer.h&quot; #include &quot;person.h&quot; #include &lt;cstdlib&gt; void propertyChanged( Person const&amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... Respond to changed name } } int main() { using PersonObserver = Observer&lt;Person,Person::StateChange&gt;; PersonObserver nameObserver( propertyChanged ); PersonObserver addressObserver( [/*captured state*/]( Person const&amp; person, Person::StateChange property ){ if( property == Person::addressChanged ) { // ... Respond to changed address } } ); Person homer( &quot;Homer&quot; , &quot;Simpson&quot; ); Person marge( &quot;Marge&quot; , &quot;Simpson&quot; ); Person monty( &quot;Montgomery&quot;, &quot;Burns&quot; ); // Attaching observers homer.attach( &amp;nameObserver ); marge.attach( &amp;addressObserver ); monty.attach( &amp;addressObserver ); // Updating information on Homer Simpson homer.forename( &quot;Homer Jay&quot; ); // Adding his middle name // Updating information on Marge Simpson marge.address( &quot;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&quot; ); // Updating information on Montgomery Burns monty.address( &quot;Springfield Nuclear Power Plant&quot; ); // Detaching observers homer.detach( &amp;nameObserver ); return EXIT_SUCCESS; } In comparison The Observer uses the same template parameters, but instead of providing a virtual function as a customization point, it takes a std::function object. The Person object is the very same as in the classic example. The modern version seems easier to implement, our assumption is that it’s faster due to the lack of virtual functions, but what about the binary size? A surprising result Interestingly, the modern version produces a binary that is about 10% bigger when optimized, otherwise, with -O0 the difference is about 70%! Still, it compiled considerably faster than the classic version! Version Binary size Compile time classical observer -O0 85.5K 9.04s classical observer -O3 35.9K 9.84s classical observer -Os 47.1K 9.91s modern observer -O0 142K 7.56s modern observer -O3 39.5K 8.34s modern observer -Os 40.9K 8.2s But what can be behind this size difference? And how do they scale? Let’s focus on the -O3 version as most probably you’ll use that for your releases! I used a new observer as simple as the above ones. Adding a new observer to the classic solution adds about 400 bytes. For the modern, we have two possibilities: adding a new observer with a lambda added an extra 1500 bytes. That scales up almost 4 times as fast as the classic solution! but implementing the new observer with a free function only added a hundred extra bytes which 4 times less as for the classic one. Turning the results around At a first glance, it seems that if we want to shave off some of the binary, we should rely on free functions. Modifying the original example, to use only functions still left us with a 2k bigger binary than the classic solution. Templates can significantly increase the size of the binary. And I realized that it’s the case here too. std::function is a function template. While all our free function observers have the same type (void (*)(Subject const&amp;, StateTag)), each lambda is compiled into a different object and therefore a new function template instantiation is necessary! So what if we replace std::function with a good old function pointer? A std::function is a type erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. std::function has quite some overhead, but it provides flexibility. Watch this video on C++ Weekly to learn more. Let’s replace one line in the Observer class: 1 2 // using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;; using OnUpdate = void (*)(Subject const&amp;,StateTag); Now we have a smaller binary and even the lambdas are not problematic anymore! And we still have the compile-time advantage too! Version Binary size Compile time classical observer -O0 85.5K 9.04s classical observer -O3 35.9K 9.84s modern observer with free functions -O0 84.4K 7.0s modern observer with free functions -O0 35K 7.48s modern observer with a free function and a lambda -O3 84.6K 7.1s modern observer with a free function and a lambda -O3 35.1K 7.5s If you focus on the binary, you can win big by replacing std::function and some additional bytes by using free functions instead of lambdas. Conclusion Today, we compared classic and modern implementations of the observer design patterns in terms of binary sizes. First, we saw that the classic version of the observer pattern was smaller and scaled sometimes better than the modern implementation. Then we found that, if we don’t need the features of std::function, but you can use a function pointer to take your observers, you can win big and end up with a nicely scaling implementation that is faster and smaller than the classic version. Next time we’ll look into binary sizes and templates as we already partially discussed this topic. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-15T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The observer pattern and binary sizes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2024-04-17T22:24:47+02:00","datePublished":"2023-03-15T00:00:00+01:00","description":"In the previous article on binary sizes, we discussed how the decorator pattern’s classic and modern implementation fares in terms of binary size. We saw that the modern implementation had a smaller size, but the difference was not great and it’s not always evident how it scales. Today, let’s talk about a different pattern, the observer. Once again, I borrow the examples from Klaus Igleberger’s book, C++ Software Design. The Observer pattern The observer pattern is thoroughly explained in the famous GoF book. With the help of this pattern, you define a convenient way to notify objects about any event that happens to the observed object. I borrowed Klaus’ example, in which there are Person objects being observed for changes in their names, addresses, etc. How much more convenient it is get a notification instead of querying it all the time and tracking if the returned value means a change or not! In his book, Klaus offers two solutions, a classic and the modern one. The classic observer Let’s have a look at the classic first. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 // observer.h #pragma once template&lt; typename Subject, typename StateTag &gt; class Observer { public: virtual ~Observer() = default; virtual void update( Subject const&amp; subject, StateTag property ) = 0; }; // name_observer.h #pragma once #include &quot;observer.h&quot; #include &quot;person.h&quot; class NameObserver : public Observer&lt;Person,Person::StateChange&gt; { public: void update( Person const&amp; person, Person::StateChange property ) override; }; // name_observer.cpp #include &quot;name_observer.h&quot; void NameObserver::update( Person const&amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... Respond to changed name } } // address_observer.h #pragma once #include &quot;observer.h&quot; #include &quot;person.h&quot; class AddressObserver : public Observer&lt;Person,Person::StateChange&gt; { public: void update( Person const&amp; person, Person::StateChange property ) override; }; // address_observer.cpp #include &quot;address_observer.h&quot; void AddressObserver::update( Person const&amp; person, Person::StateChange property ) { if( property == Person::addressChanged ) { // ... Respond to changed address } } // person.h #pragma once #include &quot;observer.h&quot; #include &lt;string&gt; #include &lt;set&gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer&lt;Person,StateChange&gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const&amp; forename() const { return forename_; } std::string const&amp; surname () const { return surname_; } std::string const&amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set&lt;PersonObserver*&gt; observers_; }; // person.cpp #include &quot;person.h&quot; void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) &gt; 0U ); } void Person::notify( StateChange property ) { // This formulation makes sure detach() operations // can be detected during the iteration for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-&gt;update(*this,property); } } // main.cpp #include &quot;address_observer.h&quot; #include &quot;name_observer.h&quot; #include &quot;person.h&quot; #include &lt;cstdlib&gt; int main() { NameObserver nameObserver; AddressObserver addressObserver; Person homer( &quot;Homer&quot; , &quot;Simpson&quot; ); Person marge( &quot;Marge&quot; , &quot;Simpson&quot; ); Person monty( &quot;Montgomery&quot;, &quot;Burns&quot; ); // Attaching observers homer.attach( &amp;nameObserver ); marge.attach( &amp;addressObserver ); monty.attach( &amp;addressObserver ); // Updating information on Homer Simpson homer.forename( &quot;Homer Jay&quot; ); // Adding his middle name // Updating information on Marge Simpson marge.address( &quot;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&quot; ); // Updating information on Montgomery Burns monty.address( &quot;Springfield Nuclear Power Plant&quot; ); // Detaching observers homer.detach( &amp;nameObserver ); return EXIT_SUCCESS; } As you can see, the observers constitute an object hierarchy, but templates are also involved. Templates often (can) contribute to a bigger binary size. Having polymorphic classes both contribute to higher binary sizes and worse run-time performance. The modern observer Now let’s look at the much more slim modern version of this pattern. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 // observer.h #pragma once #include &lt;functional&gt; template&lt; typename Subject, typename StateTag &gt; class Observer { public: // using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;; // typedef void (*OnUpdate)(Subject const&amp;,StateTag); using OnUpdate = void (*)(Subject const&amp;,StateTag); // No virtual destructor necessary explicit Observer( OnUpdate onUpdate ) : onUpdate_{ std::move(onUpdate) } { // Possibly respond on an invalid/empty std::function instance } // Non-virtual update function void update( Subject const&amp; subject, StateTag property ) { onUpdate_( subject, property ); } private: OnUpdate onUpdate_; }; // person.h #pragma once #include &quot;observer.h&quot; #include &lt;string&gt; #include &lt;set&gt; class Person { public: enum StateChange { forenameChanged, surnameChanged, addressChanged }; using PersonObserver = Observer&lt;Person,StateChange&gt;; explicit Person( std::string forename, std::string surname ) : forename_{ std::move(forename) } , surname_{ std::move(surname) } {} bool attach( PersonObserver* observer ); bool detach( PersonObserver* observer ); void notify( StateChange property ); void forename( std::string newForename ); void surname ( std::string newSurname ); void address ( std::string newAddress ); std::string const&amp; forename() const { return forename_; } std::string const&amp; surname () const { return surname_; } std::string const&amp; address () const { return address_; } private: std::string forename_; std::string surname_; std::string address_; std::set&lt;PersonObserver*&gt; observers_; }; // person.cpp #include &quot;person.h&quot; void Person::forename( std::string newForename ) { forename_ = std::move(newForename); notify( forenameChanged ); } void Person::surname( std::string newSurname ) { surname_ = std::move(newSurname); notify( surnameChanged ); } void Person::address( std::string newAddress ) { address_ = std::move(newAddress); notify( addressChanged ); } bool Person::attach( PersonObserver* observer ) { auto [pos,success] = observers_.insert( observer ); return success; } bool Person::detach( PersonObserver* observer ) { return ( observers_.erase( observer ) &gt; 0U ); } void Person::notify( StateChange property ) { // This formulation makes sure detach() operations // can be detected during the iteration for( auto iter=begin(observers_); iter!=end(observers_); ) { auto const pos = iter++; (*pos)-&gt;update(*this,property); } } // main.cpp #include &quot;observer.h&quot; #include &quot;person.h&quot; #include &lt;cstdlib&gt; void propertyChanged( Person const&amp; person, Person::StateChange property ) { if( property == Person::forenameChanged || property == Person::surnameChanged ) { // ... Respond to changed name } } int main() { using PersonObserver = Observer&lt;Person,Person::StateChange&gt;; PersonObserver nameObserver( propertyChanged ); PersonObserver addressObserver( [/*captured state*/]( Person const&amp; person, Person::StateChange property ){ if( property == Person::addressChanged ) { // ... Respond to changed address } } ); Person homer( &quot;Homer&quot; , &quot;Simpson&quot; ); Person marge( &quot;Marge&quot; , &quot;Simpson&quot; ); Person monty( &quot;Montgomery&quot;, &quot;Burns&quot; ); // Attaching observers homer.attach( &amp;nameObserver ); marge.attach( &amp;addressObserver ); monty.attach( &amp;addressObserver ); // Updating information on Homer Simpson homer.forename( &quot;Homer Jay&quot; ); // Adding his middle name // Updating information on Marge Simpson marge.address( &quot;712 Red Bark Lane, Henderson, Clark County, Nevada 89011&quot; ); // Updating information on Montgomery Burns monty.address( &quot;Springfield Nuclear Power Plant&quot; ); // Detaching observers homer.detach( &amp;nameObserver ); return EXIT_SUCCESS; } In comparison The Observer uses the same template parameters, but instead of providing a virtual function as a customization point, it takes a std::function object. The Person object is the very same as in the classic example. The modern version seems easier to implement, our assumption is that it’s faster due to the lack of virtual functions, but what about the binary size? A surprising result Interestingly, the modern version produces a binary that is about 10% bigger when optimized, otherwise, with -O0 the difference is about 70%! Still, it compiled considerably faster than the classic version! Version Binary size Compile time classical observer -O0 85.5K 9.04s classical observer -O3 35.9K 9.84s classical observer -Os 47.1K 9.91s modern observer -O0 142K 7.56s modern observer -O3 39.5K 8.34s modern observer -Os 40.9K 8.2s But what can be behind this size difference? And how do they scale? Let’s focus on the -O3 version as most probably you’ll use that for your releases! I used a new observer as simple as the above ones. Adding a new observer to the classic solution adds about 400 bytes. For the modern, we have two possibilities: adding a new observer with a lambda added an extra 1500 bytes. That scales up almost 4 times as fast as the classic solution! but implementing the new observer with a free function only added a hundred extra bytes which 4 times less as for the classic one. Turning the results around At a first glance, it seems that if we want to shave off some of the binary, we should rely on free functions. Modifying the original example, to use only functions still left us with a 2k bigger binary than the classic solution. Templates can significantly increase the size of the binary. And I realized that it’s the case here too. std::function is a function template. While all our free function observers have the same type (void (*)(Subject const&amp;, StateTag)), each lambda is compiled into a different object and therefore a new function template instantiation is necessary! So what if we replace std::function with a good old function pointer? A std::function is a type erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. std::function has quite some overhead, but it provides flexibility. Watch this video on C++ Weekly to learn more. Let’s replace one line in the Observer class: 1 2 // using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;; using OnUpdate = void (*)(Subject const&amp;,StateTag); Now we have a smaller binary and even the lambdas are not problematic anymore! And we still have the compile-time advantage too! Version Binary size Compile time classical observer -O0 85.5K 9.04s classical observer -O3 35.9K 9.84s modern observer with free functions -O0 84.4K 7.0s modern observer with free functions -O0 35K 7.48s modern observer with a free function and a lambda -O3 84.6K 7.1s modern observer with a free function and a lambda -O3 35.1K 7.5s If you focus on the binary, you can win big by replacing std::function and some additional bytes by using free functions instead of lambdas. Conclusion Today, we compared classic and modern implementations of the observer design patterns in terms of binary sizes. First, we saw that the classic version of the observer pattern was smaller and scaled sometimes better than the modern implementation. Then we found that, if we don’t need the features of std::function, but you can use a function pointer to take your observers, you can win big and end up with a nicely scaling implementation that is faster and smaller than the classic version. Next time we’ll look into binary sizes and templates as we already partially discussed this topic. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The observer pattern and binary sizes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern"},"url":"https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern"}</script><title>The observer pattern and binary sizes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/15"> 15 </a> </span> <span>The observer pattern and binary sizes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The observer pattern and binary sizes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 15, 2023, 12:00 AM +0100" prep="on" > Mar 15, 2023 <i class="unloaded">2023-03-15T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Apr 17, 2024, 10:24 PM +0200" prefix="Updated " > Apr 17, 2024 <i class="unloaded">2024-04-17T22:24:47+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2132 words">11 min</span></div></div><div class="post-content"><p>In the previous article on binary sizes, we discussed how the decorator pattern’s classic and modern implementation fares in terms of binary size. We saw that the modern implementation had a smaller size, but the difference was not great and it’s not always evident how it scales.</p><p>Today, let’s talk about a different pattern, the observer. Once again, I borrow the examples from Klaus Igleberger’s book, <a href="https://www.amazon.com/Software-Design-Principles-Patterns-High-Quality/dp/1098113160?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=e9b6f64671aac55ff52ecfd91e137d6e&amp;camp=1789&amp;creative=9325">C++ Software Design</a>.</p><h2 id="the-observer-pattern">The Observer pattern</h2><p>The observer pattern is thoroughly explained in the famous <a href="https://amzn.to/2KWCkLN">GoF book</a>. With the help of this pattern, you define a convenient way to notify objects about any event that happens to the observed object.</p><p>I borrowed Klaus’ example, in which there are <code class="language-plaintext highlighter-rouge">Person</code> objects being observed for changes in their names, addresses, etc. How much more convenient it is get a notification instead of querying it all the time and tracking if the returned value means a change or not!</p><p>In his book, Klaus offers two solutions, a classic and the modern one.</p><h2 id="the-classic-observer">The classic observer</h2><p>Let’s have a look at the classic first.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
</pre><td class="rouge-code"><pre><span class="c1">// observer.h</span>
<span class="cp">#pragma once
</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Subject</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">StateTag</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Observer</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="k">virtual</span> <span class="o">~</span><span class="n">Observer</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

   <span class="k">virtual</span> <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">subject</span><span class="p">,</span> <span class="n">StateTag</span> <span class="n">property</span> <span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// name_observer.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"observer.h"</span><span class="cp">
#include</span> <span class="cpf">"person.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">NameObserver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span><span class="o">&gt;</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>


<span class="c1">// name_observer.cpp</span>
<span class="cp">#include</span> <span class="cpf">"name_observer.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">NameObserver</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">forenameChanged</span> <span class="o">||</span>
       <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">surnameChanged</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// ... Respond to changed name</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// address_observer.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"observer.h"</span><span class="cp">
#include</span> <span class="cpf">"person.h"</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">AddressObserver</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span><span class="o">&gt;</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="kt">void</span> <span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span> <span class="k">override</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// address_observer.cpp</span>
<span class="cp">#include</span> <span class="cpf">"address_observer.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">AddressObserver</span><span class="o">::</span><span class="n">update</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">addressChanged</span> <span class="p">)</span> <span class="p">{</span>
      <span class="c1">// ... Respond to changed address</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// person.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"observer.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="k">enum</span> <span class="n">StateChange</span>
   <span class="p">{</span>
      <span class="n">forenameChanged</span><span class="p">,</span>
      <span class="n">surnameChanged</span><span class="p">,</span>
      <span class="n">addressChanged</span>
   <span class="p">};</span>

   <span class="k">using</span> <span class="n">PersonObserver</span> <span class="o">=</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">StateChange</span><span class="o">&gt;</span><span class="p">;</span>

   <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">forename_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">forename</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">,</span> <span class="n">surname_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">surname</span><span class="p">)</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="kt">bool</span> <span class="n">attach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">);</span>
   <span class="kt">bool</span> <span class="nf">detach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">);</span>

   <span class="kt">void</span> <span class="nf">notify</span><span class="p">(</span> <span class="n">StateChange</span> <span class="n">property</span> <span class="p">);</span>

   <span class="kt">void</span> <span class="nf">forename</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newForename</span> <span class="p">);</span>
   <span class="kt">void</span> <span class="nf">surname</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newSurname</span> <span class="p">);</span>
   <span class="kt">void</span> <span class="nf">address</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newAddress</span> <span class="p">);</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">forename</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">forename_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">surname</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">surname_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">address_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename_</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname_</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PersonObserver</span><span class="o">*&gt;</span> <span class="n">observers_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// person.cpp</span>
<span class="cp">#include</span> <span class="cpf">"person.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">forename</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newForename</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">forename_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newForename</span><span class="p">);</span>
   <span class="n">notify</span><span class="p">(</span> <span class="n">forenameChanged</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">surname</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newSurname</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">surname_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newSurname</span><span class="p">);</span>
   <span class="n">notify</span><span class="p">(</span> <span class="n">surnameChanged</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">address</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newAddress</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">address_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newAddress</span><span class="p">);</span>
   <span class="n">notify</span><span class="p">(</span> <span class="n">addressChanged</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Person</span><span class="o">::</span><span class="n">attach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="p">[</span><span class="n">pos</span><span class="p">,</span><span class="n">success</span><span class="p">]</span> <span class="o">=</span> <span class="n">observers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">observer</span> <span class="p">);</span>
   <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Person</span><span class="o">::</span><span class="n">detach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="p">(</span> <span class="n">observers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">observer</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0U</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span> <span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// This formulation makes sure detach() operations</span>
   <span class="c1">// can be detected during the iteration</span>
   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="n">iter</span><span class="o">=</span><span class="n">begin</span><span class="p">(</span><span class="n">observers_</span><span class="p">);</span> <span class="n">iter</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">observers_</span><span class="p">);</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="k">auto</span> <span class="k">const</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iter</span><span class="o">++</span><span class="p">;</span>
      <span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="n">property</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">"address_observer.h"</span><span class="cp">
#include</span> <span class="cpf">"name_observer.h"</span><span class="cp">
#include</span> <span class="cpf">"person.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="n">NameObserver</span> <span class="n">nameObserver</span><span class="p">;</span>
   <span class="n">AddressObserver</span> <span class="n">addressObserver</span><span class="p">;</span>

   <span class="n">Person</span> <span class="n">homer</span><span class="p">(</span> <span class="s">"Homer"</span>     <span class="p">,</span> <span class="s">"Simpson"</span> <span class="p">);</span>
   <span class="n">Person</span> <span class="n">marge</span><span class="p">(</span> <span class="s">"Marge"</span>     <span class="p">,</span> <span class="s">"Simpson"</span> <span class="p">);</span>
   <span class="n">Person</span> <span class="n">monty</span><span class="p">(</span> <span class="s">"Montgomery"</span><span class="p">,</span> <span class="s">"Burns"</span>   <span class="p">);</span>

   <span class="c1">// Attaching observers</span>
   <span class="n">homer</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span>
   <span class="n">marge</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span>
   <span class="n">monty</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span>

   <span class="c1">// Updating information on Homer Simpson</span>
   <span class="n">homer</span><span class="p">.</span><span class="n">forename</span><span class="p">(</span> <span class="s">"Homer Jay"</span> <span class="p">);</span>  <span class="c1">// Adding his middle name</span>

   <span class="c1">// Updating information on Marge Simpson</span>
   <span class="n">marge</span><span class="p">.</span><span class="n">address</span><span class="p">(</span> <span class="s">"712 Red Bark Lane, Henderson, Clark County, Nevada 89011"</span> <span class="p">);</span>

   <span class="c1">// Updating information on Montgomery Burns</span>
   <span class="n">monty</span><span class="p">.</span><span class="n">address</span><span class="p">(</span> <span class="s">"Springfield Nuclear Power Plant"</span> <span class="p">);</span>

   <span class="c1">// Detaching observers</span>
   <span class="n">homer</span><span class="p">.</span><span class="n">detach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span>

   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As you can see, the observers constitute an object hierarchy, but templates are also involved. Templates often (can) contribute to a bigger binary size. Having polymorphic classes both contribute to higher binary sizes and worse run-time performance.</p><h2 id="the-modern-observer">The modern observer</h2><p>Now let’s look at the much more slim modern version of this pattern.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
</pre><td class="rouge-code"><pre><span class="c1">// observer.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">&lt;functional&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">Subject</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">StateTag</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Observer</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="c1">// using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;;</span>
   <span class="c1">// typedef void (*OnUpdate)(Subject const&amp;,StateTag);</span>
   <span class="k">using</span> <span class="n">OnUpdate</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span><span class="n">StateTag</span><span class="p">);</span>
   <span class="c1">// No virtual destructor necessary</span>

   <span class="k">explicit</span> <span class="n">Observer</span><span class="p">(</span> <span class="n">OnUpdate</span> <span class="n">onUpdate</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">onUpdate_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">onUpdate</span><span class="p">)</span> <span class="p">}</span>
   <span class="p">{</span>
      <span class="c1">// Possibly respond on an invalid/empty std::function instance</span>
   <span class="p">}</span>

   <span class="c1">// Non-virtual update function</span>
   <span class="kt">void</span> <span class="nf">update</span><span class="p">(</span> <span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">subject</span><span class="p">,</span> <span class="n">StateTag</span> <span class="n">property</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="n">onUpdate_</span><span class="p">(</span> <span class="n">subject</span><span class="p">,</span> <span class="n">property</span> <span class="p">);</span>
   <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">OnUpdate</span> <span class="n">onUpdate_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// person.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"observer.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;set&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Person</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="k">enum</span> <span class="n">StateChange</span>
   <span class="p">{</span>
      <span class="n">forenameChanged</span><span class="p">,</span>
      <span class="n">surnameChanged</span><span class="p">,</span>
      <span class="n">addressChanged</span>
   <span class="p">};</span>

   <span class="k">using</span> <span class="n">PersonObserver</span> <span class="o">=</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">StateChange</span><span class="o">&gt;</span><span class="p">;</span>

   <span class="k">explicit</span> <span class="nf">Person</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">forename_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">forename</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">,</span> <span class="n">surname_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">surname</span><span class="p">)</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="kt">bool</span> <span class="n">attach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">);</span>
   <span class="kt">bool</span> <span class="nf">detach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">);</span>

   <span class="kt">void</span> <span class="nf">notify</span><span class="p">(</span> <span class="n">StateChange</span> <span class="n">property</span> <span class="p">);</span>

   <span class="kt">void</span> <span class="nf">forename</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newForename</span> <span class="p">);</span>
   <span class="kt">void</span> <span class="nf">surname</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newSurname</span> <span class="p">);</span>
   <span class="kt">void</span> <span class="nf">address</span> <span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newAddress</span> <span class="p">);</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">forename</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">forename_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">surname</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">surname_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">address</span> <span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">address_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">forename_</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">surname_</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">address_</span><span class="p">;</span>

   <span class="n">std</span><span class="o">::</span><span class="n">set</span><span class="o">&lt;</span><span class="n">PersonObserver</span><span class="o">*&gt;</span> <span class="n">observers_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// person.cpp</span>
<span class="cp">#include</span> <span class="cpf">"person.h"</span><span class="cp">
</span>
<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">forename</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newForename</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">forename_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newForename</span><span class="p">);</span>
   <span class="n">notify</span><span class="p">(</span> <span class="n">forenameChanged</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">surname</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newSurname</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">surname_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newSurname</span><span class="p">);</span>
   <span class="n">notify</span><span class="p">(</span> <span class="n">surnameChanged</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">address</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">newAddress</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="n">address_</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">newAddress</span><span class="p">);</span>
   <span class="n">notify</span><span class="p">(</span> <span class="n">addressChanged</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Person</span><span class="o">::</span><span class="n">attach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">auto</span> <span class="p">[</span><span class="n">pos</span><span class="p">,</span><span class="n">success</span><span class="p">]</span> <span class="o">=</span> <span class="n">observers_</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span> <span class="n">observer</span> <span class="p">);</span>
   <span class="k">return</span> <span class="n">success</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Person</span><span class="o">::</span><span class="n">detach</span><span class="p">(</span> <span class="n">PersonObserver</span><span class="o">*</span> <span class="n">observer</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="p">(</span> <span class="n">observers_</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span> <span class="n">observer</span> <span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0U</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Person</span><span class="o">::</span><span class="n">notify</span><span class="p">(</span> <span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="c1">// This formulation makes sure detach() operations</span>
   <span class="c1">// can be detected during the iteration</span>
   <span class="k">for</span><span class="p">(</span> <span class="k">auto</span> <span class="n">iter</span><span class="o">=</span><span class="n">begin</span><span class="p">(</span><span class="n">observers_</span><span class="p">);</span> <span class="n">iter</span><span class="o">!=</span><span class="n">end</span><span class="p">(</span><span class="n">observers_</span><span class="p">);</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="k">auto</span> <span class="k">const</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">iter</span><span class="o">++</span><span class="p">;</span>
      <span class="p">(</span><span class="o">*</span><span class="n">pos</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">update</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span><span class="n">property</span><span class="p">);</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">"observer.h"</span><span class="cp">
#include</span> <span class="cpf">"person.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">propertyChanged</span><span class="p">(</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">forenameChanged</span> <span class="o">||</span>
       <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">surnameChanged</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="c1">// ... Respond to changed name</span>
   <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="k">using</span> <span class="n">PersonObserver</span> <span class="o">=</span> <span class="n">Observer</span><span class="o">&lt;</span><span class="n">Person</span><span class="p">,</span><span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span><span class="o">&gt;</span><span class="p">;</span>

   <span class="n">PersonObserver</span> <span class="n">nameObserver</span><span class="p">(</span> <span class="n">propertyChanged</span> <span class="p">);</span>

   <span class="n">PersonObserver</span> <span class="n">addressObserver</span><span class="p">(</span>
      <span class="p">[</span><span class="cm">/*captured state*/</span><span class="p">](</span> <span class="n">Person</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">person</span><span class="p">,</span> <span class="n">Person</span><span class="o">::</span><span class="n">StateChange</span> <span class="n">property</span> <span class="p">){</span>
         <span class="k">if</span><span class="p">(</span> <span class="n">property</span> <span class="o">==</span> <span class="n">Person</span><span class="o">::</span><span class="n">addressChanged</span> <span class="p">)</span>
         <span class="p">{</span>
            <span class="c1">// ... Respond to changed address</span>
         <span class="p">}</span>
      <span class="p">}</span> <span class="p">);</span>
   
   <span class="n">Person</span> <span class="nf">homer</span><span class="p">(</span> <span class="s">"Homer"</span>     <span class="p">,</span> <span class="s">"Simpson"</span> <span class="p">);</span>
   <span class="n">Person</span> <span class="nf">marge</span><span class="p">(</span> <span class="s">"Marge"</span>     <span class="p">,</span> <span class="s">"Simpson"</span> <span class="p">);</span>
   <span class="n">Person</span> <span class="nf">monty</span><span class="p">(</span> <span class="s">"Montgomery"</span><span class="p">,</span> <span class="s">"Burns"</span>   <span class="p">);</span>

   <span class="c1">// Attaching observers</span>
   <span class="n">homer</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span>
   <span class="n">marge</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span>
   <span class="n">monty</span><span class="p">.</span><span class="n">attach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">addressObserver</span> <span class="p">);</span>


   <span class="c1">// Updating information on Homer Simpson</span>
   <span class="n">homer</span><span class="p">.</span><span class="n">forename</span><span class="p">(</span> <span class="s">"Homer Jay"</span> <span class="p">);</span>  <span class="c1">// Adding his middle name</span>

   <span class="c1">// Updating information on Marge Simpson</span>
   <span class="n">marge</span><span class="p">.</span><span class="n">address</span><span class="p">(</span> <span class="s">"712 Red Bark Lane, Henderson, Clark County, Nevada 89011"</span> <span class="p">);</span>

   <span class="c1">// Updating information on Montgomery Burns</span>
   <span class="n">monty</span><span class="p">.</span><span class="n">address</span><span class="p">(</span> <span class="s">"Springfield Nuclear Power Plant"</span> <span class="p">);</span>

   <span class="c1">// Detaching observers</span>
   <span class="n">homer</span><span class="p">.</span><span class="n">detach</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">nameObserver</span> <span class="p">);</span>

   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="in-comparison">In comparison</h2><p>The <code class="language-plaintext highlighter-rouge">Observer</code> uses the same template parameters, but instead of providing a <code class="language-plaintext highlighter-rouge">virtual</code> function as a customization point, it takes a <code class="language-plaintext highlighter-rouge">std::function</code> object. The <code class="language-plaintext highlighter-rouge">Person</code> object is the very same as in the classic example.</p><p>The modern version seems easier to implement, our assumption is that it’s faster due to the lack of <code class="language-plaintext highlighter-rouge">virtual</code> functions, but what about the binary size?</p><h3 id="a-surprising-result">A surprising result</h3><p>Interestingly, the modern version produces a binary that is about 10% bigger when optimized, otherwise, with <code class="language-plaintext highlighter-rouge">-O0</code> the difference is about 70%! Still, it compiled considerably faster than the classic version!</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<th>Compile time<tbody><tr><td>classical observer -O0<td>85.5K<td>9.04s<tr><td>classical observer -O3<td>35.9K<td>9.84s<tr><td>classical observer -Os<td>47.1K<td>9.91s<tr><td>modern observer -O0<td>142K<td>7.56s<tr><td>modern observer -O3<td>39.5K<td>8.34s<tr><td>modern observer -Os<td>40.9K<td>8.2s</table></div><p>But what can be behind this size difference? And how do they scale?</p><p>Let’s focus on the <code class="language-plaintext highlighter-rouge">-O3</code> version as most probably you’ll use that for your releases! I used a new observer as simple as the above ones. Adding a new observer to the classic solution adds about 400 bytes. For the modern, we have two possibilities:</p><ul><li>adding a new observer with a lambda added an extra 1500 bytes. That scales up almost 4 times as fast as the classic solution!<li>but implementing the new observer with a free function only added a hundred extra bytes which 4 times less as for the classic one.</ul><h3 id="turning-the-results-around">Turning the results around</h3><p>At a first glance, it seems that if we want to shave off some of the binary, we should rely on free functions. Modifying the original example, to use only functions still left us with a 2k bigger binary than the classic solution.</p><p>Templates can significantly increase the size of the binary. And I realized that it’s the case here too. <code class="language-plaintext highlighter-rouge">std::function</code> is a function template. While all our free function observers have the same type (<code class="language-plaintext highlighter-rouge">void (*)(Subject const&amp;, StateTag)</code>), each lambda is compiled into a different object and therefore a new function template instantiation is necessary!</p><p>So what if we replace <code class="language-plaintext highlighter-rouge">std::function</code> with a good old function pointer?</p><blockquote><p>A <code class="language-plaintext highlighter-rouge">std::function</code> is a type erased wrapper around any kind of callable. A function pointer will take a free function or something that can be implicitly converted to it. Such as a lambda without a capture. <code class="language-plaintext highlighter-rouge">std::function</code> has quite some overhead, but it provides flexibility. Watch <a href="https://www.youtube.com/watch?v=aC-aAiS5Wuc">this video on C++ Weekly</a> to learn more.</p></blockquote><p>Let’s replace one line in the Observer class:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="c1">// using OnUpdate = std::function&lt;void(Subject const&amp;,StateTag)&gt;;</span>
<span class="k">using</span> <span class="n">OnUpdate</span> <span class="o">=</span> <span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="p">)(</span><span class="n">Subject</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">,</span><span class="n">StateTag</span><span class="p">);</span>
</pre></table></code></div></div><p>Now we have a smaller binary and even the lambdas are not problematic anymore! And we still have the compile-time advantage too!</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<th>Compile time<tbody><tr><td>classical observer -O0<td>85.5K<td>9.04s<tr><td>classical observer -O3<td>35.9K<td>9.84s<tr><td>modern observer with free functions -O0<td>84.4K<td>7.0s<tr><td>modern observer with free functions -O0<td>35K<td>7.48s<tr><td>modern observer with a free function and a lambda -O3<td>84.6K<td>7.1s<tr><td>modern observer with a free function and a lambda -O3<td>35.1K<td>7.5s</table></div><p>If you focus on the binary, you can win big by replacing <code class="language-plaintext highlighter-rouge">std::function</code> and some additional bytes by using free functions instead of lambdas.</p><h2 id="conclusion">Conclusion</h2><p>Today, we compared classic and modern implementations of the observer design patterns in terms of binary sizes. First, we saw that the classic version of the observer pattern was smaller and scaled sometimes better than the modern implementation.</p><p>Then we found that, if we don’t need the features of <code class="language-plaintext highlighter-rouge">std::function</code>, but you can use a function pointer to take your observers, you can win big and end up with a nicely scaling implementation that is faster and smaller than the classic version.</p><p>Next time we’ll look into binary sizes and templates as we already partially discussed this topic.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/designpatterns/" class="post-tag no-text-decoration" >designpatterns</a> <a href="/tags/observer/" class="post-tag no-text-decoration" >observer</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The observer pattern and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The observer pattern and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The observer pattern and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The observer pattern and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/09/03/observers-part1"><div class="card-body"> <span class="timeago small" > Sep 3 <i class="unloaded">2025-09-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Discovering observers - part 1</h3><div class="text-muted small"><p> The goal of this mini-series is to explore the Observer Design Pattern in C++, walking through different implementations and weighing their pros and cons. First, let’s briefly recap what the obser...</p></div></div></a></div><div class="card"> <a href="/blog/2025/09/10/observers-part2"><div class="card-body"> <span class="timeago small" > Sep 10 <i class="unloaded">2025-09-10T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Discovering observers - part 2</h3><div class="text-muted small"><p> Last week, we took the observer pattern from a very simple example and evolved it into a more flexible, template-based implementation in C++. We ended up with abstracted publishers and subscribers,...</p></div></div></a></div><div class="card"> <a href="/blog/2025/09/17/observers-part3"><div class="card-body"> <span class="timeago small" > Sep 17 <i class="unloaded">2025-09-17T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Discovering observers - part 3</h3><div class="text-muted small"><p> Over the last two weeks, we explored different implementations of the observer pattern in C++. We began with a very simple example, then evolved toward a more flexible, template- and inheritance-ba...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/03/11/ordinary-man" class="btn btn-outline-primary" prompt="Older"><p>Ordinary Men: Reserve Police Battalion 101 and the Final Solution by Christopher Browning</p></a> <a href="/blog/2023/03/22/reasons-behind-compromises" class="btn btn-outline-primary" prompt="Newer"><p>Can we find a compromise?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The observer pattern and binary sizes'; this.page.url = 'https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern'; this.page.identifier = '/blog/2023/03/15/binary-sizes-and-observer-pattern'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
