<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The decorator pattern and binary sizes" /><meta property="og:locale" content="en_US" /><meta name="description" content="In one of the previous articles on binary sizes, we discussed how making a class polymorphic by using the virtual keyword affects the binary size. Turning a function into virtual has a substantial effect on the binary size, but adding more and more virtual methods to a class that already has at least one virtual function does not change that much. To have an elaborate example I went to the publicly available code examples of C++ Software Design by Klaus Iglberger. As I explained here, it’s one of the best books I read in 2022. If you are interested in software design and C++, in my opinion, it’s a must-read. In the book, you can find different implementations of various design patterns. All the discussed design patterns are first presented through their classic implementation, usually based on polymorphism and then modern alternatives are also explained. Sometimes, the modern implementations offer the same functionality, sometimes they are restricted for compile-time needs, but that’s often enough for the needs. In this and the next article, I want to go through two implementations of two design patterns and focus on their effects on binary sizes. Today, it’s the decorator pattern on the plate. The decorator pattern Let’s start by quickly recap on what is the decorator design pattern. In the Gang of Four book, it was listed as one of the structural design patterns. Some also refer to it as the wrapper pattern. Both names are good, as this pattern is about adding new behaviour to objects in a non-intrusive way. The decorator pattern places these objects into special wrapper objects responsible for attaching the new behaviour. Imagine that you have an item which has both a name and a price and some other attributes. However, having a price is not enough. Depending on where you want to sell it, you have to apply different taxes. Not to mention that you might also want to apply some discounts. Having the logic inside the class is not a great idea, and creating inheritance hierarchies does not scale as you add more and more taxes and discounts. The decorator pattern provides a scalable solution. The classic solution Klaus provided 3 solutions in his book. The first one is a classical solution based on runtime polymorphism. As I cannot compile templates with floating-point non-type arguments, I modified his example a bit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 // taxed.h #pragma once #include &quot;item.h&quot; #include &lt;utility&gt; class Taxed { public: Taxed( double taxRate, Item item ) : item_( std::move(item) ) , factor_( 1.0 + taxRate ) {} Money price() const { return item_.price() * factor_; } private: Item item_; double factor_; }; // money.h #pragma once #include &lt;cmath&gt; #include &lt;concepts&gt; #include &lt;cstdint&gt; #include &lt;ostream&gt; struct Money { uint64_t value{}; }; template&lt; typename T &gt; requires std::is_arithmetic_v&lt;T&gt; Money operator*( Money money, T factor ) { return Money{ static_cast&lt;uint64_t&gt;( money.value * factor ) }; } constexpr Money operator+( Money lhs, Money rhs ) noexcept { return Money{ lhs.value + rhs.value }; } std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, Money money ) { return os &lt;&lt; money.value; } // item.h #pragma once #include &quot;money.h&quot; #include &lt;memory&gt; #include &lt;utility&gt; class Item { public: template&lt; typename T &gt; Item( T item ) : pimpl_( std::make_unique&lt;Model&lt;T&gt;&gt;( std::move(item) ) ) {} Item( Item const&amp; item ) : pimpl_( item.pimpl_-&gt;clone() ) {} Item&amp; operator=( Item const&amp; item ) { pimpl_ = item.pimpl_-&gt;clone(); return *this; } ~Item() = default; Item( Item&amp;&amp; ) = default; Item&amp; operator=( Item&amp;&amp; item ) = default; Money price() const { return pimpl_-&gt;price(); } private: struct Concept { virtual ~Concept() = default; virtual Money price() const = 0; virtual std::unique_ptr&lt;Concept&gt; clone() const = 0; }; template&lt; typename T &gt; struct Model : public Concept { explicit Model( T const&amp; item ) : item_( item ) {} explicit Model( T&amp;&amp; item ) : item_( std::move(item) ) {} Money price() const override { return item_.price(); } std::unique_ptr&lt;Concept&gt; clone() const override { return std::make_unique&lt;Model&lt;T&gt;&gt;(*this); } T item_; }; std::unique_ptr&lt;Concept&gt; pimpl_; }; // discounted,h #pragma once #include &quot;item.h&quot; #include &lt;utility&gt; class Discounted { public: Discounted( double discount, Item item ) : item_( std::move(item) ) , factor_( 1.0 - discount ) {} Money price() const { return item_.price() * factor_; } private: Item item_; double factor_; }; // cpp_book.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class CppBook { public: CppBook( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // conference_ticket.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class ConferenceTicket { public: ConferenceTicket( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // main.cpp #include &quot;conference_ticket.h&quot; #include &quot;cpp_book.h&quot; #include &quot;discounted.h&quot; #include &quot;taxed.h&quot; #include &lt;cstdlib&gt; int main() { // 20% discount, 15% tax: (499*0.8)*1.15 = 459.08 Item item( Taxed( 0.15, Discounted(0.2, ConferenceTicket{ &quot;Core C++&quot;, Money{499} } ) ) ); Item item2( Taxed( 0.17, Discounted(0.2, ConferenceTicket{ &quot;Core C++&quot;, Money{499} } ) ) ); Item item3( Taxed( 0.18, Discounted(0.21, CppBook{ &quot;Software Design&quot;, Money{499} } ) ) ); Money const totalPrice = item.price(); Money const totalPrice2 = item2.price(); Money const totalPrice3 = item3.price(); // ... return EXIT_SUCCESS; } The modern solution The second solution is a modern value-semantics-based one, providing a solution for compile-time decoration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 // taxed.h #pragma once #include &quot;money.h&quot; #include &quot;priced_item.h&quot; #include &lt;utility&gt; template&lt; int taxRate, PricedItem Item &gt; class Taxed : private Item // Using inheritance { public: template&lt; typename... Args &gt; explicit Taxed( Args&amp;&amp;... args ) : Item{ std::forward&lt;Args&gt;(args)... } {} Money price() const { return Item::price() * ( 1.0 + (taxRate/100) ); } }; // priced_item.h #pragma once #include &quot;money.h&quot; template&lt; typename T &gt; concept PricedItem = requires ( T item ) { { item.price() } -&gt; std::same_as&lt;Money&gt;; }; // money.h #pragma once #include &lt;cmath&gt; #include &lt;concepts&gt; #include &lt;cstdint&gt; #include &lt;ostream&gt; struct Money { uint64_t value{}; }; template&lt; typename T &gt; requires std::is_arithmetic_v&lt;T&gt; Money operator*( Money money, T factor ) { return Money{ static_cast&lt;uint64_t&gt;( money.value * factor ) }; } constexpr Money operator+( Money lhs, Money rhs ) noexcept { return Money{ lhs.value + rhs.value }; } std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, Money money ) { return os &lt;&lt; money.value; } // discounted.h #pragma once #include &quot;money.h&quot; #include &quot;priced_item.h&quot; #include &lt;utility&gt; template&lt; int discount, PricedItem Item &gt; class Discounted // Using composition { public: template&lt; typename... Args &gt; explicit Discounted( Args&amp;&amp;... args ) : item_{ std::forward&lt;Args&gt;(args)... } {} Money price() const { return item_.price() * ( 1.0 - (discount/100) ); } private: Item item_; }; // cpp_book.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class CppBook { public: CppBook( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // main.cpp #include &quot;conference_ticket.h&quot; #include &quot;cpp_book.h&quot; #include &quot;discounted.h&quot; #include &quot;taxed.h&quot; #include &lt;cstdlib&gt; int main() { // 20% discount, 15% tax: (499*0.8)*1.15 = 459.08 Taxed&lt;15,Discounted&lt;20,ConferenceTicket&gt;&gt; item{ &quot;Core C++&quot;, Money{499} }; Taxed&lt;16,Discounted&lt;21,ConferenceTicket&gt;&gt; item2{ &quot;Core C++&quot;, Money{499} }; Taxed&lt;17,Discounted&lt;22,CppBook&gt;&gt; item3{ &quot;Core C++&quot;, Money{499} }; Money const totalPrice = item.price(); // Results in 459.08 Money const totalPrice2 = item2.price(); Money const totalPrice3 = item3.price(); // ... return EXIT_SUCCESS; } Comparing the solutions As Klaus explains in the book, the compile-time approach provides a faster run-time performance by a factor of 10. That’s a huge difference! It’s not very surprising though as there is no virtual dispatching, no run-time type resolution, and everything is known at compile-time. If that fits your needs, you should seriously consider the compile-time version. But what about the executable sizes? As we saw, declaring classes with virtual destructors has a price. The polymorphic solution is not just slower, but it also generates a bigger executable. Version Binary size at -O0 Binary size at -O3 Binary size at -Os classical decorator 76.1K 35.5K 36.1K modern decorator 39.9K 33.6K 34.3K But… There is a huge but here. The scope of the example is very limited in terms of different items. Meaning that while the size of the virtual solution is slightly bigger, we have to ask ourselves the question of how would it scale. The runtime solution requires creating a new subclass for each different kind of item and that costs some bytes. We cannot talk about exact sizes as it depends on so many things. But in the -Os/-O3 optimized version, a new JavaBook class (based on CppBook) added an extra 200 bytes. But it could easily be much more depending on the class itself. On the other hand, the compile-time solution uses templates both for taking a discount, for a tax and for taking the item too. Each different invocation will generate a new class which also adds up to the size. Based on what I can see, if you deal with the same few types of items, but with a variety of taxes and discounts, the virtual solution will scale better. But if there are also lots of new item types needed, the compile-time solution is not that bad not even in terms of executable size. Based on my experiments, both solutions scaled similarly when I added new types of items. But you have to measure so that you know for sure. And also let’s not forget that a compile-time decorated is not always an option as you might need that runtime flexibility. Conclusion Today, we compared classic and modern implementations of the decorator patterns in terms of binary sizes. The modern version of a decorator pattern is both faster and smaller than the classic implementation. But you have to keep in mind, that the virtual solution might scale better and that you might need the run-time flexibility of the classic pattern. Next week, we’ll look into the observer design pattern! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In one of the previous articles on binary sizes, we discussed how making a class polymorphic by using the virtual keyword affects the binary size. Turning a function into virtual has a substantial effect on the binary size, but adding more and more virtual methods to a class that already has at least one virtual function does not change that much. To have an elaborate example I went to the publicly available code examples of C++ Software Design by Klaus Iglberger. As I explained here, it’s one of the best books I read in 2022. If you are interested in software design and C++, in my opinion, it’s a must-read. In the book, you can find different implementations of various design patterns. All the discussed design patterns are first presented through their classic implementation, usually based on polymorphism and then modern alternatives are also explained. Sometimes, the modern implementations offer the same functionality, sometimes they are restricted for compile-time needs, but that’s often enough for the needs. In this and the next article, I want to go through two implementations of two design patterns and focus on their effects on binary sizes. Today, it’s the decorator pattern on the plate. The decorator pattern Let’s start by quickly recap on what is the decorator design pattern. In the Gang of Four book, it was listed as one of the structural design patterns. Some also refer to it as the wrapper pattern. Both names are good, as this pattern is about adding new behaviour to objects in a non-intrusive way. The decorator pattern places these objects into special wrapper objects responsible for attaching the new behaviour. Imagine that you have an item which has both a name and a price and some other attributes. However, having a price is not enough. Depending on where you want to sell it, you have to apply different taxes. Not to mention that you might also want to apply some discounts. Having the logic inside the class is not a great idea, and creating inheritance hierarchies does not scale as you add more and more taxes and discounts. The decorator pattern provides a scalable solution. The classic solution Klaus provided 3 solutions in his book. The first one is a classical solution based on runtime polymorphism. As I cannot compile templates with floating-point non-type arguments, I modified his example a bit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 // taxed.h #pragma once #include &quot;item.h&quot; #include &lt;utility&gt; class Taxed { public: Taxed( double taxRate, Item item ) : item_( std::move(item) ) , factor_( 1.0 + taxRate ) {} Money price() const { return item_.price() * factor_; } private: Item item_; double factor_; }; // money.h #pragma once #include &lt;cmath&gt; #include &lt;concepts&gt; #include &lt;cstdint&gt; #include &lt;ostream&gt; struct Money { uint64_t value{}; }; template&lt; typename T &gt; requires std::is_arithmetic_v&lt;T&gt; Money operator*( Money money, T factor ) { return Money{ static_cast&lt;uint64_t&gt;( money.value * factor ) }; } constexpr Money operator+( Money lhs, Money rhs ) noexcept { return Money{ lhs.value + rhs.value }; } std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, Money money ) { return os &lt;&lt; money.value; } // item.h #pragma once #include &quot;money.h&quot; #include &lt;memory&gt; #include &lt;utility&gt; class Item { public: template&lt; typename T &gt; Item( T item ) : pimpl_( std::make_unique&lt;Model&lt;T&gt;&gt;( std::move(item) ) ) {} Item( Item const&amp; item ) : pimpl_( item.pimpl_-&gt;clone() ) {} Item&amp; operator=( Item const&amp; item ) { pimpl_ = item.pimpl_-&gt;clone(); return *this; } ~Item() = default; Item( Item&amp;&amp; ) = default; Item&amp; operator=( Item&amp;&amp; item ) = default; Money price() const { return pimpl_-&gt;price(); } private: struct Concept { virtual ~Concept() = default; virtual Money price() const = 0; virtual std::unique_ptr&lt;Concept&gt; clone() const = 0; }; template&lt; typename T &gt; struct Model : public Concept { explicit Model( T const&amp; item ) : item_( item ) {} explicit Model( T&amp;&amp; item ) : item_( std::move(item) ) {} Money price() const override { return item_.price(); } std::unique_ptr&lt;Concept&gt; clone() const override { return std::make_unique&lt;Model&lt;T&gt;&gt;(*this); } T item_; }; std::unique_ptr&lt;Concept&gt; pimpl_; }; // discounted,h #pragma once #include &quot;item.h&quot; #include &lt;utility&gt; class Discounted { public: Discounted( double discount, Item item ) : item_( std::move(item) ) , factor_( 1.0 - discount ) {} Money price() const { return item_.price() * factor_; } private: Item item_; double factor_; }; // cpp_book.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class CppBook { public: CppBook( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // conference_ticket.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class ConferenceTicket { public: ConferenceTicket( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // main.cpp #include &quot;conference_ticket.h&quot; #include &quot;cpp_book.h&quot; #include &quot;discounted.h&quot; #include &quot;taxed.h&quot; #include &lt;cstdlib&gt; int main() { // 20% discount, 15% tax: (499*0.8)*1.15 = 459.08 Item item( Taxed( 0.15, Discounted(0.2, ConferenceTicket{ &quot;Core C++&quot;, Money{499} } ) ) ); Item item2( Taxed( 0.17, Discounted(0.2, ConferenceTicket{ &quot;Core C++&quot;, Money{499} } ) ) ); Item item3( Taxed( 0.18, Discounted(0.21, CppBook{ &quot;Software Design&quot;, Money{499} } ) ) ); Money const totalPrice = item.price(); Money const totalPrice2 = item2.price(); Money const totalPrice3 = item3.price(); // ... return EXIT_SUCCESS; } The modern solution The second solution is a modern value-semantics-based one, providing a solution for compile-time decoration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 // taxed.h #pragma once #include &quot;money.h&quot; #include &quot;priced_item.h&quot; #include &lt;utility&gt; template&lt; int taxRate, PricedItem Item &gt; class Taxed : private Item // Using inheritance { public: template&lt; typename... Args &gt; explicit Taxed( Args&amp;&amp;... args ) : Item{ std::forward&lt;Args&gt;(args)... } {} Money price() const { return Item::price() * ( 1.0 + (taxRate/100) ); } }; // priced_item.h #pragma once #include &quot;money.h&quot; template&lt; typename T &gt; concept PricedItem = requires ( T item ) { { item.price() } -&gt; std::same_as&lt;Money&gt;; }; // money.h #pragma once #include &lt;cmath&gt; #include &lt;concepts&gt; #include &lt;cstdint&gt; #include &lt;ostream&gt; struct Money { uint64_t value{}; }; template&lt; typename T &gt; requires std::is_arithmetic_v&lt;T&gt; Money operator*( Money money, T factor ) { return Money{ static_cast&lt;uint64_t&gt;( money.value * factor ) }; } constexpr Money operator+( Money lhs, Money rhs ) noexcept { return Money{ lhs.value + rhs.value }; } std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, Money money ) { return os &lt;&lt; money.value; } // discounted.h #pragma once #include &quot;money.h&quot; #include &quot;priced_item.h&quot; #include &lt;utility&gt; template&lt; int discount, PricedItem Item &gt; class Discounted // Using composition { public: template&lt; typename... Args &gt; explicit Discounted( Args&amp;&amp;... args ) : item_{ std::forward&lt;Args&gt;(args)... } {} Money price() const { return item_.price() * ( 1.0 - (discount/100) ); } private: Item item_; }; // cpp_book.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class CppBook { public: CppBook( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // main.cpp #include &quot;conference_ticket.h&quot; #include &quot;cpp_book.h&quot; #include &quot;discounted.h&quot; #include &quot;taxed.h&quot; #include &lt;cstdlib&gt; int main() { // 20% discount, 15% tax: (499*0.8)*1.15 = 459.08 Taxed&lt;15,Discounted&lt;20,ConferenceTicket&gt;&gt; item{ &quot;Core C++&quot;, Money{499} }; Taxed&lt;16,Discounted&lt;21,ConferenceTicket&gt;&gt; item2{ &quot;Core C++&quot;, Money{499} }; Taxed&lt;17,Discounted&lt;22,CppBook&gt;&gt; item3{ &quot;Core C++&quot;, Money{499} }; Money const totalPrice = item.price(); // Results in 459.08 Money const totalPrice2 = item2.price(); Money const totalPrice3 = item3.price(); // ... return EXIT_SUCCESS; } Comparing the solutions As Klaus explains in the book, the compile-time approach provides a faster run-time performance by a factor of 10. That’s a huge difference! It’s not very surprising though as there is no virtual dispatching, no run-time type resolution, and everything is known at compile-time. If that fits your needs, you should seriously consider the compile-time version. But what about the executable sizes? As we saw, declaring classes with virtual destructors has a price. The polymorphic solution is not just slower, but it also generates a bigger executable. Version Binary size at -O0 Binary size at -O3 Binary size at -Os classical decorator 76.1K 35.5K 36.1K modern decorator 39.9K 33.6K 34.3K But… There is a huge but here. The scope of the example is very limited in terms of different items. Meaning that while the size of the virtual solution is slightly bigger, we have to ask ourselves the question of how would it scale. The runtime solution requires creating a new subclass for each different kind of item and that costs some bytes. We cannot talk about exact sizes as it depends on so many things. But in the -Os/-O3 optimized version, a new JavaBook class (based on CppBook) added an extra 200 bytes. But it could easily be much more depending on the class itself. On the other hand, the compile-time solution uses templates both for taking a discount, for a tax and for taking the item too. Each different invocation will generate a new class which also adds up to the size. Based on what I can see, if you deal with the same few types of items, but with a variety of taxes and discounts, the virtual solution will scale better. But if there are also lots of new item types needed, the compile-time solution is not that bad not even in terms of executable size. Based on my experiments, both solutions scaled similarly when I added new types of items. But you have to measure so that you know for sure. And also let’s not forget that a compile-time decorated is not always an option as you might need that runtime flexibility. Conclusion Today, we compared classic and modern implementations of the decorator patterns in terms of binary sizes. The modern version of a decorator pattern is both faster and smaller than the classic implementation. But you have to keep in mind, that the virtual solution might scale better and that you might need the run-time flexibility of the classic pattern. Next week, we’ll look into the observer design pattern! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-08T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The decorator pattern and binary sizes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-08T00:00:00+01:00","datePublished":"2023-03-08T00:00:00+01:00","description":"In one of the previous articles on binary sizes, we discussed how making a class polymorphic by using the virtual keyword affects the binary size. Turning a function into virtual has a substantial effect on the binary size, but adding more and more virtual methods to a class that already has at least one virtual function does not change that much. To have an elaborate example I went to the publicly available code examples of C++ Software Design by Klaus Iglberger. As I explained here, it’s one of the best books I read in 2022. If you are interested in software design and C++, in my opinion, it’s a must-read. In the book, you can find different implementations of various design patterns. All the discussed design patterns are first presented through their classic implementation, usually based on polymorphism and then modern alternatives are also explained. Sometimes, the modern implementations offer the same functionality, sometimes they are restricted for compile-time needs, but that’s often enough for the needs. In this and the next article, I want to go through two implementations of two design patterns and focus on their effects on binary sizes. Today, it’s the decorator pattern on the plate. The decorator pattern Let’s start by quickly recap on what is the decorator design pattern. In the Gang of Four book, it was listed as one of the structural design patterns. Some also refer to it as the wrapper pattern. Both names are good, as this pattern is about adding new behaviour to objects in a non-intrusive way. The decorator pattern places these objects into special wrapper objects responsible for attaching the new behaviour. Imagine that you have an item which has both a name and a price and some other attributes. However, having a price is not enough. Depending on where you want to sell it, you have to apply different taxes. Not to mention that you might also want to apply some discounts. Having the logic inside the class is not a great idea, and creating inheritance hierarchies does not scale as you add more and more taxes and discounts. The decorator pattern provides a scalable solution. The classic solution Klaus provided 3 solutions in his book. The first one is a classical solution based on runtime polymorphism. As I cannot compile templates with floating-point non-type arguments, I modified his example a bit. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 // taxed.h #pragma once #include &quot;item.h&quot; #include &lt;utility&gt; class Taxed { public: Taxed( double taxRate, Item item ) : item_( std::move(item) ) , factor_( 1.0 + taxRate ) {} Money price() const { return item_.price() * factor_; } private: Item item_; double factor_; }; // money.h #pragma once #include &lt;cmath&gt; #include &lt;concepts&gt; #include &lt;cstdint&gt; #include &lt;ostream&gt; struct Money { uint64_t value{}; }; template&lt; typename T &gt; requires std::is_arithmetic_v&lt;T&gt; Money operator*( Money money, T factor ) { return Money{ static_cast&lt;uint64_t&gt;( money.value * factor ) }; } constexpr Money operator+( Money lhs, Money rhs ) noexcept { return Money{ lhs.value + rhs.value }; } std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, Money money ) { return os &lt;&lt; money.value; } // item.h #pragma once #include &quot;money.h&quot; #include &lt;memory&gt; #include &lt;utility&gt; class Item { public: template&lt; typename T &gt; Item( T item ) : pimpl_( std::make_unique&lt;Model&lt;T&gt;&gt;( std::move(item) ) ) {} Item( Item const&amp; item ) : pimpl_( item.pimpl_-&gt;clone() ) {} Item&amp; operator=( Item const&amp; item ) { pimpl_ = item.pimpl_-&gt;clone(); return *this; } ~Item() = default; Item( Item&amp;&amp; ) = default; Item&amp; operator=( Item&amp;&amp; item ) = default; Money price() const { return pimpl_-&gt;price(); } private: struct Concept { virtual ~Concept() = default; virtual Money price() const = 0; virtual std::unique_ptr&lt;Concept&gt; clone() const = 0; }; template&lt; typename T &gt; struct Model : public Concept { explicit Model( T const&amp; item ) : item_( item ) {} explicit Model( T&amp;&amp; item ) : item_( std::move(item) ) {} Money price() const override { return item_.price(); } std::unique_ptr&lt;Concept&gt; clone() const override { return std::make_unique&lt;Model&lt;T&gt;&gt;(*this); } T item_; }; std::unique_ptr&lt;Concept&gt; pimpl_; }; // discounted,h #pragma once #include &quot;item.h&quot; #include &lt;utility&gt; class Discounted { public: Discounted( double discount, Item item ) : item_( std::move(item) ) , factor_( 1.0 - discount ) {} Money price() const { return item_.price() * factor_; } private: Item item_; double factor_; }; // cpp_book.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class CppBook { public: CppBook( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // conference_ticket.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class ConferenceTicket { public: ConferenceTicket( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // main.cpp #include &quot;conference_ticket.h&quot; #include &quot;cpp_book.h&quot; #include &quot;discounted.h&quot; #include &quot;taxed.h&quot; #include &lt;cstdlib&gt; int main() { // 20% discount, 15% tax: (499*0.8)*1.15 = 459.08 Item item( Taxed( 0.15, Discounted(0.2, ConferenceTicket{ &quot;Core C++&quot;, Money{499} } ) ) ); Item item2( Taxed( 0.17, Discounted(0.2, ConferenceTicket{ &quot;Core C++&quot;, Money{499} } ) ) ); Item item3( Taxed( 0.18, Discounted(0.21, CppBook{ &quot;Software Design&quot;, Money{499} } ) ) ); Money const totalPrice = item.price(); Money const totalPrice2 = item2.price(); Money const totalPrice3 = item3.price(); // ... return EXIT_SUCCESS; } The modern solution The second solution is a modern value-semantics-based one, providing a solution for compile-time decoration. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 // taxed.h #pragma once #include &quot;money.h&quot; #include &quot;priced_item.h&quot; #include &lt;utility&gt; template&lt; int taxRate, PricedItem Item &gt; class Taxed : private Item // Using inheritance { public: template&lt; typename... Args &gt; explicit Taxed( Args&amp;&amp;... args ) : Item{ std::forward&lt;Args&gt;(args)... } {} Money price() const { return Item::price() * ( 1.0 + (taxRate/100) ); } }; // priced_item.h #pragma once #include &quot;money.h&quot; template&lt; typename T &gt; concept PricedItem = requires ( T item ) { { item.price() } -&gt; std::same_as&lt;Money&gt;; }; // money.h #pragma once #include &lt;cmath&gt; #include &lt;concepts&gt; #include &lt;cstdint&gt; #include &lt;ostream&gt; struct Money { uint64_t value{}; }; template&lt; typename T &gt; requires std::is_arithmetic_v&lt;T&gt; Money operator*( Money money, T factor ) { return Money{ static_cast&lt;uint64_t&gt;( money.value * factor ) }; } constexpr Money operator+( Money lhs, Money rhs ) noexcept { return Money{ lhs.value + rhs.value }; } std::ostream&amp; operator&lt;&lt;( std::ostream&amp; os, Money money ) { return os &lt;&lt; money.value; } // discounted.h #pragma once #include &quot;money.h&quot; #include &quot;priced_item.h&quot; #include &lt;utility&gt; template&lt; int discount, PricedItem Item &gt; class Discounted // Using composition { public: template&lt; typename... Args &gt; explicit Discounted( Args&amp;&amp;... args ) : item_{ std::forward&lt;Args&gt;(args)... } {} Money price() const { return item_.price() * ( 1.0 - (discount/100) ); } private: Item item_; }; // cpp_book.h #pragma once #include &quot;money.h&quot; #include &lt;string&gt; #include &lt;utility&gt; class CppBook { public: CppBook( std::string name, Money price ) : name_{ std::move(name) } , price_{ price } {} std::string const&amp; name() const { return name_; } Money price() const { return price_; } private: std::string name_; Money price_; }; // main.cpp #include &quot;conference_ticket.h&quot; #include &quot;cpp_book.h&quot; #include &quot;discounted.h&quot; #include &quot;taxed.h&quot; #include &lt;cstdlib&gt; int main() { // 20% discount, 15% tax: (499*0.8)*1.15 = 459.08 Taxed&lt;15,Discounted&lt;20,ConferenceTicket&gt;&gt; item{ &quot;Core C++&quot;, Money{499} }; Taxed&lt;16,Discounted&lt;21,ConferenceTicket&gt;&gt; item2{ &quot;Core C++&quot;, Money{499} }; Taxed&lt;17,Discounted&lt;22,CppBook&gt;&gt; item3{ &quot;Core C++&quot;, Money{499} }; Money const totalPrice = item.price(); // Results in 459.08 Money const totalPrice2 = item2.price(); Money const totalPrice3 = item3.price(); // ... return EXIT_SUCCESS; } Comparing the solutions As Klaus explains in the book, the compile-time approach provides a faster run-time performance by a factor of 10. That’s a huge difference! It’s not very surprising though as there is no virtual dispatching, no run-time type resolution, and everything is known at compile-time. If that fits your needs, you should seriously consider the compile-time version. But what about the executable sizes? As we saw, declaring classes with virtual destructors has a price. The polymorphic solution is not just slower, but it also generates a bigger executable. Version Binary size at -O0 Binary size at -O3 Binary size at -Os classical decorator 76.1K 35.5K 36.1K modern decorator 39.9K 33.6K 34.3K But… There is a huge but here. The scope of the example is very limited in terms of different items. Meaning that while the size of the virtual solution is slightly bigger, we have to ask ourselves the question of how would it scale. The runtime solution requires creating a new subclass for each different kind of item and that costs some bytes. We cannot talk about exact sizes as it depends on so many things. But in the -Os/-O3 optimized version, a new JavaBook class (based on CppBook) added an extra 200 bytes. But it could easily be much more depending on the class itself. On the other hand, the compile-time solution uses templates both for taking a discount, for a tax and for taking the item too. Each different invocation will generate a new class which also adds up to the size. Based on what I can see, if you deal with the same few types of items, but with a variety of taxes and discounts, the virtual solution will scale better. But if there are also lots of new item types needed, the compile-time solution is not that bad not even in terms of executable size. Based on my experiments, both solutions scaled similarly when I added new types of items. But you have to measure so that you know for sure. And also let’s not forget that a compile-time decorated is not always an option as you might need that runtime flexibility. Conclusion Today, we compared classic and modern implementations of the decorator patterns in terms of binary sizes. The modern version of a decorator pattern is both faster and smaller than the classic implementation. But you have to keep in mind, that the virtual solution might scale better and that you might need the run-time flexibility of the classic pattern. Next week, we’ll look into the observer design pattern! Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The decorator pattern and binary sizes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern"},"url":"https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern"}</script><title>The decorator pattern and binary sizes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/08"> 08 </a> </span> <span>The decorator pattern and binary sizes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The decorator pattern and binary sizes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 8, 2023, 12:00 AM +0100" prep="on" > Mar 8, 2023 <i class="unloaded">2023-03-08T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2024 words">11 min</span></div></div><div class="post-content"><p><a href="https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual">In one of the previous articles on binary sizes</a>, we discussed how making a class polymorphic by using the <code class="language-plaintext highlighter-rouge">virtual</code> keyword affects the binary size. Turning a function into <code class="language-plaintext highlighter-rouge">virtual</code> has a substantial effect on the binary size, but adding more and more <code class="language-plaintext highlighter-rouge">virtual</code> methods to a class that already has at least one <code class="language-plaintext highlighter-rouge">virtual</code> function does not change that much.</p><p>To have an elaborate example I went to the publicly available code examples of <a href="https://www.amazon.com/Software-Design-Principles-Patterns-High-Quality/dp/1098113160?&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=e9b6f64671aac55ff52ecfd91e137d6e&amp;camp=1789&amp;creative=9325">C++ Software Design</a> by <a href="https://coaches.xing.com/profile/Klaus_Iglberger/trainings">Klaus Iglberger</a>. As I explained <a href="https://www.sandordargo.com/blog/2022/12/31/8-best-books-in-2022">here</a>, it’s one of the best books I read in 2022. If you are interested in software design and C++, in my opinion, it’s a must-read.</p><p>In the book, you can find different implementations of various design patterns. All the discussed design patterns are first presented through their classic implementation, usually based on polymorphism and then modern alternatives are also explained.</p><p>Sometimes, the modern implementations offer the same functionality, sometimes they are restricted for compile-time needs, but that’s often enough for the needs.</p><p>In this and the next article, I want to go through two implementations of two design patterns and focus on their effects on binary sizes. Today, it’s the decorator pattern on the plate.</p><h2 id="the-decorator-pattern">The decorator pattern</h2><p>Let’s start by quickly recap on what is the <em>decorator design pattern</em>. In the <a href="https://amzn.to/2KWCkLN">Gang of Four book</a>, it was listed as one of the structural design patterns. Some also refer to it as the <em>wrapper pattern</em>. Both names are good, as this pattern is about adding new behaviour to objects in a non-intrusive way. The decorator pattern places these objects into special wrapper objects responsible for attaching the new behaviour.</p><p>Imagine that you have an item which has both a name and a price and some other attributes. However, having a price is not enough. Depending on where you want to sell it, you have to apply different taxes. Not to mention that you might also want to apply some discounts.</p><p>Having the logic inside the class is not a great idea, and creating inheritance hierarchies does not scale as you add more and more taxes and discounts.</p><p>The <em>decorator pattern</em> provides a scalable solution.</p><h2 id="the-classic-solution">The classic solution</h2><p>Klaus provided 3 solutions in his book. The first one is a classical solution based on runtime polymorphism. As I cannot compile templates with floating-point non-type arguments, I modified his example a bit.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
</pre><td class="rouge-code"><pre><span class="c1">// taxed.h</span>
<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"item.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Taxed</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="n">Taxed</span><span class="p">(</span> <span class="kt">double</span> <span class="n">taxRate</span><span class="p">,</span> <span class="n">Item</span> <span class="n">item</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">item_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">,</span> <span class="n">factor_</span><span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="n">taxRate</span> <span class="p">)</span>
   <span class="p">{}</span>

   <span class="n">Money</span> <span class="n">price</span><span class="p">()</span> <span class="k">const</span>
   <span class="p">{</span>
      <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">;</span>
   <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">Item</span> <span class="n">item_</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">factor_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// money.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Money</span>
<span class="p">{</span>
   <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">{};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="p">&gt;</span>
   <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">Money</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="n">Money</span> <span class="n">money</span><span class="p">,</span> <span class="n">T</span> <span class="n">factor</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">Money</span><span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">money</span><span class="p">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">factor</span> <span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Money</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">Money</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Money</span> <span class="n">rhs</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">Money</span><span class="p">{</span> <span class="n">lhs</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Money</span> <span class="n">money</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">money</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// item.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Item</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="p">&gt;</span>
   <span class="n">Item</span><span class="p">(</span> <span class="n">T</span> <span class="n">item</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">)</span> <span class="p">)</span>
   <span class="p">{}</span>

   <span class="n">Item</span><span class="p">(</span> <span class="n">Item</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span> <span class="p">)</span> <span class="o">:</span> <span class="n">pimpl_</span><span class="p">(</span> <span class="n">item</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">()</span> <span class="p">)</span> <span class="p">{}</span>

   <span class="n">Item</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">Item</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span> <span class="p">)</span>
   <span class="p">{</span>
      <span class="n">pimpl_</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">clone</span><span class="p">();</span>
      <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
   <span class="p">}</span>

   <span class="o">~</span><span class="n">Item</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
   <span class="n">Item</span><span class="p">(</span> <span class="n">Item</span><span class="o">&amp;&amp;</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
   <span class="n">Item</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span> <span class="n">Item</span><span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

   <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">pimpl_</span><span class="o">-&gt;</span><span class="n">price</span><span class="p">();</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="k">struct</span> <span class="nc">Concept</span>
   <span class="p">{</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">Concept</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="n">Money</span> <span class="n">price</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="p">&gt;</span>
   <span class="k">struct</span> <span class="nc">Model</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Concept</span>
   <span class="p">{</span>
      <span class="k">explicit</span> <span class="n">Model</span><span class="p">(</span> <span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">item</span> <span class="p">)</span> <span class="o">:</span> <span class="n">item_</span><span class="p">(</span> <span class="n">item</span> <span class="p">)</span> <span class="p">{}</span>
      <span class="k">explicit</span> <span class="nf">Model</span><span class="p">(</span> <span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">item</span> <span class="p">)</span> <span class="o">:</span> <span class="n">item_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">)</span> <span class="p">{}</span>

      <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
      <span class="p">{</span>
         <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
      <span class="p">}</span>

      <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span>
      <span class="p">{</span>
         <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Model</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
      <span class="p">}</span>

      <span class="n">T</span> <span class="n">item_</span><span class="p">;</span>
   <span class="p">};</span>

   <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Concept</span><span class="o">&gt;</span> <span class="n">pimpl_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// discounted,h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"item.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">Discounted</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="n">Discounted</span><span class="p">(</span> <span class="kt">double</span> <span class="n">discount</span><span class="p">,</span> <span class="n">Item</span> <span class="n">item</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">item_</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="p">)</span>
      <span class="p">,</span> <span class="n">factor_</span><span class="p">(</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="n">discount</span> <span class="p">)</span>
   <span class="p">{}</span>

   <span class="n">Money</span> <span class="n">price</span><span class="p">()</span> <span class="k">const</span>
   <span class="p">{</span>
      <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="n">factor_</span><span class="p">;</span>
   <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">Item</span> <span class="n">item_</span><span class="p">;</span>
   <span class="kt">double</span> <span class="n">factor_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// cpp_book.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">CppBook</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="n">CppBook</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">name_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">,</span> <span class="n">price_</span><span class="p">{</span> <span class="n">price</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">Money</span> <span class="n">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
   <span class="n">Money</span> <span class="n">price_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// conference_ticket.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">ConferenceTicket</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="n">ConferenceTicket</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">name_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">,</span> <span class="n">price_</span><span class="p">{</span> <span class="n">price</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">Money</span> <span class="n">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
   <span class="n">Money</span> <span class="n">price_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">"conference_ticket.h"</span><span class="cp">
#include</span> <span class="cpf">"cpp_book.h"</span><span class="cp">
#include</span> <span class="cpf">"discounted.h"</span><span class="cp">
#include</span> <span class="cpf">"taxed.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// 20% discount, 15% tax: (499*0.8)*1.15 = 459.08</span>
   <span class="n">Item</span> <span class="n">item</span><span class="p">(</span> <span class="n">Taxed</span><span class="p">(</span> <span class="mf">0.15</span><span class="p">,</span> <span class="n">Discounted</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="p">{</span> <span class="s">"Core C++"</span><span class="p">,</span> <span class="n">Money</span><span class="p">{</span><span class="mi">499</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
   <span class="n">Item</span> <span class="nf">item2</span><span class="p">(</span> <span class="n">Taxed</span><span class="p">(</span> <span class="mf">0.17</span><span class="p">,</span> <span class="n">Discounted</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">ConferenceTicket</span><span class="p">{</span> <span class="s">"Core C++"</span><span class="p">,</span> <span class="n">Money</span><span class="p">{</span><span class="mi">499</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>
   <span class="n">Item</span> <span class="nf">item3</span><span class="p">(</span> <span class="n">Taxed</span><span class="p">(</span> <span class="mf">0.18</span><span class="p">,</span> <span class="n">Discounted</span><span class="p">(</span><span class="mf">0.21</span><span class="p">,</span> <span class="n">CppBook</span><span class="p">{</span> <span class="s">"Software Design"</span><span class="p">,</span> <span class="n">Money</span><span class="p">{</span><span class="mi">499</span><span class="p">}</span> <span class="p">}</span> <span class="p">)</span> <span class="p">)</span> <span class="p">);</span>


   <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
   <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice2</span> <span class="o">=</span> <span class="n">item2</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
   <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice3</span> <span class="o">=</span> <span class="n">item3</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>

   <span class="c1">// ...</span>

   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="the-modern-solution">The modern solution</h2><p>The second solution is a modern value-semantics-based one, providing a solution for compile-time decoration.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
</pre><td class="rouge-code"><pre><span class="c1">// taxed.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
#include</span> <span class="cpf">"priced_item.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="n">taxRate</span><span class="p">,</span> <span class="n">PricedItem</span> <span class="n">Item</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Taxed</span> <span class="o">:</span> <span class="k">private</span> <span class="n">Item</span>  <span class="c1">// Using inheritance</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span> <span class="p">&gt;</span>
   <span class="k">explicit</span> <span class="n">Taxed</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">Item</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">Item</span><span class="o">::</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">+</span> <span class="p">(</span><span class="n">taxRate</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span> <span class="p">);</span>
   <span class="p">}</span>
<span class="p">};</span>

<span class="c1">// priced_item.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="p">&gt;</span>
<span class="k">concept</span> <span class="n">PricedItem</span> <span class="o">=</span>
   <span class="k">requires</span> <span class="p">(</span> <span class="n">T</span> <span class="n">item</span> <span class="p">)</span> <span class="p">{</span>
      <span class="p">{</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="p">}</span> <span class="o">-&gt;</span> <span class="n">std</span><span class="o">::</span><span class="n">same_as</span><span class="o">&lt;</span><span class="n">Money</span><span class="o">&gt;</span><span class="p">;</span>
   <span class="p">};</span>

<span class="c1">// money.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">&lt;cmath&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;concepts&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cstdint&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;ostream&gt;</span><span class="cp">
</span>
<span class="k">struct</span> <span class="nc">Money</span>
<span class="p">{</span>
   <span class="kt">uint64_t</span> <span class="n">value</span><span class="p">{};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span> <span class="nc">T</span> <span class="p">&gt;</span>
   <span class="k">requires</span> <span class="n">std</span><span class="o">::</span><span class="n">is_arithmetic_v</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span>
<span class="n">Money</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span> <span class="n">Money</span> <span class="n">money</span><span class="p">,</span> <span class="n">T</span> <span class="n">factor</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">Money</span><span class="p">{</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">money</span><span class="p">.</span><span class="n">value</span> <span class="o">*</span> <span class="n">factor</span> <span class="p">)</span> <span class="p">};</span>
<span class="p">}</span>

<span class="k">constexpr</span> <span class="n">Money</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span> <span class="n">Money</span> <span class="n">lhs</span><span class="p">,</span> <span class="n">Money</span> <span class="n">rhs</span> <span class="p">)</span> <span class="k">noexcept</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">Money</span><span class="p">{</span> <span class="n">lhs</span><span class="p">.</span><span class="n">value</span> <span class="o">+</span> <span class="n">rhs</span><span class="p">.</span><span class="n">value</span> <span class="p">};</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="n">Money</span> <span class="n">money</span> <span class="p">)</span>
<span class="p">{</span>
   <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="n">money</span><span class="p">.</span><span class="n">value</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// discounted.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
#include</span> <span class="cpf">"priced_item.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">template</span><span class="o">&lt;</span> <span class="kt">int</span> <span class="n">discount</span><span class="p">,</span> <span class="n">PricedItem</span> <span class="n">Item</span> <span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Discounted</span>  <span class="c1">// Using composition</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="k">template</span><span class="o">&lt;</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span> <span class="p">&gt;</span>
   <span class="k">explicit</span> <span class="n">Discounted</span><span class="p">(</span> <span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">item_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)...</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="n">Money</span> <span class="nf">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">item_</span><span class="p">.</span><span class="n">price</span><span class="p">()</span> <span class="o">*</span> <span class="p">(</span> <span class="mf">1.0</span> <span class="o">-</span> <span class="p">(</span><span class="n">discount</span><span class="o">/</span><span class="mi">100</span><span class="p">)</span> <span class="p">);</span>
   <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">Item</span> <span class="n">item_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// cpp_book.h</span>

<span class="cp">#pragma once
</span>
<span class="cp">#include</span> <span class="cpf">"money.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">CppBook</span>
<span class="p">{</span>
 <span class="nl">public:</span>
   <span class="n">CppBook</span><span class="p">(</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name</span><span class="p">,</span> <span class="n">Money</span> <span class="n">price</span> <span class="p">)</span>
      <span class="o">:</span> <span class="n">name_</span><span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">name</span><span class="p">)</span> <span class="p">}</span>
      <span class="p">,</span> <span class="n">price_</span><span class="p">{</span> <span class="n">price</span> <span class="p">}</span>
   <span class="p">{}</span>

   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name_</span><span class="p">;</span> <span class="p">}</span>
   <span class="n">Money</span> <span class="n">price</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">price_</span><span class="p">;</span> <span class="p">}</span>

 <span class="k">private</span><span class="o">:</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">name_</span><span class="p">;</span>
   <span class="n">Money</span> <span class="n">price_</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// main.cpp</span>

<span class="cp">#include</span> <span class="cpf">"conference_ticket.h"</span><span class="cp">
#include</span> <span class="cpf">"cpp_book.h"</span><span class="cp">
#include</span> <span class="cpf">"discounted.h"</span><span class="cp">
#include</span> <span class="cpf">"taxed.h"</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;cstdlib&gt;</span><span class="cp">
</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// 20% discount, 15% tax: (499*0.8)*1.15 = 459.08</span>
   <span class="n">Taxed</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span><span class="n">Discounted</span><span class="o">&lt;</span><span class="mi">20</span><span class="p">,</span><span class="n">ConferenceTicket</span><span class="o">&gt;&gt;</span> <span class="n">item</span><span class="p">{</span> <span class="s">"Core C++"</span><span class="p">,</span> <span class="n">Money</span><span class="p">{</span><span class="mi">499</span><span class="p">}</span> <span class="p">};</span>
   <span class="n">Taxed</span><span class="o">&lt;</span><span class="mi">16</span><span class="p">,</span><span class="n">Discounted</span><span class="o">&lt;</span><span class="mi">21</span><span class="p">,</span><span class="n">ConferenceTicket</span><span class="o">&gt;&gt;</span> <span class="n">item2</span><span class="p">{</span> <span class="s">"Core C++"</span><span class="p">,</span> <span class="n">Money</span><span class="p">{</span><span class="mi">499</span><span class="p">}</span> <span class="p">};</span>
   <span class="n">Taxed</span><span class="o">&lt;</span><span class="mi">17</span><span class="p">,</span><span class="n">Discounted</span><span class="o">&lt;</span><span class="mi">22</span><span class="p">,</span><span class="n">CppBook</span><span class="o">&gt;&gt;</span> <span class="n">item3</span><span class="p">{</span> <span class="s">"Core C++"</span><span class="p">,</span> <span class="n">Money</span><span class="p">{</span><span class="mi">499</span><span class="p">}</span> <span class="p">};</span>

   <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice</span> <span class="o">=</span> <span class="n">item</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>  <span class="c1">// Results in 459.08</span>
   <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice2</span> <span class="o">=</span> <span class="n">item2</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
   <span class="n">Money</span> <span class="k">const</span> <span class="n">totalPrice3</span> <span class="o">=</span> <span class="n">item3</span><span class="p">.</span><span class="n">price</span><span class="p">();</span>
      <span class="c1">// ...</span>

   <span class="k">return</span> <span class="n">EXIT_SUCCESS</span><span class="p">;</span>
<span class="p">}</span>   
</pre></table></code></div></div><h2 id="comparing-the-solutions">Comparing the solutions</h2><p>As Klaus explains in the book, the compile-time approach provides a faster run-time performance by a factor of 10.</p><p>That’s a huge difference!</p><p>It’s not very surprising though as there is no virtual dispatching, no run-time type resolution, and everything is known at compile-time. If that fits your needs, you should seriously consider the compile-time version.</p><p>But what about the executable sizes?</p><p><a href="https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual">As we saw</a>, declaring classes with <code class="language-plaintext highlighter-rouge">virtual</code> destructors has a price. The polymorphic solution is not just slower, but it also generates a bigger executable.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size at -O0<th>Binary size at -O3<th>Binary size at -Os<tbody><tr><td>classical decorator<td>76.1K<td>35.5K<td>36.1K<tr><td>modern decorator<td>39.9K<td>33.6K<td>34.3K</table></div><p>But…</p><p>There is a huge <em>but</em> here. The scope of the example is very limited in terms of different items. Meaning that while the size of the <code class="language-plaintext highlighter-rouge">virtual</code> solution is slightly bigger, we have to ask ourselves the question of how would it scale.</p><p>The runtime solution requires creating a new subclass for each different kind of item and that costs some bytes. We cannot talk about exact sizes as it depends on so many things. But in the <code class="language-plaintext highlighter-rouge">-Os/-O3</code> optimized version, a new <code class="language-plaintext highlighter-rouge">JavaBook</code> class (based on <code class="language-plaintext highlighter-rouge">CppBook</code>) added an extra 200 bytes. But it could easily be much more depending on the class itself.</p><p>On the other hand, the compile-time solution uses templates both for taking a discount, for a tax and for taking the item too. Each different invocation will generate a new class which also adds up to the size.</p><p>Based on what I can see, if you deal with the same few types of items, but with a variety of taxes and discounts, the virtual solution will scale better.</p><p>But if there are also lots of new item types needed, the compile-time solution is not that bad not even in terms of executable size. Based on my experiments, both solutions scaled similarly when I added new types of items.</p><p>But you have to measure so that you know for sure. And also let’s not forget that a compile-time decorated is not always an option as you might need that runtime flexibility.</p><h2 id="conclusion">Conclusion</h2><p>Today, we compared classic and modern implementations of the decorator patterns in terms of binary sizes. The modern version of a decorator pattern is both faster and smaller than the classic implementation. But you have to keep in mind, that the <code class="language-plaintext highlighter-rouge">virtual</code> solution might scale better and that you might need the run-time flexibility of the classic pattern.</p><p>Next week, we’ll look into the observer design pattern!</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/designpatterns/" class="post-tag no-text-decoration" >designpatterns</a> <a href="/tags/decorator/" class="post-tag no-text-decoration" >decorator</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The decorator pattern and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The decorator pattern and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The decorator pattern and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The decorator pattern and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/31/rule-of-5-once-again"><div class="card-body"> <span class="timeago small" > Jul 31, 2024 <i class="unloaded">2024-07-31T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Once more about the rule of 5</h3><div class="text-muted small"><p> Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule...</p></div></div></a></div><div class="card"> <a href="/blog/2024/08/07/rule-of-five-and-base-classes"><div class="card-body"> <span class="timeago small" > Aug 7, 2024 <i class="unloaded">2024-08-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>The rule of 5 and inheritance</h3><div class="text-muted small"><p> Last week, we talked about the rule of five and we discovered what it means for move operations if we only declare a destructor and not the rest of the special member functions. In that case, move ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/03/01/binary-sizes-and-rtti" class="btn btn-outline-primary" prompt="Older"><p>Binary sizes and RTTI</p></a> <a href="/blog/2023/03/11/ordinary-man" class="btn btn-outline-primary" prompt="Newer"><p>Ordinary Men: Reserve Police Battalion 101 and the Final Solution by Christopher Browning</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The decorator pattern and binary sizes'; this.page.url = 'https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern'; this.page.identifier = '/blog/2023/03/08/binary-sizes-and-decorator-pattern'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
