<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Binary size and exceptions" /><meta property="og:locale" content="en_US" /><meta name="description" content="In this series of articles about binary sizes, we already talked about the default keyword and said that the default keyword will make a special function noexcept, whenever it can. What is noexcept? The noexcept specifier specifies whether a function could throw an exception.. If a function has the noexcept or noexcept(expression == true) specifier, then it cannot throw an exception. If it still throws either explicitly or through another function it calls then the program will call std::terminate immediately. Do unthrown exceptions have a cost? When we learn about exceptions, we are often taught about the table below. We learn about the significant cost of CPU operations of throwing and catching C++ exceptions. As you can see, the costs are quite high, even compared to reading from the main RAM, not to mention reading from the cache or calling even a virtual function. Still, we can often pay this price for the abstraction of exceptions, because we don’t have that speed pressure or because other parts of the program are much slower and the relative slowness of exceptions is negligible. Or we simply consider that when an exception is thrown then something has already gone wrong and the speed penalty is acceptable. We are often told that exceptions are zero-cost when they are not thrown. That’s not completely true. The CPU cost is not the only cost. Your binary will grow if you use exceptions. Obviously, that has nothing to do with the number of actual exceptions thrown and caught. Handling exceptions require quite some overhead and the level of available details can be overwhelming. If we want to simplify it as much as possible, we can say that the compiler needs to store in the binary what kind of exceptions can be thrown by the different parts of the code and how they should be handled. The exact implementation details are out of our scope. If a piece of code cannot throw exceptions at all, then no such information has to be stored. At least that’s the theory, now let’s see how much this is true in practice. Let’s turn exceptions completely off Let’s start by completely prohibiting exceptions in our code. If we compile, with the flag -fno-exceptions, we can tell the compiler not to allow exceptions at all. This does not only mean that exception handling will not happen and the program will terminate in case of an exception, but it also means that you are not allowed to write any exception handling code. At the same time, you are allowed to use external code that throws, but your program will terminate in case of an error is thrown. If you want to test it, call the at(size_t) method on a vector. It’s among the few methods in the standard library that throws. at(size_t) does bounds checking and throws an instance of std::out_of_range exception in case you try to access something beyond the limits of a container. A class with default or empty special functions Let’s see what happens if turn exceptions off for some of the code, that we wrote during the last few weeks. First, I turned exceptions of a simple piece of code where we tested the binary sizes of classes with defaulted special functions. Version Binary size default special functions with exceptions -O0 116,302 default special functions without exceptions -O0 116,302 default special functions with exceptions -O3 116,270 default special functions without exceptions -O3 116,270 default special functions with exceptions -Os 116,270 default special functions without exceptions -Os 116,270 As you can see, we didn’t gain anything at all. When we only had a class with its defaulted special functions, removing the support for exceptions didn’t change a thing. As I wrote earlier, the default implementation of a special function is not simply about generating empty (or the simplest) bodies for special functions. It also adds noexcept where it is possible. In our case, it’s certainly possible. With that in mind, let’s run our experiment with a similarly simple piece of code. In this case, the member functions are not defaulted, but they have an empty implementation and they are not noexcept. Version Binary size empty special functions with exceptions -O0 33,983 empty special functions without exceptions -O0 33,823 empty special functions with exceptions -O3 16,879 empty special functions without exceptions -O3 16,879 empty special functions with exceptions -Os 16,879 empty special functions without exceptions -Os 16,879 In this case, -fno-exceptions helped a bit, but only without optimization. With optimization turned on, we gained nothing as the compiler is smart enough on its own without hints. But it cannot always deduce all this kind of information. In order to demonstrate that, we need a more complex example. The decorator pattern Let’s have a look at the decorator pattern that we discussed recently. Now we see a difference with all the different optimization levels that we tried. Version Binary size modern decorator pattern with exceptions -O0 76,481 modern decorator pattern without exceptions -O0 58,881 modern decorator pattern with exceptions -O3 35,729 modern decorator pattern without exceptions -O3 35,457 modern decorator pattern with exceptions -Os 36,257 modern decorator pattern without exceptions -Os 36,193 We see a difference, but it’s not significant, apart from the -O0 optimization level. If we examine the classic implementation of the decorator pattern, the difference is even smaller. In fact, it completely disappears if we compile with -O3. The observer pattern As we haven’t seen any significant differences, let’s continue and try the observer pattern. Once again, we see some differences for the classic implementation. Version Binary size classic observer pattern with exceptions -O0 86,081 classic observer pattern without exceptions -O0 84,769 classic observer pattern with exceptions -O3 36,385 classic observer pattern without exceptions -O3 36,225 classic observer pattern with exceptions -Os 37,569 classic observer pattern without exceptions -Os 37,265 In this case, the difference persists both with the modern and the classic implementation! Version Binary size modern observer pattern with exceptions -O0 84,689 modern observer pattern without exceptions -O0 83,345 modern observer pattern with exceptions -O3 35,137 modern observer pattern without exceptions -O3 34,977 modern observer pattern with exceptions -Os 36,305 modern observer pattern without exceptions -Os 36,017 The difference is not great, but it is there. Let’s have a look at the assembly to see if we can spot something interesting. As a reminder, if you compile using clang with the -S flag you can get the assembly code. As we’ve seen above, when you compile without -fno-exceptions you get a slightly bigger assembly. I’m not going to list all the changes, I’d suggest that you try it for yourself if you are interested. Here are some excerpts that you can only find in the version with exceptions. Lfunc_begin0: .cfi_startproc .cfi_personality 155, ___gxx_personality_v0 .cfi_lsda 16, Lexception0 // ... Lfunc_begin0: .cfi_startproc .cfi_personality 155, ___gxx_personality_v0 .cfi_lsda 16, Lexception0 ; %bb.0: stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill stp x29, x30, [sp, #16] ; 16-byte Folded Spill add x29, sp, #16 sub sp, sp, #528 .cfi_def_cfa w29, 16 .cfi_offset w30, -8 .cfi_offset w29, -16 .cfi_offset w19, -24 .cfi_offset w20, -32 Lloh0: adrp x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGE Lloh1: add x9, x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGEOFF Lloh2: adrp x8, __ZZ4mainEN3$_08__invokeERK6PersonNS0_11StateChangeE@PAGE // few hundred lines LBB2_33: ldur x0, [x29, #-128] bl __ZdlPv mov w0, #0 add sp, sp, #528 ldp x29, x30, [sp, #16] ; 16-byte Folded Reload ldp x20, x19, [sp], #32 ; 16-byte Folded Reload ret // another lengthy section Lfunc_end0: .cfi_endproc .section __TEXT,__gcc_except_tab .p2align 2 GCC_except_table2: Lexception0: .byte 255 ; @LPStart Encoding = omit .byte 255 ; @TType Encoding = omit .byte 1 ; Call site Encoding = uleb128 .uleb128 Lcst_end0-Lcst_begin0 Lcst_begin0: .uleb128 Ltmp0-Lfunc_begin0 ; &gt;&gt; Call Site 1 &lt;&lt; .uleb128 Ltmp5-Ltmp0 ; Call between Ltmp0 and Ltmp5 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp6-Lfunc_begin0 ; &gt;&gt; Call Site 2 &lt;&lt; .uleb128 Ltmp7-Ltmp6 ; Call between Ltmp6 and Ltmp7 .uleb128 Ltmp8-Lfunc_begin0 ; jumps to Ltmp8 .byte 0 ; On action: cleanup .uleb128 Ltmp9-Lfunc_begin0 ; &gt;&gt; Call Site 3 &lt;&lt; .uleb128 Ltmp10-Ltmp9 ; Call between Ltmp9 and Ltmp10 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp11-Lfunc_begin0 ; &gt;&gt; Call Site 4 &lt;&lt; .uleb128 Ltmp12-Ltmp11 ; Call between Ltmp11 and Ltmp12 .uleb128 Ltmp13-Lfunc_begin0 ; jumps to Ltmp13 .byte 0 ; On action: cleanup .uleb128 Ltmp14-Lfunc_begin0 ; &gt;&gt; Call Site 5 &lt;&lt; .uleb128 Ltmp15-Ltmp14 ; Call between Ltmp14 and Ltmp15 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp16-Lfunc_begin0 ; &gt;&gt; Call Site 6 &lt;&lt; .uleb128 Ltmp17-Ltmp16 ; Call between Ltmp16 and Ltmp17 .uleb128 Ltmp18-Lfunc_begin0 ; jumps to Ltmp18 .byte 0 ; On action: cleanup .uleb128 Ltmp19-Lfunc_begin0 ; &gt;&gt; Call Site 7 &lt;&lt; .uleb128 Ltmp20-Ltmp19 ; Call between Ltmp19 and Ltmp20 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp20-Lfunc_begin0 ; &gt;&gt; Call Site 8 &lt;&lt; .uleb128 Lfunc_end0-Ltmp20 ; Call between Ltmp20 and Lfunc_end0 .byte 0 ; has no landing pad .byte 0 ; On action: cleanup Lcst_end0: .p2align 2 Even if we don’t understand every bit of information, we can see except or exception appearing at several places in the code. We see here parts of the exception tables. Or at least make noexcept whatever we can Now that we’ve seen how -fno-exceptions affect our binary, let’s see what happens when you cannot turn exceptions off, but you still want to reduce the toll of exceptions, let’s use the noexcept specifier. Let’s work with the modern observer. As a first step, I took all the classes and I added noexcept to all the user-provided constructors. Version Binary size modern observer pattern -O0 84,689 modern observer pattern noexcept constructors -O0 83,345 modern observer pattern -O3 35,137 modern observer pattern noexcept constructors -O3 34,977 modern observer pattern -Os 36,305 modern observer pattern noexcept constructors -Os 36,017 So as you can see nothing changed at all. Then I started to add everywhere. I knew it can be harmful in production code, but I wanted to see if I can shave off the difference between the versions built with -fno-exceptions and without it by using noexcept extensively. Version Binary size modern observer pattern -O0 84,689 modern observer pattern noexcept everywhere -O0 84,785 modern observer pattern -O3 35,137 modern observer pattern noexcept everywhere -O3 35,425 modern observer pattern -Os 36,305 modern observer pattern noexcept everywhere -Os 36,577 To my plain horror, the binary size became bigger than it was without any noexcept! I kept quite some time trying to figure out what happened. For some time, I thought that I messed up the numbers or my script. But no, the numbers are right, the script does its job. When I looked into the assembly code, I found that from main.s, all exception-related code disappeared, but person.h became much bigger. By much I mean that it grew from 23KB to 29KB. When I looked it up, I found such exception tables: 1 2 3 4 5 Lexception0: .byte 255 ; @LPStart Encoding = omit .byte 155 ; @TType Encoding = indirect pcrel sdata4 .uleb128 Lttbase0-Lttbaseref0 // ... it&#39;s much longer After quite some googling, I found an RFC on llvm.org. It turns out that indeed, the binary should decrease and it does on GCC. But there is a bug on llvm and the compiler emits code for stack unwinding and exception handling, whereas it could and should just terminate. This doesn’t mean that noexcept will always make your binary bigger on clang, it means that you might not get the benefits you expect and you should measure. Conclusion Today we discussed exceptions and how they affect your binary. Even if exceptions are often considered zero-cost when they are not thrown, it’s not true. There is no free lunch in life, and in this case, you have to pay for a bigger binary. If you don’t use exceptions at all and you want to get rid of the overhead, you should tell the compiler so. If you don’t use exceptions at all, you can turn them off, if you just want to communicate that some functions cannot throw, you should use noexcept. If you worry more about the binary size than what you communicate to the readers of your code, don’t forget to measure, because compilers are not perfect and they might not do what you expect them to do. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="In this series of articles about binary sizes, we already talked about the default keyword and said that the default keyword will make a special function noexcept, whenever it can. What is noexcept? The noexcept specifier specifies whether a function could throw an exception.. If a function has the noexcept or noexcept(expression == true) specifier, then it cannot throw an exception. If it still throws either explicitly or through another function it calls then the program will call std::terminate immediately. Do unthrown exceptions have a cost? When we learn about exceptions, we are often taught about the table below. We learn about the significant cost of CPU operations of throwing and catching C++ exceptions. As you can see, the costs are quite high, even compared to reading from the main RAM, not to mention reading from the cache or calling even a virtual function. Still, we can often pay this price for the abstraction of exceptions, because we don’t have that speed pressure or because other parts of the program are much slower and the relative slowness of exceptions is negligible. Or we simply consider that when an exception is thrown then something has already gone wrong and the speed penalty is acceptable. We are often told that exceptions are zero-cost when they are not thrown. That’s not completely true. The CPU cost is not the only cost. Your binary will grow if you use exceptions. Obviously, that has nothing to do with the number of actual exceptions thrown and caught. Handling exceptions require quite some overhead and the level of available details can be overwhelming. If we want to simplify it as much as possible, we can say that the compiler needs to store in the binary what kind of exceptions can be thrown by the different parts of the code and how they should be handled. The exact implementation details are out of our scope. If a piece of code cannot throw exceptions at all, then no such information has to be stored. At least that’s the theory, now let’s see how much this is true in practice. Let’s turn exceptions completely off Let’s start by completely prohibiting exceptions in our code. If we compile, with the flag -fno-exceptions, we can tell the compiler not to allow exceptions at all. This does not only mean that exception handling will not happen and the program will terminate in case of an exception, but it also means that you are not allowed to write any exception handling code. At the same time, you are allowed to use external code that throws, but your program will terminate in case of an error is thrown. If you want to test it, call the at(size_t) method on a vector. It’s among the few methods in the standard library that throws. at(size_t) does bounds checking and throws an instance of std::out_of_range exception in case you try to access something beyond the limits of a container. A class with default or empty special functions Let’s see what happens if turn exceptions off for some of the code, that we wrote during the last few weeks. First, I turned exceptions of a simple piece of code where we tested the binary sizes of classes with defaulted special functions. Version Binary size default special functions with exceptions -O0 116,302 default special functions without exceptions -O0 116,302 default special functions with exceptions -O3 116,270 default special functions without exceptions -O3 116,270 default special functions with exceptions -Os 116,270 default special functions without exceptions -Os 116,270 As you can see, we didn’t gain anything at all. When we only had a class with its defaulted special functions, removing the support for exceptions didn’t change a thing. As I wrote earlier, the default implementation of a special function is not simply about generating empty (or the simplest) bodies for special functions. It also adds noexcept where it is possible. In our case, it’s certainly possible. With that in mind, let’s run our experiment with a similarly simple piece of code. In this case, the member functions are not defaulted, but they have an empty implementation and they are not noexcept. Version Binary size empty special functions with exceptions -O0 33,983 empty special functions without exceptions -O0 33,823 empty special functions with exceptions -O3 16,879 empty special functions without exceptions -O3 16,879 empty special functions with exceptions -Os 16,879 empty special functions without exceptions -Os 16,879 In this case, -fno-exceptions helped a bit, but only without optimization. With optimization turned on, we gained nothing as the compiler is smart enough on its own without hints. But it cannot always deduce all this kind of information. In order to demonstrate that, we need a more complex example. The decorator pattern Let’s have a look at the decorator pattern that we discussed recently. Now we see a difference with all the different optimization levels that we tried. Version Binary size modern decorator pattern with exceptions -O0 76,481 modern decorator pattern without exceptions -O0 58,881 modern decorator pattern with exceptions -O3 35,729 modern decorator pattern without exceptions -O3 35,457 modern decorator pattern with exceptions -Os 36,257 modern decorator pattern without exceptions -Os 36,193 We see a difference, but it’s not significant, apart from the -O0 optimization level. If we examine the classic implementation of the decorator pattern, the difference is even smaller. In fact, it completely disappears if we compile with -O3. The observer pattern As we haven’t seen any significant differences, let’s continue and try the observer pattern. Once again, we see some differences for the classic implementation. Version Binary size classic observer pattern with exceptions -O0 86,081 classic observer pattern without exceptions -O0 84,769 classic observer pattern with exceptions -O3 36,385 classic observer pattern without exceptions -O3 36,225 classic observer pattern with exceptions -Os 37,569 classic observer pattern without exceptions -Os 37,265 In this case, the difference persists both with the modern and the classic implementation! Version Binary size modern observer pattern with exceptions -O0 84,689 modern observer pattern without exceptions -O0 83,345 modern observer pattern with exceptions -O3 35,137 modern observer pattern without exceptions -O3 34,977 modern observer pattern with exceptions -Os 36,305 modern observer pattern without exceptions -Os 36,017 The difference is not great, but it is there. Let’s have a look at the assembly to see if we can spot something interesting. As a reminder, if you compile using clang with the -S flag you can get the assembly code. As we’ve seen above, when you compile without -fno-exceptions you get a slightly bigger assembly. I’m not going to list all the changes, I’d suggest that you try it for yourself if you are interested. Here are some excerpts that you can only find in the version with exceptions. Lfunc_begin0: .cfi_startproc .cfi_personality 155, ___gxx_personality_v0 .cfi_lsda 16, Lexception0 // ... Lfunc_begin0: .cfi_startproc .cfi_personality 155, ___gxx_personality_v0 .cfi_lsda 16, Lexception0 ; %bb.0: stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill stp x29, x30, [sp, #16] ; 16-byte Folded Spill add x29, sp, #16 sub sp, sp, #528 .cfi_def_cfa w29, 16 .cfi_offset w30, -8 .cfi_offset w29, -16 .cfi_offset w19, -24 .cfi_offset w20, -32 Lloh0: adrp x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGE Lloh1: add x9, x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGEOFF Lloh2: adrp x8, __ZZ4mainEN3$_08__invokeERK6PersonNS0_11StateChangeE@PAGE // few hundred lines LBB2_33: ldur x0, [x29, #-128] bl __ZdlPv mov w0, #0 add sp, sp, #528 ldp x29, x30, [sp, #16] ; 16-byte Folded Reload ldp x20, x19, [sp], #32 ; 16-byte Folded Reload ret // another lengthy section Lfunc_end0: .cfi_endproc .section __TEXT,__gcc_except_tab .p2align 2 GCC_except_table2: Lexception0: .byte 255 ; @LPStart Encoding = omit .byte 255 ; @TType Encoding = omit .byte 1 ; Call site Encoding = uleb128 .uleb128 Lcst_end0-Lcst_begin0 Lcst_begin0: .uleb128 Ltmp0-Lfunc_begin0 ; &gt;&gt; Call Site 1 &lt;&lt; .uleb128 Ltmp5-Ltmp0 ; Call between Ltmp0 and Ltmp5 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp6-Lfunc_begin0 ; &gt;&gt; Call Site 2 &lt;&lt; .uleb128 Ltmp7-Ltmp6 ; Call between Ltmp6 and Ltmp7 .uleb128 Ltmp8-Lfunc_begin0 ; jumps to Ltmp8 .byte 0 ; On action: cleanup .uleb128 Ltmp9-Lfunc_begin0 ; &gt;&gt; Call Site 3 &lt;&lt; .uleb128 Ltmp10-Ltmp9 ; Call between Ltmp9 and Ltmp10 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp11-Lfunc_begin0 ; &gt;&gt; Call Site 4 &lt;&lt; .uleb128 Ltmp12-Ltmp11 ; Call between Ltmp11 and Ltmp12 .uleb128 Ltmp13-Lfunc_begin0 ; jumps to Ltmp13 .byte 0 ; On action: cleanup .uleb128 Ltmp14-Lfunc_begin0 ; &gt;&gt; Call Site 5 &lt;&lt; .uleb128 Ltmp15-Ltmp14 ; Call between Ltmp14 and Ltmp15 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp16-Lfunc_begin0 ; &gt;&gt; Call Site 6 &lt;&lt; .uleb128 Ltmp17-Ltmp16 ; Call between Ltmp16 and Ltmp17 .uleb128 Ltmp18-Lfunc_begin0 ; jumps to Ltmp18 .byte 0 ; On action: cleanup .uleb128 Ltmp19-Lfunc_begin0 ; &gt;&gt; Call Site 7 &lt;&lt; .uleb128 Ltmp20-Ltmp19 ; Call between Ltmp19 and Ltmp20 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp20-Lfunc_begin0 ; &gt;&gt; Call Site 8 &lt;&lt; .uleb128 Lfunc_end0-Ltmp20 ; Call between Ltmp20 and Lfunc_end0 .byte 0 ; has no landing pad .byte 0 ; On action: cleanup Lcst_end0: .p2align 2 Even if we don’t understand every bit of information, we can see except or exception appearing at several places in the code. We see here parts of the exception tables. Or at least make noexcept whatever we can Now that we’ve seen how -fno-exceptions affect our binary, let’s see what happens when you cannot turn exceptions off, but you still want to reduce the toll of exceptions, let’s use the noexcept specifier. Let’s work with the modern observer. As a first step, I took all the classes and I added noexcept to all the user-provided constructors. Version Binary size modern observer pattern -O0 84,689 modern observer pattern noexcept constructors -O0 83,345 modern observer pattern -O3 35,137 modern observer pattern noexcept constructors -O3 34,977 modern observer pattern -Os 36,305 modern observer pattern noexcept constructors -Os 36,017 So as you can see nothing changed at all. Then I started to add everywhere. I knew it can be harmful in production code, but I wanted to see if I can shave off the difference between the versions built with -fno-exceptions and without it by using noexcept extensively. Version Binary size modern observer pattern -O0 84,689 modern observer pattern noexcept everywhere -O0 84,785 modern observer pattern -O3 35,137 modern observer pattern noexcept everywhere -O3 35,425 modern observer pattern -Os 36,305 modern observer pattern noexcept everywhere -Os 36,577 To my plain horror, the binary size became bigger than it was without any noexcept! I kept quite some time trying to figure out what happened. For some time, I thought that I messed up the numbers or my script. But no, the numbers are right, the script does its job. When I looked into the assembly code, I found that from main.s, all exception-related code disappeared, but person.h became much bigger. By much I mean that it grew from 23KB to 29KB. When I looked it up, I found such exception tables: 1 2 3 4 5 Lexception0: .byte 255 ; @LPStart Encoding = omit .byte 155 ; @TType Encoding = indirect pcrel sdata4 .uleb128 Lttbase0-Lttbaseref0 // ... it&#39;s much longer After quite some googling, I found an RFC on llvm.org. It turns out that indeed, the binary should decrease and it does on GCC. But there is a bug on llvm and the compiler emits code for stack unwinding and exception handling, whereas it could and should just terminate. This doesn’t mean that noexcept will always make your binary bigger on clang, it means that you might not get the benefits you expect and you should measure. Conclusion Today we discussed exceptions and how they affect your binary. Even if exceptions are often considered zero-cost when they are not thrown, it’s not true. There is no free lunch in life, and in this case, you have to pay for a bigger binary. If you don’t use exceptions at all and you want to get rid of the overhead, you should tell the compiler so. If you don’t use exceptions at all, you can turn them off, if you just want to communicate that some functions cannot throw, you should use noexcept. If you worry more about the binary size than what you communicate to the readers of your code, don’t forget to measure, because compilers are not perfect and they might not do what you expect them to do. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-03-29T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Binary size and exceptions" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-03-29T00:00:00+02:00","datePublished":"2023-03-29T00:00:00+02:00","description":"In this series of articles about binary sizes, we already talked about the default keyword and said that the default keyword will make a special function noexcept, whenever it can. What is noexcept? The noexcept specifier specifies whether a function could throw an exception.. If a function has the noexcept or noexcept(expression == true) specifier, then it cannot throw an exception. If it still throws either explicitly or through another function it calls then the program will call std::terminate immediately. Do unthrown exceptions have a cost? When we learn about exceptions, we are often taught about the table below. We learn about the significant cost of CPU operations of throwing and catching C++ exceptions. As you can see, the costs are quite high, even compared to reading from the main RAM, not to mention reading from the cache or calling even a virtual function. Still, we can often pay this price for the abstraction of exceptions, because we don’t have that speed pressure or because other parts of the program are much slower and the relative slowness of exceptions is negligible. Or we simply consider that when an exception is thrown then something has already gone wrong and the speed penalty is acceptable. We are often told that exceptions are zero-cost when they are not thrown. That’s not completely true. The CPU cost is not the only cost. Your binary will grow if you use exceptions. Obviously, that has nothing to do with the number of actual exceptions thrown and caught. Handling exceptions require quite some overhead and the level of available details can be overwhelming. If we want to simplify it as much as possible, we can say that the compiler needs to store in the binary what kind of exceptions can be thrown by the different parts of the code and how they should be handled. The exact implementation details are out of our scope. If a piece of code cannot throw exceptions at all, then no such information has to be stored. At least that’s the theory, now let’s see how much this is true in practice. Let’s turn exceptions completely off Let’s start by completely prohibiting exceptions in our code. If we compile, with the flag -fno-exceptions, we can tell the compiler not to allow exceptions at all. This does not only mean that exception handling will not happen and the program will terminate in case of an exception, but it also means that you are not allowed to write any exception handling code. At the same time, you are allowed to use external code that throws, but your program will terminate in case of an error is thrown. If you want to test it, call the at(size_t) method on a vector. It’s among the few methods in the standard library that throws. at(size_t) does bounds checking and throws an instance of std::out_of_range exception in case you try to access something beyond the limits of a container. A class with default or empty special functions Let’s see what happens if turn exceptions off for some of the code, that we wrote during the last few weeks. First, I turned exceptions of a simple piece of code where we tested the binary sizes of classes with defaulted special functions. Version Binary size default special functions with exceptions -O0 116,302 default special functions without exceptions -O0 116,302 default special functions with exceptions -O3 116,270 default special functions without exceptions -O3 116,270 default special functions with exceptions -Os 116,270 default special functions without exceptions -Os 116,270 As you can see, we didn’t gain anything at all. When we only had a class with its defaulted special functions, removing the support for exceptions didn’t change a thing. As I wrote earlier, the default implementation of a special function is not simply about generating empty (or the simplest) bodies for special functions. It also adds noexcept where it is possible. In our case, it’s certainly possible. With that in mind, let’s run our experiment with a similarly simple piece of code. In this case, the member functions are not defaulted, but they have an empty implementation and they are not noexcept. Version Binary size empty special functions with exceptions -O0 33,983 empty special functions without exceptions -O0 33,823 empty special functions with exceptions -O3 16,879 empty special functions without exceptions -O3 16,879 empty special functions with exceptions -Os 16,879 empty special functions without exceptions -Os 16,879 In this case, -fno-exceptions helped a bit, but only without optimization. With optimization turned on, we gained nothing as the compiler is smart enough on its own without hints. But it cannot always deduce all this kind of information. In order to demonstrate that, we need a more complex example. The decorator pattern Let’s have a look at the decorator pattern that we discussed recently. Now we see a difference with all the different optimization levels that we tried. Version Binary size modern decorator pattern with exceptions -O0 76,481 modern decorator pattern without exceptions -O0 58,881 modern decorator pattern with exceptions -O3 35,729 modern decorator pattern without exceptions -O3 35,457 modern decorator pattern with exceptions -Os 36,257 modern decorator pattern without exceptions -Os 36,193 We see a difference, but it’s not significant, apart from the -O0 optimization level. If we examine the classic implementation of the decorator pattern, the difference is even smaller. In fact, it completely disappears if we compile with -O3. The observer pattern As we haven’t seen any significant differences, let’s continue and try the observer pattern. Once again, we see some differences for the classic implementation. Version Binary size classic observer pattern with exceptions -O0 86,081 classic observer pattern without exceptions -O0 84,769 classic observer pattern with exceptions -O3 36,385 classic observer pattern without exceptions -O3 36,225 classic observer pattern with exceptions -Os 37,569 classic observer pattern without exceptions -Os 37,265 In this case, the difference persists both with the modern and the classic implementation! Version Binary size modern observer pattern with exceptions -O0 84,689 modern observer pattern without exceptions -O0 83,345 modern observer pattern with exceptions -O3 35,137 modern observer pattern without exceptions -O3 34,977 modern observer pattern with exceptions -Os 36,305 modern observer pattern without exceptions -Os 36,017 The difference is not great, but it is there. Let’s have a look at the assembly to see if we can spot something interesting. As a reminder, if you compile using clang with the -S flag you can get the assembly code. As we’ve seen above, when you compile without -fno-exceptions you get a slightly bigger assembly. I’m not going to list all the changes, I’d suggest that you try it for yourself if you are interested. Here are some excerpts that you can only find in the version with exceptions. Lfunc_begin0: .cfi_startproc .cfi_personality 155, ___gxx_personality_v0 .cfi_lsda 16, Lexception0 // ... Lfunc_begin0: .cfi_startproc .cfi_personality 155, ___gxx_personality_v0 .cfi_lsda 16, Lexception0 ; %bb.0: stp x20, x19, [sp, #-32]! ; 16-byte Folded Spill stp x29, x30, [sp, #16] ; 16-byte Folded Spill add x29, sp, #16 sub sp, sp, #528 .cfi_def_cfa w29, 16 .cfi_offset w30, -8 .cfi_offset w29, -16 .cfi_offset w19, -24 .cfi_offset w20, -32 Lloh0: adrp x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGE Lloh1: add x9, x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGEOFF Lloh2: adrp x8, __ZZ4mainEN3$_08__invokeERK6PersonNS0_11StateChangeE@PAGE // few hundred lines LBB2_33: ldur x0, [x29, #-128] bl __ZdlPv mov w0, #0 add sp, sp, #528 ldp x29, x30, [sp, #16] ; 16-byte Folded Reload ldp x20, x19, [sp], #32 ; 16-byte Folded Reload ret // another lengthy section Lfunc_end0: .cfi_endproc .section __TEXT,__gcc_except_tab .p2align 2 GCC_except_table2: Lexception0: .byte 255 ; @LPStart Encoding = omit .byte 255 ; @TType Encoding = omit .byte 1 ; Call site Encoding = uleb128 .uleb128 Lcst_end0-Lcst_begin0 Lcst_begin0: .uleb128 Ltmp0-Lfunc_begin0 ; &gt;&gt; Call Site 1 &lt;&lt; .uleb128 Ltmp5-Ltmp0 ; Call between Ltmp0 and Ltmp5 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp6-Lfunc_begin0 ; &gt;&gt; Call Site 2 &lt;&lt; .uleb128 Ltmp7-Ltmp6 ; Call between Ltmp6 and Ltmp7 .uleb128 Ltmp8-Lfunc_begin0 ; jumps to Ltmp8 .byte 0 ; On action: cleanup .uleb128 Ltmp9-Lfunc_begin0 ; &gt;&gt; Call Site 3 &lt;&lt; .uleb128 Ltmp10-Ltmp9 ; Call between Ltmp9 and Ltmp10 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp11-Lfunc_begin0 ; &gt;&gt; Call Site 4 &lt;&lt; .uleb128 Ltmp12-Ltmp11 ; Call between Ltmp11 and Ltmp12 .uleb128 Ltmp13-Lfunc_begin0 ; jumps to Ltmp13 .byte 0 ; On action: cleanup .uleb128 Ltmp14-Lfunc_begin0 ; &gt;&gt; Call Site 5 &lt;&lt; .uleb128 Ltmp15-Ltmp14 ; Call between Ltmp14 and Ltmp15 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp16-Lfunc_begin0 ; &gt;&gt; Call Site 6 &lt;&lt; .uleb128 Ltmp17-Ltmp16 ; Call between Ltmp16 and Ltmp17 .uleb128 Ltmp18-Lfunc_begin0 ; jumps to Ltmp18 .byte 0 ; On action: cleanup .uleb128 Ltmp19-Lfunc_begin0 ; &gt;&gt; Call Site 7 &lt;&lt; .uleb128 Ltmp20-Ltmp19 ; Call between Ltmp19 and Ltmp20 .uleb128 Ltmp21-Lfunc_begin0 ; jumps to Ltmp21 .byte 0 ; On action: cleanup .uleb128 Ltmp20-Lfunc_begin0 ; &gt;&gt; Call Site 8 &lt;&lt; .uleb128 Lfunc_end0-Ltmp20 ; Call between Ltmp20 and Lfunc_end0 .byte 0 ; has no landing pad .byte 0 ; On action: cleanup Lcst_end0: .p2align 2 Even if we don’t understand every bit of information, we can see except or exception appearing at several places in the code. We see here parts of the exception tables. Or at least make noexcept whatever we can Now that we’ve seen how -fno-exceptions affect our binary, let’s see what happens when you cannot turn exceptions off, but you still want to reduce the toll of exceptions, let’s use the noexcept specifier. Let’s work with the modern observer. As a first step, I took all the classes and I added noexcept to all the user-provided constructors. Version Binary size modern observer pattern -O0 84,689 modern observer pattern noexcept constructors -O0 83,345 modern observer pattern -O3 35,137 modern observer pattern noexcept constructors -O3 34,977 modern observer pattern -Os 36,305 modern observer pattern noexcept constructors -Os 36,017 So as you can see nothing changed at all. Then I started to add everywhere. I knew it can be harmful in production code, but I wanted to see if I can shave off the difference between the versions built with -fno-exceptions and without it by using noexcept extensively. Version Binary size modern observer pattern -O0 84,689 modern observer pattern noexcept everywhere -O0 84,785 modern observer pattern -O3 35,137 modern observer pattern noexcept everywhere -O3 35,425 modern observer pattern -Os 36,305 modern observer pattern noexcept everywhere -Os 36,577 To my plain horror, the binary size became bigger than it was without any noexcept! I kept quite some time trying to figure out what happened. For some time, I thought that I messed up the numbers or my script. But no, the numbers are right, the script does its job. When I looked into the assembly code, I found that from main.s, all exception-related code disappeared, but person.h became much bigger. By much I mean that it grew from 23KB to 29KB. When I looked it up, I found such exception tables: 1 2 3 4 5 Lexception0: .byte 255 ; @LPStart Encoding = omit .byte 155 ; @TType Encoding = indirect pcrel sdata4 .uleb128 Lttbase0-Lttbaseref0 // ... it&#39;s much longer After quite some googling, I found an RFC on llvm.org. It turns out that indeed, the binary should decrease and it does on GCC. But there is a bug on llvm and the compiler emits code for stack unwinding and exception handling, whereas it could and should just terminate. This doesn’t mean that noexcept will always make your binary bigger on clang, it means that you might not get the benefits you expect and you should measure. Conclusion Today we discussed exceptions and how they affect your binary. Even if exceptions are often considered zero-cost when they are not thrown, it’s not true. There is no free lunch in life, and in this case, you have to pay for a bigger binary. If you don’t use exceptions at all and you want to get rid of the overhead, you should tell the compiler so. If you don’t use exceptions at all, you can turn them off, if you just want to communicate that some functions cannot throw, you should use noexcept. If you worry more about the binary size than what you communicate to the readers of your code, don’t forget to measure, because compilers are not perfect and they might not do what you expect them to do. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Binary size and exceptions","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions"},"url":"https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions"}</script><title>Binary size and exceptions | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/03"> 03 </a> </span> <span> <a href="/29"> 29 </a> </span> <span>Binary size and exceptions</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Binary size and exceptions</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Mar 29, 2023, 12:00 AM +0200" prep="on" > Mar 29, 2023 <i class="unloaded">2023-03-29T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2072 words">11 min</span></div></div><div class="post-content"><p>In this series of articles about binary sizes, <a href="https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes">we already talked about the <code class="language-plaintext highlighter-rouge">default</code> keyword</a> and said that the <code class="language-plaintext highlighter-rouge">default</code> keyword will make a special function <code class="language-plaintext highlighter-rouge">noexcept</code>, whenever it can.</p><h2 id="what-is-noexcept">What is <code class="language-plaintext highlighter-rouge">noexcept</code>?</h2><p><a href="https://en.cppreference.com/w/cpp/language/noexcept_spec">The <code class="language-plaintext highlighter-rouge">noexcept</code> specifier specifies whether a function could throw an exception.</a>. If a function has the <code class="language-plaintext highlighter-rouge">noexcept</code> or <code class="language-plaintext highlighter-rouge">noexcept(expression == true)</code> specifier, then it cannot throw an exception. If it still throws either explicitly or through another function it calls then the program will call <code class="language-plaintext highlighter-rouge">std::terminate</code> immediately.</p><h2 id="do-unthrown-exceptions-have-a-cost">Do unthrown exceptions have a cost?</h2><p>When we learn about exceptions, we are often taught about the table below.</p><p><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="/assets/img/cpu-costs-ignatchenko.png" alt="Operation costs in CPU cycles" title="Operation costs in CPU cycles" /></p><p>We learn about the significant cost of CPU operations of throwing and catching C++ exceptions. As you can see, the costs are quite high, even compared to reading from the main RAM, not to mention reading from the cache or calling even a <code class="language-plaintext highlighter-rouge">virtual</code> function.</p><p>Still, we can often pay this price for the abstraction of exceptions, because we don’t have that speed pressure or because other parts of the program are much slower and the relative slowness of exceptions is negligible. Or we simply consider that when an exception is thrown then something has already gone wrong and the speed penalty is acceptable.</p><p>We are often told that exceptions are zero-cost when they are not thrown.</p><p>That’s not completely true.</p><p>The CPU cost is not the only cost.</p><p>Your binary will grow if you use exceptions. Obviously, that has nothing to do with the number of actual exceptions thrown and caught.</p><p>Handling exceptions require quite some overhead and <a href="https://itanium-cxx-abi.github.io/cxx-abi/exceptions.pdf">the level of available details can be overwhelming</a>. If we want to simplify it as much as possible, we can say that the compiler needs to store in the binary what kind of exceptions can be thrown by the different parts of the code and how they should be handled. The exact implementation details are out of our scope.</p><p>If a piece of code cannot throw exceptions at all, then no such information has to be stored. At least that’s the theory, now let’s see how much this is true in practice.</p><h2 id="lets-turn-exceptions-completely-off">Let’s turn exceptions completely off</h2><p>Let’s start by completely prohibiting exceptions in our code.</p><p>If we compile, with the flag <code class="language-plaintext highlighter-rouge">-fno-exceptions</code>, we can tell the compiler not to allow exceptions at all. This does not only mean that exception handling will not happen and the program will terminate in case of an exception, but it also means that you are not allowed to write any exception handling code.</p><p>At the same time, you are allowed to use external code that throws, but your program will terminate in case of an error is thrown. If you want to test it, call the <code class="language-plaintext highlighter-rouge">at(size_t)</code> method on a <code class="language-plaintext highlighter-rouge">vector</code>. It’s among the few methods in the standard library that throws. <code class="language-plaintext highlighter-rouge">at(size_t)</code> does bounds checking and throws an instance of <code class="language-plaintext highlighter-rouge">std::out_of_range</code> exception in case you try to access something beyond the limits of a container.</p><h3 id="a-class-with-default-or-empty-special-functions">A class with default or empty special functions</h3><p>Let’s see what happens if turn exceptions off for some of the code, that we wrote during the last few weeks. First, I turned exceptions of a simple piece of code <a href="https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes">where we tested the binary sizes of classes with <code class="language-plaintext highlighter-rouge">default</code>ed special functions</a>.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>default special functions with exceptions -O0<td>116,302<tr><td>default special functions without exceptions -O0<td>116,302<tr><td>default special functions with exceptions -O3<td>116,270<tr><td>default special functions without exceptions -O3<td>116,270<tr><td>default special functions with exceptions -Os<td>116,270<tr><td>default special functions without exceptions -Os<td>116,270</table></div><p>As you can see, we didn’t gain anything at all. When we only had a class with its defaulted special functions, removing the support for exceptions didn’t change a thing. As I wrote earlier, the <code class="language-plaintext highlighter-rouge">default</code> implementation of a special function is not simply about generating empty (or the simplest) bodies for special functions. It also adds <code class="language-plaintext highlighter-rouge">noexcept</code> where it is possible. In our case, it’s certainly possible.</p><p>With that in mind, let’s run our experiment with a similarly simple piece of code. In this case, the member functions are not <code class="language-plaintext highlighter-rouge">default</code>ed, but they have an empty implementation and they are <strong><em>not</em></strong> <code class="language-plaintext highlighter-rouge">noexcept</code>.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>empty special functions with exceptions -O0<td>33,983<tr><td>empty special functions without exceptions -O0<td>33,823<tr><td>empty special functions with exceptions -O3<td>16,879<tr><td>empty special functions without exceptions -O3<td>16,879<tr><td>empty special functions with exceptions -Os<td>16,879<tr><td>empty special functions without exceptions -Os<td>16,879</table></div><p>In this case, <code class="language-plaintext highlighter-rouge">-fno-exceptions</code> helped a bit, but only without optimization. With optimization turned on, we gained nothing as the compiler is smart enough on its own without hints. But it cannot always deduce all this kind of information.</p><p>In order to demonstrate that, we need a more complex example.</p><h3 id="the-decorator-pattern">The decorator pattern</h3><p>Let’s have a look at <a href="https://www.sandordargo.com/blog/2023/03/08/binary-sizes-and-decorator-pattern">the decorator pattern that we discussed recently</a>. Now we see a difference with all the different optimization levels that we tried.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>modern decorator pattern with exceptions -O0<td>76,481<tr><td>modern decorator pattern without exceptions -O0<td>58,881<tr><td>modern decorator pattern with exceptions -O3<td>35,729<tr><td>modern decorator pattern without exceptions -O3<td>35,457<tr><td>modern decorator pattern with exceptions -Os<td>36,257<tr><td>modern decorator pattern without exceptions -Os<td>36,193</table></div><p>We see a difference, but it’s not significant, apart from the <code class="language-plaintext highlighter-rouge">-O0</code> optimization level. If we examine the classic implementation of the decorator pattern, the difference is even smaller. In fact, it completely disappears if we compile with <code class="language-plaintext highlighter-rouge">-O3</code>.</p><h3 id="the-observer-pattern">The observer pattern</h3><p>As we haven’t seen any significant differences, let’s continue and try <a href="https://www.sandordargo.com/blog/2023/03/15/binary-sizes-and-observer-pattern">the observer pattern</a>. Once again, we see <em>some</em> differences for the classic implementation.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>classic observer pattern with exceptions -O0<td>86,081<tr><td>classic observer pattern without exceptions -O0<td>84,769<tr><td>classic observer pattern with exceptions -O3<td>36,385<tr><td>classic observer pattern without exceptions -O3<td>36,225<tr><td>classic observer pattern with exceptions -Os<td>37,569<tr><td>classic observer pattern without exceptions -Os<td>37,265</table></div><p>In this case, the difference persists both with the modern and the classic implementation!</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>modern observer pattern with exceptions -O0<td>84,689<tr><td>modern observer pattern without exceptions -O0<td>83,345<tr><td>modern observer pattern with exceptions -O3<td>35,137<tr><td>modern observer pattern without exceptions -O3<td>34,977<tr><td>modern observer pattern with exceptions -Os<td>36,305<tr><td>modern observer pattern without exceptions -Os<td>36,017</table></div><p>The difference is not great, but it is there. Let’s have a look at the assembly to see if we can spot something interesting.</p><p>As a reminder, if you compile using <code class="language-plaintext highlighter-rouge">clang</code> with the <code class="language-plaintext highlighter-rouge">-S</code> flag you can get the assembly code. As we’ve seen above, when you compile without <code class="language-plaintext highlighter-rouge">-fno-exceptions</code> you get a slightly bigger assembly. I’m not going to list all the changes, I’d suggest that you try it for yourself if you are interested. Here are some excerpts that you can only find in the version with exceptions.</p><pre><code class="language-asm">Lfunc_begin0:
	.cfi_startproc
	.cfi_personality 155, ___gxx_personality_v0
	.cfi_lsda 16, Lexception0

// ...

Lfunc_begin0:
	.cfi_startproc
	.cfi_personality 155, ___gxx_personality_v0
	.cfi_lsda 16, Lexception0
; %bb.0:
	stp	x20, x19, [sp, #-32]!           ; 16-byte Folded Spill
	stp	x29, x30, [sp, #16]             ; 16-byte Folded Spill
	add	x29, sp, #16
	sub	sp, sp, #528
	.cfi_def_cfa w29, 16
	.cfi_offset w30, -8
	.cfi_offset w29, -16
	.cfi_offset w19, -24
	.cfi_offset w20, -32
Lloh0:
	adrp	x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGE
Lloh1:
	add	x9, x8, __Z15propertyChangedRK6PersonNS_11StateChangeE@PAGEOFF
Lloh2:
	adrp	x8, __ZZ4mainEN3$_08__invokeERK6PersonNS0_11StateChangeE@PAGE
 // few hundred lines
LBB2_33:
	ldur	x0, [x29, #-128]
	bl	__ZdlPv
	mov	w0, #0
	add	sp, sp, #528
	ldp	x29, x30, [sp, #16]             ; 16-byte Folded Reload
	ldp	x20, x19, [sp], #32             ; 16-byte Folded Reload
	ret


// another lengthy section
Lfunc_end0:
	.cfi_endproc
	.section	__TEXT,__gcc_except_tab
	.p2align	2
GCC_except_table2:
Lexception0:
	.byte	255                             ; @LPStart Encoding = omit
	.byte	255                             ; @TType Encoding = omit
	.byte	1                               ; Call site Encoding = uleb128
	.uleb128 Lcst_end0-Lcst_begin0
Lcst_begin0:
	.uleb128 Ltmp0-Lfunc_begin0             ; &gt;&gt; Call Site 1 &lt;&lt;
	.uleb128 Ltmp5-Ltmp0                    ;   Call between Ltmp0 and Ltmp5
	.uleb128 Ltmp21-Lfunc_begin0            ;     jumps to Ltmp21
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp6-Lfunc_begin0             ; &gt;&gt; Call Site 2 &lt;&lt;
	.uleb128 Ltmp7-Ltmp6                    ;   Call between Ltmp6 and Ltmp7
	.uleb128 Ltmp8-Lfunc_begin0             ;     jumps to Ltmp8
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp9-Lfunc_begin0             ; &gt;&gt; Call Site 3 &lt;&lt;
	.uleb128 Ltmp10-Ltmp9                   ;   Call between Ltmp9 and Ltmp10
	.uleb128 Ltmp21-Lfunc_begin0            ;     jumps to Ltmp21
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp11-Lfunc_begin0            ; &gt;&gt; Call Site 4 &lt;&lt;
	.uleb128 Ltmp12-Ltmp11                  ;   Call between Ltmp11 and Ltmp12
	.uleb128 Ltmp13-Lfunc_begin0            ;     jumps to Ltmp13
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp14-Lfunc_begin0            ; &gt;&gt; Call Site 5 &lt;&lt;
	.uleb128 Ltmp15-Ltmp14                  ;   Call between Ltmp14 and Ltmp15
	.uleb128 Ltmp21-Lfunc_begin0            ;     jumps to Ltmp21
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp16-Lfunc_begin0            ; &gt;&gt; Call Site 6 &lt;&lt;
	.uleb128 Ltmp17-Ltmp16                  ;   Call between Ltmp16 and Ltmp17
	.uleb128 Ltmp18-Lfunc_begin0            ;     jumps to Ltmp18
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp19-Lfunc_begin0            ; &gt;&gt; Call Site 7 &lt;&lt;
	.uleb128 Ltmp20-Ltmp19                  ;   Call between Ltmp19 and Ltmp20
	.uleb128 Ltmp21-Lfunc_begin0            ;     jumps to Ltmp21
	.byte	0                               ;   On action: cleanup
	.uleb128 Ltmp20-Lfunc_begin0            ; &gt;&gt; Call Site 8 &lt;&lt;
	.uleb128 Lfunc_end0-Ltmp20              ;   Call between Ltmp20 and Lfunc_end0
	.byte	0                               ;     has no landing pad
	.byte	0                               ;   On action: cleanup
Lcst_end0:
	.p2align	2
</code></pre><p>Even if we don’t understand every bit of information, we can see <em>except</em> or <em>exception</em> appearing at several places in the code. We see here parts of the exception tables.</p><h2 id="or-at-least-make-noexcept-whatever-we-can">Or at least make noexcept whatever we can</h2><p>Now that we’ve seen how <code class="language-plaintext highlighter-rouge">-fno-exceptions</code> affect our binary, let’s see what happens when you cannot turn exceptions off, but you still want to reduce the toll of exceptions, let’s use the <code class="language-plaintext highlighter-rouge">noexcept</code> specifier.</p><p>Let’s work with the modern observer. As a first step, I took all the classes and I added <code class="language-plaintext highlighter-rouge">noexcept</code> to all the user-provided constructors.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>modern observer pattern -O0<td>84,689<tr><td>modern observer pattern noexcept constructors -O0<td>83,345<tr><td>modern observer pattern -O3<td>35,137<tr><td>modern observer pattern noexcept constructors -O3<td>34,977<tr><td>modern observer pattern -Os<td>36,305<tr><td>modern observer pattern noexcept constructors -Os<td>36,017</table></div><p>So as you can see nothing changed at all. Then I started to add everywhere. I knew it can be harmful in production code, but I wanted to see if I can shave off the difference between the versions built with <code class="language-plaintext highlighter-rouge">-fno-exceptions</code> and without it by using <code class="language-plaintext highlighter-rouge">noexcept</code> extensively.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>modern observer pattern -O0<td>84,689<tr><td>modern observer pattern noexcept everywhere -O0<td>84,785<tr><td>modern observer pattern -O3<td>35,137<tr><td>modern observer pattern noexcept everywhere -O3<td>35,425<tr><td>modern observer pattern -Os<td>36,305<tr><td>modern observer pattern noexcept everywhere -Os<td>36,577</table></div><p>To my plain horror, the binary size became bigger than it was without any <code class="language-plaintext highlighter-rouge">noexcept</code>!</p><p>I kept quite some time trying to figure out what happened. For some time, I thought that I messed up the numbers or my script. But no, the numbers are right, the script does its job.</p><p>When I looked into the assembly code, I found that from <code class="language-plaintext highlighter-rouge">main.s</code>, all exception-related code disappeared, but <code class="language-plaintext highlighter-rouge">person.h</code> became much bigger. By much I mean that it grew from 23KB to 29KB.</p><p>When I looked it up, I found such exception tables:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre>Lexception0:
	.byte	255                             ; @LPStart Encoding = omit
	.byte	155                             ; @TType Encoding = indirect pcrel sdata4
	.uleb128 Lttbase0-Lttbaseref0
// ... it's much longer
</pre></table></code></div></div><p>After quite some googling, I found <a href="https://discourse.llvm.org/t/rfc-add-call-unwindabort-to-llvm-ir/62543">an RFC on llvm.org</a>. It turns out that indeed, the binary should decrease and it does on GCC. But there is a bug on llvm and the compiler emits code for stack unwinding and exception handling, whereas it could and should just terminate.</p><p>This doesn’t mean that <code class="language-plaintext highlighter-rouge">noexcept</code> will always make your binary bigger on <code class="language-plaintext highlighter-rouge">clang</code>, it means that you might not get the benefits you expect and you should measure.</p><h2 id="conclusion">Conclusion</h2><p>Today we discussed exceptions and how they affect your binary. Even if exceptions are often considered zero-cost when they are not thrown, it’s not true. There is no free lunch in life, and in this case, you have to pay for a bigger binary.</p><p>If you don’t use exceptions at all and you want to get rid of the overhead, you should tell the compiler so. If you don’t use exceptions at all, you can turn them off, if you just want to communicate that some functions cannot throw, you should use <code class="language-plaintext highlighter-rouge">noexcept</code>.</p><p>If you worry more about the binary size than what you communicate to the readers of your code, don’t forget to measure, because compilers are not perfect and they might not do what you expect them to do.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/noexcept/" class="post-tag no-text-decoration" >noexcept</a> <a href="/tags/exceptions/" class="post-tag no-text-decoration" >exceptions</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Binary size and exceptions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Binary size and exceptions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Binary size and exceptions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Binary size and exceptions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/05/31/cpp23-noexcept-related-changes"><div class="card-body"> <span class="timeago small" > May 31, 2023 <i class="unloaded">2023-05-31T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: two additional noexcept functions</h3><div class="text-muted small"><p> If my math is correct, there are 125 changes / fixes / new features in C++23 and we are progressively covering them on this blog. I try to go from topic to topic. There are some topics with many sm...</p></div></div></a></div><div class="card"> <a href="/blog/2024/06/26/member-ordering-and-binary-size"><div class="card-body"> <span class="timeago small" > Jun 26, 2024 <i class="unloaded">2024-06-26T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Member ordering and binary sizes</h3><div class="text-muted small"><p> While I have been preparing my presentation for C++ On Sea, I realized that something is missing from How to keep your binaries small. The importance of member ordering! I remember learning at a p...</p></div></div></a></div><div class="card"> <a href="/blog/2024/07/31/rule-of-5-once-again"><div class="card-body"> <span class="timeago small" > Jul 31, 2024 <i class="unloaded">2024-07-31T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Once more about the rule of 5</h3><div class="text-muted small"><p> Arne Mertz talked about misused guidelines at C++OnSea. Among those, there was the rule of 5. Which made me think about a pattern I’ve seen. Let’s first repeat what the rule of 5 says. The Rule...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/03/22/reasons-behind-compromises" class="btn btn-outline-primary" prompt="Older"><p>Can we find a compromise?</p></a> <a href="/blog/2023/04/05/binary-size-and-templates" class="btn btn-outline-primary" prompt="Newer"><p>Binary sizes and passing functions to functions</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Binary size and exceptions'; this.page.url = 'https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions'; this.page.identifier = '/blog/2023/03/29/binary-size-and-exceptions'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
