<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Virtual functions and binary sizes" /><meta property="og:locale" content="en_US" /><meta name="description" content="In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary. Our conclusion was that if we could, we should follow the rule of 0. Not only because of simplicity for the reader but also for the compiler. If that’s not possible, we should not declare destructors virtual in vain. And if it’s possible, we should =default non-virtual destructors in the header both for readability and for binary sizes. On the other hand, if we must have a non-virtual destructor, we should clearly think about implementing (preferably with =default) the destructor in the .cpp file, in other words, out-of-line. While you might find it strange in terms of readability, it produced a smaller binary. It’s still worth noting that in most circumstances, a class with a virtual destructor contributes to a larger binary file. But does it matter how many functions are virtual? Given the same amount of methods in a class, is there a difference in terms of binary size whether one or all of them are virtual? That’s the question we are going to discuss in this post. What does the virtual keyword do? When any of a class-member function is declared with the virtual keyword, it means that the compiler cannot know during compile-time which implementation of the virtual function will be called. How could it resolve during runtime which function is to be called? As it’s explained on Johnny’s Software Lab, the way to do it is not standardized. Yet, most compilers do it in a similar way. For each class that has at least one virtual method, the compiler creates a virtual table. It’s usually just referred to as a vtable. The vtable of each class contains a pointer to each of their virtual functions. A virtual table might not contain pointers only to the same class. If a derived class doesn’t override a method of a base class, then it will point to that base class implementation. When an object is created at runtime, there is also a virtual pointer (vpointer) created pointing to the right virtual table. So there is one vpointer for each object created at run-time, but only one vtable per type which is created per compile-time. I think we can rightly expect that therefore a virtual method - due to the vtable - results in an increased binary size and we could also expect that any additional virtual method will add to the size of the binary as the vtable grows, but only a little bit. Validate our hypothesis Now let’s create two main.cpp files. In the first one, we are going to have two classes with a virtual destructor and with 3 members each having a non-virtual accessor. In the second example, the same class will have those accessors turned into virtual ones. I know it’s not a particularly elaborate example, but it’s a start. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // main-single-virtual.cpp #include &lt;array&gt; class SingleVirtual { public: SingleVirtual() = default; SingleVirtual(int a, int b, int c) : m_a(a), m_b(b), m_c(c) {} virtual ~SingleVirtual() = default; int getA() const { return m_a; } int getB() const { return m_b; } int getC() const { return m_c; } private: int m_a = 0; int m_b = 0; int m_c = 0; }; std::array&lt;SingleVirtual, 10&#39;000&gt; a; int main() { } // main-many-virtuals.cpp #include &lt;array&gt; class ManyVirtuals { public: ManyVirtuals() = default; ManyVirtuals(int a, int b, int c) : m_a(a), m_b(b), m_c(c) {} virtual ~ManyVirtuals() = default; virtual int getA() const { return m_a; } virtual int getB() const { return m_b; } virtual int getC() const { return m_c; } private: int m_a = 0; int m_b = 0; int m_c = 0; }; std::array&lt;ManyVirtuals, 10&#39;000&gt; a; int main() { } Depending on the optimization level, the version where only the destructor is virtual was compiled into a binary with the size of 281,488/281,520. The fully virtual version had slightly bigger binaries, 281,615/281,647. We can see that the difference is small. In the previous articles, I used an array of 10,000 objects so that we don’t have to look into tiny differences. But in this case, it’s worth having a look at the exact size of the difference. It’s less than 200 bytes per 10,000 objects. To be more precise, the difference is 127 bytes, way less than one byte per object. It cannot have anything to do with the number of objects. It is only about the size of the vtable. It’s almost negligible. First, I ran both examples with a much smaller array of only 10 objects. The difference between the two versions was still exactly 127 bytes. As we start to remove the virtual keywords from the accessors one by one, the difference also shrinks. First by 48 byes to 79 bytes, then by another 32/48 bytes (depending on the optimization level) to 31-47 bytes. And finally, by devirtualizing the third accessor, the difference shrinks by another 48 bytes depending. Another observation that we can make, is that at the end, ManyVirtuals ended up with a smaller binary. That’s because its name is shorter. But that only mattered when the optimization level was -O0 What can we learn from this? It seems that the size of a vtable entry is about 48 bytes, at least on Apple Clang 15. It might not seem a big deal at first, but if we have 10 classes with 3 virtual methods each that’s already more than 1KB. But these numbers can be much higher, especially if we consider a virtual method in a class template. That can quickly explode if we don’t pay attention. At the same time, we can only rest assured that the length of class/function names is not a problem anymore as it was in the past - given that we turn on compiler optimizations. If we have a look at the assembly code after an unoptimized build (so that it remains somewhat readable), we can see things that seem like a list, probably the virtual table: // SingleVirtual.s .section __DATA,__const .globl __ZTV13SingleVirtual ; @_ZTV13SingleVirtual .weak_def_can_be_hidden __ZTV13SingleVirtual .p2align 3 __ZTV13SingleVirtual: .quad 0 .quad __ZTI13SingleVirtual .quad __ZN13SingleVirtualD1Ev .quad __ZN13SingleVirtualD0Ev // ManyVirtuals.s .section __DATA,__const .globl __ZTV12ManyVirtuals ; @_ZTV12ManyVirtuals .weak_def_can_be_hidden __ZTV12ManyVirtuals .p2align 3 __ZTV12ManyVirtuals: .quad 0 .quad __ZTI12ManyVirtuals .quad __ZN12ManyVirtualsD1Ev .quad __ZN12ManyVirtualsD0Ev .quad __ZNK12ManyVirtuals4getAEv .quad __ZNK12ManyVirtuals4getBEv .quad __ZNK12ManyVirtuals4getCEv For SingleVirtual, we can see an entry for the constructors and the destructor. We can also see that it’s in the const DATA section. But there is nothing for the getter methods. On the other hand, those are there in ManyVirtuals. I couldn’t figure out why there are entries for the constructors which are not virtual in C++. If you happen to know, please share in the comments or by e-mail. Conclusion In this post, we saw how little it matters whether we add a new virtual method to a class that has already a virtual destructor. Having a virtual destructor ensures that everything necessary is instrumented for polymorphic behaviour which can make a huge difference in your binary size - and runtime performance. At the same time, adding another virtual function barely adds to the size of the binary. It’ll only mean an extra entry in your vtable. In the next episode, we’ll have a look into two classic design patterns. We’ll take a classical reference semantic and a modern value semantic implementation and see how much that matters in terms of binary size." /><meta property="og:description" content="In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary. Our conclusion was that if we could, we should follow the rule of 0. Not only because of simplicity for the reader but also for the compiler. If that’s not possible, we should not declare destructors virtual in vain. And if it’s possible, we should =default non-virtual destructors in the header both for readability and for binary sizes. On the other hand, if we must have a non-virtual destructor, we should clearly think about implementing (preferably with =default) the destructor in the .cpp file, in other words, out-of-line. While you might find it strange in terms of readability, it produced a smaller binary. It’s still worth noting that in most circumstances, a class with a virtual destructor contributes to a larger binary file. But does it matter how many functions are virtual? Given the same amount of methods in a class, is there a difference in terms of binary size whether one or all of them are virtual? That’s the question we are going to discuss in this post. What does the virtual keyword do? When any of a class-member function is declared with the virtual keyword, it means that the compiler cannot know during compile-time which implementation of the virtual function will be called. How could it resolve during runtime which function is to be called? As it’s explained on Johnny’s Software Lab, the way to do it is not standardized. Yet, most compilers do it in a similar way. For each class that has at least one virtual method, the compiler creates a virtual table. It’s usually just referred to as a vtable. The vtable of each class contains a pointer to each of their virtual functions. A virtual table might not contain pointers only to the same class. If a derived class doesn’t override a method of a base class, then it will point to that base class implementation. When an object is created at runtime, there is also a virtual pointer (vpointer) created pointing to the right virtual table. So there is one vpointer for each object created at run-time, but only one vtable per type which is created per compile-time. I think we can rightly expect that therefore a virtual method - due to the vtable - results in an increased binary size and we could also expect that any additional virtual method will add to the size of the binary as the vtable grows, but only a little bit. Validate our hypothesis Now let’s create two main.cpp files. In the first one, we are going to have two classes with a virtual destructor and with 3 members each having a non-virtual accessor. In the second example, the same class will have those accessors turned into virtual ones. I know it’s not a particularly elaborate example, but it’s a start. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // main-single-virtual.cpp #include &lt;array&gt; class SingleVirtual { public: SingleVirtual() = default; SingleVirtual(int a, int b, int c) : m_a(a), m_b(b), m_c(c) {} virtual ~SingleVirtual() = default; int getA() const { return m_a; } int getB() const { return m_b; } int getC() const { return m_c; } private: int m_a = 0; int m_b = 0; int m_c = 0; }; std::array&lt;SingleVirtual, 10&#39;000&gt; a; int main() { } // main-many-virtuals.cpp #include &lt;array&gt; class ManyVirtuals { public: ManyVirtuals() = default; ManyVirtuals(int a, int b, int c) : m_a(a), m_b(b), m_c(c) {} virtual ~ManyVirtuals() = default; virtual int getA() const { return m_a; } virtual int getB() const { return m_b; } virtual int getC() const { return m_c; } private: int m_a = 0; int m_b = 0; int m_c = 0; }; std::array&lt;ManyVirtuals, 10&#39;000&gt; a; int main() { } Depending on the optimization level, the version where only the destructor is virtual was compiled into a binary with the size of 281,488/281,520. The fully virtual version had slightly bigger binaries, 281,615/281,647. We can see that the difference is small. In the previous articles, I used an array of 10,000 objects so that we don’t have to look into tiny differences. But in this case, it’s worth having a look at the exact size of the difference. It’s less than 200 bytes per 10,000 objects. To be more precise, the difference is 127 bytes, way less than one byte per object. It cannot have anything to do with the number of objects. It is only about the size of the vtable. It’s almost negligible. First, I ran both examples with a much smaller array of only 10 objects. The difference between the two versions was still exactly 127 bytes. As we start to remove the virtual keywords from the accessors one by one, the difference also shrinks. First by 48 byes to 79 bytes, then by another 32/48 bytes (depending on the optimization level) to 31-47 bytes. And finally, by devirtualizing the third accessor, the difference shrinks by another 48 bytes depending. Another observation that we can make, is that at the end, ManyVirtuals ended up with a smaller binary. That’s because its name is shorter. But that only mattered when the optimization level was -O0 What can we learn from this? It seems that the size of a vtable entry is about 48 bytes, at least on Apple Clang 15. It might not seem a big deal at first, but if we have 10 classes with 3 virtual methods each that’s already more than 1KB. But these numbers can be much higher, especially if we consider a virtual method in a class template. That can quickly explode if we don’t pay attention. At the same time, we can only rest assured that the length of class/function names is not a problem anymore as it was in the past - given that we turn on compiler optimizations. If we have a look at the assembly code after an unoptimized build (so that it remains somewhat readable), we can see things that seem like a list, probably the virtual table: // SingleVirtual.s .section __DATA,__const .globl __ZTV13SingleVirtual ; @_ZTV13SingleVirtual .weak_def_can_be_hidden __ZTV13SingleVirtual .p2align 3 __ZTV13SingleVirtual: .quad 0 .quad __ZTI13SingleVirtual .quad __ZN13SingleVirtualD1Ev .quad __ZN13SingleVirtualD0Ev // ManyVirtuals.s .section __DATA,__const .globl __ZTV12ManyVirtuals ; @_ZTV12ManyVirtuals .weak_def_can_be_hidden __ZTV12ManyVirtuals .p2align 3 __ZTV12ManyVirtuals: .quad 0 .quad __ZTI12ManyVirtuals .quad __ZN12ManyVirtualsD1Ev .quad __ZN12ManyVirtualsD0Ev .quad __ZNK12ManyVirtuals4getAEv .quad __ZNK12ManyVirtuals4getBEv .quad __ZNK12ManyVirtuals4getCEv For SingleVirtual, we can see an entry for the constructors and the destructor. We can also see that it’s in the const DATA section. But there is nothing for the getter methods. On the other hand, those are there in ManyVirtuals. I couldn’t figure out why there are entries for the constructors which are not virtual in C++. If you happen to know, please share in the comments or by e-mail. Conclusion In this post, we saw how little it matters whether we add a new virtual method to a class that has already a virtual destructor. Having a virtual destructor ensures that everything necessary is instrumented for polymorphic behaviour which can make a huge difference in your binary size - and runtime performance. At the same time, adding another virtual function barely adds to the size of the binary. It’ll only mean an extra entry in your vtable. In the next episode, we’ll have a look into two classic design patterns. We’ll take a classical reference semantic and a modern value semantic implementation and see how much that matters in terms of binary size." /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-08T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Virtual functions and binary sizes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-08T00:00:00+01:00","datePublished":"2023-02-08T00:00:00+01:00","description":"In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary. Our conclusion was that if we could, we should follow the rule of 0. Not only because of simplicity for the reader but also for the compiler. If that’s not possible, we should not declare destructors virtual in vain. And if it’s possible, we should =default non-virtual destructors in the header both for readability and for binary sizes. On the other hand, if we must have a non-virtual destructor, we should clearly think about implementing (preferably with =default) the destructor in the .cpp file, in other words, out-of-line. While you might find it strange in terms of readability, it produced a smaller binary. It’s still worth noting that in most circumstances, a class with a virtual destructor contributes to a larger binary file. But does it matter how many functions are virtual? Given the same amount of methods in a class, is there a difference in terms of binary size whether one or all of them are virtual? That’s the question we are going to discuss in this post. What does the virtual keyword do? When any of a class-member function is declared with the virtual keyword, it means that the compiler cannot know during compile-time which implementation of the virtual function will be called. How could it resolve during runtime which function is to be called? As it’s explained on Johnny’s Software Lab, the way to do it is not standardized. Yet, most compilers do it in a similar way. For each class that has at least one virtual method, the compiler creates a virtual table. It’s usually just referred to as a vtable. The vtable of each class contains a pointer to each of their virtual functions. A virtual table might not contain pointers only to the same class. If a derived class doesn’t override a method of a base class, then it will point to that base class implementation. When an object is created at runtime, there is also a virtual pointer (vpointer) created pointing to the right virtual table. So there is one vpointer for each object created at run-time, but only one vtable per type which is created per compile-time. I think we can rightly expect that therefore a virtual method - due to the vtable - results in an increased binary size and we could also expect that any additional virtual method will add to the size of the binary as the vtable grows, but only a little bit. Validate our hypothesis Now let’s create two main.cpp files. In the first one, we are going to have two classes with a virtual destructor and with 3 members each having a non-virtual accessor. In the second example, the same class will have those accessors turned into virtual ones. I know it’s not a particularly elaborate example, but it’s a start. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 // main-single-virtual.cpp #include &lt;array&gt; class SingleVirtual { public: SingleVirtual() = default; SingleVirtual(int a, int b, int c) : m_a(a), m_b(b), m_c(c) {} virtual ~SingleVirtual() = default; int getA() const { return m_a; } int getB() const { return m_b; } int getC() const { return m_c; } private: int m_a = 0; int m_b = 0; int m_c = 0; }; std::array&lt;SingleVirtual, 10&#39;000&gt; a; int main() { } // main-many-virtuals.cpp #include &lt;array&gt; class ManyVirtuals { public: ManyVirtuals() = default; ManyVirtuals(int a, int b, int c) : m_a(a), m_b(b), m_c(c) {} virtual ~ManyVirtuals() = default; virtual int getA() const { return m_a; } virtual int getB() const { return m_b; } virtual int getC() const { return m_c; } private: int m_a = 0; int m_b = 0; int m_c = 0; }; std::array&lt;ManyVirtuals, 10&#39;000&gt; a; int main() { } Depending on the optimization level, the version where only the destructor is virtual was compiled into a binary with the size of 281,488/281,520. The fully virtual version had slightly bigger binaries, 281,615/281,647. We can see that the difference is small. In the previous articles, I used an array of 10,000 objects so that we don’t have to look into tiny differences. But in this case, it’s worth having a look at the exact size of the difference. It’s less than 200 bytes per 10,000 objects. To be more precise, the difference is 127 bytes, way less than one byte per object. It cannot have anything to do with the number of objects. It is only about the size of the vtable. It’s almost negligible. First, I ran both examples with a much smaller array of only 10 objects. The difference between the two versions was still exactly 127 bytes. As we start to remove the virtual keywords from the accessors one by one, the difference also shrinks. First by 48 byes to 79 bytes, then by another 32/48 bytes (depending on the optimization level) to 31-47 bytes. And finally, by devirtualizing the third accessor, the difference shrinks by another 48 bytes depending. Another observation that we can make, is that at the end, ManyVirtuals ended up with a smaller binary. That’s because its name is shorter. But that only mattered when the optimization level was -O0 What can we learn from this? It seems that the size of a vtable entry is about 48 bytes, at least on Apple Clang 15. It might not seem a big deal at first, but if we have 10 classes with 3 virtual methods each that’s already more than 1KB. But these numbers can be much higher, especially if we consider a virtual method in a class template. That can quickly explode if we don’t pay attention. At the same time, we can only rest assured that the length of class/function names is not a problem anymore as it was in the past - given that we turn on compiler optimizations. If we have a look at the assembly code after an unoptimized build (so that it remains somewhat readable), we can see things that seem like a list, probably the virtual table: // SingleVirtual.s .section __DATA,__const .globl __ZTV13SingleVirtual ; @_ZTV13SingleVirtual .weak_def_can_be_hidden __ZTV13SingleVirtual .p2align 3 __ZTV13SingleVirtual: .quad 0 .quad __ZTI13SingleVirtual .quad __ZN13SingleVirtualD1Ev .quad __ZN13SingleVirtualD0Ev // ManyVirtuals.s .section __DATA,__const .globl __ZTV12ManyVirtuals ; @_ZTV12ManyVirtuals .weak_def_can_be_hidden __ZTV12ManyVirtuals .p2align 3 __ZTV12ManyVirtuals: .quad 0 .quad __ZTI12ManyVirtuals .quad __ZN12ManyVirtualsD1Ev .quad __ZN12ManyVirtualsD0Ev .quad __ZNK12ManyVirtuals4getAEv .quad __ZNK12ManyVirtuals4getBEv .quad __ZNK12ManyVirtuals4getCEv For SingleVirtual, we can see an entry for the constructors and the destructor. We can also see that it’s in the const DATA section. But there is nothing for the getter methods. On the other hand, those are there in ManyVirtuals. I couldn’t figure out why there are entries for the constructors which are not virtual in C++. If you happen to know, please share in the comments or by e-mail. Conclusion In this post, we saw how little it matters whether we add a new virtual method to a class that has already a virtual destructor. Having a virtual destructor ensures that everything necessary is instrumented for polymorphic behaviour which can make a huge difference in your binary size - and runtime performance. At the same time, adding another virtual function barely adds to the size of the binary. It’ll only mean an extra entry in your vtable. In the next episode, we’ll have a look into two classic design patterns. We’ll take a classical reference semantic and a modern value semantic implementation and see how much that matters in terms of binary size.","headline":"Virtual functions and binary sizes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual"},"url":"https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual"}</script><title>Virtual functions and binary sizes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/08"> 08 </a> </span> <span>Virtual functions and binary sizes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Virtual functions and binary sizes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 8, 2023, 12:00 AM +0100" prep="on" > Feb 8, 2023 <i class="unloaded">2023-02-08T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1291 words">7 min</span></div></div><div class="post-content"><p>In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary.</p><p>Our conclusion was that if we could, we should follow the rule of 0. Not only because of simplicity for the reader but also for the compiler. If that’s not possible, we should not declare destructors virtual in vain. And if it’s possible, we should <code class="language-plaintext highlighter-rouge">=default</code> non-<code class="language-plaintext highlighter-rouge">virtual</code> destructors in the header both for readability and for binary sizes.</p><p>On the other hand, if we must have a non-<code class="language-plaintext highlighter-rouge">virtual</code> destructor, we should clearly think about implementing (preferably with <code class="language-plaintext highlighter-rouge">=default</code>) the destructor in the <code class="language-plaintext highlighter-rouge">.cpp</code> file, in other words, out-of-line. While you might find it strange in terms of readability, it produced a smaller binary.</p><p>It’s still worth noting that in most circumstances, a class with a <code class="language-plaintext highlighter-rouge">virtual</code> destructor contributes to a larger binary file.</p><p>But does it matter how many functions are virtual? Given the same amount of methods in a class, is there a difference in terms of binary size whether one or all of them are virtual?</p><p>That’s the question we are going to discuss in this post.</p><h2 id="what-does-the-virtual-keyword-do">What does the <code class="language-plaintext highlighter-rouge">virtual</code> keyword do?</h2><p>When any of a class-member function is declared with the <code class="language-plaintext highlighter-rouge">virtual</code> keyword, it means that the compiler cannot know during compile-time which implementation of the <code class="language-plaintext highlighter-rouge">virtual</code> function will be called.</p><p>How could it resolve during runtime which function is to be called?</p><p>As it’s explained on <a href="https://johnnysswlab.com/the-true-price-of-virtual-functions-in-c/">Johnny’s Software Lab</a>, the way to do it is not standardized. Yet, most compilers do it in a similar way.</p><p>For each class that has at least one <code class="language-plaintext highlighter-rouge">virtual</code> method, the compiler creates a virtual table. It’s usually just referred to as a <em>vtable</em>. The <em>vtable</em> of each class contains a pointer to each of their <code class="language-plaintext highlighter-rouge">virtual</code> functions. A virtual table might not contain pointers only to the same class. If a derived class doesn’t <a href="https://www.sandordargo.com/blog/2018/07/05/cpp-override">override</a> a method of a base class, then it will point to that base class implementation.</p><p>When an object is created at runtime, there is also a virtual pointer (<em>vpointer</em>) created pointing to the right virtual table.</p><p>So there is one <em>vpointer</em> for each object created at run-time, but only one <em>vtable</em> per type which is created per compile-time.</p><p>I think we can rightly expect that therefore a <code class="language-plaintext highlighter-rouge">virtual</code> method - due to the <em>vtable</em> - results in an increased binary size and we could also expect that any additional <code class="language-plaintext highlighter-rouge">virtual</code> method will add to the size of the binary as the <em>vtable</em> grows, but only a little bit.</p><h2 id="validate-our-hypothesis">Validate our hypothesis</h2><p>Now let’s create two <code class="language-plaintext highlighter-rouge">main.cpp</code> files. In the first one, we are going to have two classes with a <code class="language-plaintext highlighter-rouge">virtual</code> destructor and with 3 members each having a non-<code class="language-plaintext highlighter-rouge">virtual</code> accessor. In the second example, the same class will have those accessors turned into <code class="language-plaintext highlighter-rouge">virtual</code> ones. I know it’s not a particularly elaborate example, but it’s a start.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
</pre><td class="rouge-code"><pre><span class="c1">// main-single-virtual.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">SingleVirtual</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">SingleVirtual</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">SingleVirtual</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">m_b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">m_c</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">SingleVirtual</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">getA</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_a</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">getB</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_b</span><span class="p">;</span> <span class="p">}</span>
    <span class="kt">int</span> <span class="n">getC</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_c</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>


<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">SingleVirtual</span><span class="p">,</span> <span class="mi">10'000</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="c1">// main-many-virtuals.cpp</span>
<span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">ManyVirtuals</span> <span class="p">{</span>
<span class="nl">public:</span>
    <span class="n">ManyVirtuals</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="n">ManyVirtuals</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span> <span class="n">m_a</span><span class="p">(</span><span class="n">a</span><span class="p">),</span> <span class="n">m_b</span><span class="p">(</span><span class="n">b</span><span class="p">),</span> <span class="n">m_c</span><span class="p">(</span><span class="n">c</span><span class="p">)</span> <span class="p">{}</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">ManyVirtuals</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getA</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_a</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getB</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_b</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="kt">int</span> <span class="n">getC</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">m_c</span><span class="p">;</span> <span class="p">}</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">int</span> <span class="n">m_a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_b</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">m_c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">ManyVirtuals</span><span class="p">,</span> <span class="mi">10'000</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</pre></table></code></div></div><p>Depending on the optimization level, the version where only the destructor is <code class="language-plaintext highlighter-rouge">virtual</code> was compiled into a binary with the size of <code class="language-plaintext highlighter-rouge">281,488</code>/<code class="language-plaintext highlighter-rouge">281,520</code>. The fully virtual version had slightly bigger binaries, <code class="language-plaintext highlighter-rouge">281,615</code>/<code class="language-plaintext highlighter-rouge">281,647</code>.</p><p>We can see that the difference is small. In the previous articles, I used an array of 10,000 objects so that we don’t have to look into tiny differences. But in this case, it’s worth having a look at the exact size of the difference.</p><p>It’s less than 200 bytes per 10,000 objects. To be more precise, the difference is 127 bytes, way less than one byte per object. It cannot have anything to do with the number of objects. It is only about the size of the <em>vtable</em>. It’s almost negligible.</p><p>First, I ran both examples with a much smaller array of only 10 objects. The difference between the two versions was still exactly 127 bytes.</p><p>As we start to remove the <code class="language-plaintext highlighter-rouge">virtual</code> keywords from the accessors one by one, the difference also shrinks. First by 48 byes to 79 bytes, then by another 32/48 bytes (depending on the optimization level) to 31-47 bytes. And finally, by devirtualizing the third accessor, the difference shrinks by another 48 bytes depending.</p><p>Another observation that we can make, is that at the end, <code class="language-plaintext highlighter-rouge">ManyVirtuals</code> ended up with a smaller binary. That’s because its name is shorter. But that only mattered when the optimization level was <code class="language-plaintext highlighter-rouge">-O0</code></p><h2 id="what-can-we-learn-from-this">What can we learn from this?</h2><p>It seems that the size of a <em>vtable</em> entry is about 48 bytes, at least on Apple Clang 15. It might not seem a big deal at first, but if we have 10 classes with 3 virtual methods each that’s already more than 1KB. But these numbers can be much higher, especially if we consider a <code class="language-plaintext highlighter-rouge">virtual</code> method in a class template. That can quickly explode if we don’t pay attention.</p><p>At the same time, we can only rest assured that the length of class/function names is not a problem anymore as it was in the past - given that we turn on compiler optimizations.</p><p>If we have a look at the assembly code after an unoptimized build (so that it remains somewhat readable), we can see things that seem like a list, probably the virtual table:</p><pre><code class="language-asm">// SingleVirtual.s

    .section    __DATA,__const
    .globl  __ZTV13SingleVirtual            ; @_ZTV13SingleVirtual
    .weak_def_can_be_hidden __ZTV13SingleVirtual
    .p2align    3
__ZTV13SingleVirtual:
    .quad   0
    .quad   __ZTI13SingleVirtual
    .quad   __ZN13SingleVirtualD1Ev
    .quad   __ZN13SingleVirtualD0Ev


// ManyVirtuals.s

    .section    __DATA,__const
    .globl  __ZTV12ManyVirtuals             ; @_ZTV12ManyVirtuals
    .weak_def_can_be_hidden __ZTV12ManyVirtuals
    .p2align    3
__ZTV12ManyVirtuals:
    .quad   0
    .quad   __ZTI12ManyVirtuals
    .quad   __ZN12ManyVirtualsD1Ev
    .quad   __ZN12ManyVirtualsD0Ev
    .quad   __ZNK12ManyVirtuals4getAEv
    .quad   __ZNK12ManyVirtuals4getBEv
    .quad   __ZNK12ManyVirtuals4getCEv
</code></pre><p>For <code class="language-plaintext highlighter-rouge">SingleVirtual</code>, we can see an entry for the constructors and the destructor. We can also see that it’s in the <code class="language-plaintext highlighter-rouge">const DATA</code> section. But there is nothing for the getter methods. On the other hand, those are there in <code class="language-plaintext highlighter-rouge">ManyVirtuals</code>. I couldn’t figure out why there are entries for the constructors which are not virtual in C++. If you happen to know, please share in the comments or by e-mail.</p><h2 id="conclusion">Conclusion</h2><p>In this post, we saw how little it matters whether we add a new <code class="language-plaintext highlighter-rouge">virtual</code> method to a class that has already a <code class="language-plaintext highlighter-rouge">virtual</code> destructor. Having a <code class="language-plaintext highlighter-rouge">virtual</code> destructor ensures that everything necessary is instrumented for polymorphic behaviour which can make a huge difference in your binary size - and runtime performance. At the same time, adding another <code class="language-plaintext highlighter-rouge">virtual</code> function barely adds to the size of the binary. It’ll only mean an extra entry in your <em>vtable</em>.</p><p>In the next episode, we’ll have a look into two classic design patterns. We’ll take a classical reference semantic and a modern value semantic implementation and see how much that matters in terms of binary size.</p><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/executables/" class="post-tag no-text-decoration" >executables</a> <a href="/tags/compilation/" class="post-tag no-text-decoration" >compilation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Virtual functions and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Virtual functions and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Virtual functions and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Virtual functions and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/01/11/executable-and-its-structure"><div class="card-body"> <span class="timeago small" > Jan 11, 2023 <i class="unloaded">2023-01-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What's an executable and how is it structured</h3><div class="text-muted small"><p> In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured. How executables are generated? In this section let’s ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/01/18/object-initialization-and-binary-sizes"><div class="card-body"> <span class="timeago small" > Jan 18, 2023 <i class="unloaded">2023-01-18T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Object initialization and binary sizes</h3><div class="text-muted small"><p> Let’s have this piece of code that generates a big binary. #include &lt;array&gt; struct Node { int a = 1, b = 1; }; std::array &lt;Node, 10'000&gt; a; int main() {} If you compile this p...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/01/special-functions-and-binary-sizes"><div class="card-body"> <span class="timeago small" > Feb 1, 2023 <i class="unloaded">2023-02-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Special functions and binary sizes</h3><div class="text-muted small"><p> These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/02/01/special-functions-and-binary-sizes" class="btn btn-outline-primary" prompt="Older"><p>Special functions and binary sizes</p></a> <a href="/blog/2023/02/15/evolution-of-enums" class="btn btn-outline-primary" prompt="Newer"><p>The evolution of enums</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Virtual functions and binary sizes'; this.page.url = 'https://www.sandordargo.com/blog/2023/02/08/binary-sizes-and-virtual'; this.page.identifier = '/blog/2023/02/08/binary-sizes-and-virtual'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
