<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="The evolution of enums" /><meta property="og:locale" content="en_US" /><meta name="description" content="Constants are great. Types are great. Constants of a specific type are really great. This is why enum classes are just fantastic. Last year, we talked about why we should avoid using boolean function parameters. One of the solutions proposed uses strong types, in particular using enums instead of raw booleans. This time, let’s see how enums and the related support evolved during the course of the years. Unscoped enumerations Enumerations are part of the original C++ language, in fact, they were taken over from C. Enumerations are distinct types with a restricted range of values. The range of values is restricted to some explicitly named constants. Let’s quickly have a look at an enum. 1 enum Color { red, green, blue }; After having read this very small example, it’s worth noticing two things: The enum itself is a singular noun, even though it enumerates multiple values. We use such conventions because we keep in mind that it will be always used with one value. If you take a Color function parameter, one colour will be taken. When you compare against a value, you’ll compare against one value. E.g. it reads better to compare against Color::red than against Colors::red The enumerator values are not written in ALL_CAPS! Even though there is a fair chance that you are used to that. I also used to do that. So why didn’t I follow that practice? Because for writing this article, I checked the core guidelines and Enum.5 clearly says that we should not use ALL_CAPS in order to avoid clashes with macros. By the way, Enum.1 clearly said that we should use enumerations over macros. Since C++11, the number of possibilities to declare an enum grew. C++11 introduced the possibility of specifying the underlying type of an enum. If it’s left undefined, the underlying type is implementation-defined but in any case, it’s an integral type. How to specify it? Syntax-wise it might seem a bit like inheritance! Though there are no access levels to define. 1 enum Color : int { red, green, blue }; With that you can be sure what the underlying type is. Still, it must be an integral type! For example, it cannot be a string. Should you try that and you’ll get a very explicit error message: 1 2 3 main.cpp:4:19: error: underlying type &#39;std::string&#39; {aka &#39;std::__cxx11::basic_string&lt;char&gt;&#39;} of &#39;Color&#39; must be an integral type 4 | enum Color : std::string { red, green, blue }; | ^~~~~~ Note that the core guidelines advocate against this practice! You should only specify the underlying value if it is necessary. Why can it be necessary? It gives us two reasons. If you know that the number of choices will be very limited and you want to save a bit of memory: 1 2 enum Direction : char { north, south, east, west, northeast, northwest, southeast, southwest }; Or if you happen to forward declare an enum then you also must declare the type: 1 2 3 4 5 enum Direction : char; void navigate(Direction d); enum Direction : char { north, south, east, west, northeast, northwest, southeast, southwest }; You can also specify the exact value of one or all the enumerated values as long as they are constexpr. 1 enum Color : int { red = 0, green = 1, blue = 2 }; Once again, the guidelines recommends us not to do this, unless it’s necessary! Once you start doing it, it’s easy to make mistakes and mess it up. We can rely on the compiler assigning subsequent values to the subsequent enumerator values. A good reason to specify the enumerator value is to define only the starting value. If you define the months and you don’t want to start with zero. 1 2 enum Month { jan = 1, feb, mar, apr, may, jun, jul, august, sep, oct, nov, dec }; Another reason can be if you want to define the values as some meaningful character 1 2 3 4 enum altitude: char { high = &#39;h&#39;, low = &#39;l&#39; }; One other reason can be emulating some bitfields. So you don’t want subsequent values, but you always want the next power of two 1 enum access_type { read = 1, write = 2, exec = 4 }; Scoped enumerations In the previous section, we saw declarations such as enum EnumName{};. C++11 brought a new type of enumeration called scoped enums. They declared either with the class or with the struct keywords and there is no difference between those two. The syntax is the following: 1 enum class Color { red, green, blue }; For scoped enumerations the default underlying type is defined in the standard, it is int. This also means that if you want to forward declare a scoped enum, you don’t have to specify the underlying type. If it is meant to be int, this is enough: 1 enum class Color; Apart from how the syntactical differences between how they are declared, what other differences exist? Unscoped enums can be implicitly converted to their underlying type. Implicit conversions are often not what you want, and scoped enums don’t have this “feature”. Exactly because of the unwelcome implicit conversions, the Core Guidelines strongly recommends using scoped over unscoped enums. 1 2 3 4 5 6 7 8 9 10 void Print_color(int color); enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum Product_info { red = 0, purple = 1, blue = 2 }; Web_color webby = Web_color::blue; // Clearly at least one of these calls is buggy. Print_color(webby); Print_color(Product_info::blue); Unscoped enums export their enumerators to the enclosing scope which might lead to name clashes. On the other hand, with scoped enums, you must always specify the name of the enum alongside with the enumerators. 1 2 3 4 5 6 7 8 enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; int main() { [[maybe_unused]] UnscopedColor uc = red; // [[maybe_unused]] ScopedColor sc = red; // Doesn&#39;t compile [[maybe_unused]] ScopedColor sc = ScopedColor::red; } What else Now that we saw how un/scoped enums work and what are the differences between them, let’s see what other enum related functionalities the language or standard library offers. std::is_enum C++11 introduced the &lt;type_traits&gt; header. It includes utilities to check the properties of types. Not surprisingly is_enum is there to check whether a type is an enum of not. It returns true both for scoped and unscoped versions. Since C++17, is_enum_v is also available for easier usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; struct S{}; int main() { std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_enum&lt;UnscopedColor&gt;::value &lt;&lt; &#39;\n&#39; &lt;&lt; std::is_enum&lt;ScopedColor&gt;::value &lt;&lt; &#39;\n&#39; &lt;&lt; std::is_enum_v&lt;S&gt; &lt;&lt; &#39;\n&#39;; } std::underlying_type std::underlying_type was also an addition to C++11. It helps us retrieve the underlying type of an enum. Until C++20 if the checked enum is not completely defined or not an enum, the behaviour is undefined. Starting with C++, the program becomes ill-formed for incomplete enum types. C++14 introduced a related helper, std::underlying_type_t. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; enum class CharBasedColor : char { red = &#39;r&#39;, green = &#39;g&#39;, blue = &#39;b&#39; }; int main() { constexpr bool isUnscopedColorInt = std::is_same_v&lt; std::underlying_type&lt;UnscopedColor&gt;::type, int &gt;; constexpr bool isScopedColorInt = std::is_same_v&lt; std::underlying_type_t&lt;ScopedColor&gt;, int &gt;; constexpr bool isCharBasedColorInt = std::is_same_v&lt; std::underlying_type_t&lt;CharBasedColor&gt;, int &gt;; constexpr bool isCharBasedColorChar = std::is_same_v&lt; std::underlying_type_t&lt;CharBasedColor&gt;, char &gt;; std::cout &lt;&lt; &quot;underlying type for &#39;UnscopedColor&#39; is &quot; &lt;&lt; (isUnscopedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;underlying type for &#39;ScopedColor&#39; is &quot; &lt;&lt; (isScopedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;underlying type for &#39;CharBasedColor&#39; is &quot; &lt;&lt; (isCharBasedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;underlying type for &#39;CharBasedColor&#39; is &quot; &lt;&lt; (isCharBasedColorChar ? &quot;char&quot; : &quot;non-char&quot;) &lt;&lt; &#39;\n&#39; ; } Using-enum-declaration since C++20 Since C++20, use can use using with enums. It introduces the enumerator names in the given scope. The feature is smart enough to raise a compilation error in case a second using would introduce an enumerator name that was already introduced from another enum. 1 2 3 4 5 6 7 8 9 #include &lt;type_traits&gt; enum class ScopedColor { red, green, blue }; enum class CharBasedColor : char { red = &#39;r&#39;, green = &#39;g&#39;, blue = &#39;b&#39; }; int main() { using enum ScopedColor; // OK! using enum CharBasedColor; // error: &#39;CharBasedColor CharBasedColor::red&#39; conflicts with a previous declaration } It’s worth noting that it doesn’t recognize if an unscoped enum already introduced an enumerator name in the given namespace. In the following example, there is already red, green, and blue available from UnscopedColor, still, the using of ScopedColor with the same enumerator names is accepted. 1 2 3 4 5 6 7 8 #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; int main() { using enum ScopedColor; } C++23 brings std::is_scoped_enum C++23 will introduce one more enum related function in the &lt;type_traits&gt; header, one of it is std::is_scoped_enum and it’s helper function std::is_scoped_enum_v. As the name suggests and the below snippet proves, it checks whether it is argument is a scoped enum or not. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; struct S{}; int main() { std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; std::is_scoped_enum&lt;UnscopedColor&gt;::value &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;ScopedColor&gt; &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;S&gt; &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;int&gt; &lt;&lt; &#39;\n&#39;; } /* false true false false */ If you want to try out C++23 features, use the -std=c++2b compiler flag. C++23 introduces std::to_underlying C++23 will introduce another library feature for enums. The &lt;utility&gt; header will be enriched with std::to_underlying. It converts an enum to its underlying type. As mentioned, this is a library feature, meaning that it can be implemented in earlier versions. This one is can be replaced with a static_cast if you have access only to earlier versions: static_cast&lt;std::underlying_type_t&lt;MyEnum&gt;&gt;(e);. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; enum class ScopedColor { red, green, blue }; int main() { ScopedColor sc = ScopedColor::red; [[maybe_unused]] int underlying = std::to_underlying(sc); [[maybe_unused]] int underlyingEmulated = static_cast&lt;std::underlying_type_t&lt;ScopedColor&gt;&gt;(sc); [[maybe_unused]] std::underlying_type_t&lt;ScopedColor&gt; underlyingDeduced = std::to_underlying(sc); } As a reminder, let me repate that if you want to try out C++23 features, use the -std=c++2b compiler flag. Conclusion In this article, we discussed all the language and library features that are about enumerations. We saw how scoped and unscoped enums differ and why it’s better to use scoped enums. That’s not the only Core Guidelines recommendation we discussed. Then we checked how the standard library has been enriched during the years supporting an easier work with enums. We also had a sneak peek into the future and checked what C++23 will bring for us. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Constants are great. Types are great. Constants of a specific type are really great. This is why enum classes are just fantastic. Last year, we talked about why we should avoid using boolean function parameters. One of the solutions proposed uses strong types, in particular using enums instead of raw booleans. This time, let’s see how enums and the related support evolved during the course of the years. Unscoped enumerations Enumerations are part of the original C++ language, in fact, they were taken over from C. Enumerations are distinct types with a restricted range of values. The range of values is restricted to some explicitly named constants. Let’s quickly have a look at an enum. 1 enum Color { red, green, blue }; After having read this very small example, it’s worth noticing two things: The enum itself is a singular noun, even though it enumerates multiple values. We use such conventions because we keep in mind that it will be always used with one value. If you take a Color function parameter, one colour will be taken. When you compare against a value, you’ll compare against one value. E.g. it reads better to compare against Color::red than against Colors::red The enumerator values are not written in ALL_CAPS! Even though there is a fair chance that you are used to that. I also used to do that. So why didn’t I follow that practice? Because for writing this article, I checked the core guidelines and Enum.5 clearly says that we should not use ALL_CAPS in order to avoid clashes with macros. By the way, Enum.1 clearly said that we should use enumerations over macros. Since C++11, the number of possibilities to declare an enum grew. C++11 introduced the possibility of specifying the underlying type of an enum. If it’s left undefined, the underlying type is implementation-defined but in any case, it’s an integral type. How to specify it? Syntax-wise it might seem a bit like inheritance! Though there are no access levels to define. 1 enum Color : int { red, green, blue }; With that you can be sure what the underlying type is. Still, it must be an integral type! For example, it cannot be a string. Should you try that and you’ll get a very explicit error message: 1 2 3 main.cpp:4:19: error: underlying type &#39;std::string&#39; {aka &#39;std::__cxx11::basic_string&lt;char&gt;&#39;} of &#39;Color&#39; must be an integral type 4 | enum Color : std::string { red, green, blue }; | ^~~~~~ Note that the core guidelines advocate against this practice! You should only specify the underlying value if it is necessary. Why can it be necessary? It gives us two reasons. If you know that the number of choices will be very limited and you want to save a bit of memory: 1 2 enum Direction : char { north, south, east, west, northeast, northwest, southeast, southwest }; Or if you happen to forward declare an enum then you also must declare the type: 1 2 3 4 5 enum Direction : char; void navigate(Direction d); enum Direction : char { north, south, east, west, northeast, northwest, southeast, southwest }; You can also specify the exact value of one or all the enumerated values as long as they are constexpr. 1 enum Color : int { red = 0, green = 1, blue = 2 }; Once again, the guidelines recommends us not to do this, unless it’s necessary! Once you start doing it, it’s easy to make mistakes and mess it up. We can rely on the compiler assigning subsequent values to the subsequent enumerator values. A good reason to specify the enumerator value is to define only the starting value. If you define the months and you don’t want to start with zero. 1 2 enum Month { jan = 1, feb, mar, apr, may, jun, jul, august, sep, oct, nov, dec }; Another reason can be if you want to define the values as some meaningful character 1 2 3 4 enum altitude: char { high = &#39;h&#39;, low = &#39;l&#39; }; One other reason can be emulating some bitfields. So you don’t want subsequent values, but you always want the next power of two 1 enum access_type { read = 1, write = 2, exec = 4 }; Scoped enumerations In the previous section, we saw declarations such as enum EnumName{};. C++11 brought a new type of enumeration called scoped enums. They declared either with the class or with the struct keywords and there is no difference between those two. The syntax is the following: 1 enum class Color { red, green, blue }; For scoped enumerations the default underlying type is defined in the standard, it is int. This also means that if you want to forward declare a scoped enum, you don’t have to specify the underlying type. If it is meant to be int, this is enough: 1 enum class Color; Apart from how the syntactical differences between how they are declared, what other differences exist? Unscoped enums can be implicitly converted to their underlying type. Implicit conversions are often not what you want, and scoped enums don’t have this “feature”. Exactly because of the unwelcome implicit conversions, the Core Guidelines strongly recommends using scoped over unscoped enums. 1 2 3 4 5 6 7 8 9 10 void Print_color(int color); enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum Product_info { red = 0, purple = 1, blue = 2 }; Web_color webby = Web_color::blue; // Clearly at least one of these calls is buggy. Print_color(webby); Print_color(Product_info::blue); Unscoped enums export their enumerators to the enclosing scope which might lead to name clashes. On the other hand, with scoped enums, you must always specify the name of the enum alongside with the enumerators. 1 2 3 4 5 6 7 8 enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; int main() { [[maybe_unused]] UnscopedColor uc = red; // [[maybe_unused]] ScopedColor sc = red; // Doesn&#39;t compile [[maybe_unused]] ScopedColor sc = ScopedColor::red; } What else Now that we saw how un/scoped enums work and what are the differences between them, let’s see what other enum related functionalities the language or standard library offers. std::is_enum C++11 introduced the &lt;type_traits&gt; header. It includes utilities to check the properties of types. Not surprisingly is_enum is there to check whether a type is an enum of not. It returns true both for scoped and unscoped versions. Since C++17, is_enum_v is also available for easier usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; struct S{}; int main() { std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_enum&lt;UnscopedColor&gt;::value &lt;&lt; &#39;\n&#39; &lt;&lt; std::is_enum&lt;ScopedColor&gt;::value &lt;&lt; &#39;\n&#39; &lt;&lt; std::is_enum_v&lt;S&gt; &lt;&lt; &#39;\n&#39;; } std::underlying_type std::underlying_type was also an addition to C++11. It helps us retrieve the underlying type of an enum. Until C++20 if the checked enum is not completely defined or not an enum, the behaviour is undefined. Starting with C++, the program becomes ill-formed for incomplete enum types. C++14 introduced a related helper, std::underlying_type_t. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; enum class CharBasedColor : char { red = &#39;r&#39;, green = &#39;g&#39;, blue = &#39;b&#39; }; int main() { constexpr bool isUnscopedColorInt = std::is_same_v&lt; std::underlying_type&lt;UnscopedColor&gt;::type, int &gt;; constexpr bool isScopedColorInt = std::is_same_v&lt; std::underlying_type_t&lt;ScopedColor&gt;, int &gt;; constexpr bool isCharBasedColorInt = std::is_same_v&lt; std::underlying_type_t&lt;CharBasedColor&gt;, int &gt;; constexpr bool isCharBasedColorChar = std::is_same_v&lt; std::underlying_type_t&lt;CharBasedColor&gt;, char &gt;; std::cout &lt;&lt; &quot;underlying type for &#39;UnscopedColor&#39; is &quot; &lt;&lt; (isUnscopedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;underlying type for &#39;ScopedColor&#39; is &quot; &lt;&lt; (isScopedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;underlying type for &#39;CharBasedColor&#39; is &quot; &lt;&lt; (isCharBasedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\n&#39; &lt;&lt; &quot;underlying type for &#39;CharBasedColor&#39; is &quot; &lt;&lt; (isCharBasedColorChar ? &quot;char&quot; : &quot;non-char&quot;) &lt;&lt; &#39;\n&#39; ; } Using-enum-declaration since C++20 Since C++20, use can use using with enums. It introduces the enumerator names in the given scope. The feature is smart enough to raise a compilation error in case a second using would introduce an enumerator name that was already introduced from another enum. 1 2 3 4 5 6 7 8 9 #include &lt;type_traits&gt; enum class ScopedColor { red, green, blue }; enum class CharBasedColor : char { red = &#39;r&#39;, green = &#39;g&#39;, blue = &#39;b&#39; }; int main() { using enum ScopedColor; // OK! using enum CharBasedColor; // error: &#39;CharBasedColor CharBasedColor::red&#39; conflicts with a previous declaration } It’s worth noting that it doesn’t recognize if an unscoped enum already introduced an enumerator name in the given namespace. In the following example, there is already red, green, and blue available from UnscopedColor, still, the using of ScopedColor with the same enumerator names is accepted. 1 2 3 4 5 6 7 8 #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; int main() { using enum ScopedColor; } C++23 brings std::is_scoped_enum C++23 will introduce one more enum related function in the &lt;type_traits&gt; header, one of it is std::is_scoped_enum and it’s helper function std::is_scoped_enum_v. As the name suggests and the below snippet proves, it checks whether it is argument is a scoped enum or not. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; struct S{}; int main() { std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; std::is_scoped_enum&lt;UnscopedColor&gt;::value &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;ScopedColor&gt; &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;S&gt; &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;int&gt; &lt;&lt; &#39;\n&#39;; } /* false true false false */ If you want to try out C++23 features, use the -std=c++2b compiler flag. C++23 introduces std::to_underlying C++23 will introduce another library feature for enums. The &lt;utility&gt; header will be enriched with std::to_underlying. It converts an enum to its underlying type. As mentioned, this is a library feature, meaning that it can be implemented in earlier versions. This one is can be replaced with a static_cast if you have access only to earlier versions: static_cast&lt;std::underlying_type_t&lt;MyEnum&gt;&gt;(e);. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; enum class ScopedColor { red, green, blue }; int main() { ScopedColor sc = ScopedColor::red; [[maybe_unused]] int underlying = std::to_underlying(sc); [[maybe_unused]] int underlyingEmulated = static_cast&lt;std::underlying_type_t&lt;ScopedColor&gt;&gt;(sc); [[maybe_unused]] std::underlying_type_t&lt;ScopedColor&gt; underlyingDeduced = std::to_underlying(sc); } As a reminder, let me repate that if you want to try out C++23 features, use the -std=c++2b compiler flag. Conclusion In this article, we discussed all the language and library features that are about enumerations. We saw how scoped and unscoped enums differ and why it’s better to use scoped enums. That’s not the only Core Guidelines recommendation we discussed. Then we checked how the standard library has been enriched during the years supporting an easier work with enums. We also had a sneak peek into the future and checked what C++23 will bring for us. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-15T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="The evolution of enums" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-15T22:37:45+01:00","datePublished":"2023-02-15T00:00:00+01:00","description":"Constants are great. Types are great. Constants of a specific type are really great. This is why enum classes are just fantastic. Last year, we talked about why we should avoid using boolean function parameters. One of the solutions proposed uses strong types, in particular using enums instead of raw booleans. This time, let’s see how enums and the related support evolved during the course of the years. Unscoped enumerations Enumerations are part of the original C++ language, in fact, they were taken over from C. Enumerations are distinct types with a restricted range of values. The range of values is restricted to some explicitly named constants. Let’s quickly have a look at an enum. 1 enum Color { red, green, blue }; After having read this very small example, it’s worth noticing two things: The enum itself is a singular noun, even though it enumerates multiple values. We use such conventions because we keep in mind that it will be always used with one value. If you take a Color function parameter, one colour will be taken. When you compare against a value, you’ll compare against one value. E.g. it reads better to compare against Color::red than against Colors::red The enumerator values are not written in ALL_CAPS! Even though there is a fair chance that you are used to that. I also used to do that. So why didn’t I follow that practice? Because for writing this article, I checked the core guidelines and Enum.5 clearly says that we should not use ALL_CAPS in order to avoid clashes with macros. By the way, Enum.1 clearly said that we should use enumerations over macros. Since C++11, the number of possibilities to declare an enum grew. C++11 introduced the possibility of specifying the underlying type of an enum. If it’s left undefined, the underlying type is implementation-defined but in any case, it’s an integral type. How to specify it? Syntax-wise it might seem a bit like inheritance! Though there are no access levels to define. 1 enum Color : int { red, green, blue }; With that you can be sure what the underlying type is. Still, it must be an integral type! For example, it cannot be a string. Should you try that and you’ll get a very explicit error message: 1 2 3 main.cpp:4:19: error: underlying type &#39;std::string&#39; {aka &#39;std::__cxx11::basic_string&lt;char&gt;&#39;} of &#39;Color&#39; must be an integral type 4 | enum Color : std::string { red, green, blue }; | ^~~~~~ Note that the core guidelines advocate against this practice! You should only specify the underlying value if it is necessary. Why can it be necessary? It gives us two reasons. If you know that the number of choices will be very limited and you want to save a bit of memory: 1 2 enum Direction : char { north, south, east, west, northeast, northwest, southeast, southwest }; Or if you happen to forward declare an enum then you also must declare the type: 1 2 3 4 5 enum Direction : char; void navigate(Direction d); enum Direction : char { north, south, east, west, northeast, northwest, southeast, southwest }; You can also specify the exact value of one or all the enumerated values as long as they are constexpr. 1 enum Color : int { red = 0, green = 1, blue = 2 }; Once again, the guidelines recommends us not to do this, unless it’s necessary! Once you start doing it, it’s easy to make mistakes and mess it up. We can rely on the compiler assigning subsequent values to the subsequent enumerator values. A good reason to specify the enumerator value is to define only the starting value. If you define the months and you don’t want to start with zero. 1 2 enum Month { jan = 1, feb, mar, apr, may, jun, jul, august, sep, oct, nov, dec }; Another reason can be if you want to define the values as some meaningful character 1 2 3 4 enum altitude: char { high = &#39;h&#39;, low = &#39;l&#39; }; One other reason can be emulating some bitfields. So you don’t want subsequent values, but you always want the next power of two 1 enum access_type { read = 1, write = 2, exec = 4 }; Scoped enumerations In the previous section, we saw declarations such as enum EnumName{};. C++11 brought a new type of enumeration called scoped enums. They declared either with the class or with the struct keywords and there is no difference between those two. The syntax is the following: 1 enum class Color { red, green, blue }; For scoped enumerations the default underlying type is defined in the standard, it is int. This also means that if you want to forward declare a scoped enum, you don’t have to specify the underlying type. If it is meant to be int, this is enough: 1 enum class Color; Apart from how the syntactical differences between how they are declared, what other differences exist? Unscoped enums can be implicitly converted to their underlying type. Implicit conversions are often not what you want, and scoped enums don’t have this “feature”. Exactly because of the unwelcome implicit conversions, the Core Guidelines strongly recommends using scoped over unscoped enums. 1 2 3 4 5 6 7 8 9 10 void Print_color(int color); enum Web_color { red = 0xFF0000, green = 0x00FF00, blue = 0x0000FF }; enum Product_info { red = 0, purple = 1, blue = 2 }; Web_color webby = Web_color::blue; // Clearly at least one of these calls is buggy. Print_color(webby); Print_color(Product_info::blue); Unscoped enums export their enumerators to the enclosing scope which might lead to name clashes. On the other hand, with scoped enums, you must always specify the name of the enum alongside with the enumerators. 1 2 3 4 5 6 7 8 enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; int main() { [[maybe_unused]] UnscopedColor uc = red; // [[maybe_unused]] ScopedColor sc = red; // Doesn&#39;t compile [[maybe_unused]] ScopedColor sc = ScopedColor::red; } What else Now that we saw how un/scoped enums work and what are the differences between them, let’s see what other enum related functionalities the language or standard library offers. std::is_enum C++11 introduced the &lt;type_traits&gt; header. It includes utilities to check the properties of types. Not surprisingly is_enum is there to check whether a type is an enum of not. It returns true both for scoped and unscoped versions. Since C++17, is_enum_v is also available for easier usage. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; struct S{}; int main() { std::cout &lt;&lt; std::boolalpha &lt;&lt; std::is_enum&lt;UnscopedColor&gt;::value &lt;&lt; &#39;\\n&#39; &lt;&lt; std::is_enum&lt;ScopedColor&gt;::value &lt;&lt; &#39;\\n&#39; &lt;&lt; std::is_enum_v&lt;S&gt; &lt;&lt; &#39;\\n&#39;; } std::underlying_type std::underlying_type was also an addition to C++11. It helps us retrieve the underlying type of an enum. Until C++20 if the checked enum is not completely defined or not an enum, the behaviour is undefined. Starting with C++, the program becomes ill-formed for incomplete enum types. C++14 introduced a related helper, std::underlying_type_t. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; enum class CharBasedColor : char { red = &#39;r&#39;, green = &#39;g&#39;, blue = &#39;b&#39; }; int main() { constexpr bool isUnscopedColorInt = std::is_same_v&lt; std::underlying_type&lt;UnscopedColor&gt;::type, int &gt;; constexpr bool isScopedColorInt = std::is_same_v&lt; std::underlying_type_t&lt;ScopedColor&gt;, int &gt;; constexpr bool isCharBasedColorInt = std::is_same_v&lt; std::underlying_type_t&lt;CharBasedColor&gt;, int &gt;; constexpr bool isCharBasedColorChar = std::is_same_v&lt; std::underlying_type_t&lt;CharBasedColor&gt;, char &gt;; std::cout &lt;&lt; &quot;underlying type for &#39;UnscopedColor&#39; is &quot; &lt;&lt; (isUnscopedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\\n&#39; &lt;&lt; &quot;underlying type for &#39;ScopedColor&#39; is &quot; &lt;&lt; (isScopedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\\n&#39; &lt;&lt; &quot;underlying type for &#39;CharBasedColor&#39; is &quot; &lt;&lt; (isCharBasedColorInt ? &quot;int&quot; : &quot;non-int&quot;) &lt;&lt; &#39;\\n&#39; &lt;&lt; &quot;underlying type for &#39;CharBasedColor&#39; is &quot; &lt;&lt; (isCharBasedColorChar ? &quot;char&quot; : &quot;non-char&quot;) &lt;&lt; &#39;\\n&#39; ; } Using-enum-declaration since C++20 Since C++20, use can use using with enums. It introduces the enumerator names in the given scope. The feature is smart enough to raise a compilation error in case a second using would introduce an enumerator name that was already introduced from another enum. 1 2 3 4 5 6 7 8 9 #include &lt;type_traits&gt; enum class ScopedColor { red, green, blue }; enum class CharBasedColor : char { red = &#39;r&#39;, green = &#39;g&#39;, blue = &#39;b&#39; }; int main() { using enum ScopedColor; // OK! using enum CharBasedColor; // error: &#39;CharBasedColor CharBasedColor::red&#39; conflicts with a previous declaration } It’s worth noting that it doesn’t recognize if an unscoped enum already introduced an enumerator name in the given namespace. In the following example, there is already red, green, and blue available from UnscopedColor, still, the using of ScopedColor with the same enumerator names is accepted. 1 2 3 4 5 6 7 8 #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; int main() { using enum ScopedColor; } C++23 brings std::is_scoped_enum C++23 will introduce one more enum related function in the &lt;type_traits&gt; header, one of it is std::is_scoped_enum and it’s helper function std::is_scoped_enum_v. As the name suggests and the below snippet proves, it checks whether it is argument is a scoped enum or not. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;iostream&gt; #include &lt;type_traits&gt; enum UnscopedColor { red, green, blue }; enum class ScopedColor { red, green, blue }; struct S{}; int main() { std::cout &lt;&lt; std::boolalpha; std::cout &lt;&lt; std::is_scoped_enum&lt;UnscopedColor&gt;::value &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;ScopedColor&gt; &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;S&gt; &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; std::is_scoped_enum_v&lt;int&gt; &lt;&lt; &#39;\\n&#39;; } /* false true false false */ If you want to try out C++23 features, use the -std=c++2b compiler flag. C++23 introduces std::to_underlying C++23 will introduce another library feature for enums. The &lt;utility&gt; header will be enriched with std::to_underlying. It converts an enum to its underlying type. As mentioned, this is a library feature, meaning that it can be implemented in earlier versions. This one is can be replaced with a static_cast if you have access only to earlier versions: static_cast&lt;std::underlying_type_t&lt;MyEnum&gt;&gt;(e);. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;type_traits&gt; #include &lt;utility&gt; enum class ScopedColor { red, green, blue }; int main() { ScopedColor sc = ScopedColor::red; [[maybe_unused]] int underlying = std::to_underlying(sc); [[maybe_unused]] int underlyingEmulated = static_cast&lt;std::underlying_type_t&lt;ScopedColor&gt;&gt;(sc); [[maybe_unused]] std::underlying_type_t&lt;ScopedColor&gt; underlyingDeduced = std::to_underlying(sc); } As a reminder, let me repate that if you want to try out C++23 features, use the -std=c++2b compiler flag. Conclusion In this article, we discussed all the language and library features that are about enumerations. We saw how scoped and unscoped enums differ and why it’s better to use scoped enums. That’s not the only Core Guidelines recommendation we discussed. Then we checked how the standard library has been enriched during the years supporting an easier work with enums. We also had a sneak peek into the future and checked what C++23 will bring for us. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"The evolution of enums","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums"},"url":"https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums"}</script><title>The evolution of enums | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/15"> 15 </a> </span> <span>The evolution of enums</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>The evolution of enums</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 15, 2023, 12:00 AM +0100" prep="on" > Feb 15, 2023 <i class="unloaded">2023-02-15T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 15, 2023, 10:37 PM +0100" prefix="Updated " > Feb 15, 2023 <i class="unloaded">2023-02-15T22:37:45+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1895 words">10 min</span></div></div><div class="post-content"><p>Constants are great. Types are great. Constants of a specific type are really great. This is why <code class="language-plaintext highlighter-rouge">enum class</code>es are just fantastic.</p><p>Last year, we talked about <a href="https://www.sandordargo.com/blog/2022/04/06/use-strong-types-instead-booleans">why we should avoid using boolean function parameters</a>. One of the solutions proposed uses strong types, in particular using <code class="language-plaintext highlighter-rouge">enum</code>s instead of raw booleans. This time, let’s see how <code class="language-plaintext highlighter-rouge">enum</code>s and the related support evolved during the course of the years.</p><h2 id="unscoped-enumerations">Unscoped enumerations</h2><p>Enumerations are part of the original C++ language, in fact, they were taken over from C. Enumerations are distinct types with a restricted range of values. The range of values is restricted to some explicitly named constants. Let’s quickly have a look at an <code class="language-plaintext highlighter-rouge">enum</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</pre></table></code></div></div><p>After having read this very small example, it’s worth noticing two things:</p><ul><li>The <code class="language-plaintext highlighter-rouge">enum</code> itself is a singular noun, even though it enumerates multiple values. We use such conventions because we keep in mind that it will be always used with one value. If you take a <code class="language-plaintext highlighter-rouge">Color</code> function parameter, one colour will be taken. When you compare against a value, you’ll compare against one value. E.g. it reads better to compare against <code class="language-plaintext highlighter-rouge">Color::red</code> than against <code class="language-plaintext highlighter-rouge">Colors::red</code><li>The enumerator values are not written in <em>ALL_CAPS</em>! Even though there is a fair chance that you are used to that. I also used to do that. So why didn’t I follow that practice? Because for writing this article, I checked the core guidelines and <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum5-dont-use-all_caps-for-enumerators">Enum.5</a> clearly says that we should not use <em>ALL_CAPS</em> in order to avoid clashes with macros. By the way, <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum5-dont-use-all_caps-for-enumerators">Enum.1</a> clearly said that we should use enumerations over macros.</ul><p>Since C++11, the number of possibilities to declare an <code class="language-plaintext highlighter-rouge">enum</code> grew. C++11 introduced the possibility of specifying the underlying type of an enum. If it’s left undefined, the underlying type is implementation-defined but in any case, it’s an integral type.</p><p>How to specify it? Syntax-wise it might seem a bit like inheritance! Though there are no access levels to define.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Color</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</pre></table></code></div></div><p>With that you can be sure what the underlying type is. Still, it must be an integral type! For example, it cannot be a string. Should you try that and you’ll get a very explicit error message:</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>main.cpp:4:19: error: underlying type 'std::string' {aka 'std::__cxx11::basic_string&lt;char&gt;'} of 'Color' must be an integral type
    4 | enum Color : std::string { red, green, blue };
      |                   ^~~~~~
</pre></table></code></div></div><p>Note that <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum7-specify-the-underlying-type-of-an-enumeration-only-when-necessary">the core guidelines advocate against this practice</a>! You should only specify the underlying value if it is necessary.</p><p>Why can it be necessary? It gives us two reasons.</p><ul><li>If you know that the number of choices will be very limited and you want to save a bit of memory:<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Direction</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span><span class="p">,</span>
   <span class="n">northeast</span><span class="p">,</span> <span class="n">northwest</span><span class="p">,</span> <span class="n">southeast</span><span class="p">,</span> <span class="n">southwest</span> <span class="p">};</span> 
</pre></table></code></div></div><li>Or if you happen to forward declare an <code class="language-plaintext highlighter-rouge">enum</code> then you also must declare the type:</ul><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Direction</span> <span class="o">:</span> <span class="kt">char</span><span class="p">;</span>
<span class="kt">void</span> <span class="nf">navigate</span><span class="p">(</span><span class="n">Direction</span> <span class="n">d</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">Direction</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span> <span class="n">north</span><span class="p">,</span> <span class="n">south</span><span class="p">,</span> <span class="n">east</span><span class="p">,</span> <span class="n">west</span><span class="p">,</span>
     <span class="n">northeast</span><span class="p">,</span> <span class="n">northwest</span><span class="p">,</span> <span class="n">southeast</span><span class="p">,</span> <span class="n">southwest</span> <span class="p">};</span> 
</pre></table></code></div></div><p>You can also specify the exact value of one or all the enumerated values as long as they are <code class="language-plaintext highlighter-rouge">constexpr</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Color</span> <span class="o">:</span> <span class="kt">int</span> <span class="p">{</span> <span class="n">red</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">green</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>
</pre></table></code></div></div><p>Once again, <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum8-specify-enumerator-values-only-when-necessary">the guidelines recommends us not to do this</a>, unless it’s necessary! Once you start doing it, it’s easy to make mistakes and mess it up. We can rely on the compiler assigning subsequent values to the subsequent enumerator values.</p><ul><li>A good reason to specify the enumerator value is to define only the starting value. If you define the months and you don’t want to start with zero.<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">Month</span> <span class="p">{</span> <span class="n">jan</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">feb</span><span class="p">,</span> <span class="n">mar</span><span class="p">,</span> <span class="n">apr</span><span class="p">,</span> <span class="n">may</span><span class="p">,</span> <span class="n">jun</span><span class="p">,</span>
                 <span class="n">jul</span><span class="p">,</span> <span class="n">august</span><span class="p">,</span> <span class="n">sep</span><span class="p">,</span> <span class="n">oct</span><span class="p">,</span> <span class="n">nov</span><span class="p">,</span> <span class="n">dec</span> <span class="p">};</span> 
</pre></table></code></div></div><li>Another reason can be if you want to define the values as some meaningful character<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">altitude</span><span class="o">:</span> <span class="kt">char</span> <span class="p">{</span>
  <span class="n">high</span> <span class="o">=</span> <span class="sc">'h'</span><span class="p">,</span>
  <span class="n">low</span> <span class="o">=</span> <span class="sc">'l'</span>
<span class="p">};</span> 
</pre></table></code></div></div><li>One other reason can be emulating some bitfields. So you don’t want subsequent values, but you always want the next power of two<div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">access_type</span> <span class="p">{</span> <span class="n">read</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">write</span> <span class="o">=</span> <span class="mi">2</span><span class="p">,</span> <span class="n">exec</span> <span class="o">=</span> <span class="mi">4</span> <span class="p">};</span>
</pre></table></code></div></div></ul><h2 id="scoped-enumerations">Scoped enumerations</h2><p>In the previous section, we saw declarations such as <code class="language-plaintext highlighter-rouge">enum EnumName{};</code>. C++11 brought a new type of enumeration called scoped <code class="language-plaintext highlighter-rouge">enum</code>s. They declared either with the <code class="language-plaintext highlighter-rouge">class</code> or with the <code class="language-plaintext highlighter-rouge">struct</code> keywords and there is no difference between those two.</p><p>The syntax is the following:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
</pre></table></code></div></div><p>For scoped enumerations the default underlying type is defined in the standard, it is <code class="language-plaintext highlighter-rouge">int</code>. This also means that if you want to forward declare a scoped <code class="language-plaintext highlighter-rouge">enum</code>, you don’t have to specify the underlying type. If it is meant to be <code class="language-plaintext highlighter-rouge">int</code>, this is enough:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="k">class</span> <span class="nc">Color</span><span class="p">;</span>
</pre></table></code></div></div><p>Apart from how the syntactical differences between how they are declared, what other differences exist?</p><p>Unscoped <code class="language-plaintext highlighter-rouge">enum</code>s can be implicitly converted to their underlying type. Implicit conversions are often not what you want, and scoped <code class="language-plaintext highlighter-rouge">enum</code>s don’t have this <em>“feature”</em>. Exactly because of the unwelcome implicit conversions, <a href="https://github.com/isocpp/CppCoreGuidelines/blob/master/CppCoreGuidelines.md#enum3-prefer-class-enums-over-plain-enums">the Core Guidelines strongly recommends using scoped over unscoped <code class="language-plaintext highlighter-rouge">enum</code>s</a>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">Print_color</span><span class="p">(</span><span class="kt">int</span> <span class="n">color</span><span class="p">);</span>

<span class="k">enum</span> <span class="n">Web_color</span> <span class="p">{</span> <span class="n">red</span> <span class="o">=</span> <span class="mh">0xFF0000</span><span class="p">,</span> <span class="n">green</span> <span class="o">=</span> <span class="mh">0x00FF00</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="mh">0x0000FF</span> <span class="p">};</span>
<span class="k">enum</span> <span class="n">Product_info</span> <span class="p">{</span> <span class="n">red</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">purple</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="mi">2</span> <span class="p">};</span>

<span class="n">Web_color</span> <span class="n">webby</span> <span class="o">=</span> <span class="n">Web_color</span><span class="o">::</span><span class="n">blue</span><span class="p">;</span>

<span class="c1">// Clearly at least one of these calls is buggy.</span>
<span class="n">Print_color</span><span class="p">(</span><span class="n">webby</span><span class="p">);</span>
<span class="n">Print_color</span><span class="p">(</span><span class="n">Product_info</span><span class="o">::</span><span class="n">blue</span><span class="p">);</span>
</pre></table></code></div></div><p>Unscoped <code class="language-plaintext highlighter-rouge">enum</code>s export their enumerators to the enclosing scope which might lead to name clashes. On the other hand, with scoped <code class="language-plaintext highlighter-rouge">enum</code>s, you must always specify the name of the <code class="language-plaintext highlighter-rouge">enum</code> alongside with the enumerators.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="k">enum</span> <span class="n">UnscopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="n">UnscopedColor</span> <span class="n">uc</span> <span class="o">=</span> <span class="n">red</span><span class="p">;</span>
    <span class="c1">// [[maybe_unused]] ScopedColor sc = red; // Doesn't compile</span>
    <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="n">ScopedColor</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">ScopedColor</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="what-else">What else</h2><p>Now that we saw how un/scoped <code class="language-plaintext highlighter-rouge">enum</code>s work and what are the differences between them, let’s see what other <code class="language-plaintext highlighter-rouge">enum</code> related functionalities the language or standard library offers.</p><h3 id="stdis_enum"><code class="language-plaintext highlighter-rouge">std::is_enum</code></h3><p>C++11 introduced the <code class="language-plaintext highlighter-rouge">&lt;type_traits&gt;</code> header. It includes utilities to check the properties of types. Not surprisingly <code class="language-plaintext highlighter-rouge">is_enum</code> is there to check whether a type is an <code class="language-plaintext highlighter-rouge">enum</code> of not. It returns <code class="language-plaintext highlighter-rouge">true</code> both for scoped and unscoped versions.</p><p>Since C++17, <code class="language-plaintext highlighter-rouge">is_enum_v</code> is also available for easier usage.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">UnscopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">S</span><span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">UnscopedColor</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_enum</span><span class="o">&lt;</span><span class="n">ScopedColor</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
              <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_enum_v</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><h3 id="stdunderlying_type"><code class="language-plaintext highlighter-rouge">std::underlying_type</code></h3><p><code class="language-plaintext highlighter-rouge">std::underlying_type</code> was also an addition to C++11. It helps us retrieve the underlying type of an <code class="language-plaintext highlighter-rouge">enum</code>. Until C++20 if the checked <code class="language-plaintext highlighter-rouge">enum</code> is not completely defined or not an <code class="language-plaintext highlighter-rouge">enum</code>, the behaviour is undefined. Starting with C++, the program becomes ill-formed for incomplete <code class="language-plaintext highlighter-rouge">enum</code> types.</p><p>C++14 introduced a related helper, <code class="language-plaintext highlighter-rouge">std::underlying_type_t</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">UnscopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">CharBasedColor</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span> <span class="n">red</span> <span class="o">=</span> <span class="sc">'r'</span><span class="p">,</span> <span class="n">green</span> <span class="o">=</span> <span class="sc">'g'</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="sc">'b'</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
 
  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">isUnscopedColorInt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type</span><span class="o">&lt;</span><span class="n">UnscopedColor</span><span class="o">&gt;::</span><span class="n">type</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">isScopedColorInt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">ScopedColor</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">isCharBasedColorInt</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">CharBasedColor</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="o">&gt;</span><span class="p">;</span>
  <span class="k">constexpr</span> <span class="kt">bool</span> <span class="n">isCharBasedColorChar</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">is_same_v</span><span class="o">&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">CharBasedColor</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">char</span> <span class="o">&gt;</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">cout</span>
    <span class="o">&lt;&lt;</span> <span class="s">"underlying type for 'UnscopedColor' is "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">isUnscopedColorInt</span> <span class="o">?</span> <span class="s">"int"</span> <span class="o">:</span> <span class="s">"non-int"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
    <span class="o">&lt;&lt;</span> <span class="s">"underlying type for 'ScopedColor' is "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">isScopedColorInt</span> <span class="o">?</span> <span class="s">"int"</span> <span class="o">:</span> <span class="s">"non-int"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
    <span class="o">&lt;&lt;</span> <span class="s">"underlying type for 'CharBasedColor' is "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">isCharBasedColorInt</span> <span class="o">?</span> <span class="s">"int"</span> <span class="o">:</span> <span class="s">"non-int"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
    <span class="o">&lt;&lt;</span> <span class="s">"underlying type for 'CharBasedColor' is "</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">isCharBasedColorChar</span> <span class="o">?</span> <span class="s">"char"</span> <span class="o">:</span> <span class="s">"non-char"</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span>
    <span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="using-enum-declaration-since-c20">Using-enum-declaration since C++20</h3><p>Since C++20, use can use <code class="language-plaintext highlighter-rouge">using</code> with <code class="language-plaintext highlighter-rouge">enum</code>s. It introduces the enumerator names in the given scope.</p><p>The feature is smart enough to raise a compilation error in case a second <code class="language-plaintext highlighter-rouge">using</code> would introduce an enumerator name that was already introduced from another <code class="language-plaintext highlighter-rouge">enum</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">CharBasedColor</span> <span class="o">:</span> <span class="kt">char</span> <span class="p">{</span> <span class="n">red</span> <span class="o">=</span> <span class="sc">'r'</span><span class="p">,</span> <span class="n">green</span> <span class="o">=</span> <span class="sc">'g'</span><span class="p">,</span> <span class="n">blue</span> <span class="o">=</span> <span class="sc">'b'</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">using</span> <span class="k">enum</span> <span class="n">ScopedColor</span><span class="p">;</span> <span class="c1">// OK!</span>
  <span class="k">using</span> <span class="k">enum</span> <span class="n">CharBasedColor</span><span class="p">;</span> <span class="c1">// error: 'CharBasedColor CharBasedColor::red' conflicts with a previous declaration</span>
<span class="p">}</span>
</pre></table></code></div></div><p>It’s worth noting that it doesn’t recognize if an unscoped enum already introduced an enumerator name in the given namespace. In the following example, there is already <code class="language-plaintext highlighter-rouge">red</code>, <code class="language-plaintext highlighter-rouge">green</code>, and <code class="language-plaintext highlighter-rouge">blue</code> available from <code class="language-plaintext highlighter-rouge">UnscopedColor</code>, still, the <code class="language-plaintext highlighter-rouge">using</code> of <code class="language-plaintext highlighter-rouge">ScopedColor</code> with the same enumerator names is accepted.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span>
<span class="k">enum</span> <span class="n">UnscopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">using</span> <span class="k">enum</span> <span class="n">ScopedColor</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="c23-brings-stdis_scoped_enum">C++23 brings <code class="language-plaintext highlighter-rouge">std::is_scoped_enum</code></h3><p>C++23 will introduce one more <code class="language-plaintext highlighter-rouge">enum</code> related function in the <code class="language-plaintext highlighter-rouge">&lt;type_traits&gt;</code> header, one of it is <code class="language-plaintext highlighter-rouge">std::is_scoped_enum</code> and it’s helper function <code class="language-plaintext highlighter-rouge">std::is_scoped_enum_v</code>. As the name suggests and the below snippet proves, it checks whether it is argument is a <strong>scoped</strong> <code class="language-plaintext highlighter-rouge">enum</code> or not.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
</span> 
<span class="k">enum</span> <span class="n">UnscopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>
<span class="k">struct</span> <span class="nc">S</span><span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">boolalpha</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_scoped_enum</span><span class="o">&lt;</span><span class="n">UnscopedColor</span><span class="o">&gt;::</span><span class="n">value</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_scoped_enum_v</span><span class="o">&lt;</span><span class="n">ScopedColor</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_scoped_enum_v</span><span class="o">&lt;</span><span class="n">S</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">is_scoped_enum_v</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
false
true
false
false
*/</span>
</pre></table></code></div></div><p>If you want to try out C++23 features, use the <code class="language-plaintext highlighter-rouge">-std=c++2b</code> compiler flag.</p><h3 id="c23-introduces-stdto_underlying">C++23 introduces <code class="language-plaintext highlighter-rouge">std::to_underlying</code></h3><p>C++23 will introduce another library feature for <code class="language-plaintext highlighter-rouge">enum</code>s. The <code class="language-plaintext highlighter-rouge">&lt;utility&gt;</code> header will be enriched with <code class="language-plaintext highlighter-rouge">std::to_underlying</code>. It converts an <code class="language-plaintext highlighter-rouge">enum</code> to its underlying type. As mentioned, this is a library feature, meaning that it can be implemented in earlier versions.</p><p>This one is can be replaced with a <code class="language-plaintext highlighter-rouge">static_cast</code> if you have access only to earlier versions: <code class="language-plaintext highlighter-rouge">static_cast&lt;std::underlying_type_t&lt;MyEnum&gt;&gt;(e);</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;type_traits&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;utility&gt;</span><span class="cp">
</span> 
<span class="k">enum</span> <span class="k">class</span> <span class="nc">ScopedColor</span> <span class="p">{</span> <span class="n">red</span><span class="p">,</span> <span class="n">green</span><span class="p">,</span> <span class="n">blue</span> <span class="p">};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> 
<span class="p">{</span>
    <span class="n">ScopedColor</span> <span class="n">sc</span> <span class="o">=</span> <span class="n">ScopedColor</span><span class="o">::</span><span class="n">red</span><span class="p">;</span>
    <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="kt">int</span> <span class="n">underlying</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_underlying</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
    <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="kt">int</span> <span class="n">underlyingEmulated</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">ScopedColor</span><span class="o">&gt;&gt;</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
    <span class="p">[[</span><span class="n">maybe_unused</span><span class="p">]]</span> <span class="n">std</span><span class="o">::</span><span class="n">underlying_type_t</span><span class="o">&lt;</span><span class="n">ScopedColor</span><span class="o">&gt;</span> <span class="n">underlyingDeduced</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">to_underlying</span><span class="p">(</span><span class="n">sc</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>As a reminder, let me repate that if you want to try out C++23 features, use the <code class="language-plaintext highlighter-rouge">-std=c++2b</code> compiler flag.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we discussed all the language and library features that are about enumerations. We saw how scoped and unscoped <code class="language-plaintext highlighter-rouge">enum</code>s differ and why it’s better to use scoped <code class="language-plaintext highlighter-rouge">enum</code>s. That’s not the only <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#S-enum">Core Guidelines</a> recommendation we discussed.</p><p>Then we checked how the standard library has been enriched during the years supporting an easier work with <code class="language-plaintext highlighter-rouge">enum</code>s. We also had a sneak peek into the future and checked what C++23 will bring for us.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp20/" class="post-tag no-text-decoration" >cpp20</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/enums/" class="post-tag no-text-decoration" >enums</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=The evolution of enums - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=The evolution of enums - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=The evolution of enums - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=The evolution of enums - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/04/16/raw-loops-for-performance"><div class="card-body"> <span class="timeago small" > Apr 16 <i class="unloaded">2025-04-16T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Raw loops for performance?</h3><div class="text-muted small"><p> To my greatest satisfaction, I’ve recently joined a new project. I started to read through the codebase before joining and at that stage, whenever I saw a possibility for a minor improvement, I rai...</p></div></div></a></div><div class="card"> <a href="/blog/2021/04/03/cpp20-get-the-details-rainer-grimm"><div class="card-body"> <span class="timeago small" > Apr 3, 2021 <i class="unloaded">2021-04-03T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++ 20: Get the details by Rainer Grimm</h3><div class="text-muted small"><p> I could say that I picked C++ 20: Get the details up because I wanted to learn about the latest version of C++. I wouldn’t lie if I said so, but truth be told I was already an avid reader of Modern...</p></div></div></a></div><div class="card"> <a href="/blog/2022/04/13/first-company-project-experience-with-cpp20"><div class="card-body"> <span class="timeago small" > Apr 13, 2022 <i class="unloaded">2022-04-13T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>My first work experience with C++20</h3><div class="text-muted small"><p> I joined a new team recently. We have our own internal microservices as well as libraries. While for microservices we support one main branch, for libraries we do have to support at least three, in...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/02/08/binary-sizes-and-virtual" class="btn btn-outline-primary" prompt="Older"><p>Virtual functions and binary sizes</p></a> <a href="/blog/2023/02/22/4-ways-of-my-remote-journey" class="btn btn-outline-primary" prompt="Newer"><p>4 different ways I've worked remotely</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'The evolution of enums'; this.page.url = 'https://www.sandordargo.com/blog/2023/02/15/evolution-of-enums'; this.page.identifier = '/blog/2023/02/15/evolution-of-enums'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
