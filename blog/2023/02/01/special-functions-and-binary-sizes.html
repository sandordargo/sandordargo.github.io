<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Special functions and binary sizes" /><meta property="og:locale" content="en_US" /><meta name="description" content="These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member functions. We are going to discuss whether it matters or not if we make our special functions default or if we provide empty implementations. We are also going to see if we should have the implementations in the header or in the cpp files. Or maybe not having them all is the best? The simplest cases For my first tests, I used this very simple piece of code as a basis: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;array&gt; class C { public: C() = default; ~C() = default; C(const C&amp;) = default; C(C&amp;&amp;) = default; C&amp; operator=(const C&amp;) = default; C&amp; operator=(C&amp;&amp;) = default; }; std::array&lt;C, 10000&gt; a{}; int main() { } I took this simple class and modified it in various ways. I compiled 6 different versions: special functions with defaulted at declaration time special functions with empty implementation in the class declaration no special functions at all, abiding to the rule of 0 I tried all these both with virtual and with non-virtual destructors The results are here: Version Binary size default non-virtual 16K default virtual 116K empty non-virtual 17-34K empty virtual 33-34K missing non-virtual 16K missing virtual 116K I found no huge differences in compile time and runtime, even though my tests here were not very thorough. I created classes with a virtual destructor, but I haven’t used them in a polymorphic way. That’s not for today. I made here two interesting observations. If our class doesn’t have a virtual destructor, then either defaulting the special functions or completely omitting them potentially leaves us with a smaller binary than if we provide empty implementations. With an empty implementation, it depends on the optimization level. I think it’s because if we let the compiler generate these functions, it can optimize better. We also have to mention that a defaulted special function can be implicitly noexcept. But it won’t be noexcept if you provide an empty implementation and you don’t declare it explicitly noexcept Another interesting observation was that for classes with a virtual destructor and an empty implementation always generated smaller code than the default implementations. While it’s clear that we shouldn’t add a virtual destructor to a class if it was not meant to be used polymorphically, this latter observation bothers me a bit. Then I realized that while the first tests gave me an interesting start, I should clearly be closer to real usage. Classes are rarely declared at the same translation unit with main(), they are often used by different translation units and classes are very often separated into a different header and implementation file. Besides, classes more often than not have member variables. So I decided to run more experiments. The results of the next tests I incrementally implemented the missing items to see how the numbers change. main and the non-virtual class in different files First of all, I separated the main() and the class into different files. As a first step, I kept the implementation in the header file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // c.h class C { public: C() = default; ~C() = default; C(const C&amp;) = default; C(C&amp;&amp;) = default; C&amp; operator=(const C&amp;) = default; C&amp; operator=(C&amp;&amp;) = default; }; // main.cpp #include &quot;c.h&quot; #include &lt;array&gt; std::array&lt;C, 10000&gt; a; int main() { } Then I also ran some tests where I defaulted the implementations in the cpp file. Then I did the same experiments with empty implementations. Something we can so often see in old code. I ended up with these numbers: Version Binary size default non-virtual header/only 16K default non-virtual separated 34K empty non-virtual header-only 15-34K empty non-virtual separated 34K I skipped run-times and compile-times here, because the differences are so little, that I don’t think it makes sense to include those. So what seems interesting to see is that for these non-polymorphic classes, the header-only versions produced a smaller binary both when they are defaulted and also when the implementations are left empty. main and the virtual class in different files Let’s see what the numbers say for a virtual class. Version Binary size default virtual header/only. 116K default virtual separated 34K empty virtual header-only 33-34K empty virtual separated 17-34 Polymorphic and non-polymorphic classes seemingly behave the opposite way. While for non-virtual classes header-only implementations resulted in a smaller binary, for polymorphic classes moving the implementations to the cpp file was a clear win and the empty implementation was even smaller than the defaulted one. Don’t get me wrong, I’m not advocating for an empty implementation over a default one, the default has several advantages, I’m simply sharing what I found while I was implementing. In the defaulted version’s assembly, we can see the line .quad __ZTV1C+16 exactly 10,000 times. For the empty implementation, instead of that, we can observe once again a .zero fill. For some reason, the compiler was able to deduce something for the empty implementation that it could not for the defaulted one. So how should we implement special functions? First of all, we should not. Whenever possible, we should follow the rule of zero. By all means, that’s the best. But assuming that you have to implement your special functions what to do is not obvious. In our examples, we saw that empty implementations ({}) might produce smaller binaries than defaulted ones in case you have a virtual destructor. Still, I wouldn’t go for empty implementations. The ones generated by the compiler might not be completely the same, and the compiler knows it better than us. A defaulted special function might be noexcept, while an empty implementation will only be noexcept if you explicitly state so. Some time ago, I posted a question on Twitter and I got some answers from Jason Turner. His opinion was that I should certainly default in the header. “If you forward declare an explicitly defaulted constructor then you’re going to tell the compiler “Ooooh, I have something important for you, you’ll find it later” Then later you say “haha, just kidding, it’s really just a default constructor!” Later he also mentioned that this can be a technique if you explicitly want to out-of-line a defaulted constructor because of compile times. And I have to add that eventually for binary size too. At the same time, it should be documented somewhere and widely known in the organization, because it’s not intuitive and someone will come to move those definitions back to the header where it belongs. Jason is right. I’ve been there, I’ve done that myself. No, not the documentation part… For classes with non-virtual destructors, we should definitely avoid out-of-line destructors because of three reasons: as said, it decreases readability it might increase the binary size a default outside of the class declaration is considered a user-provided constructor/destructor and therefore the class is not trivial anymore For polymorphic classes, it’s different though. First of all, they are not trivial. Second, the binary size would actually decrease by moving things out of line. So it boils down to binary size and probably a bit of compile-time vs readability. Then the answer is it depends. If you optimize for binary size, then I think you should move virtual destructors out of line. And if you do it for the destructor, I’d take the others too so that it looks less strange. But don’t forget to measure to see if it really has an impact. The class has to be used with lots of instances. Conclusion Today we were looking for understanding what to do with special member functions of a class if we want to walk away with the smallest binary. We did different experiments and we saw that the outcomes and suggestions are different based on whether the destructor is virtual or not. For classes with virtual destructors, it’s worth considering moving the implementation (even if it’s the default) out of line, out of the header file. On the other hand for classes with non-virtual destructors, there is no reason to provide special members out of line. Next time we’ll keep discovering how having a virtual destructor is affecting our binaries. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member functions. We are going to discuss whether it matters or not if we make our special functions default or if we provide empty implementations. We are also going to see if we should have the implementations in the header or in the cpp files. Or maybe not having them all is the best? The simplest cases For my first tests, I used this very simple piece of code as a basis: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;array&gt; class C { public: C() = default; ~C() = default; C(const C&amp;) = default; C(C&amp;&amp;) = default; C&amp; operator=(const C&amp;) = default; C&amp; operator=(C&amp;&amp;) = default; }; std::array&lt;C, 10000&gt; a{}; int main() { } I took this simple class and modified it in various ways. I compiled 6 different versions: special functions with defaulted at declaration time special functions with empty implementation in the class declaration no special functions at all, abiding to the rule of 0 I tried all these both with virtual and with non-virtual destructors The results are here: Version Binary size default non-virtual 16K default virtual 116K empty non-virtual 17-34K empty virtual 33-34K missing non-virtual 16K missing virtual 116K I found no huge differences in compile time and runtime, even though my tests here were not very thorough. I created classes with a virtual destructor, but I haven’t used them in a polymorphic way. That’s not for today. I made here two interesting observations. If our class doesn’t have a virtual destructor, then either defaulting the special functions or completely omitting them potentially leaves us with a smaller binary than if we provide empty implementations. With an empty implementation, it depends on the optimization level. I think it’s because if we let the compiler generate these functions, it can optimize better. We also have to mention that a defaulted special function can be implicitly noexcept. But it won’t be noexcept if you provide an empty implementation and you don’t declare it explicitly noexcept Another interesting observation was that for classes with a virtual destructor and an empty implementation always generated smaller code than the default implementations. While it’s clear that we shouldn’t add a virtual destructor to a class if it was not meant to be used polymorphically, this latter observation bothers me a bit. Then I realized that while the first tests gave me an interesting start, I should clearly be closer to real usage. Classes are rarely declared at the same translation unit with main(), they are often used by different translation units and classes are very often separated into a different header and implementation file. Besides, classes more often than not have member variables. So I decided to run more experiments. The results of the next tests I incrementally implemented the missing items to see how the numbers change. main and the non-virtual class in different files First of all, I separated the main() and the class into different files. As a first step, I kept the implementation in the header file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // c.h class C { public: C() = default; ~C() = default; C(const C&amp;) = default; C(C&amp;&amp;) = default; C&amp; operator=(const C&amp;) = default; C&amp; operator=(C&amp;&amp;) = default; }; // main.cpp #include &quot;c.h&quot; #include &lt;array&gt; std::array&lt;C, 10000&gt; a; int main() { } Then I also ran some tests where I defaulted the implementations in the cpp file. Then I did the same experiments with empty implementations. Something we can so often see in old code. I ended up with these numbers: Version Binary size default non-virtual header/only 16K default non-virtual separated 34K empty non-virtual header-only 15-34K empty non-virtual separated 34K I skipped run-times and compile-times here, because the differences are so little, that I don’t think it makes sense to include those. So what seems interesting to see is that for these non-polymorphic classes, the header-only versions produced a smaller binary both when they are defaulted and also when the implementations are left empty. main and the virtual class in different files Let’s see what the numbers say for a virtual class. Version Binary size default virtual header/only. 116K default virtual separated 34K empty virtual header-only 33-34K empty virtual separated 17-34 Polymorphic and non-polymorphic classes seemingly behave the opposite way. While for non-virtual classes header-only implementations resulted in a smaller binary, for polymorphic classes moving the implementations to the cpp file was a clear win and the empty implementation was even smaller than the defaulted one. Don’t get me wrong, I’m not advocating for an empty implementation over a default one, the default has several advantages, I’m simply sharing what I found while I was implementing. In the defaulted version’s assembly, we can see the line .quad __ZTV1C+16 exactly 10,000 times. For the empty implementation, instead of that, we can observe once again a .zero fill. For some reason, the compiler was able to deduce something for the empty implementation that it could not for the defaulted one. So how should we implement special functions? First of all, we should not. Whenever possible, we should follow the rule of zero. By all means, that’s the best. But assuming that you have to implement your special functions what to do is not obvious. In our examples, we saw that empty implementations ({}) might produce smaller binaries than defaulted ones in case you have a virtual destructor. Still, I wouldn’t go for empty implementations. The ones generated by the compiler might not be completely the same, and the compiler knows it better than us. A defaulted special function might be noexcept, while an empty implementation will only be noexcept if you explicitly state so. Some time ago, I posted a question on Twitter and I got some answers from Jason Turner. His opinion was that I should certainly default in the header. “If you forward declare an explicitly defaulted constructor then you’re going to tell the compiler “Ooooh, I have something important for you, you’ll find it later” Then later you say “haha, just kidding, it’s really just a default constructor!” Later he also mentioned that this can be a technique if you explicitly want to out-of-line a defaulted constructor because of compile times. And I have to add that eventually for binary size too. At the same time, it should be documented somewhere and widely known in the organization, because it’s not intuitive and someone will come to move those definitions back to the header where it belongs. Jason is right. I’ve been there, I’ve done that myself. No, not the documentation part… For classes with non-virtual destructors, we should definitely avoid out-of-line destructors because of three reasons: as said, it decreases readability it might increase the binary size a default outside of the class declaration is considered a user-provided constructor/destructor and therefore the class is not trivial anymore For polymorphic classes, it’s different though. First of all, they are not trivial. Second, the binary size would actually decrease by moving things out of line. So it boils down to binary size and probably a bit of compile-time vs readability. Then the answer is it depends. If you optimize for binary size, then I think you should move virtual destructors out of line. And if you do it for the destructor, I’d take the others too so that it looks less strange. But don’t forget to measure to see if it really has an impact. The class has to be used with lots of instances. Conclusion Today we were looking for understanding what to do with special member functions of a class if we want to walk away with the smallest binary. We did different experiments and we saw that the outcomes and suggestions are different based on whether the destructor is virtual or not. For classes with virtual destructors, it’s worth considering moving the implementation (even if it’s the default) out of line, out of the header file. On the other hand for classes with non-virtual destructors, there is no reason to provide special members out of line. Next time we’ll keep discovering how having a virtual destructor is affecting our binaries. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-02-01T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Special functions and binary sizes" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-02-01T00:00:00+01:00","datePublished":"2023-02-01T00:00:00+01:00","description":"These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member functions. We are going to discuss whether it matters or not if we make our special functions default or if we provide empty implementations. We are also going to see if we should have the implementations in the header or in the cpp files. Or maybe not having them all is the best? The simplest cases For my first tests, I used this very simple piece of code as a basis: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;array&gt; class C { public: C() = default; ~C() = default; C(const C&amp;) = default; C(C&amp;&amp;) = default; C&amp; operator=(const C&amp;) = default; C&amp; operator=(C&amp;&amp;) = default; }; std::array&lt;C, 10000&gt; a{}; int main() { } I took this simple class and modified it in various ways. I compiled 6 different versions: special functions with defaulted at declaration time special functions with empty implementation in the class declaration no special functions at all, abiding to the rule of 0 I tried all these both with virtual and with non-virtual destructors The results are here: Version Binary size default non-virtual 16K default virtual 116K empty non-virtual 17-34K empty virtual 33-34K missing non-virtual 16K missing virtual 116K I found no huge differences in compile time and runtime, even though my tests here were not very thorough. I created classes with a virtual destructor, but I haven’t used them in a polymorphic way. That’s not for today. I made here two interesting observations. If our class doesn’t have a virtual destructor, then either defaulting the special functions or completely omitting them potentially leaves us with a smaller binary than if we provide empty implementations. With an empty implementation, it depends on the optimization level. I think it’s because if we let the compiler generate these functions, it can optimize better. We also have to mention that a defaulted special function can be implicitly noexcept. But it won’t be noexcept if you provide an empty implementation and you don’t declare it explicitly noexcept Another interesting observation was that for classes with a virtual destructor and an empty implementation always generated smaller code than the default implementations. While it’s clear that we shouldn’t add a virtual destructor to a class if it was not meant to be used polymorphically, this latter observation bothers me a bit. Then I realized that while the first tests gave me an interesting start, I should clearly be closer to real usage. Classes are rarely declared at the same translation unit with main(), they are often used by different translation units and classes are very often separated into a different header and implementation file. Besides, classes more often than not have member variables. So I decided to run more experiments. The results of the next tests I incrementally implemented the missing items to see how the numbers change. main and the non-virtual class in different files First of all, I separated the main() and the class into different files. As a first step, I kept the implementation in the header file. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 // c.h class C { public: C() = default; ~C() = default; C(const C&amp;) = default; C(C&amp;&amp;) = default; C&amp; operator=(const C&amp;) = default; C&amp; operator=(C&amp;&amp;) = default; }; // main.cpp #include &quot;c.h&quot; #include &lt;array&gt; std::array&lt;C, 10000&gt; a; int main() { } Then I also ran some tests where I defaulted the implementations in the cpp file. Then I did the same experiments with empty implementations. Something we can so often see in old code. I ended up with these numbers: Version Binary size default non-virtual header/only 16K default non-virtual separated 34K empty non-virtual header-only 15-34K empty non-virtual separated 34K I skipped run-times and compile-times here, because the differences are so little, that I don’t think it makes sense to include those. So what seems interesting to see is that for these non-polymorphic classes, the header-only versions produced a smaller binary both when they are defaulted and also when the implementations are left empty. main and the virtual class in different files Let’s see what the numbers say for a virtual class. Version Binary size default virtual header/only. 116K default virtual separated 34K empty virtual header-only 33-34K empty virtual separated 17-34 Polymorphic and non-polymorphic classes seemingly behave the opposite way. While for non-virtual classes header-only implementations resulted in a smaller binary, for polymorphic classes moving the implementations to the cpp file was a clear win and the empty implementation was even smaller than the defaulted one. Don’t get me wrong, I’m not advocating for an empty implementation over a default one, the default has several advantages, I’m simply sharing what I found while I was implementing. In the defaulted version’s assembly, we can see the line .quad __ZTV1C+16 exactly 10,000 times. For the empty implementation, instead of that, we can observe once again a .zero fill. For some reason, the compiler was able to deduce something for the empty implementation that it could not for the defaulted one. So how should we implement special functions? First of all, we should not. Whenever possible, we should follow the rule of zero. By all means, that’s the best. But assuming that you have to implement your special functions what to do is not obvious. In our examples, we saw that empty implementations ({}) might produce smaller binaries than defaulted ones in case you have a virtual destructor. Still, I wouldn’t go for empty implementations. The ones generated by the compiler might not be completely the same, and the compiler knows it better than us. A defaulted special function might be noexcept, while an empty implementation will only be noexcept if you explicitly state so. Some time ago, I posted a question on Twitter and I got some answers from Jason Turner. His opinion was that I should certainly default in the header. “If you forward declare an explicitly defaulted constructor then you’re going to tell the compiler “Ooooh, I have something important for you, you’ll find it later” Then later you say “haha, just kidding, it’s really just a default constructor!” Later he also mentioned that this can be a technique if you explicitly want to out-of-line a defaulted constructor because of compile times. And I have to add that eventually for binary size too. At the same time, it should be documented somewhere and widely known in the organization, because it’s not intuitive and someone will come to move those definitions back to the header where it belongs. Jason is right. I’ve been there, I’ve done that myself. No, not the documentation part… For classes with non-virtual destructors, we should definitely avoid out-of-line destructors because of three reasons: as said, it decreases readability it might increase the binary size a default outside of the class declaration is considered a user-provided constructor/destructor and therefore the class is not trivial anymore For polymorphic classes, it’s different though. First of all, they are not trivial. Second, the binary size would actually decrease by moving things out of line. So it boils down to binary size and probably a bit of compile-time vs readability. Then the answer is it depends. If you optimize for binary size, then I think you should move virtual destructors out of line. And if you do it for the destructor, I’d take the others too so that it looks less strange. But don’t forget to measure to see if it really has an impact. The class has to be used with lots of instances. Conclusion Today we were looking for understanding what to do with special member functions of a class if we want to walk away with the smallest binary. We did different experiments and we saw that the outcomes and suggestions are different based on whether the destructor is virtual or not. For classes with virtual destructors, it’s worth considering moving the implementation (even if it’s the default) out of line, out of the header file. On the other hand for classes with non-virtual destructors, there is no reason to provide special members out of line. Next time we’ll keep discovering how having a virtual destructor is affecting our binaries. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Special functions and binary sizes","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes"},"url":"https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes"}</script><title>Special functions and binary sizes | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/02"> 02 </a> </span> <span> <a href="/01"> 01 </a> </span> <span>Special functions and binary sizes</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Special functions and binary sizes</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Feb 1, 2023, 12:00 AM +0100" prep="on" > Feb 1, 2023 <i class="unloaded">2023-02-01T00:00:00+01:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1431 words">7 min</span></div></div><div class="post-content"><p>These months, I try to better understand how our code affects binary sizes. Last week, we had a look into storage durations and memory allocations. This week, let’s have a look into special member functions.</p><p>We are going to discuss whether it matters or not if we make our special functions <code class="language-plaintext highlighter-rouge">default</code> or if we provide <code class="language-plaintext highlighter-rouge">empty</code> implementations. We are also going to see if we should have the implementations in the header or in the cpp files. Or maybe not having them all is the best?</p><h2 id="the-simplest-cases">The simplest cases</h2><p>For my first tests, I used this very simple piece of code as a basis:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="n">C</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="p">};</span>

<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="mi">10000</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">{};</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
	
<span class="p">}</span>
</pre></table></code></div></div><p>I took this simple class and modified it in various ways. I compiled 6 different versions:</p><ul><li>special functions with defaulted at declaration time<li>special functions with empty implementation in the class declaration<li>no special functions at all, abiding to the rule of 0<li>I tried all these both with <code class="language-plaintext highlighter-rouge">virtual</code> and with non-<code class="language-plaintext highlighter-rouge">virtual</code> destructors</ul><p>The results are here:</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>default non-virtual<td>16K<tr><td>default virtual<td>116K<tr><td>empty non-virtual<td>17-34K<tr><td>empty virtual<td>33-34K<tr><td>missing non-virtual<td>16K<tr><td>missing virtual<td>116K</table></div><p>I found no huge differences in compile time and runtime, even though my tests here were not very thorough. I created classes with a virtual destructor, but I haven’t used them in a polymorphic way. That’s not for today.</p><p>I made here two interesting observations. If our class doesn’t have a <code class="language-plaintext highlighter-rouge">virtual</code> destructor, then either defaulting the special functions or completely omitting them potentially leaves us with a smaller binary than if we provide empty implementations. With an empty implementation, it depends on the optimization level. I think it’s because if we let the compiler generate these functions, it can optimize better. We also have to mention that a defaulted special function can be implicitly <code class="language-plaintext highlighter-rouge">noexcept</code>. But it won’t be <code class="language-plaintext highlighter-rouge">noexcept</code> if you provide an empty implementation and you don’t declare it explicitly <code class="language-plaintext highlighter-rouge">noexcept</code></p><p>Another interesting observation was that for classes with a virtual destructor and an empty implementation always generated smaller code than the default implementations.</p><p>While it’s clear that we shouldn’t add a <code class="language-plaintext highlighter-rouge">virtual</code> destructor to a class if it was not meant to be used polymorphically, this latter observation bothers me a bit.</p><p>Then I realized that while the first tests gave me an interesting start, I should clearly be closer to real usage.</p><p>Classes are rarely declared at the same translation unit with <code class="language-plaintext highlighter-rouge">main()</code>, they are often used by different translation units and classes are very often separated into a different header and implementation file.</p><p>Besides, classes more often than not have member variables.</p><p>So I decided to run more experiments.</p><h2 id="the-results-of-the-next-tests">The results of the next tests</h2><p>I incrementally implemented the missing items to see how the numbers change.</p><h3 id="main-and-the-non-virtual-class-in-different-files"><code class="language-plaintext highlighter-rouge">main</code> and the non-virtual class in different files</h3><p>First of all, I separated the <code class="language-plaintext highlighter-rouge">main()</code> and the class into different files. As a first step, I kept the implementation in the header file.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
</pre><td class="rouge-code"><pre><span class="c1">// c.h</span>
<span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>
<span class="nl">public:</span>
	<span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="o">~</span><span class="n">C</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

	<span class="n">C</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">C</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">C</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
	<span class="n">C</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">C</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

<span class="p">};</span>

<span class="c1">// main.cpp</span>
<span class="cp">#include</span> <span class="cpf">"c.h"</span><span class="cp">
#include</span> <span class="cpf">&lt;array&gt;</span><span class="cp">
</span>
<span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="n">C</span><span class="p">,</span> <span class="mi">10000</span><span class="o">&gt;</span> <span class="n">a</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

<span class="p">}</span>
</pre></table></code></div></div><p>Then I also ran some tests where I defaulted the implementations in the cpp file. Then I did the same experiments with empty implementations. Something we can so often see in old code.</p><p>I ended up with these numbers:</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>default non-virtual header/only<td>16K<tr><td>default non-virtual separated<td>34K<tr><td>empty non-virtual header-only<td>15-34K<tr><td>empty non-virtual separated<td>34K</table></div><p>I skipped run-times and compile-times here, because the differences are so little, that I don’t think it makes sense to include those.</p><p>So what seems interesting to see is that for these non-polymorphic classes, the header-only versions produced a smaller binary both when they are defaulted and also when the implementations are left empty.</p><h3 id="main-and-the-virtual-class-in-different-files"><code class="language-plaintext highlighter-rouge">main</code> and the virtual class in different files</h3><p>Let’s see what the numbers say for a virtual class.</p><div class="table-wrapper"><table><thead><tr><th>Version<th>Binary size<tbody><tr><td>default virtual header/only.<td>116K<tr><td>default virtual separated<td>34K<tr><td>empty virtual header-only<td>33-34K<tr><td>empty virtual separated<td>17-34</table></div><p>Polymorphic and non-polymorphic classes seemingly behave the opposite way. While for non-<code class="language-plaintext highlighter-rouge">virtual</code> classes header-only implementations resulted in a smaller binary, for polymorphic classes moving the implementations to the cpp file was a clear win and the empty implementation was even smaller than the defaulted one.</p><p>Don’t get me wrong, I’m not advocating for an empty implementation over a default one, the default has several advantages, I’m simply sharing what I found while I was implementing.</p><p>In the defaulted version’s assembly, we can see the line <code class="language-plaintext highlighter-rouge">.quad __ZTV1C+16</code> exactly 10,000 times. For the empty implementation, instead of that, we can observe once again a <code class="language-plaintext highlighter-rouge">.zero fill</code>. For some reason, the compiler was able to deduce something for the empty implementation that it could not for the <code class="language-plaintext highlighter-rouge">default</code>ed one.</p><h2 id="so-how-should-we-implement-special-functions">So how should we implement special functions?</h2><p>First of all, we should not. Whenever possible, we should follow the rule of zero. By all means, that’s the best.</p><p>But assuming that you have to implement your special functions what to do is not obvious. In our examples, we saw that empty implementations (<code class="language-plaintext highlighter-rouge">{}</code>) might produce smaller binaries than defaulted ones in case you have a <code class="language-plaintext highlighter-rouge">virtual</code> destructor. Still, I wouldn’t go for empty implementations. The ones generated by the compiler might not be completely the same, and the compiler knows it better than us. A defaulted special function might be <code class="language-plaintext highlighter-rouge">noexcept</code>, while an empty implementation will only be <code class="language-plaintext highlighter-rouge">noexcept</code> if you explicitly state so.</p><p>Some time ago, <a href="https://twitter.com/lefticus/status/1406965561326596101">I posted a question on Twitter and I got some answers from Jason Turner</a>. His opinion was that I should certainly default in the header. “If you forward declare an explicitly defaulted constructor then you’re going to tell the compiler “Ooooh, I have something important for you, you’ll find it later” Then later you say “haha, just kidding, it’s really just a default constructor!”</p><p>Later he also mentioned that this can be a technique if you explicitly want to out-of-line a defaulted constructor because of compile times. And I have to add that eventually for binary size too.</p><p>At the same time, it should be documented somewhere and widely known in the organization, because it’s not intuitive and someone will come to move those definitions back to the header where it belongs. Jason is right. I’ve been there, I’ve done that myself. No, not the documentation part…</p><p>For classes with non-<code class="language-plaintext highlighter-rouge">virtual</code> destructors, we should definitely avoid out-of-line destructors because of three reasons:</p><ul><li>as said, it decreases readability<li>it might increase the binary size<li>a <code class="language-plaintext highlighter-rouge">default</code> outside of the class declaration is considered a user-provided constructor/destructor and therefore the class is not trivial anymore</ul><p>For polymorphic classes, it’s different though. First of all, they are not trivial. Second, the binary size would actually decrease by moving things out of line.</p><p>So it boils down to binary size and probably a bit of compile-time vs readability.</p><p>Then the answer is it depends. If you optimize for binary size, then I think you should move virtual destructors out of line. And if you do it for the destructor, I’d take the others too so that it looks less strange. But don’t forget to measure to see if it really has an impact. The class has to be used with lots of instances.</p><h2 id="conclusion">Conclusion</h2><p>Today we were looking for understanding what to do with special member functions of a class if we want to walk away with the smallest binary. We did different experiments and we saw that the outcomes and suggestions are different based on whether the destructor is virtual or not.</p><p>For classes with virtual destructors, it’s worth considering moving the implementation (even if it’s the default) out of line, out of the header file. On the other hand for classes with non-virtual destructors, there is no reason to provide special members out of line.</p><p>Next time we’ll keep discovering how having a virtual destructor is affecting our binaries.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/binarysizes/" class="post-tag no-text-decoration" >binarysizes</a> <a href="/tags/executables/" class="post-tag no-text-decoration" >executables</a> <a href="/tags/compilation/" class="post-tag no-text-decoration" >compilation</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Special functions and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Special functions and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Special functions and binary sizes - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Special functions and binary sizes - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/01/11/executable-and-its-structure"><div class="card-body"> <span class="timeago small" > Jan 11, 2023 <i class="unloaded">2023-01-11T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What's an executable and how is it structured</h3><div class="text-muted small"><p> In this post, let’s have a look at how executables are generated, what are the most important executable formats and how they are structured. How executables are generated? In this section let’s ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/01/18/object-initialization-and-binary-sizes"><div class="card-body"> <span class="timeago small" > Jan 18, 2023 <i class="unloaded">2023-01-18T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Object initialization and binary sizes</h3><div class="text-muted small"><p> Let’s have this piece of code that generates a big binary. #include &lt;array&gt; struct Node { int a = 1, b = 1; }; std::array &lt;Node, 10'000&gt; a; int main() {} If you compile this p...</p></div></div></a></div><div class="card"> <a href="/blog/2023/02/08/binary-sizes-and-virtual"><div class="card-body"> <span class="timeago small" > Feb 8, 2023 <i class="unloaded">2023-02-08T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Virtual functions and binary sizes</h3><div class="text-muted small"><p> In the previous article of this series on binary sizes, we discussed how special functions’ implementations - or their lack of - influence the size of the generated binary. Our conclusion was that...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/01/25/deep-vs-shallow-modules" class="btn btn-outline-primary" prompt="Older"><p>Deep vs shallow modules</p></a> <a href="/blog/2023/02/08/binary-sizes-and-virtual" class="btn btn-outline-primary" prompt="Newer"><p>Virtual functions and binary sizes</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Special functions and binary sizes'; this.page.url = 'https://www.sandordargo.com/blog/2023/02/01/special-functions-and-binary-sizes'; this.page.identifier = '/blog/2023/02/01/special-functions-and-binary-sizes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
