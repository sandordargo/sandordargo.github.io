<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: Even more constexpr" /><meta property="og:locale" content="en_US" /><meta name="description" content="Ever since C++ introduced the constexpr keyword in C++11, each new standard brought us more and more opportunities to make our code increasingly constexpr, in other words, compile-time execution friendly. In this article, we are going to review briefly what changes with C++23 on this front. Non-literal variables in constexpr functions P2242R3 proposes to remove the restriction that a constexpr function cannot contain a definition of a variable of a non-literal type a definition of a variable of static or thread storage duration, or a goto statement, or an identifier label. The rationale behind this change is that the presence of the listed things in a function is not a problem as long as they are not evaluated at compile-time. We should remind ourselves that a constexpr function may or may not be evaluated at compile-time. Let’s suppose that in a constexpr function we want to call a piece of code that is guaranteed to be evaluated at compile-time. Then we need to have that piece of code in a block under the condition of either if consteval or if (std::is_constant_evaluated()). With this paper, the following code becomes valid. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; constexpr bool f() { if (std::is_constant_evaluated()) { // ... return true; } else { T t; // This could have been problematic before // ... return true; } } struct nonliteral { nonliteral(); }; static_assert(f&lt;nonliteral&gt;()); As nonliteral is a non-literal type, the compilation should fail without this proposal, even though the line that causes the failure is not in a constant-evaluated context. This change is available starting from GCC 12 and Clang 15. Relaxing some more constexpr restrictions As I mentioned in the intro, every new standard relaxes a bit constexpr conditions and in fact, even the previous section discussed relaxations. But there is more. Thanks to Barry Revzin and P2448R2. Let’s see the two main issues the paper wants to solve. Functions that are not yet constexpr As I wrote earlier, a constexpr function might be evaluated at compile-time but might not. Whether or not a call can be constant-evaluated might depend on the parameters passed in. Often it seems straightforward that a function cannot be constant-evaluated because of the non-constexpr functions it calls. But never say never! More and more functions in the standard library become constexpr and conditionally marking functions constexpr - as in the next happens - is painful: 1 2 3 4 5 6 7 8 #include &lt;optional&gt; #if __cpp_lib_optional &gt;= 202106 constexpr #endif void h(std::optional&lt;int&gt;&amp; o) { o.reset(); } Explicitly defaulted functions follow different rules Another problem Barry wanted to address is related to explicitly defaulted functions. Let’s use the following template to demonstrate the issue: 1 2 3 4 5 6 7 8 9 10 11 template &lt;typename T&gt; struct Wrapper { constexpr Wrapper() = default; constexpr Wrapper(Wrapper const&amp;) = default; constexpr Wrapper(T const&amp; t) : t(t) { } constexpr T get() const { return t; } constexpr bool operator==(Wrapper const&amp;) const = default; private: T t; }; If you mark a member function constexpr, it means that it might be evaluated in a constant-evaluation context. On the other hand, if you default a member function, it means that it must be constexpr-compatible in all instantiations. Yet, not all the compilers complain if you violate this rule and those that raise an error, they don’t raise the error in each case. In the case of a template, this means that all instantiations should be constexpr-compatible. If that’s not possible, the current solution is to remove the constexpr from the explicitly defaulted constructors and operator==(). We might end up with an instantiation where they would be usable in a constant-evaluation context, yet they are not marked as constexpr What is changing after all? With the acceptance of this proposal, there are a couple of restrictions removed. Constructors and destructors will follow the same rules as functions in terms of constexpr. In addition, an explicitly defaulted function on its first declaration will not only be implicitly inline but also implicitly constexpr if it satisfies the requirements of a constexpr function. And even constexpr functions will get some relaxed rules - beyond the relaxation presented in the previous section. They can return and/or take as parameters non-literal types. This change is available starting from GCC 13. Permitting static constexpr variables in constexpr functions P2647R1 corrects a hole in the standard. As the proposal says, there is no good reason why a constexpr function cannot have today a static constexpr local variable. While this is fine: 1 2 3 4 char xdigit(int n) { static constexpr char digits[] = &quot;0123456789abcdef&quot;; return digits[n]; } Its constexpr version wouldn’t compile without some workarounds presented in the paper: 1 2 3 4 constexpr char xdigit(int n) { static constexpr char digits[] = &quot;0123456789abcdef&quot;; return digits[n]; } Not anymore! The above code is becoming legit. GCC 13 and Clang 16 already support it! constexpr type_info::operator==() At the moment, typeid is allowed in constant expressions, but the returned std::type_info object has no constexpr methods, therefore it’s not practically usable in a constexpr context. P1328R1 makes the equality operator (operator==()) constexpr to std::type_info becomes practically usable in compile-time functions! It’s fascinating how far the constexpr came. I mean, typeid() and std::type_info are used for Run-Time Type Information (RTTI) and yet we talk about constexpr… GCC 12, Clang 17 and MSVC 19.33 already provide this feature! constexpr for &lt;cmath&gt; and &lt;cstdlib&gt; Until now, &lt;cmath&gt; and &lt;cstdlib&gt; has barely contained any constexpr functions. P0533R9 aims to improve on this situation in order to facilitate compile-time programming. These headers have been simply neglected so far, otherwise, there is no reason why std::chrono::abs is constexpr but std::abs is not. In (8.E-G sections of P0533R9 you can find the full list of functions that are going to become constexpr. Luckily it’s quite a long list! This is yet to be implemented by the compilers! constexpr std::unique_ptr P2273R3 is bringing us constexpr unique pointers. The requirements of constexpr were loosened by P0784R7, adopted by C++20. With that new and delete might be used in certain constexpr-contexts, so it was worth trying making std::unique_ptr also constexpr. It worked out fine and it’s already available in the new versions of major compilers. The authors also tried to make shared_ptr constexpr, but due to missing compile-time atomic support it’s not possible for the moment to implement shared_ptr according to the standard. The authors are going to explore their possibilities further. GCC 12, Clang 16 and MSVC 19.33 already provide this feature! constexpr for integral overloads of std::to_chars() and std::from_chars() At compile-time, there is currently no standard way to make conversions between numbers and strings. Now that a std::string can be instantiated at compile-time, we are much closer to get a constexpr std::format and this is a gap. std::to_chars and std::from_chars are fundamental blocks for parsing and formatting as they are locale-independent, they don’t throw and don’t allocate memory. Except for the floating point overloads now they will become constexpr thanks to P2291R3. They will be another step forward to have constexpr std::format. GCC 13, Clang 16 and MSVC 19.34 already provide this feature! constexpr std::bitset P2417R2 extends the constexpr interface of std::bitset. So far, only one of the constructors and operator[] was marked as constexpr. However, since std::string can be constexpr, all the internals - and therefore the full API - of std::bitset can be constexpr. GCC 13, Clang 16 and MSVC 19.34 already provide this feature! DR: constexpr for std::optional and std::variant P2231R1 adds some missing constexpr both to std::optional and std::variant. As the already referenced P0784R7 made it possible to use new and delete at compile-time (by using std::construct_at), there was no reason to not making optional and variant fully constexpr. GCC 11, Clang 13 and MSVC 19.31 already provide this fix! Conclusion In this article, we reviewed the constexpr related changes in C++23. There are quite many of them, and our options for compile-time programming are growing! You can check on C++ Reference whether they are implemented by your compiler of choice. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Ever since C++ introduced the constexpr keyword in C++11, each new standard brought us more and more opportunities to make our code increasingly constexpr, in other words, compile-time execution friendly. In this article, we are going to review briefly what changes with C++23 on this front. Non-literal variables in constexpr functions P2242R3 proposes to remove the restriction that a constexpr function cannot contain a definition of a variable of a non-literal type a definition of a variable of static or thread storage duration, or a goto statement, or an identifier label. The rationale behind this change is that the presence of the listed things in a function is not a problem as long as they are not evaluated at compile-time. We should remind ourselves that a constexpr function may or may not be evaluated at compile-time. Let’s suppose that in a constexpr function we want to call a piece of code that is guaranteed to be evaluated at compile-time. Then we need to have that piece of code in a block under the condition of either if consteval or if (std::is_constant_evaluated()). With this paper, the following code becomes valid. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; constexpr bool f() { if (std::is_constant_evaluated()) { // ... return true; } else { T t; // This could have been problematic before // ... return true; } } struct nonliteral { nonliteral(); }; static_assert(f&lt;nonliteral&gt;()); As nonliteral is a non-literal type, the compilation should fail without this proposal, even though the line that causes the failure is not in a constant-evaluated context. This change is available starting from GCC 12 and Clang 15. Relaxing some more constexpr restrictions As I mentioned in the intro, every new standard relaxes a bit constexpr conditions and in fact, even the previous section discussed relaxations. But there is more. Thanks to Barry Revzin and P2448R2. Let’s see the two main issues the paper wants to solve. Functions that are not yet constexpr As I wrote earlier, a constexpr function might be evaluated at compile-time but might not. Whether or not a call can be constant-evaluated might depend on the parameters passed in. Often it seems straightforward that a function cannot be constant-evaluated because of the non-constexpr functions it calls. But never say never! More and more functions in the standard library become constexpr and conditionally marking functions constexpr - as in the next happens - is painful: 1 2 3 4 5 6 7 8 #include &lt;optional&gt; #if __cpp_lib_optional &gt;= 202106 constexpr #endif void h(std::optional&lt;int&gt;&amp; o) { o.reset(); } Explicitly defaulted functions follow different rules Another problem Barry wanted to address is related to explicitly defaulted functions. Let’s use the following template to demonstrate the issue: 1 2 3 4 5 6 7 8 9 10 11 template &lt;typename T&gt; struct Wrapper { constexpr Wrapper() = default; constexpr Wrapper(Wrapper const&amp;) = default; constexpr Wrapper(T const&amp; t) : t(t) { } constexpr T get() const { return t; } constexpr bool operator==(Wrapper const&amp;) const = default; private: T t; }; If you mark a member function constexpr, it means that it might be evaluated in a constant-evaluation context. On the other hand, if you default a member function, it means that it must be constexpr-compatible in all instantiations. Yet, not all the compilers complain if you violate this rule and those that raise an error, they don’t raise the error in each case. In the case of a template, this means that all instantiations should be constexpr-compatible. If that’s not possible, the current solution is to remove the constexpr from the explicitly defaulted constructors and operator==(). We might end up with an instantiation where they would be usable in a constant-evaluation context, yet they are not marked as constexpr What is changing after all? With the acceptance of this proposal, there are a couple of restrictions removed. Constructors and destructors will follow the same rules as functions in terms of constexpr. In addition, an explicitly defaulted function on its first declaration will not only be implicitly inline but also implicitly constexpr if it satisfies the requirements of a constexpr function. And even constexpr functions will get some relaxed rules - beyond the relaxation presented in the previous section. They can return and/or take as parameters non-literal types. This change is available starting from GCC 13. Permitting static constexpr variables in constexpr functions P2647R1 corrects a hole in the standard. As the proposal says, there is no good reason why a constexpr function cannot have today a static constexpr local variable. While this is fine: 1 2 3 4 char xdigit(int n) { static constexpr char digits[] = &quot;0123456789abcdef&quot;; return digits[n]; } Its constexpr version wouldn’t compile without some workarounds presented in the paper: 1 2 3 4 constexpr char xdigit(int n) { static constexpr char digits[] = &quot;0123456789abcdef&quot;; return digits[n]; } Not anymore! The above code is becoming legit. GCC 13 and Clang 16 already support it! constexpr type_info::operator==() At the moment, typeid is allowed in constant expressions, but the returned std::type_info object has no constexpr methods, therefore it’s not practically usable in a constexpr context. P1328R1 makes the equality operator (operator==()) constexpr to std::type_info becomes practically usable in compile-time functions! It’s fascinating how far the constexpr came. I mean, typeid() and std::type_info are used for Run-Time Type Information (RTTI) and yet we talk about constexpr… GCC 12, Clang 17 and MSVC 19.33 already provide this feature! constexpr for &lt;cmath&gt; and &lt;cstdlib&gt; Until now, &lt;cmath&gt; and &lt;cstdlib&gt; has barely contained any constexpr functions. P0533R9 aims to improve on this situation in order to facilitate compile-time programming. These headers have been simply neglected so far, otherwise, there is no reason why std::chrono::abs is constexpr but std::abs is not. In (8.E-G sections of P0533R9 you can find the full list of functions that are going to become constexpr. Luckily it’s quite a long list! This is yet to be implemented by the compilers! constexpr std::unique_ptr P2273R3 is bringing us constexpr unique pointers. The requirements of constexpr were loosened by P0784R7, adopted by C++20. With that new and delete might be used in certain constexpr-contexts, so it was worth trying making std::unique_ptr also constexpr. It worked out fine and it’s already available in the new versions of major compilers. The authors also tried to make shared_ptr constexpr, but due to missing compile-time atomic support it’s not possible for the moment to implement shared_ptr according to the standard. The authors are going to explore their possibilities further. GCC 12, Clang 16 and MSVC 19.33 already provide this feature! constexpr for integral overloads of std::to_chars() and std::from_chars() At compile-time, there is currently no standard way to make conversions between numbers and strings. Now that a std::string can be instantiated at compile-time, we are much closer to get a constexpr std::format and this is a gap. std::to_chars and std::from_chars are fundamental blocks for parsing and formatting as they are locale-independent, they don’t throw and don’t allocate memory. Except for the floating point overloads now they will become constexpr thanks to P2291R3. They will be another step forward to have constexpr std::format. GCC 13, Clang 16 and MSVC 19.34 already provide this feature! constexpr std::bitset P2417R2 extends the constexpr interface of std::bitset. So far, only one of the constructors and operator[] was marked as constexpr. However, since std::string can be constexpr, all the internals - and therefore the full API - of std::bitset can be constexpr. GCC 13, Clang 16 and MSVC 19.34 already provide this feature! DR: constexpr for std::optional and std::variant P2231R1 adds some missing constexpr both to std::optional and std::variant. As the already referenced P0784R7 made it possible to use new and delete at compile-time (by using std::construct_at), there was no reason to not making optional and variant fully constexpr. GCC 11, Clang 13 and MSVC 19.31 already provide this fix! Conclusion In this article, we reviewed the constexpr related changes in C++23. There are quite many of them, and our options for compile-time programming are growing! You can check on C++ Reference whether they are implemented by your compiler of choice. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-24T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: Even more constexpr" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-07-19T10:08:04+02:00","datePublished":"2023-05-24T00:00:00+02:00","description":"Ever since C++ introduced the constexpr keyword in C++11, each new standard brought us more and more opportunities to make our code increasingly constexpr, in other words, compile-time execution friendly. In this article, we are going to review briefly what changes with C++23 on this front. Non-literal variables in constexpr functions P2242R3 proposes to remove the restriction that a constexpr function cannot contain a definition of a variable of a non-literal type a definition of a variable of static or thread storage duration, or a goto statement, or an identifier label. The rationale behind this change is that the presence of the listed things in a function is not a problem as long as they are not evaluated at compile-time. We should remind ourselves that a constexpr function may or may not be evaluated at compile-time. Let’s suppose that in a constexpr function we want to call a piece of code that is guaranteed to be evaluated at compile-time. Then we need to have that piece of code in a block under the condition of either if consteval or if (std::is_constant_evaluated()). With this paper, the following code becomes valid. 1 2 3 4 5 6 7 8 9 10 11 12 template&lt;typename T&gt; constexpr bool f() { if (std::is_constant_evaluated()) { // ... return true; } else { T t; // This could have been problematic before // ... return true; } } struct nonliteral { nonliteral(); }; static_assert(f&lt;nonliteral&gt;()); As nonliteral is a non-literal type, the compilation should fail without this proposal, even though the line that causes the failure is not in a constant-evaluated context. This change is available starting from GCC 12 and Clang 15. Relaxing some more constexpr restrictions As I mentioned in the intro, every new standard relaxes a bit constexpr conditions and in fact, even the previous section discussed relaxations. But there is more. Thanks to Barry Revzin and P2448R2. Let’s see the two main issues the paper wants to solve. Functions that are not yet constexpr As I wrote earlier, a constexpr function might be evaluated at compile-time but might not. Whether or not a call can be constant-evaluated might depend on the parameters passed in. Often it seems straightforward that a function cannot be constant-evaluated because of the non-constexpr functions it calls. But never say never! More and more functions in the standard library become constexpr and conditionally marking functions constexpr - as in the next happens - is painful: 1 2 3 4 5 6 7 8 #include &lt;optional&gt; #if __cpp_lib_optional &gt;= 202106 constexpr #endif void h(std::optional&lt;int&gt;&amp; o) { o.reset(); } Explicitly defaulted functions follow different rules Another problem Barry wanted to address is related to explicitly defaulted functions. Let’s use the following template to demonstrate the issue: 1 2 3 4 5 6 7 8 9 10 11 template &lt;typename T&gt; struct Wrapper { constexpr Wrapper() = default; constexpr Wrapper(Wrapper const&amp;) = default; constexpr Wrapper(T const&amp; t) : t(t) { } constexpr T get() const { return t; } constexpr bool operator==(Wrapper const&amp;) const = default; private: T t; }; If you mark a member function constexpr, it means that it might be evaluated in a constant-evaluation context. On the other hand, if you default a member function, it means that it must be constexpr-compatible in all instantiations. Yet, not all the compilers complain if you violate this rule and those that raise an error, they don’t raise the error in each case. In the case of a template, this means that all instantiations should be constexpr-compatible. If that’s not possible, the current solution is to remove the constexpr from the explicitly defaulted constructors and operator==(). We might end up with an instantiation where they would be usable in a constant-evaluation context, yet they are not marked as constexpr What is changing after all? With the acceptance of this proposal, there are a couple of restrictions removed. Constructors and destructors will follow the same rules as functions in terms of constexpr. In addition, an explicitly defaulted function on its first declaration will not only be implicitly inline but also implicitly constexpr if it satisfies the requirements of a constexpr function. And even constexpr functions will get some relaxed rules - beyond the relaxation presented in the previous section. They can return and/or take as parameters non-literal types. This change is available starting from GCC 13. Permitting static constexpr variables in constexpr functions P2647R1 corrects a hole in the standard. As the proposal says, there is no good reason why a constexpr function cannot have today a static constexpr local variable. While this is fine: 1 2 3 4 char xdigit(int n) { static constexpr char digits[] = &quot;0123456789abcdef&quot;; return digits[n]; } Its constexpr version wouldn’t compile without some workarounds presented in the paper: 1 2 3 4 constexpr char xdigit(int n) { static constexpr char digits[] = &quot;0123456789abcdef&quot;; return digits[n]; } Not anymore! The above code is becoming legit. GCC 13 and Clang 16 already support it! constexpr type_info::operator==() At the moment, typeid is allowed in constant expressions, but the returned std::type_info object has no constexpr methods, therefore it’s not practically usable in a constexpr context. P1328R1 makes the equality operator (operator==()) constexpr to std::type_info becomes practically usable in compile-time functions! It’s fascinating how far the constexpr came. I mean, typeid() and std::type_info are used for Run-Time Type Information (RTTI) and yet we talk about constexpr… GCC 12, Clang 17 and MSVC 19.33 already provide this feature! constexpr for &lt;cmath&gt; and &lt;cstdlib&gt; Until now, &lt;cmath&gt; and &lt;cstdlib&gt; has barely contained any constexpr functions. P0533R9 aims to improve on this situation in order to facilitate compile-time programming. These headers have been simply neglected so far, otherwise, there is no reason why std::chrono::abs is constexpr but std::abs is not. In (8.E-G sections of P0533R9 you can find the full list of functions that are going to become constexpr. Luckily it’s quite a long list! This is yet to be implemented by the compilers! constexpr std::unique_ptr P2273R3 is bringing us constexpr unique pointers. The requirements of constexpr were loosened by P0784R7, adopted by C++20. With that new and delete might be used in certain constexpr-contexts, so it was worth trying making std::unique_ptr also constexpr. It worked out fine and it’s already available in the new versions of major compilers. The authors also tried to make shared_ptr constexpr, but due to missing compile-time atomic support it’s not possible for the moment to implement shared_ptr according to the standard. The authors are going to explore their possibilities further. GCC 12, Clang 16 and MSVC 19.33 already provide this feature! constexpr for integral overloads of std::to_chars() and std::from_chars() At compile-time, there is currently no standard way to make conversions between numbers and strings. Now that a std::string can be instantiated at compile-time, we are much closer to get a constexpr std::format and this is a gap. std::to_chars and std::from_chars are fundamental blocks for parsing and formatting as they are locale-independent, they don’t throw and don’t allocate memory. Except for the floating point overloads now they will become constexpr thanks to P2291R3. They will be another step forward to have constexpr std::format. GCC 13, Clang 16 and MSVC 19.34 already provide this feature! constexpr std::bitset P2417R2 extends the constexpr interface of std::bitset. So far, only one of the constructors and operator[] was marked as constexpr. However, since std::string can be constexpr, all the internals - and therefore the full API - of std::bitset can be constexpr. GCC 13, Clang 16 and MSVC 19.34 already provide this feature! DR: constexpr for std::optional and std::variant P2231R1 adds some missing constexpr both to std::optional and std::variant. As the already referenced P0784R7 made it possible to use new and delete at compile-time (by using std::construct_at), there was no reason to not making optional and variant fully constexpr. GCC 11, Clang 13 and MSVC 19.31 already provide this fix! Conclusion In this article, we reviewed the constexpr related changes in C++23. There are quite many of them, and our options for compile-time programming are growing! You can check on C++ Reference whether they are implemented by your compiler of choice. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: Even more constexpr","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr"},"url":"https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr"}</script><title>C++23: Even more constexpr | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/24"> 24 </a> </span> <span>C++23: Even more constexpr</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: Even more constexpr</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 24, 2023, 12:00 AM +0200" prep="on" > May 24, 2023 <i class="unloaded">2023-05-24T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, Jul 19, 2023, 10:08 AM +0200" prefix="Updated " > Jul 19, 2023 <i class="unloaded">2023-07-19T10:08:04+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1368 words">7 min</span></div></div><div class="post-content"><p>Ever since C++ introduced the <code class="language-plaintext highlighter-rouge">constexpr</code> keyword in C++11, each new standard brought us more and more opportunities to make our code increasingly <code class="language-plaintext highlighter-rouge">constexpr</code>, in other words, compile-time execution friendly.</p><p>In this article, we are going to review briefly what changes with C++23 on this front.</p><h2 id="non-literal-variables-in-constexpr-functions">Non-literal variables in <code class="language-plaintext highlighter-rouge">constexpr</code> functions</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2242r3.html">P2242R3</a> proposes to remove the restriction that a <code class="language-plaintext highlighter-rouge">constexpr</code> function cannot contain</p><ul><li>a definition of a variable of a <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">non-literal type</a><li>a definition of a variable of static or thread storage duration,<li>or a goto statement,<li>or an identifier label.</ul><p>The rationale behind this change is that the presence of the listed things in a function is not a problem as long as they are not evaluated at compile-time. We should remind ourselves that a <code class="language-plaintext highlighter-rouge">constexpr</code> function may or may not be evaluated at compile-time.</p><p>Let’s suppose that in a <code class="language-plaintext highlighter-rouge">constexpr</code> function we want to call a piece of code that is guaranteed to be evaluated at compile-time. Then we need to have that piece of code in a block under the condition of either <a href="https://www.sandordargo.com/blog/2022/06/01/cpp23-if-consteval"><code class="language-plaintext highlighter-rouge">if consteval</code></a> or <code class="language-plaintext highlighter-rouge">if (std::is_constant_evaluated())</code>.</p><p>With this paper, the following code becomes valid.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span> <span class="k">constexpr</span> <span class="kt">bool</span> <span class="nf">f</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">is_constant_evaluated</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">T</span> <span class="n">t</span><span class="p">;</span> <span class="c1">// This could have been problematic before</span>
    <span class="c1">// ...</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
<span class="k">struct</span> <span class="nc">nonliteral</span> <span class="p">{</span> <span class="n">nonliteral</span><span class="p">();</span> <span class="p">};</span>
<span class="k">static_assert</span><span class="p">(</span><span class="n">f</span><span class="o">&lt;</span><span class="n">nonliteral</span><span class="o">&gt;</span><span class="p">());</span>
</pre></table></code></div></div><p>As <code class="language-plaintext highlighter-rouge">nonliteral</code> is a non-literal type, the compilation should fail without this proposal, even though the line that causes the failure is not in a constant-evaluated context.</p><p>This change is available starting from GCC 12 and Clang 15.</p><h2 id="relaxing-some-more-constexpr-restrictions">Relaxing some more <code class="language-plaintext highlighter-rouge">constexpr</code> restrictions</h2><p>As I mentioned in the intro, every new standard relaxes a bit <code class="language-plaintext highlighter-rouge">constexpr</code> conditions and in fact, even the previous section discussed relaxations. But there is more. Thanks to <a href="https://brevzin.github.io/">Barry Revzin</a> and <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2448r2.html">P2448R2</a>.</p><p>Let’s see the two main issues the paper wants to solve.</p><h3 id="functions-that-are-not-yet-constexpr">Functions that are not <em>yet</em> <code class="language-plaintext highlighter-rouge">constexpr</code></h3><p>As I wrote earlier, a <code class="language-plaintext highlighter-rouge">constexpr</code> function might be evaluated at compile-time but might not. Whether or not a call can be constant-evaluated might depend on the parameters passed in. Often it seems straightforward that a function cannot be constant-evaluated because of the non-<code class="language-plaintext highlighter-rouge">constexpr</code> functions it calls. But never say never! More and more functions in the standard library become <code class="language-plaintext highlighter-rouge">constexpr</code> and conditionally marking functions <code class="language-plaintext highlighter-rouge">constexpr</code> - as in the next happens - is painful:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;optional&gt;</span><span class="cp">
</span>
<span class="cp">#if __cpp_lib_optional &gt;= 202106
</span><span class="k">constexpr</span>
<span class="cp">#endif
</span><span class="kt">void</span> <span class="nf">h</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span> <span class="n">o</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">o</span><span class="p">.</span><span class="n">reset</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="explicitly-defaulted-functions-follow-different-rules">Explicitly defaulted functions follow different rules</h3><p>Another problem Barry wanted to address is related to explicitly defaulted functions. Let’s use the following template to demonstrate the issue:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Wrapper</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="n">Wrapper</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">Wrapper</span><span class="p">(</span><span class="n">Wrapper</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="k">constexpr</span> <span class="n">Wrapper</span><span class="p">(</span><span class="n">T</span> <span class="k">const</span><span class="o">&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="o">:</span> <span class="n">t</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">constexpr</span> <span class="n">T</span> <span class="n">get</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">t</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">constexpr</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Wrapper</span> <span class="k">const</span><span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
    <span class="n">T</span> <span class="n">t</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>If you mark a member function <code class="language-plaintext highlighter-rouge">constexpr</code>, it means that it <em>might</em> be evaluated in a constant-evaluation context.</p><p>On the other hand, if you <code class="language-plaintext highlighter-rouge">default</code> a member function, it means that it must be <code class="language-plaintext highlighter-rouge">constexpr</code>-compatible in all instantiations. Yet, not all the compilers complain if you violate this rule and those that raise an error, they don’t raise the error in each case.</p><p>In the case of a template, this means that all instantiations should be <code class="language-plaintext highlighter-rouge">constexpr</code>-compatible. If that’s not possible, the current solution is to remove the <code class="language-plaintext highlighter-rouge">constexpr</code> from the explicitly defaulted constructors and <code class="language-plaintext highlighter-rouge">operator==()</code>. We might end up with an instantiation where they would be usable in a constant-evaluation context, yet they are not marked as <code class="language-plaintext highlighter-rouge">constexpr</code></p><h3 id="what-is-changing-after-all">What is changing after all?</h3><p>With the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2448r2.html">this proposal</a>, there are a couple of restrictions removed.</p><p>Constructors and destructors will follow the same rules as functions in terms of <code class="language-plaintext highlighter-rouge">constexpr</code>. In addition, an explicitly defaulted function on its first declaration will not only be implicitly inline but also implicitly <code class="language-plaintext highlighter-rouge">constexpr</code> if it satisfies the requirements of a <code class="language-plaintext highlighter-rouge">constexpr</code> function.</p><p>And even <code class="language-plaintext highlighter-rouge">constexpr</code> functions will get some relaxed rules - beyond the relaxation presented in the previous section. They can return and/or take as parameters <a href="https://en.cppreference.com/w/cpp/named_req/LiteralType">non-literal types</a>.</p><p>This change is available starting from GCC 13.</p><h2 id="permitting-static-constexpr-variables-in-constexpr-functions">Permitting static <code class="language-plaintext highlighter-rouge">constexpr</code> variables in <code class="language-plaintext highlighter-rouge">constexpr</code> functions</h2><p><a href="https://wg21.link/P2647R1">P2647R1</a> corrects a hole in the standard. As the proposal says, there is no good reason why a <code class="language-plaintext highlighter-rouge">constexpr</code> function cannot have today a <code class="language-plaintext highlighter-rouge">static constexpr</code> local variable.</p><p>While this is fine:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="kt">char</span> <span class="nf">xdigit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">digits</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"0123456789abcdef"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">digits</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Its <code class="language-plaintext highlighter-rouge">constexpr</code> version wouldn’t compile without some workarounds presented in the <a href="https://wg21.link/P2647R1">paper</a>:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">constexpr</span> <span class="kt">char</span> <span class="nf">xdigit</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">constexpr</span> <span class="kt">char</span> <span class="n">digits</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"0123456789abcdef"</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">digits</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Not anymore! The above code is becoming legit. GCC 13 and Clang 16 already support it!</p><h2 id="constexpr-type_infooperator"><code class="language-plaintext highlighter-rouge">constexpr type_info::operator==()</code></h2><p>At the moment, <code class="language-plaintext highlighter-rouge">typeid</code> is allowed in constant expressions, but the returned <a href="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti#typeid-and-stdtype_info"><code class="language-plaintext highlighter-rouge">std::type_info</code></a> object has no <code class="language-plaintext highlighter-rouge">constexpr</code> methods, therefore it’s not practically usable in a <code class="language-plaintext highlighter-rouge">constexpr</code> context.</p><p><a href="https://wg21.link/P1328R1">P1328R1</a> makes the equality operator (<code class="language-plaintext highlighter-rouge">operator==()</code>) <code class="language-plaintext highlighter-rouge">constexpr</code> to <code class="language-plaintext highlighter-rouge">std::type_info</code> becomes practically usable in compile-time functions!</p><p>It’s fascinating how far the <code class="language-plaintext highlighter-rouge">constexpr</code> came. I mean, <code class="language-plaintext highlighter-rouge">typeid()</code> and <code class="language-plaintext highlighter-rouge">std::type_info</code> are used for <a href="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti">Run-Time Type Information (RTTI)</a> and yet we talk about <code class="language-plaintext highlighter-rouge">constexpr</code>…</p><p>GCC 12, Clang 17 and MSVC 19.33 already provide this feature!</p><h2 id="constexpr-for-cmath-and-cstdlib"><code class="language-plaintext highlighter-rouge">constexpr</code> for <code class="language-plaintext highlighter-rouge">&lt;cmath&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;cstdlib&gt;</code></h2><p>Until now, <code class="language-plaintext highlighter-rouge">&lt;cmath&gt;</code> and <code class="language-plaintext highlighter-rouge">&lt;cstdlib&gt;</code> has barely contained any <code class="language-plaintext highlighter-rouge">constexpr</code> functions. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf">P0533R9</a> aims to improve on this situation in order to facilitate compile-time programming. These headers have been simply neglected so far, otherwise, there is no reason why <code class="language-plaintext highlighter-rouge">std::chrono::abs</code> is <code class="language-plaintext highlighter-rouge">constexpr</code> but <code class="language-plaintext highlighter-rouge">std::abs</code> is not.</p><p>In (8.E-G sections of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0533r9.pdf">P0533R9</a> you can find the full list of functions that are going to become <code class="language-plaintext highlighter-rouge">constexpr</code>. Luckily it’s quite a long list!</p><p>This is yet to be implemented by the compilers!</p><h2 id="constexpr-stdunique_ptr"><code class="language-plaintext highlighter-rouge">constexpr std::unique_ptr</code></h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2273r3.pdf">P2273R3</a> is bringing us <code class="language-plaintext highlighter-rouge">constexpr</code> unique pointers. The requirements of <code class="language-plaintext highlighter-rouge">constexpr</code> were loosened by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html">P0784R7</a>, adopted by C++20. With that <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code> might be used in certain <code class="language-plaintext highlighter-rouge">constexpr</code>-contexts, so it was worth trying making <code class="language-plaintext highlighter-rouge">std::unique_ptr</code> also <code class="language-plaintext highlighter-rouge">constexpr</code>. It worked out fine and it’s already available in the new versions of major compilers.</p><p>The authors also tried to make <code class="language-plaintext highlighter-rouge">shared_ptr</code> <code class="language-plaintext highlighter-rouge">constexpr</code>, but due to missing compile-time atomic support it’s not possible for the moment to implement <code class="language-plaintext highlighter-rouge">shared_ptr</code> according to the standard. The authors are going to explore their possibilities further.</p><p>GCC 12, Clang 16 and MSVC 19.33 already provide this feature!</p><h2 id="constexpr-for-integral-overloads-of-stdto_chars-and-stdfrom_chars"><code class="language-plaintext highlighter-rouge">constexpr</code> for integral overloads of <code class="language-plaintext highlighter-rouge">std::to_chars()</code> and <code class="language-plaintext highlighter-rouge">std::from_chars()</code></h2><p>At compile-time, there is currently no standard way to make conversions between numbers and strings. Now that a <code class="language-plaintext highlighter-rouge">std::string</code> can be instantiated at compile-time, we are much closer to get a <code class="language-plaintext highlighter-rouge">constexpr std::format</code> and this is a gap.</p><p><code class="language-plaintext highlighter-rouge">std::to_chars</code> and <code class="language-plaintext highlighter-rouge">std::from_chars</code> are fundamental blocks for parsing and formatting as they are locale-independent, they don’t throw and don’t allocate memory. Except for the floating point overloads now they will become <code class="language-plaintext highlighter-rouge">constexpr</code> thanks to <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2291r3.pdf">P2291R3</a>.</p><p>They will be another step forward to have <code class="language-plaintext highlighter-rouge">constexpr std::format</code>.</p><p>GCC 13, Clang 16 and MSVC 19.34 already provide this feature!</p><h2 id="constexpr-stdbitset"><code class="language-plaintext highlighter-rouge">constexpr std::bitset</code></h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2022/p2417r2.pdf">P2417R2</a> extends the <code class="language-plaintext highlighter-rouge">constexpr</code> interface of <code class="language-plaintext highlighter-rouge">std::bitset</code>. So far, only one of the constructors and <code class="language-plaintext highlighter-rouge">operator[]</code> was marked as <code class="language-plaintext highlighter-rouge">constexpr</code>. However, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0980r1.pdf">since <code class="language-plaintext highlighter-rouge">std::string</code> can be <code class="language-plaintext highlighter-rouge">constexpr</code></a>, all the internals - and therefore the full API - of <code class="language-plaintext highlighter-rouge">std::bitset</code> can be <code class="language-plaintext highlighter-rouge">constexpr</code>.</p><p>GCC 13, Clang 16 and MSVC 19.34 already provide this feature!</p><h2 id="dr-constexpr-for-stdoptional-and-stdvariant">DR: constexpr for std::optional and std::variant</h2><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2231r1.html">P2231R1</a> adds some missing <code class="language-plaintext highlighter-rouge">constexpr</code> both to <code class="language-plaintext highlighter-rouge">std::optional</code> and <code class="language-plaintext highlighter-rouge">std::variant</code>. As the already referenced <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0784r7.html">P0784R7</a> made it possible to use <code class="language-plaintext highlighter-rouge">new</code> and <code class="language-plaintext highlighter-rouge">delete</code> at compile-time (by using <code class="language-plaintext highlighter-rouge">std::construct_at</code>), there was no reason to not making <code class="language-plaintext highlighter-rouge">optional</code> and <code class="language-plaintext highlighter-rouge">variant</code> fully constexpr.</p><p>GCC 11, Clang 13 and MSVC 19.31 already provide this fix!</p><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed the <code class="language-plaintext highlighter-rouge">constexpr</code> related changes in C++23. There are quite many of them, and our options for compile-time programming are growing! You can check on <a href="https://en.cppreference.com/w/cpp/23">C++ Reference</a> whether they are implemented by your compiler of choice.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/constexpr/" class="post-tag no-text-decoration" >constexpr</a> <a href="/tags/compiletime/" class="post-tag no-text-decoration" >compiletime</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: Even more constexpr - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: Even more constexpr - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: Even more constexpr - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: Even more constexpr - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/09/06/cpp23-templates"><div class="card-body"> <span class="timeago small" > Sep 6, 2023 <i class="unloaded">2023-09-06T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: some changes related to templates</h3><div class="text-muted small"><p> I know the above title is a bit vague. As we move forward with the introduction of C++23 features, there are going to be some articles like that. At the same time, there are more than two features ...</p></div></div></a></div><div class="card"> <a href="/blog/2023/11/01/cpp23-garbage-collection"><div class="card-body"> <span class="timeago small" > Nov 1, 2023 <i class="unloaded">2023-11-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: Removing garbage collection support</h3><div class="text-muted small"><p> If we go through the list of C++23 features, we can stumble upon the notion of garbage collection twice. Once among the language and once among the library features. Both entries refer to the same ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/05/17/spoiled-or-abused" class="btn btn-outline-primary" prompt="Older"><p>Are we - developers - spoiled or abused?</p></a> <a href="/blog/2023/05/31/cpp23-noexcept-related-changes" class="btn btn-outline-primary" prompt="Newer"><p>C++23: two additional noexcept functions</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: Even more constexpr'; this.page.url = 'https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr'; this.page.identifier = '/blog/2023/05/24/cpp23-constexpr'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
