<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Variadic functions vs variadic templates" /><meta property="og:locale" content="en_US" /><meta name="description" content="A few months ago, I wrote a review on Template Metaprogramming with C++ by Marius Bancila where I mentioned not only that it’s a great book, but also that there are some topics which I’ll cover more in detail. Some time ago we discussed constructor templates and today I want to discuss variadic functions and variadic function templates. What are variadic functions? Even if you don’t explicitly know about variadic functions, you have most probably used the printf() family in C and/or C++. A variadic function is a function that can take an arbitrary number of arguments of any type. It must be the last (group of) parameters in a function signature. 1 void printAll(std::string items, ...); Then in order to process the arguments, you have to use a couple of macros defined in &lt;cstdarg&gt;. First, we need va_list to hold the information needed by the other macros. Then using va_start() you get access to the first argument, then with va_arg() you get access to each coming one and with va_end() you finish the traversal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;cstdarg&gt; #include &lt;iostream&gt; void printAll(size_t count, ...) { va_list args; va_start(args, count); for(size_t i = 0; i &lt; count; ++i) { std::cout &lt;&lt; va_arg(args, int); std::cout &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39;; va_end(args); } int main() { printAll(4, 3, 2, 1); printAll(3, 8.2, 2, 1.1); printAll(5, 23, 32, 8, 11, 9); } The thing is, it’s extremely error-prone. Only one out of the above 3 calls is correct. Let’s see the outputs. 1 2 3 3 2 1 -665149312 2 -665177168 24116274 23 32 8 11 9 In the first call, we first pass 4 indicating that we are passing 4 arguments and that’s what we do, we pass overall four and four values are printed. While the first three are fine, the fourth one is a negative number. Well, the function reads some value from uncharted memory territories. We should have passed in 3 as a count to show that we want to print 3 arguments. Sadly, the function didn’t complain that we try to print more than was passed in. In the second case, we send in the right amount of parameters, but while the function tries to read out int values, two of the inputs are floating point numbers. And while you might have expected that those numbers are truncated to integers, instead some odd values are printed. The reason is that an integer and a floating point number are represented differently in memory so when you try to read an int as a float or a float as an int, you’ll end up with something completely different. Though I don’t understand why the value 2 appears in the first place, instead of the second. The third call is fine. We pass in the right amount of parameters and of the right type. But these short examples already showcased how easy it is to shoot ourselves in the leg with variadic functions. It’s one thing that they rely on macros, which is clearly not the way in 2022, but they are also entirely unsafe and they rely on that you count the number of passed-in arguments. Now let’s see if variadic templates are safer. What are variadic templates? What is going to be similar is the use of the three dots (or ellipses): .... But where should those dots appear? They can both appear before and after the type parameter! Depending on where they appear, they have different meanings. So far, so bad! Let’s have a look at the implementation of our printAll function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;cstdarg&gt; #include &lt;iostream&gt; template &lt;typename T&gt; void printAll(T item) { std::cout &lt;&lt; item &lt;&lt; &#39; &#39;; } template &lt;typename T, typename... Args&gt; void printAll(T item, Args... args) { printAll(item); printAll(args...); std::cout &lt;&lt; &#39;\n&#39;; } int main() { printAll(3, 2, 1); printAll(8.2, 2, 1.1, &quot;duck&quot;); printAll(23, 32, 8, 11, 9); } You notice immediately that we have 2 overloads. One for the normal case and one for the variadic one. The first one prints one argument, while the second one recursively calls the first as it expands its parameter pack. Let’s talk about two things here. First, the position of the ellipses and second a bug in our implementation and how to fix it. In the template parameter list, there are three dots between the typename keyword and the name of the template parameter pack (Args). That’s by convention that it’s attached to the typename but they can be attached to the parameter (...Args) or they can be standalone as longs as the dots are consecutive (typename ... Args), the compiler does not care. It’s similar to the function parameter list. You can put the ellipses wherever you want between the parameter type and the parameter name. Again, by convention, we attach them to the parameter name meaning that there will be many of them coming. In the implementation, the three dots must follow the parameters, it does not matter whether there is a space in between or not. But if the ... are missing, in other words, if you don’t unpack the parameter pack, the compilation fails. As long as there is more than one parameter in the pack, the same variadic overload is called recursively and once there is only one left, the other overload is pulled that will stop the recursion. And now let’s talk about the problem, which does not come up for example if you want to sum up a list of numbers, but I still decided to keep this example. We might learn something interesting. With this version, We are printing n-2 newlines after calling printAll where n is the number of parameters to be printed. One way to overcome this issue would be to have a parameter for indicating whether a new line should be printed at the end of the call, and it would be only true for the client printAll() call. To make the client pass in a boolean (or any other parameter) all the time would not be nice. It makes the API more difficult to use and also error-prone. Ideally, that could be done with a default argument, but both a default argument and a variadic template argument need to have the last place. Even though there are some techniques to overcome this they are too complex to keep our code clean. We need a helper method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; template &lt;typename T&gt; void printAllImpl(T item) { std::cout &lt;&lt; item &lt;&lt; &#39; &#39;; } template &lt;typename T, typename ...Args&gt; void printAllImpl(T item, Args ... args) { printAllImpl(item); printAllImpl(args...); } template &lt;typename... Args&gt; void printAll(Args&amp;&amp;... args) { printAllImpl(std::forward&lt;Args&gt;(args) ...); std::cout &lt;&lt; &#39;\n&#39;; } int main() { printAll(3, 2, 1); printAll(8.2, 2, 1.1, &quot;duck&quot;); printAll(23, 32, 8, 11, 9); } /* 3 2 1 8.2 2 1.1 duck 23 32 8 11 9 */ With the separation of printAllImpl from the non-recurisve printAll we achieved that there will only be one newline character printed and we used perfect forwarding so that we reduce the unnecessary copies. This solution is totally superior to the variadic function both in terms of readability and in terms of type safety. Conclusion In this article, we discussed the differences between variadic functions and variadic templates. We saw how to use variadic functions, how they rely on macros and that we pass in exactly the types a variadic function expects and also the right amount of them. Variadic templates are easier to read and easier to use. They provide the type safety that is missing from the old variadic functions. Do you still use variadic functions? If so what are your arguments? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="A few months ago, I wrote a review on Template Metaprogramming with C++ by Marius Bancila where I mentioned not only that it’s a great book, but also that there are some topics which I’ll cover more in detail. Some time ago we discussed constructor templates and today I want to discuss variadic functions and variadic function templates. What are variadic functions? Even if you don’t explicitly know about variadic functions, you have most probably used the printf() family in C and/or C++. A variadic function is a function that can take an arbitrary number of arguments of any type. It must be the last (group of) parameters in a function signature. 1 void printAll(std::string items, ...); Then in order to process the arguments, you have to use a couple of macros defined in &lt;cstdarg&gt;. First, we need va_list to hold the information needed by the other macros. Then using va_start() you get access to the first argument, then with va_arg() you get access to each coming one and with va_end() you finish the traversal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;cstdarg&gt; #include &lt;iostream&gt; void printAll(size_t count, ...) { va_list args; va_start(args, count); for(size_t i = 0; i &lt; count; ++i) { std::cout &lt;&lt; va_arg(args, int); std::cout &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\n&#39;; va_end(args); } int main() { printAll(4, 3, 2, 1); printAll(3, 8.2, 2, 1.1); printAll(5, 23, 32, 8, 11, 9); } The thing is, it’s extremely error-prone. Only one out of the above 3 calls is correct. Let’s see the outputs. 1 2 3 3 2 1 -665149312 2 -665177168 24116274 23 32 8 11 9 In the first call, we first pass 4 indicating that we are passing 4 arguments and that’s what we do, we pass overall four and four values are printed. While the first three are fine, the fourth one is a negative number. Well, the function reads some value from uncharted memory territories. We should have passed in 3 as a count to show that we want to print 3 arguments. Sadly, the function didn’t complain that we try to print more than was passed in. In the second case, we send in the right amount of parameters, but while the function tries to read out int values, two of the inputs are floating point numbers. And while you might have expected that those numbers are truncated to integers, instead some odd values are printed. The reason is that an integer and a floating point number are represented differently in memory so when you try to read an int as a float or a float as an int, you’ll end up with something completely different. Though I don’t understand why the value 2 appears in the first place, instead of the second. The third call is fine. We pass in the right amount of parameters and of the right type. But these short examples already showcased how easy it is to shoot ourselves in the leg with variadic functions. It’s one thing that they rely on macros, which is clearly not the way in 2022, but they are also entirely unsafe and they rely on that you count the number of passed-in arguments. Now let’s see if variadic templates are safer. What are variadic templates? What is going to be similar is the use of the three dots (or ellipses): .... But where should those dots appear? They can both appear before and after the type parameter! Depending on where they appear, they have different meanings. So far, so bad! Let’s have a look at the implementation of our printAll function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;cstdarg&gt; #include &lt;iostream&gt; template &lt;typename T&gt; void printAll(T item) { std::cout &lt;&lt; item &lt;&lt; &#39; &#39;; } template &lt;typename T, typename... Args&gt; void printAll(T item, Args... args) { printAll(item); printAll(args...); std::cout &lt;&lt; &#39;\n&#39;; } int main() { printAll(3, 2, 1); printAll(8.2, 2, 1.1, &quot;duck&quot;); printAll(23, 32, 8, 11, 9); } You notice immediately that we have 2 overloads. One for the normal case and one for the variadic one. The first one prints one argument, while the second one recursively calls the first as it expands its parameter pack. Let’s talk about two things here. First, the position of the ellipses and second a bug in our implementation and how to fix it. In the template parameter list, there are three dots between the typename keyword and the name of the template parameter pack (Args). That’s by convention that it’s attached to the typename but they can be attached to the parameter (...Args) or they can be standalone as longs as the dots are consecutive (typename ... Args), the compiler does not care. It’s similar to the function parameter list. You can put the ellipses wherever you want between the parameter type and the parameter name. Again, by convention, we attach them to the parameter name meaning that there will be many of them coming. In the implementation, the three dots must follow the parameters, it does not matter whether there is a space in between or not. But if the ... are missing, in other words, if you don’t unpack the parameter pack, the compilation fails. As long as there is more than one parameter in the pack, the same variadic overload is called recursively and once there is only one left, the other overload is pulled that will stop the recursion. And now let’s talk about the problem, which does not come up for example if you want to sum up a list of numbers, but I still decided to keep this example. We might learn something interesting. With this version, We are printing n-2 newlines after calling printAll where n is the number of parameters to be printed. One way to overcome this issue would be to have a parameter for indicating whether a new line should be printed at the end of the call, and it would be only true for the client printAll() call. To make the client pass in a boolean (or any other parameter) all the time would not be nice. It makes the API more difficult to use and also error-prone. Ideally, that could be done with a default argument, but both a default argument and a variadic template argument need to have the last place. Even though there are some techniques to overcome this they are too complex to keep our code clean. We need a helper method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; template &lt;typename T&gt; void printAllImpl(T item) { std::cout &lt;&lt; item &lt;&lt; &#39; &#39;; } template &lt;typename T, typename ...Args&gt; void printAllImpl(T item, Args ... args) { printAllImpl(item); printAllImpl(args...); } template &lt;typename... Args&gt; void printAll(Args&amp;&amp;... args) { printAllImpl(std::forward&lt;Args&gt;(args) ...); std::cout &lt;&lt; &#39;\n&#39;; } int main() { printAll(3, 2, 1); printAll(8.2, 2, 1.1, &quot;duck&quot;); printAll(23, 32, 8, 11, 9); } /* 3 2 1 8.2 2 1.1 duck 23 32 8 11 9 */ With the separation of printAllImpl from the non-recurisve printAll we achieved that there will only be one newline character printed and we used perfect forwarding so that we reduce the unnecessary copies. This solution is totally superior to the variadic function both in terms of readability and in terms of type safety. Conclusion In this article, we discussed the differences between variadic functions and variadic templates. We saw how to use variadic functions, how they rely on macros and that we pass in exactly the types a variadic function expects and also the right amount of them. Variadic templates are easier to read and easier to use. They provide the type safety that is missing from the old variadic functions. Do you still use variadic functions? If so what are your arguments? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-03T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Variadic functions vs variadic templates" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-10T09:50:57+02:00","datePublished":"2023-05-03T00:00:00+02:00","description":"A few months ago, I wrote a review on Template Metaprogramming with C++ by Marius Bancila where I mentioned not only that it’s a great book, but also that there are some topics which I’ll cover more in detail. Some time ago we discussed constructor templates and today I want to discuss variadic functions and variadic function templates. What are variadic functions? Even if you don’t explicitly know about variadic functions, you have most probably used the printf() family in C and/or C++. A variadic function is a function that can take an arbitrary number of arguments of any type. It must be the last (group of) parameters in a function signature. 1 void printAll(std::string items, ...); Then in order to process the arguments, you have to use a couple of macros defined in &lt;cstdarg&gt;. First, we need va_list to hold the information needed by the other macros. Then using va_start() you get access to the first argument, then with va_arg() you get access to each coming one and with va_end() you finish the traversal. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 #include &lt;cstdarg&gt; #include &lt;iostream&gt; void printAll(size_t count, ...) { va_list args; va_start(args, count); for(size_t i = 0; i &lt; count; ++i) { std::cout &lt;&lt; va_arg(args, int); std::cout &lt;&lt; &quot; &quot;; } std::cout &lt;&lt; &#39;\\n&#39;; va_end(args); } int main() { printAll(4, 3, 2, 1); printAll(3, 8.2, 2, 1.1); printAll(5, 23, 32, 8, 11, 9); } The thing is, it’s extremely error-prone. Only one out of the above 3 calls is correct. Let’s see the outputs. 1 2 3 3 2 1 -665149312 2 -665177168 24116274 23 32 8 11 9 In the first call, we first pass 4 indicating that we are passing 4 arguments and that’s what we do, we pass overall four and four values are printed. While the first three are fine, the fourth one is a negative number. Well, the function reads some value from uncharted memory territories. We should have passed in 3 as a count to show that we want to print 3 arguments. Sadly, the function didn’t complain that we try to print more than was passed in. In the second case, we send in the right amount of parameters, but while the function tries to read out int values, two of the inputs are floating point numbers. And while you might have expected that those numbers are truncated to integers, instead some odd values are printed. The reason is that an integer and a floating point number are represented differently in memory so when you try to read an int as a float or a float as an int, you’ll end up with something completely different. Though I don’t understand why the value 2 appears in the first place, instead of the second. The third call is fine. We pass in the right amount of parameters and of the right type. But these short examples already showcased how easy it is to shoot ourselves in the leg with variadic functions. It’s one thing that they rely on macros, which is clearly not the way in 2022, but they are also entirely unsafe and they rely on that you count the number of passed-in arguments. Now let’s see if variadic templates are safer. What are variadic templates? What is going to be similar is the use of the three dots (or ellipses): .... But where should those dots appear? They can both appear before and after the type parameter! Depending on where they appear, they have different meanings. So far, so bad! Let’s have a look at the implementation of our printAll function. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #include &lt;cstdarg&gt; #include &lt;iostream&gt; template &lt;typename T&gt; void printAll(T item) { std::cout &lt;&lt; item &lt;&lt; &#39; &#39;; } template &lt;typename T, typename... Args&gt; void printAll(T item, Args... args) { printAll(item); printAll(args...); std::cout &lt;&lt; &#39;\\n&#39;; } int main() { printAll(3, 2, 1); printAll(8.2, 2, 1.1, &quot;duck&quot;); printAll(23, 32, 8, 11, 9); } You notice immediately that we have 2 overloads. One for the normal case and one for the variadic one. The first one prints one argument, while the second one recursively calls the first as it expands its parameter pack. Let’s talk about two things here. First, the position of the ellipses and second a bug in our implementation and how to fix it. In the template parameter list, there are three dots between the typename keyword and the name of the template parameter pack (Args). That’s by convention that it’s attached to the typename but they can be attached to the parameter (...Args) or they can be standalone as longs as the dots are consecutive (typename ... Args), the compiler does not care. It’s similar to the function parameter list. You can put the ellipses wherever you want between the parameter type and the parameter name. Again, by convention, we attach them to the parameter name meaning that there will be many of them coming. In the implementation, the three dots must follow the parameters, it does not matter whether there is a space in between or not. But if the ... are missing, in other words, if you don’t unpack the parameter pack, the compilation fails. As long as there is more than one parameter in the pack, the same variadic overload is called recursively and once there is only one left, the other overload is pulled that will stop the recursion. And now let’s talk about the problem, which does not come up for example if you want to sum up a list of numbers, but I still decided to keep this example. We might learn something interesting. With this version, We are printing n-2 newlines after calling printAll where n is the number of parameters to be printed. One way to overcome this issue would be to have a parameter for indicating whether a new line should be printed at the end of the call, and it would be only true for the client printAll() call. To make the client pass in a boolean (or any other parameter) all the time would not be nice. It makes the API more difficult to use and also error-prone. Ideally, that could be done with a default argument, but both a default argument and a variadic template argument need to have the last place. Even though there are some techniques to overcome this they are too complex to keep our code clean. We need a helper method. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 #include &lt;iostream&gt; template &lt;typename T&gt; void printAllImpl(T item) { std::cout &lt;&lt; item &lt;&lt; &#39; &#39;; } template &lt;typename T, typename ...Args&gt; void printAllImpl(T item, Args ... args) { printAllImpl(item); printAllImpl(args...); } template &lt;typename... Args&gt; void printAll(Args&amp;&amp;... args) { printAllImpl(std::forward&lt;Args&gt;(args) ...); std::cout &lt;&lt; &#39;\\n&#39;; } int main() { printAll(3, 2, 1); printAll(8.2, 2, 1.1, &quot;duck&quot;); printAll(23, 32, 8, 11, 9); } /* 3 2 1 8.2 2 1.1 duck 23 32 8 11 9 */ With the separation of printAllImpl from the non-recurisve printAll we achieved that there will only be one newline character printed and we used perfect forwarding so that we reduce the unnecessary copies. This solution is totally superior to the variadic function both in terms of readability and in terms of type safety. Conclusion In this article, we discussed the differences between variadic functions and variadic templates. We saw how to use variadic functions, how they rely on macros and that we pass in exactly the types a variadic function expects and also the right amount of them. Variadic templates are easier to read and easier to use. They provide the type safety that is missing from the old variadic functions. Do you still use variadic functions? If so what are your arguments? Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Variadic functions vs variadic templates","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates"},"url":"https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates"}</script><title>Variadic functions vs variadic templates | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/03"> 03 </a> </span> <span>Variadic functions vs variadic templates</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Variadic functions vs variadic templates</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 3, 2023, 12:00 AM +0200" prep="on" > May 3, 2023 <i class="unloaded">2023-05-03T00:00:00+02:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Wed, May 10, 2023, 9:50 AM +0200" prefix="Updated " > May 10, 2023 <i class="unloaded">2023-05-10T09:50:57+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1360 words">7 min</span></div></div><div class="post-content"><p>A few months ago, I wrote a review on <a href="https://www.sandordargo.com/blog/2022/10/28/template-metaprogramming-with-cpp-by-marius-bancila">Template Metaprogramming with C++ by Marius Bancila </a> where I mentioned not only that it’s a great book, but also that there are some topics which I’ll cover more in detail. Some time ago we discussed constructor templates and today I want to discuss variadic functions and variadic function templates.</p><h2 id="what-are-variadic-functions">What are variadic functions?</h2><p>Even if you don’t explicitly know about variadic functions, you have most probably used the <code class="language-plaintext highlighter-rouge">printf()</code> family in C and/or C++. A variadic function is a function that can take an arbitrary number of arguments of any type. It must be the last (group of) parameters in a function signature.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre>void printAll(std::string items, ...);
</pre></table></code></div></div><p>Then in order to process the arguments, you have to use a couple of macros defined in <code class="language-plaintext highlighter-rouge">&lt;cstdarg&gt;</code>.</p><p>First, we need <code class="language-plaintext highlighter-rouge">va_list</code> to hold the information needed by the other macros. Then using <code class="language-plaintext highlighter-rouge">va_start()</code> you get access to the first argument, then with <code class="language-plaintext highlighter-rouge">va_arg()</code> you get access to each coming one and with <code class="language-plaintext highlighter-rouge">va_end()</code> you finish the traversal.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;cstdarg&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">printAll</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span> <span class="p">...)</span> <span class="p">{</span>
    <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
    <span class="n">va_start</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="n">count</span><span class="p">);</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">args</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
      <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">" "</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">va_end</span><span class="p">(</span><span class="n">args</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mf">8.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mi">5</span><span class="p">,</span> <span class="mi">23</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The thing is, it’s extremely error-prone. Only one out of the above 3 calls is correct.</p><p>Let’s see the outputs.</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
</pre><td class="rouge-code"><pre>3 2 1 -665149312 
2 -665177168 24116274 
23 32 8 11 9 
</pre></table></code></div></div><p>In the first call, we first pass 4 indicating that we are passing 4 arguments and that’s what we do, we pass overall four and four values are printed. While the first three are fine, the fourth one is a negative number. Well, the function reads some value from uncharted memory territories. We should have passed in <code class="language-plaintext highlighter-rouge">3</code> as a count to show that we want to print 3 arguments. Sadly, the function didn’t complain that we try to print more than was passed in.</p><p>In the second case, we send in the right amount of parameters, but while the function tries to read out <code class="language-plaintext highlighter-rouge">int</code> values, two of the inputs are floating point numbers. And while you might have expected that those numbers are truncated to integers, instead some odd values are printed. The reason is that an integer and a floating point number are represented differently in memory so when you try to read an <code class="language-plaintext highlighter-rouge">int</code> as a <code class="language-plaintext highlighter-rouge">float</code> or a <code class="language-plaintext highlighter-rouge">float</code> as an <code class="language-plaintext highlighter-rouge">int</code>, you’ll end up with something completely different. Though I don’t understand why the value <code class="language-plaintext highlighter-rouge">2</code> appears in the first place, instead of the second.</p><p>The third call is fine. We pass in the right amount of parameters and of the right type. But these short examples already showcased how easy it is to shoot ourselves in the leg with variadic functions. It’s one thing that they rely on macros, which is clearly not the way in 2022, but they are also entirely unsafe and they rely on that you count the number of passed-in arguments.</p><p>Now let’s see if variadic templates are safer.</p><h2 id="what-are-variadic-templates">What are variadic templates?</h2><p>What is going to be similar is the use of the three dots (or ellipses): <code class="language-plaintext highlighter-rouge">...</code>. But where should those dots appear?</p><p>They can both appear before and after the type parameter! Depending on where they appear, they have different meanings. So far, so bad!</p><p>Let’s have a look at the implementation of our <code class="language-plaintext highlighter-rouge">printAll</code> function.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;cstdarg&gt;</span><span class="cp">
</span>
<span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printAll</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printAll</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">,</span> <span class="n">Args</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printAll</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mf">8.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="s">"duck"</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>You notice immediately that we have 2 overloads. One for the normal case and one for the variadic one. The first one prints one argument, while the second one recursively calls the first as it expands its parameter pack.</p><p>Let’s talk about two things here. First, the position of the ellipses and second a bug in our implementation and how to fix it.</p><p>In the template parameter list, there are three dots between the <code class="language-plaintext highlighter-rouge">typename</code> keyword and the name of the template parameter pack (<code class="language-plaintext highlighter-rouge">Args</code>). That’s by convention that it’s attached to the <code class="language-plaintext highlighter-rouge">typename</code> but they can be attached to the parameter (<code class="language-plaintext highlighter-rouge">...Args</code>) or they can be standalone as longs as the dots are consecutive (<code class="language-plaintext highlighter-rouge">typename ... Args</code>), the compiler does not care.</p><p>It’s similar to the function parameter list. You can put the ellipses wherever you want between the parameter type and the parameter name. Again, by convention, we attach them to the parameter name meaning that there will be many of them coming.</p><p>In the implementation, the three dots must follow the parameters, it does not matter whether there is a space in between or not. But if the <code class="language-plaintext highlighter-rouge">...</code> are missing, in other words, if you don’t unpack the parameter pack, the compilation fails. As long as there is more than one parameter in the pack, the same variadic overload is called recursively and once there is only one left, the other overload is pulled that will stop the recursion.</p><p>And now let’s talk about the problem, which does not come up for example if you want to sum up a list of numbers, but I still decided to keep this example. We might learn something interesting.</p><p>With this version, We are printing <em>n-2</em> newlines after calling <code class="language-plaintext highlighter-rouge">printAll</code> where n is the number of parameters to be printed. One way to overcome this issue would be to have a parameter for indicating whether a new line should be printed at the end of the call, and it would be only <code class="language-plaintext highlighter-rouge">true</code> for the client <code class="language-plaintext highlighter-rouge">printAll()</code> call. To make the client pass in a boolean (or any other parameter) all the time would not be nice. It makes the API more difficult to use and also error-prone. Ideally, that could be done with a default argument, but both a default argument and a variadic template argument need to have the last place. Even though <a href="https://stackoverflow.com/questions/14805192/c-variadic-template-function-parameter-with-default-value">there are some techniques to overcome this</a> they are too complex to keep our code clean.</p><p>We need a helper method.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printAllImpl</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">item</span> <span class="o">&lt;&lt;</span> <span class="sc">' '</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">,</span> <span class="k">typename</span> <span class="o">...</span><span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printAllImpl</span><span class="p">(</span><span class="n">T</span> <span class="n">item</span><span class="p">,</span> <span class="n">Args</span> <span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printAllImpl</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>
  <span class="n">printAllImpl</span><span class="p">(</span><span class="n">args</span><span class="p">...);</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span><span class="o">...</span> <span class="nc">Args</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">printAll</span><span class="p">(</span><span class="n">Args</span><span class="o">&amp;&amp;</span><span class="p">...</span> <span class="n">args</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">printAllImpl</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">forward</span><span class="o">&lt;</span><span class="n">Args</span><span class="o">&gt;</span><span class="p">(</span><span class="n">args</span><span class="p">)</span> <span class="p">...);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

  <span class="n">printAll</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mf">8.2</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mf">1.1</span><span class="p">,</span> <span class="s">"duck"</span><span class="p">);</span>
  <span class="n">printAll</span><span class="p">(</span><span class="mi">23</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">11</span><span class="p">,</span> <span class="mi">9</span><span class="p">);</span>
<span class="p">}</span>
<span class="cm">/*
3 2 1 
8.2 2 1.1 duck 
23 32 8 11 9 
*/</span>
</pre></table></code></div></div><p>With the separation of <code class="language-plaintext highlighter-rouge">printAllImpl</code> from the non-recurisve <code class="language-plaintext highlighter-rouge">printAll</code> we achieved that there will only be one newline character printed and we used perfect forwarding so that we reduce the unnecessary copies.</p><p>This solution is totally superior to the variadic function both in terms of readability and in terms of type safety.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we discussed the differences between variadic functions and variadic templates. We saw how to use variadic functions, how they rely on macros and that we pass in exactly the types a variadic function expects and also the right amount of them. Variadic templates are easier to read and easier to use. They provide the type safety that is missing from the old variadic functions.</p><p>Do you still use variadic functions? If so what are your arguments?</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/templates/" class="post-tag no-text-decoration" >templates</a> <a href="/tags/variadic/" class="post-tag no-text-decoration" >variadic</a> <a href="/tags/tmp/" class="post-tag no-text-decoration" >tmp</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Variadic functions vs variadic templates - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Variadic functions vs variadic templates - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Variadic functions vs variadic templates - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Variadic functions vs variadic templates - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2025/06/18/variadic-inheritance"><div class="card-body"> <span class="timeago small" > Jun 18 <i class="unloaded">2025-06-18T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Variadic class template arguments</h3><div class="text-muted small"><p> Let’s talk about class templates and variadic parameters. How to use them in combination? But first of all, what are variadic templates? Variadic template don’t accept a fixed size of parameters,...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/21/class-template-vs-class-with-ctor-template"><div class="card-body"> <span class="timeago small" > Dec 21, 2022 <i class="unloaded">2022-12-21T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Class templates versus constructor templates</h3><div class="text-muted small"><p> I realized that this simple but important difference should be covered twice during the last year. Once when I wrote about how shared and unique pointers take their deleters, and once when I read T...</p></div></div></a></div><div class="card"> <a href="/blog/2021/04/07/what-are-type-traits"><div class="card-body"> <span class="timeago small" > Apr 7, 2021 <i class="unloaded">2021-04-07T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>What are type traits?</h3><div class="text-muted small"><p> Let’s start with a more generic question, what is a trait? What does the word trait mean? According to the Cambridge Dictionary, a trait is “a particular characteristic that can produce a particu...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/04/26/without-rtti-your-code-will-be-cleaner" class="btn btn-outline-primary" prompt="Older"><p>Without RTTI your code will be cleaner</p></a> <a href="/blog/2023/05/10/is-this-dynamic-cast-needed" class="btn btn-outline-primary" prompt="Newer"><p>Is this dynamic_cast needed?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Variadic functions vs variadic templates'; this.page.url = 'https://www.sandordargo.com/blog/2023/05/03/variadic-functions-vs-variadic-templates'; this.page.identifier = '/blog/2023/05/03/variadic-functions-vs-variadic-templates'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
