<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: two additional noexcept functions" /><meta property="og:locale" content="en_US" /><meta name="description" content="If my math is correct, there are 125 changes / fixes / new features in C++23 and we are progressively covering them on this blog. I try to go from topic to topic. There are some topics with many smaller changes, such as constexpr, there are some significant topics where even one topic must be in its own post such as the stacktrace library, and there are also some shorter posts with few and quite small changes on a given topic. Today we are going to discuss noexcept related changes. If you haven’t read it, I’d recommend reading my article on noexcept and its effects on binary size We can definitely see two trends in the proposals accepted for the latest standards. They try to make more and more functions: constexpr, and noexcept The two main changes presented today fit into this trend. But let’s start with discussing a bit of noexcept policies in the standard. noexcept, but with conditions The current policies on whether something in the standard can be noexcept or not is defined by P1656R2. Let me summarize the gist of it here. As we got used to it, a destructor should never throw and therefore even if you don’t mark it noexcept they implicitly are! There might be standard library functions marked unconditionally noexcept if the committee fully agrees that the given function cannot throw. The standard specifies a couple of special member functions and library functions that can be marked conditionally noexcept, based on the underlying types and the types these functions operate on. Nothing else can be marked noexcept, except for library functions that are designed for compatibility with C. Those can be unconditionally noexcept. Most often, we mark functions either noexcept or not. So we often mark our functions unconditionally noexcept. But noexcept can take a compile-time computable condition, such as std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; std::is_nothrow_assignable_v&lt;T&amp;, U&gt; Here is the list that can be marked conditionally noexcept according to C++20. std::swap the copy-constructor and -assignment operator the move-constructor and -assignment operator This list is getting modified in the C++23 standard. It’s also worth noting that an implementation can mark conditionally noexcept a function even if it’s not listed by the standard so. Add a conditional noexcept specification to std::exchange One of the primary use cases for std::exchange is implementing the move constructor and move assignment operator. In a certain way, it’s quite similar to std::swap. Yet, while std::swap and move operations can be conditionally noexcept, it was not the case for std::exchange. Up until C++23. P2401R0 makes std::exchange conditionally noexcept. The conditions are the same as for move operations: is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_assignable_v&lt;T&amp;, U&gt;. Add a conditional noexcept specification to std::apply With the introduction of zip algorithms in C++23, people in and around the committee started to talk once again more and more about std::apply. The reason is that std::apply could be effectively used to implement these new algorithms. In fact, in the previously referenced proposal apply appears quite a few times. Sadly, std::apply is not noexcept. But, if we have a look into the exposition-only implementation of apply, we can see that it uses invoke and get. The latter is noexcept and the former is conditionally noexcept, so there is no reason why std::apply should not be conditionally noexcept. And that becomes the new reality with C++23: 1 2 3 4 template&lt;class F, class Tuple&gt; constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) noexcept(see below); // Let I be the pack 0, 1, ..., (tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;-1). The exception specification is equivalent to: noexcept(invoke(std::forward&lt;F&gt;(f), get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...)). Conclusion In this article, we reviewed how the standard defines its policies towards the noexcept specification and we also see that two standard library functions (std::apply and std::exchange) are becoming noexcept. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="If my math is correct, there are 125 changes / fixes / new features in C++23 and we are progressively covering them on this blog. I try to go from topic to topic. There are some topics with many smaller changes, such as constexpr, there are some significant topics where even one topic must be in its own post such as the stacktrace library, and there are also some shorter posts with few and quite small changes on a given topic. Today we are going to discuss noexcept related changes. If you haven’t read it, I’d recommend reading my article on noexcept and its effects on binary size We can definitely see two trends in the proposals accepted for the latest standards. They try to make more and more functions: constexpr, and noexcept The two main changes presented today fit into this trend. But let’s start with discussing a bit of noexcept policies in the standard. noexcept, but with conditions The current policies on whether something in the standard can be noexcept or not is defined by P1656R2. Let me summarize the gist of it here. As we got used to it, a destructor should never throw and therefore even if you don’t mark it noexcept they implicitly are! There might be standard library functions marked unconditionally noexcept if the committee fully agrees that the given function cannot throw. The standard specifies a couple of special member functions and library functions that can be marked conditionally noexcept, based on the underlying types and the types these functions operate on. Nothing else can be marked noexcept, except for library functions that are designed for compatibility with C. Those can be unconditionally noexcept. Most often, we mark functions either noexcept or not. So we often mark our functions unconditionally noexcept. But noexcept can take a compile-time computable condition, such as std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; std::is_nothrow_assignable_v&lt;T&amp;, U&gt; Here is the list that can be marked conditionally noexcept according to C++20. std::swap the copy-constructor and -assignment operator the move-constructor and -assignment operator This list is getting modified in the C++23 standard. It’s also worth noting that an implementation can mark conditionally noexcept a function even if it’s not listed by the standard so. Add a conditional noexcept specification to std::exchange One of the primary use cases for std::exchange is implementing the move constructor and move assignment operator. In a certain way, it’s quite similar to std::swap. Yet, while std::swap and move operations can be conditionally noexcept, it was not the case for std::exchange. Up until C++23. P2401R0 makes std::exchange conditionally noexcept. The conditions are the same as for move operations: is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_assignable_v&lt;T&amp;, U&gt;. Add a conditional noexcept specification to std::apply With the introduction of zip algorithms in C++23, people in and around the committee started to talk once again more and more about std::apply. The reason is that std::apply could be effectively used to implement these new algorithms. In fact, in the previously referenced proposal apply appears quite a few times. Sadly, std::apply is not noexcept. But, if we have a look into the exposition-only implementation of apply, we can see that it uses invoke and get. The latter is noexcept and the former is conditionally noexcept, so there is no reason why std::apply should not be conditionally noexcept. And that becomes the new reality with C++23: 1 2 3 4 template&lt;class F, class Tuple&gt; constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) noexcept(see below); // Let I be the pack 0, 1, ..., (tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;-1). The exception specification is equivalent to: noexcept(invoke(std::forward&lt;F&gt;(f), get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...)). Conclusion In this article, we reviewed how the standard defines its policies towards the noexcept specification and we also see that two standard library functions (std::apply and std::exchange) are becoming noexcept. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-31T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: two additional noexcept functions" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-31T00:00:00+02:00","datePublished":"2023-05-31T00:00:00+02:00","description":"If my math is correct, there are 125 changes / fixes / new features in C++23 and we are progressively covering them on this blog. I try to go from topic to topic. There are some topics with many smaller changes, such as constexpr, there are some significant topics where even one topic must be in its own post such as the stacktrace library, and there are also some shorter posts with few and quite small changes on a given topic. Today we are going to discuss noexcept related changes. If you haven’t read it, I’d recommend reading my article on noexcept and its effects on binary size We can definitely see two trends in the proposals accepted for the latest standards. They try to make more and more functions: constexpr, and noexcept The two main changes presented today fit into this trend. But let’s start with discussing a bit of noexcept policies in the standard. noexcept, but with conditions The current policies on whether something in the standard can be noexcept or not is defined by P1656R2. Let me summarize the gist of it here. As we got used to it, a destructor should never throw and therefore even if you don’t mark it noexcept they implicitly are! There might be standard library functions marked unconditionally noexcept if the committee fully agrees that the given function cannot throw. The standard specifies a couple of special member functions and library functions that can be marked conditionally noexcept, based on the underlying types and the types these functions operate on. Nothing else can be marked noexcept, except for library functions that are designed for compatibility with C. Those can be unconditionally noexcept. Most often, we mark functions either noexcept or not. So we often mark our functions unconditionally noexcept. But noexcept can take a compile-time computable condition, such as std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; std::is_nothrow_assignable_v&lt;T&amp;, U&gt; Here is the list that can be marked conditionally noexcept according to C++20. std::swap the copy-constructor and -assignment operator the move-constructor and -assignment operator This list is getting modified in the C++23 standard. It’s also worth noting that an implementation can mark conditionally noexcept a function even if it’s not listed by the standard so. Add a conditional noexcept specification to std::exchange One of the primary use cases for std::exchange is implementing the move constructor and move assignment operator. In a certain way, it’s quite similar to std::swap. Yet, while std::swap and move operations can be conditionally noexcept, it was not the case for std::exchange. Up until C++23. P2401R0 makes std::exchange conditionally noexcept. The conditions are the same as for move operations: is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_assignable_v&lt;T&amp;, U&gt;. Add a conditional noexcept specification to std::apply With the introduction of zip algorithms in C++23, people in and around the committee started to talk once again more and more about std::apply. The reason is that std::apply could be effectively used to implement these new algorithms. In fact, in the previously referenced proposal apply appears quite a few times. Sadly, std::apply is not noexcept. But, if we have a look into the exposition-only implementation of apply, we can see that it uses invoke and get. The latter is noexcept and the former is conditionally noexcept, so there is no reason why std::apply should not be conditionally noexcept. And that becomes the new reality with C++23: 1 2 3 4 template&lt;class F, class Tuple&gt; constexpr decltype(auto) apply(F&amp;&amp; f, Tuple&amp;&amp; t) noexcept(see below); // Let I be the pack 0, 1, ..., (tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;-1). The exception specification is equivalent to: noexcept(invoke(std::forward&lt;F&gt;(f), get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...)). Conclusion In this article, we reviewed how the standard defines its policies towards the noexcept specification and we also see that two standard library functions (std::apply and std::exchange) are becoming noexcept. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: two additional noexcept functions","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes"},"url":"https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes"}</script><title>C++23: two additional noexcept functions | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/31"> 31 </a> </span> <span>C++23: two additional noexcept functions</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: two additional noexcept functions</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 31, 2023, 12:00 AM +0200" prep="on" > May 31, 2023 <i class="unloaded">2023-05-31T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="639 words">3 min</span></div></div><div class="post-content"><p>If my math is correct, there are 125 changes / fixes / new features in C++23 and we are progressively covering them on this blog. I try to go from topic to topic. There are some topics with many smaller changes, such as <a href="https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr"><code class="language-plaintext highlighter-rouge">constexpr</code></a>, there are some significant topics where even one topic must be in its own post such as <a href="https://www.sandordargo.com/blog/2022/09/21/cpp23-stacktrace-library">the stacktrace library</a>, and there are also some shorter posts with few and quite small changes on a given topic. Today we are going to discuss <code class="language-plaintext highlighter-rouge">noexcept</code> related changes.</p><blockquote><p>If you haven’t read it, I’d recommend reading my article on <code class="language-plaintext highlighter-rouge">noexcept</code> and its effects <a href="https://www.sandordargo.com/blog/2023/03/29/binary-size-and-exceptions">on binary size</a></p></blockquote><p>We can definitely see two trends in the proposals accepted for the latest standards. They try to make more and more functions:</p><ul><li><a href="https://www.sandordargo.com/blog/2023/05/24/cpp23-constexpr"><code class="language-plaintext highlighter-rouge">constexpr</code></a>, and<li><code class="language-plaintext highlighter-rouge">noexcept</code></ul><p>The two main changes presented today fit into this trend. But let’s start with discussing a bit of <code class="language-plaintext highlighter-rouge">noexcept</code> policies in the standard.</p><h2 id="noexcept-but-with-conditions"><code class="language-plaintext highlighter-rouge">noexcept</code>, but with conditions</h2><p>The current policies on whether something in the standard can be <code class="language-plaintext highlighter-rouge">noexcept</code> or not is defined by <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2020/p1656r2.html">P1656R2</a>. Let me summarize the gist of it here.</p><p>As we got used to it, a destructor should never throw and therefore even if you don’t mark it <code class="language-plaintext highlighter-rouge">noexcept</code> they implicitly are!</p><p>There might be standard library functions marked unconditionally <code class="language-plaintext highlighter-rouge">noexcept</code> if the committee fully agrees that the given function cannot throw.</p><p>The standard specifies a couple of special member functions and library functions that can be marked conditionally <code class="language-plaintext highlighter-rouge">noexcept</code>, based on the underlying types and the types these functions operate on. Nothing else can be marked <code class="language-plaintext highlighter-rouge">noexcept</code>, except for library functions that are designed for compatibility with C. Those can be unconditionally <code class="language-plaintext highlighter-rouge">noexcept</code>.</p><blockquote><p>Most often, we mark functions either <code class="language-plaintext highlighter-rouge">noexcept</code> or not. So we often mark our functions unconditionally <code class="language-plaintext highlighter-rouge">noexcept</code>. But <code class="language-plaintext highlighter-rouge">noexcept</code> can take a compile-time computable condition, such as <code class="language-plaintext highlighter-rouge">std::is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; std::is_nothrow_assignable_v&lt;T&amp;, U&gt;</code></p></blockquote><p>Here is the list that can be marked conditionally <code class="language-plaintext highlighter-rouge">noexcept</code> according to C++20.</p><ul><li><code class="language-plaintext highlighter-rouge">std::swap</code><li>the copy-constructor and -assignment operator<li>the move-constructor and -assignment operator</ul><p>This list is getting modified in the C++23 standard.</p><p>It’s also worth noting that an implementation can mark conditionally <code class="language-plaintext highlighter-rouge">noexcept</code> a function even if it’s not listed by the standard so.</p><h2 id="add-a-conditional-noexcept-specification-to-stdexchange">Add a conditional noexcept specification to <code class="language-plaintext highlighter-rouge">std::exchange</code></h2><p>One of the primary use cases for <code class="language-plaintext highlighter-rouge">std::exchange</code> is implementing the move constructor and move assignment operator. In a certain way, it’s quite similar to <code class="language-plaintext highlighter-rouge">std::swap</code>. Yet, while <code class="language-plaintext highlighter-rouge">std::swap</code> and move operations can be conditionally <code class="language-plaintext highlighter-rouge">noexcept</code>, it was not the case for <code class="language-plaintext highlighter-rouge">std::exchange</code>.</p><p>Up until C++23.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2401r0.html">P2401R0</a> makes <code class="language-plaintext highlighter-rouge">std::exchange</code> conditionally <code class="language-plaintext highlighter-rouge">noexcept</code>. The conditions are the same as for move operations: <code class="language-plaintext highlighter-rouge">is_nothrow_move_constructible_v&lt;T&gt; &amp;&amp; is_nothrow_assignable_v&lt;T&amp;, U&gt;</code>.</p><h2 id="add-a-conditional-noexcept-specification-to-stdapply">Add a conditional noexcept specification to <code class="language-plaintext highlighter-rouge">std::apply</code></h2><p>With <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p2321r2.html">the introduction of <code class="language-plaintext highlighter-rouge">zip</code> algorithms in C++23</a>, people in and around the committee started to talk once again more and more about <code class="language-plaintext highlighter-rouge">std::apply</code>.</p><p>The reason is that <code class="language-plaintext highlighter-rouge">std::apply</code> could be effectively used to implement these new algorithms. In fact, in the previously referenced proposal <code class="language-plaintext highlighter-rouge">apply</code> appears quite a few times. Sadly, <code class="language-plaintext highlighter-rouge">std::apply</code> is not <code class="language-plaintext highlighter-rouge">noexcept</code>.</p><p>But, if we have a look into the exposition-only implementation of <code class="language-plaintext highlighter-rouge">apply</code>, we can see that it uses <code class="language-plaintext highlighter-rouge">invoke</code> and <code class="language-plaintext highlighter-rouge">get</code>. The latter is <code class="language-plaintext highlighter-rouge">noexcept</code> and the former is conditionally <code class="language-plaintext highlighter-rouge">noexcept</code>, so there is no reason why <code class="language-plaintext highlighter-rouge">std::apply</code> should not be conditionally <code class="language-plaintext highlighter-rouge">noexcept</code>.</p><p>And that becomes the new reality with C++23:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">F</span><span class="p">,</span> <span class="k">class</span> <span class="nc">Tuple</span><span class="p">&gt;</span>
  <span class="k">constexpr</span> <span class="nf">decltype</span><span class="p">(</span><span class="k">auto</span><span class="p">)</span> <span class="n">apply</span><span class="p">(</span><span class="n">F</span><span class="o">&amp;&amp;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tuple</span><span class="o">&amp;&amp;</span> <span class="n">t</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">(</span><span class="n">see</span> <span class="n">below</span><span class="p">);</span>
  
<span class="c1">// Let I be the pack 0, 1, ..., (tuple_size_v&lt;remove_reference_t&lt;Tuple&gt;&gt;-1). The exception specification is equivalent to: noexcept(invoke(std::forward&lt;F&gt;(f), get&lt;I&gt;(std::forward&lt;Tuple&gt;(t))...)).</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>In this article, we reviewed how the standard defines its policies towards the <code class="language-plaintext highlighter-rouge">noexcept</code> specification and we also see that two standard library functions (<code class="language-plaintext highlighter-rouge">std::apply</code> and <code class="language-plaintext highlighter-rouge">std::exchange</code>) are becoming <code class="language-plaintext highlighter-rouge">noexcept</code>.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/noexcept/" class="post-tag no-text-decoration" >noexcept</a> <a href="/tags/exceptions/" class="post-tag no-text-decoration" >exceptions</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: two additional noexcept functions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: two additional noexcept functions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: two additional noexcept functions - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: two additional noexcept functions - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2026/01/21/clocks-part-8-cpp20-timezones">Time in C++: C++20 Brought Us Time Zones</a><li><a href="/blog/2019/04/10/lesson-of-a-booking-dont-trust-the-system">Lesson of a booking: Don't trust the system!</a><li><a href="/blog/2020/07/22/always-catch-exceptions-by-reference">Why should we always catch exceptions by reference?</a><li><a href="/blog/2020/11/28/emergent-design">Emergent Design: The Evolutionary Nature of Professional Software Development by Scott Bain</a><li><a href="/blog/2021/10/06/airy-code-reviews">Bring some fresh AIR and write effective code review comments</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2023/03/29/binary-size-and-exceptions"><div class="card-body"> <span class="timeago small" > Mar 29, 2023 <i class="unloaded">2023-03-29T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Binary size and exceptions</h3><div class="text-muted small"><p> In this series of articles about binary sizes, we already talked about the default keyword and said that the default keyword will make a special function noexcept, whenever it can. What is noexcep...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/05/24/cpp23-constexpr" class="btn btn-outline-primary" prompt="Older"><p>C++23: Even more constexpr</p></a> <a href="/blog/2023/06/07/recent-changes-and-commitments" class="btn btn-outline-primary" prompt="Newer"><p>Recent changes and personal commitments</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: two additional noexcept functions'; this.page.url = 'https://www.sandordargo.com/blog/2023/05/31/cpp23-noexcept-related-changes'; this.page.identifier = '/blog/2023/05/31/cpp23-noexcept-related-changes'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2026 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
