<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="Is this dynamic_cast needed?" /><meta property="og:locale" content="en_US" /><meta name="description" content="I have already written a couple of times about dynamic_cast. I claimed that if you can avoid using it and RTTI, you can get a smaller binary. I also claimed that without dynamic_cast your code will be cleaner. The first claim is new from my side, I didn’t care about executable size earlier. The second one is less so, I read a long time ago in the Core Guidelines that one should avoid using dynamic_cast whenever possible, but there are some cases when you cannot avoid it. I’ve discussed this topic with a friend of mine who’s been teaching C++ for a couple of years and I know he doesn’t share these views that much. Or at least he’s not so critical towards dynamic_cast. He thinks that it is a useful tool in many cases and there must be a reason why it’s in the language and not removed. It is true that is mentioned in the Core Guidelines that there can be some cases when it is needed. Besides, one of the greatest superpowers of C++ is backward compatibility. Removing dynamic_cast would break half of the world… dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. This friend of mine sends me some piece of code every now and then saying that this might be a good example. He sent me an example a few weeks ago and maybe this was the good one. Maybe. A tree combining templates and virtuals The example is from Category Theory for Programmers written by Bartosz Milewski who also wrote C++ In Action: Industrial Strength Programming Techniques. He shows that we should be able to write/recognize some algebraic data structures in C++ and implement fmap for them. fmap is a higher-order function in functional programming that applies a given function to the elements of a container and returns a new container with the results. And here is his implementation for a Tree and fmap(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template&lt;class T&gt; struct Tree { virtual ~Tree() {}; }; template&lt;class T&gt; struct Leaf : public Tree&lt;T&gt; { T _label; Leaf(T l) : _label(l) {} }; template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} }; template&lt;class A, class B&gt; Tree&lt;B&gt; * fmap(std::function&lt;B(A)&gt; f, Tree&lt;A&gt; * t) { Leaf&lt;A&gt; * pl = dynamic_cast &lt;Leaf&lt;A&gt;*&gt;(t); if (pl) return new Leaf&lt;B&gt;(f (pl-&gt;_label)); Node&lt;A&gt; * pn = dynamic_cast&lt;Node&lt;A&gt;*&gt;(t); if (pn) return new Node&lt;B&gt;( fmap&lt;A&gt;(f, pn-&gt;_left) , fmap&lt;A&gt;(f, pn-&gt;_right)); return nullptr; } Is that a good implementation? What is good anyway? The author explicitly writes that he omitted resource and memory management and in production code, one should use smart pointers. I think it’s a meaningful simplification in a book or in a blog post. Let’s concentrate on fmap() first and just take note that it’s probably an acceptable idea to return nullptr if both casts fail. I’d probably throw an exception instead if exceptions are allowed, otherwise, let’s say that this is fine. But what about the dynamic_cast? My first idea was that hey, we should replace the one “big” fmap() with 2 overloads: 1 2 3 4 5 6 7 8 9 10 template &lt;typename A, typename B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) { return new Leaf&lt;B&gt;(f2(t-&gt;label)); } template &lt;typename A, typename B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) { return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), fmap2&lt;A&gt;(f, t-&gt;_right)); } But in this case, the compilation fails! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &lt;source&gt;: In instantiation of &#39;Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*) [with A = int; B = float]&#39;: &lt;source&gt;:82:28: required from here &lt;source&gt;:68:32: error: no matching function for call to &#39;fmap2&lt;int&gt;(std::function&lt;float(int)&gt;&amp;, Tree&lt;int&gt;*&amp;)&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~~~~~~^~~~~~~~~~~~~ &lt;source&gt;:62:10: note: candidate: &#39;template&lt;class A, class B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Leaf&lt;A&gt;*)&#39; 62 | Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) { | ^~~~~ &lt;source&gt;:62:10: note: template argument deduction/substitution failed: &lt;source&gt;:68:39: note: cannot convert &#39;t-&gt;Node&lt;int&gt;::_left&#39; (type &#39;Tree&lt;int&gt;*&#39;) to type &#39;Leaf&lt;int&gt;*&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~^~~~~ &lt;source&gt;:67:10: note: candidate: &#39;template&lt;class A, class B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*)&#39; 67 | Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) { | ^~~~~ &lt;source&gt;:67:10: note: template argument deduction/substitution failed: &lt;source&gt;:68:39: note: cannot convert &#39;t-&gt;Node&lt;int&gt;::_left&#39; (type &#39;Tree&lt;int&gt;*&#39;) to type &#39;Node&lt;int&gt;*&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~^~~~~ Of course! What if t is a Tree&lt;A&gt; and not a Leaf of a Node?! That shouldn’t happen, but even in the original code we have a case to handle that, so let’s just add: 1 2 3 4 template &lt;typename A, typename B&gt; Tree&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Tree&lt;A&gt;*) { return nullptr; } Now the code compiles, but the executable returned 139. In other words, we have a segmentation fault. Right, Node has two pointers to Tree and instead of matching one of the overloads for Leaf or Node, the one for Tree is matched which returns a nullptr and when we try to print the labels we crash. In case of function overloads the static type is matched. If we want runtime dispatching, we need virtual functions and overrides. So what if we’d implement a virtual clone function? The initial idea might seem nice, but the problem is that we’d also have to either apply f on the member or just use its return type (marked by typename B). In order to do so, we could apply an extension of the prototype design pattern, where a virtual clone() method replaces a virtual constructor which doesn’t exist in C++. The only problem is that we would need to extend the pattern by passing the transformation function (f) to the clone() as a parameter. But f is a template type and we cannot combine a virtual function with a template. We’d need to somehow erase f’s return type by the time we reach clone(). But you have to know where to stop and when going down the rabbit hole is not worth it - in my opinion. Let’s just accept that dynamic_cast has its merit with this Tree implementation. But do we really need it? Prefer composition over inheritance Probably we have all heard in many places that we should prefer composition over inheritance. We are also probably familiar with the KISS principle which means that we should keep things simple, stupid. Now let’s have a look at the above Node class once again: 1 2 3 4 5 6 template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} }; We have a derived class inheriting from a templated base class. This derived class stores two pointers to objects of the base class type. We use templates, composition and inheritance at the same time. That cannot be KISS. I don’t think that it’s needed. We do need templates given that we want the ability to store different types in the tree. We also need composition, as in a node we want to store references to the underlying two trees. To simplify the Tree class and also hope to remove the need for dynamic_cast, let’s get rid of the class hierarchy. (I’m also omitting the issue of memory management as I want the two solutions to remain easily comparable) What does that inheritance give us anyway? Just by looking at the type, we know whether we deal with an intermediary node or a leaf in the tree. But we can know that in other ways too. 1 2 3 4 5 6 7 8 9 10 11 template&lt;typename V&gt; class Tree { public: Tree(Tree* l, Tree* r): left(l), right(r) {} Tree(V l): label(l) {} private: Tree&lt;V&gt;* left = nullptr; Tree&lt;V&gt;* right = nullptr; std::optional&lt;V&gt; label = std::nullopt; }; In the above Tree class we have three members. Two pointers two other Trees and we also store an optional label. We expose two constructors: the one taking two pointers to Trees initializes an object that corresponds to the former Node class the other taking an instance of the template argument type initializes an object that will serve as a Leaf As the members are private, we either use Tree one way or the other. By looking at the initialization, we’ll know which way it is used. If you really want to know it during runtime, we could query an additional member bool is_leaf; which would be initialized in the constructor call. But I don’t think that we need that knowledge. (If the label cannot be nullopt in a leaf, we could also check the state of the optional label) Also, we’d need to expose certain getters to the members of this class, but we don’t need them for the fmap() implementation. You might argue that if the accessors are non-const then people can misuse the class. And that’s a valid concern. But it takes extra effort (why would you do that?) and it strikes out in a pull request, it’s easy to spot such misuses (why would you approve that?). The fmap() implementation is fairly simple: 1 2 3 4 5 6 7 template&lt;typename V, typename N&gt; Tree&lt;N&gt;* fmap(std::function&lt;N(V)&gt; f, Tree&lt;V&gt;* t) { if (!t) { return nullptr; } return new Tree(fmap(f, t-&gt;left), fmap(f, t-&gt;right), t-&gt;label ? std::optional&lt;N&gt;(f(*t-&gt;label)) : std::nullopt); } If t is nullptr then we stop the recursion by returning nullptr. Otherwise, we return a new Tree using the mapped type (V -&gt; N). In order to make this work, we need a new Tree constructor that can initialize all the members. But nobody else needs that so let’s make it private and make fmap() a friend of Tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template&lt;typename V&gt; class Tree { public: Tree(Tree* l, Tree* r): left(l), right(r) {} Tree(V l): label(l) {} private: Tree(Tree* l, Tree* r, std::optional&lt;V&gt; v): left(l), right(r), label(v) {} template&lt;typename V2, typename N&gt; friend Tree&lt;N&gt;* fmap(std::function&lt;N(V2)&gt; f, Tree&lt;V2&gt;* t); Tree&lt;V&gt;* left = nullptr; Tree&lt;V&gt;* right = nullptr; std::optional&lt;V&gt; label = std::nullopt; }; Which one is better? I don’t have a clear answer. In the original solution, you can see from the (dynamic) type whether you deal with a node or a leaf. But you also need a polymorphic structure and all the overhead that comes with it. You don’t only see this characteristic, but each type represents a clear role. You might say that my solution is not complete because we need to expose the members, but there is a very high chance that the original Tree wouldn’t stay a struct and the members would be private in that too. But even in that case, the second solution (if the accessors are non-const) might be misused. Even though it’s not convenient and it is highly visible. But what about performance? We can expect that the second solution will have a bigger memory footprint as in every case each node of the Tree has 3 members. Two pointers and an optional V. On the other hand, we can expect that the second solution will be faster, as there are no virtual functions, there is no dynamic dispatching of function calls and obviously no casting. I created a small Tree of 8 integers and applied a function on it which multiplies each value by 2 and ran it 10,000 times. The static solution took a bit longer time to compile (~3%), and its executable was a tiny bit smaller (~2%), but it was executing much faster (~50%). Even though as expected, the memory consumption was 30% higher for the non-polymorphic version. So the second solution is smaller, much faster, but it needs way more memory at runtime. It’s simpler, but in a way, it’s less expressive. In most cases, there is no black or white. Only tradeoffs. In this case, we traded off memory for runtime. Simplicity for expressiveness. Conclusion Today, we talked once again about when (not) to use dynamic_cast. We looked into a tree implementation where fmap() needed to use dynamic_cast. Then we looked into another where it was not needed. The dynamic_cast version needs more time to execute but much less memory than the non-polymorphic version. Programming, just like life, is about tradeoffs. In this case, the solution with dynamic_cast has its merits, but you might go with another solution depending on your constraints. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="I have already written a couple of times about dynamic_cast. I claimed that if you can avoid using it and RTTI, you can get a smaller binary. I also claimed that without dynamic_cast your code will be cleaner. The first claim is new from my side, I didn’t care about executable size earlier. The second one is less so, I read a long time ago in the Core Guidelines that one should avoid using dynamic_cast whenever possible, but there are some cases when you cannot avoid it. I’ve discussed this topic with a friend of mine who’s been teaching C++ for a couple of years and I know he doesn’t share these views that much. Or at least he’s not so critical towards dynamic_cast. He thinks that it is a useful tool in many cases and there must be a reason why it’s in the language and not removed. It is true that is mentioned in the Core Guidelines that there can be some cases when it is needed. Besides, one of the greatest superpowers of C++ is backward compatibility. Removing dynamic_cast would break half of the world… dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. This friend of mine sends me some piece of code every now and then saying that this might be a good example. He sent me an example a few weeks ago and maybe this was the good one. Maybe. A tree combining templates and virtuals The example is from Category Theory for Programmers written by Bartosz Milewski who also wrote C++ In Action: Industrial Strength Programming Techniques. He shows that we should be able to write/recognize some algebraic data structures in C++ and implement fmap for them. fmap is a higher-order function in functional programming that applies a given function to the elements of a container and returns a new container with the results. And here is his implementation for a Tree and fmap(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template&lt;class T&gt; struct Tree { virtual ~Tree() {}; }; template&lt;class T&gt; struct Leaf : public Tree&lt;T&gt; { T _label; Leaf(T l) : _label(l) {} }; template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} }; template&lt;class A, class B&gt; Tree&lt;B&gt; * fmap(std::function&lt;B(A)&gt; f, Tree&lt;A&gt; * t) { Leaf&lt;A&gt; * pl = dynamic_cast &lt;Leaf&lt;A&gt;*&gt;(t); if (pl) return new Leaf&lt;B&gt;(f (pl-&gt;_label)); Node&lt;A&gt; * pn = dynamic_cast&lt;Node&lt;A&gt;*&gt;(t); if (pn) return new Node&lt;B&gt;( fmap&lt;A&gt;(f, pn-&gt;_left) , fmap&lt;A&gt;(f, pn-&gt;_right)); return nullptr; } Is that a good implementation? What is good anyway? The author explicitly writes that he omitted resource and memory management and in production code, one should use smart pointers. I think it’s a meaningful simplification in a book or in a blog post. Let’s concentrate on fmap() first and just take note that it’s probably an acceptable idea to return nullptr if both casts fail. I’d probably throw an exception instead if exceptions are allowed, otherwise, let’s say that this is fine. But what about the dynamic_cast? My first idea was that hey, we should replace the one “big” fmap() with 2 overloads: 1 2 3 4 5 6 7 8 9 10 template &lt;typename A, typename B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) { return new Leaf&lt;B&gt;(f2(t-&gt;label)); } template &lt;typename A, typename B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) { return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), fmap2&lt;A&gt;(f, t-&gt;_right)); } But in this case, the compilation fails! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &lt;source&gt;: In instantiation of &#39;Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*) [with A = int; B = float]&#39;: &lt;source&gt;:82:28: required from here &lt;source&gt;:68:32: error: no matching function for call to &#39;fmap2&lt;int&gt;(std::function&lt;float(int)&gt;&amp;, Tree&lt;int&gt;*&amp;)&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~~~~~~^~~~~~~~~~~~~ &lt;source&gt;:62:10: note: candidate: &#39;template&lt;class A, class B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Leaf&lt;A&gt;*)&#39; 62 | Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) { | ^~~~~ &lt;source&gt;:62:10: note: template argument deduction/substitution failed: &lt;source&gt;:68:39: note: cannot convert &#39;t-&gt;Node&lt;int&gt;::_left&#39; (type &#39;Tree&lt;int&gt;*&#39;) to type &#39;Leaf&lt;int&gt;*&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~^~~~~ &lt;source&gt;:67:10: note: candidate: &#39;template&lt;class A, class B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*)&#39; 67 | Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) { | ^~~~~ &lt;source&gt;:67:10: note: template argument deduction/substitution failed: &lt;source&gt;:68:39: note: cannot convert &#39;t-&gt;Node&lt;int&gt;::_left&#39; (type &#39;Tree&lt;int&gt;*&#39;) to type &#39;Node&lt;int&gt;*&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~^~~~~ Of course! What if t is a Tree&lt;A&gt; and not a Leaf of a Node?! That shouldn’t happen, but even in the original code we have a case to handle that, so let’s just add: 1 2 3 4 template &lt;typename A, typename B&gt; Tree&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Tree&lt;A&gt;*) { return nullptr; } Now the code compiles, but the executable returned 139. In other words, we have a segmentation fault. Right, Node has two pointers to Tree and instead of matching one of the overloads for Leaf or Node, the one for Tree is matched which returns a nullptr and when we try to print the labels we crash. In case of function overloads the static type is matched. If we want runtime dispatching, we need virtual functions and overrides. So what if we’d implement a virtual clone function? The initial idea might seem nice, but the problem is that we’d also have to either apply f on the member or just use its return type (marked by typename B). In order to do so, we could apply an extension of the prototype design pattern, where a virtual clone() method replaces a virtual constructor which doesn’t exist in C++. The only problem is that we would need to extend the pattern by passing the transformation function (f) to the clone() as a parameter. But f is a template type and we cannot combine a virtual function with a template. We’d need to somehow erase f’s return type by the time we reach clone(). But you have to know where to stop and when going down the rabbit hole is not worth it - in my opinion. Let’s just accept that dynamic_cast has its merit with this Tree implementation. But do we really need it? Prefer composition over inheritance Probably we have all heard in many places that we should prefer composition over inheritance. We are also probably familiar with the KISS principle which means that we should keep things simple, stupid. Now let’s have a look at the above Node class once again: 1 2 3 4 5 6 template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} }; We have a derived class inheriting from a templated base class. This derived class stores two pointers to objects of the base class type. We use templates, composition and inheritance at the same time. That cannot be KISS. I don’t think that it’s needed. We do need templates given that we want the ability to store different types in the tree. We also need composition, as in a node we want to store references to the underlying two trees. To simplify the Tree class and also hope to remove the need for dynamic_cast, let’s get rid of the class hierarchy. (I’m also omitting the issue of memory management as I want the two solutions to remain easily comparable) What does that inheritance give us anyway? Just by looking at the type, we know whether we deal with an intermediary node or a leaf in the tree. But we can know that in other ways too. 1 2 3 4 5 6 7 8 9 10 11 template&lt;typename V&gt; class Tree { public: Tree(Tree* l, Tree* r): left(l), right(r) {} Tree(V l): label(l) {} private: Tree&lt;V&gt;* left = nullptr; Tree&lt;V&gt;* right = nullptr; std::optional&lt;V&gt; label = std::nullopt; }; In the above Tree class we have three members. Two pointers two other Trees and we also store an optional label. We expose two constructors: the one taking two pointers to Trees initializes an object that corresponds to the former Node class the other taking an instance of the template argument type initializes an object that will serve as a Leaf As the members are private, we either use Tree one way or the other. By looking at the initialization, we’ll know which way it is used. If you really want to know it during runtime, we could query an additional member bool is_leaf; which would be initialized in the constructor call. But I don’t think that we need that knowledge. (If the label cannot be nullopt in a leaf, we could also check the state of the optional label) Also, we’d need to expose certain getters to the members of this class, but we don’t need them for the fmap() implementation. You might argue that if the accessors are non-const then people can misuse the class. And that’s a valid concern. But it takes extra effort (why would you do that?) and it strikes out in a pull request, it’s easy to spot such misuses (why would you approve that?). The fmap() implementation is fairly simple: 1 2 3 4 5 6 7 template&lt;typename V, typename N&gt; Tree&lt;N&gt;* fmap(std::function&lt;N(V)&gt; f, Tree&lt;V&gt;* t) { if (!t) { return nullptr; } return new Tree(fmap(f, t-&gt;left), fmap(f, t-&gt;right), t-&gt;label ? std::optional&lt;N&gt;(f(*t-&gt;label)) : std::nullopt); } If t is nullptr then we stop the recursion by returning nullptr. Otherwise, we return a new Tree using the mapped type (V -&gt; N). In order to make this work, we need a new Tree constructor that can initialize all the members. But nobody else needs that so let’s make it private and make fmap() a friend of Tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template&lt;typename V&gt; class Tree { public: Tree(Tree* l, Tree* r): left(l), right(r) {} Tree(V l): label(l) {} private: Tree(Tree* l, Tree* r, std::optional&lt;V&gt; v): left(l), right(r), label(v) {} template&lt;typename V2, typename N&gt; friend Tree&lt;N&gt;* fmap(std::function&lt;N(V2)&gt; f, Tree&lt;V2&gt;* t); Tree&lt;V&gt;* left = nullptr; Tree&lt;V&gt;* right = nullptr; std::optional&lt;V&gt; label = std::nullopt; }; Which one is better? I don’t have a clear answer. In the original solution, you can see from the (dynamic) type whether you deal with a node or a leaf. But you also need a polymorphic structure and all the overhead that comes with it. You don’t only see this characteristic, but each type represents a clear role. You might say that my solution is not complete because we need to expose the members, but there is a very high chance that the original Tree wouldn’t stay a struct and the members would be private in that too. But even in that case, the second solution (if the accessors are non-const) might be misused. Even though it’s not convenient and it is highly visible. But what about performance? We can expect that the second solution will have a bigger memory footprint as in every case each node of the Tree has 3 members. Two pointers and an optional V. On the other hand, we can expect that the second solution will be faster, as there are no virtual functions, there is no dynamic dispatching of function calls and obviously no casting. I created a small Tree of 8 integers and applied a function on it which multiplies each value by 2 and ran it 10,000 times. The static solution took a bit longer time to compile (~3%), and its executable was a tiny bit smaller (~2%), but it was executing much faster (~50%). Even though as expected, the memory consumption was 30% higher for the non-polymorphic version. So the second solution is smaller, much faster, but it needs way more memory at runtime. It’s simpler, but in a way, it’s less expressive. In most cases, there is no black or white. Only tradeoffs. In this case, we traded off memory for runtime. Simplicity for expressiveness. Conclusion Today, we talked once again about when (not) to use dynamic_cast. We looked into a tree implementation where fmap() needed to use dynamic_cast. Then we looked into another where it was not needed. The dynamic_cast version needs more time to execute but much less memory than the non-polymorphic version. Programming, just like life, is about tradeoffs. In this case, the solution with dynamic_cast has its merits, but you might go with another solution depending on your constraints. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-05-10T00:00:00+02:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="Is this dynamic_cast needed?" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-05-10T00:00:00+02:00","datePublished":"2023-05-10T00:00:00+02:00","description":"I have already written a couple of times about dynamic_cast. I claimed that if you can avoid using it and RTTI, you can get a smaller binary. I also claimed that without dynamic_cast your code will be cleaner. The first claim is new from my side, I didn’t care about executable size earlier. The second one is less so, I read a long time ago in the Core Guidelines that one should avoid using dynamic_cast whenever possible, but there are some cases when you cannot avoid it. I’ve discussed this topic with a friend of mine who’s been teaching C++ for a couple of years and I know he doesn’t share these views that much. Or at least he’s not so critical towards dynamic_cast. He thinks that it is a useful tool in many cases and there must be a reason why it’s in the language and not removed. It is true that is mentioned in the Core Guidelines that there can be some cases when it is needed. Besides, one of the greatest superpowers of C++ is backward compatibility. Removing dynamic_cast would break half of the world… dynamic_cast safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy - according to CppReference. This friend of mine sends me some piece of code every now and then saying that this might be a good example. He sent me an example a few weeks ago and maybe this was the good one. Maybe. A tree combining templates and virtuals The example is from Category Theory for Programmers written by Bartosz Milewski who also wrote C++ In Action: Industrial Strength Programming Techniques. He shows that we should be able to write/recognize some algebraic data structures in C++ and implement fmap for them. fmap is a higher-order function in functional programming that applies a given function to the elements of a container and returns a new container with the results. And here is his implementation for a Tree and fmap(). 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 template&lt;class T&gt; struct Tree { virtual ~Tree() {}; }; template&lt;class T&gt; struct Leaf : public Tree&lt;T&gt; { T _label; Leaf(T l) : _label(l) {} }; template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} }; template&lt;class A, class B&gt; Tree&lt;B&gt; * fmap(std::function&lt;B(A)&gt; f, Tree&lt;A&gt; * t) { Leaf&lt;A&gt; * pl = dynamic_cast &lt;Leaf&lt;A&gt;*&gt;(t); if (pl) return new Leaf&lt;B&gt;(f (pl-&gt;_label)); Node&lt;A&gt; * pn = dynamic_cast&lt;Node&lt;A&gt;*&gt;(t); if (pn) return new Node&lt;B&gt;( fmap&lt;A&gt;(f, pn-&gt;_left) , fmap&lt;A&gt;(f, pn-&gt;_right)); return nullptr; } Is that a good implementation? What is good anyway? The author explicitly writes that he omitted resource and memory management and in production code, one should use smart pointers. I think it’s a meaningful simplification in a book or in a blog post. Let’s concentrate on fmap() first and just take note that it’s probably an acceptable idea to return nullptr if both casts fail. I’d probably throw an exception instead if exceptions are allowed, otherwise, let’s say that this is fine. But what about the dynamic_cast? My first idea was that hey, we should replace the one “big” fmap() with 2 overloads: 1 2 3 4 5 6 7 8 9 10 template &lt;typename A, typename B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) { return new Leaf&lt;B&gt;(f2(t-&gt;label)); } template &lt;typename A, typename B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) { return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), fmap2&lt;A&gt;(f, t-&gt;_right)); } But in this case, the compilation fails! 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 &lt;source&gt;: In instantiation of &#39;Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*) [with A = int; B = float]&#39;: &lt;source&gt;:82:28: required from here &lt;source&gt;:68:32: error: no matching function for call to &#39;fmap2&lt;int&gt;(std::function&lt;float(int)&gt;&amp;, Tree&lt;int&gt;*&amp;)&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~~~~~~^~~~~~~~~~~~~ &lt;source&gt;:62:10: note: candidate: &#39;template&lt;class A, class B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Leaf&lt;A&gt;*)&#39; 62 | Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) { | ^~~~~ &lt;source&gt;:62:10: note: template argument deduction/substitution failed: &lt;source&gt;:68:39: note: cannot convert &#39;t-&gt;Node&lt;int&gt;::_left&#39; (type &#39;Tree&lt;int&gt;*&#39;) to type &#39;Leaf&lt;int&gt;*&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~^~~~~ &lt;source&gt;:67:10: note: candidate: &#39;template&lt;class A, class B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*)&#39; 67 | Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) { | ^~~~~ &lt;source&gt;:67:10: note: template argument deduction/substitution failed: &lt;source&gt;:68:39: note: cannot convert &#39;t-&gt;Node&lt;int&gt;::_left&#39; (type &#39;Tree&lt;int&gt;*&#39;) to type &#39;Node&lt;int&gt;*&#39; 68 | return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left), | ~~~^~~~~ Of course! What if t is a Tree&lt;A&gt; and not a Leaf of a Node?! That shouldn’t happen, but even in the original code we have a case to handle that, so let’s just add: 1 2 3 4 template &lt;typename A, typename B&gt; Tree&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Tree&lt;A&gt;*) { return nullptr; } Now the code compiles, but the executable returned 139. In other words, we have a segmentation fault. Right, Node has two pointers to Tree and instead of matching one of the overloads for Leaf or Node, the one for Tree is matched which returns a nullptr and when we try to print the labels we crash. In case of function overloads the static type is matched. If we want runtime dispatching, we need virtual functions and overrides. So what if we’d implement a virtual clone function? The initial idea might seem nice, but the problem is that we’d also have to either apply f on the member or just use its return type (marked by typename B). In order to do so, we could apply an extension of the prototype design pattern, where a virtual clone() method replaces a virtual constructor which doesn’t exist in C++. The only problem is that we would need to extend the pattern by passing the transformation function (f) to the clone() as a parameter. But f is a template type and we cannot combine a virtual function with a template. We’d need to somehow erase f’s return type by the time we reach clone(). But you have to know where to stop and when going down the rabbit hole is not worth it - in my opinion. Let’s just accept that dynamic_cast has its merit with this Tree implementation. But do we really need it? Prefer composition over inheritance Probably we have all heard in many places that we should prefer composition over inheritance. We are also probably familiar with the KISS principle which means that we should keep things simple, stupid. Now let’s have a look at the above Node class once again: 1 2 3 4 5 6 template&lt;class T&gt; struct Node : public Tree&lt;T&gt; { Tree&lt;T&gt; * _left; Tree&lt;T&gt; * _right; Node(Tree&lt;T&gt; * l, Tree&lt;T&gt; * r) : _left(l), _right(r) {} }; We have a derived class inheriting from a templated base class. This derived class stores two pointers to objects of the base class type. We use templates, composition and inheritance at the same time. That cannot be KISS. I don’t think that it’s needed. We do need templates given that we want the ability to store different types in the tree. We also need composition, as in a node we want to store references to the underlying two trees. To simplify the Tree class and also hope to remove the need for dynamic_cast, let’s get rid of the class hierarchy. (I’m also omitting the issue of memory management as I want the two solutions to remain easily comparable) What does that inheritance give us anyway? Just by looking at the type, we know whether we deal with an intermediary node or a leaf in the tree. But we can know that in other ways too. 1 2 3 4 5 6 7 8 9 10 11 template&lt;typename V&gt; class Tree { public: Tree(Tree* l, Tree* r): left(l), right(r) {} Tree(V l): label(l) {} private: Tree&lt;V&gt;* left = nullptr; Tree&lt;V&gt;* right = nullptr; std::optional&lt;V&gt; label = std::nullopt; }; In the above Tree class we have three members. Two pointers two other Trees and we also store an optional label. We expose two constructors: the one taking two pointers to Trees initializes an object that corresponds to the former Node class the other taking an instance of the template argument type initializes an object that will serve as a Leaf As the members are private, we either use Tree one way or the other. By looking at the initialization, we’ll know which way it is used. If you really want to know it during runtime, we could query an additional member bool is_leaf; which would be initialized in the constructor call. But I don’t think that we need that knowledge. (If the label cannot be nullopt in a leaf, we could also check the state of the optional label) Also, we’d need to expose certain getters to the members of this class, but we don’t need them for the fmap() implementation. You might argue that if the accessors are non-const then people can misuse the class. And that’s a valid concern. But it takes extra effort (why would you do that?) and it strikes out in a pull request, it’s easy to spot such misuses (why would you approve that?). The fmap() implementation is fairly simple: 1 2 3 4 5 6 7 template&lt;typename V, typename N&gt; Tree&lt;N&gt;* fmap(std::function&lt;N(V)&gt; f, Tree&lt;V&gt;* t) { if (!t) { return nullptr; } return new Tree(fmap(f, t-&gt;left), fmap(f, t-&gt;right), t-&gt;label ? std::optional&lt;N&gt;(f(*t-&gt;label)) : std::nullopt); } If t is nullptr then we stop the recursion by returning nullptr. Otherwise, we return a new Tree using the mapped type (V -&gt; N). In order to make this work, we need a new Tree constructor that can initialize all the members. But nobody else needs that so let’s make it private and make fmap() a friend of Tree. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 template&lt;typename V&gt; class Tree { public: Tree(Tree* l, Tree* r): left(l), right(r) {} Tree(V l): label(l) {} private: Tree(Tree* l, Tree* r, std::optional&lt;V&gt; v): left(l), right(r), label(v) {} template&lt;typename V2, typename N&gt; friend Tree&lt;N&gt;* fmap(std::function&lt;N(V2)&gt; f, Tree&lt;V2&gt;* t); Tree&lt;V&gt;* left = nullptr; Tree&lt;V&gt;* right = nullptr; std::optional&lt;V&gt; label = std::nullopt; }; Which one is better? I don’t have a clear answer. In the original solution, you can see from the (dynamic) type whether you deal with a node or a leaf. But you also need a polymorphic structure and all the overhead that comes with it. You don’t only see this characteristic, but each type represents a clear role. You might say that my solution is not complete because we need to expose the members, but there is a very high chance that the original Tree wouldn’t stay a struct and the members would be private in that too. But even in that case, the second solution (if the accessors are non-const) might be misused. Even though it’s not convenient and it is highly visible. But what about performance? We can expect that the second solution will have a bigger memory footprint as in every case each node of the Tree has 3 members. Two pointers and an optional V. On the other hand, we can expect that the second solution will be faster, as there are no virtual functions, there is no dynamic dispatching of function calls and obviously no casting. I created a small Tree of 8 integers and applied a function on it which multiplies each value by 2 and ran it 10,000 times. The static solution took a bit longer time to compile (~3%), and its executable was a tiny bit smaller (~2%), but it was executing much faster (~50%). Even though as expected, the memory consumption was 30% higher for the non-polymorphic version. So the second solution is smaller, much faster, but it needs way more memory at runtime. It’s simpler, but in a way, it’s less expressive. In most cases, there is no black or white. Only tradeoffs. In this case, we traded off memory for runtime. Simplicity for expressiveness. Conclusion Today, we talked once again about when (not) to use dynamic_cast. We looked into a tree implementation where fmap() needed to use dynamic_cast. Then we looked into another where it was not needed. The dynamic_cast version needs more time to execute but much less memory than the non-polymorphic version. Programming, just like life, is about tradeoffs. In this case, the solution with dynamic_cast has its merits, but you might go with another solution depending on your constraints. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"Is this dynamic_cast needed?","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed"},"url":"https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed"}</script><title>Is this dynamic_cast needed? | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/05"> 05 </a> </span> <span> <a href="/10"> 10 </a> </span> <span>Is this dynamic_cast needed?</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>Is this dynamic_cast needed?</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, May 10, 2023, 12:00 AM +0200" prep="on" > May 10, 2023 <i class="unloaded">2023-05-10T00:00:00+02:00</i> </span></div><div> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2103 words">11 min</span></div></div><div class="post-content"><p>I have already written a couple of times about <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. I claimed that <a href="https://www.sandordargo.com/blog/2023/03/01/binary-sizes-and-rtti">if you can avoid using it and RTTI, you can get a smaller binary</a>. I also claimed that <a href="https://www.sandordargo.com/blog/2023/04/26/without-rtti-your-code-will-be-cleaner">without <code class="language-plaintext highlighter-rouge">dynamic_cast</code> your code will be cleaner</a>.</p><p>The first claim is new from my side, I didn’t care about executable size earlier. The second one is less so, I read a long time ago <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#c146-use-dynamic_cast-where-class-hierarchy-navigation-is-unavoidable">in the Core Guidelines</a> that one should avoid using <code class="language-plaintext highlighter-rouge">dynamic_cast</code> whenever possible, but there are some cases when you cannot avoid it.</p><p>I’ve discussed this topic with a friend of mine who’s been teaching C++ for a couple of years and I know he doesn’t share these views that much. Or at least he’s not so critical towards <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. He thinks that it is a useful tool in many cases and there must be a reason why it’s in the language and not removed.</p><p>It is true that is mentioned in the Core Guidelines that there can be some cases when it is needed. Besides, one of <a href="https://www.youtube.com/watch?v=5P7fnH9cCR0">the greatest superpowers of C++ is backward compatibility</a>. Removing <code class="language-plaintext highlighter-rouge">dynamic_cast</code> would break half of the world…</p><blockquote><p><em><code class="language-plaintext highlighter-rouge">dynamic_cast</code> safely converts pointers and references to classes up, down and sideways along the inheritance hierarchy</em> - according to <a href="https://en.cppreference.com/w/cpp/language/dynamic_cast">CppReference</a>.</p></blockquote><p>This friend of mine sends me some piece of code every now and then saying that this might be a good example. He sent me an example a few weeks ago and maybe this was the good one. Maybe.</p><h2 id="a-tree-combining-templates-and-virtuals">A tree combining templates and virtuals</h2><p>The example is from <a href="https://www.amazon.com/Category-Theory-Programmers-Bartosz-Milewski/dp/0464243874/ref=sr_1_1?crid=SBQNZW8VS5A&amp;keywords=Category+Theory+for+Programmers&amp;qid=1683655205&amp;s=books&amp;sprefix=category+theory+for+programmers+%252Cstripbooks-intl-ship%252C146&amp;sr=1-1&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=dd03bab283cd69a4cb78912fcad27448&amp;camp=1789&amp;creative=9325">Category Theory for Programmers</a> written by <a href="https://bartoszmilewski.com/">Bartosz Milewski</a> who also wrote <a href="https://www.amazon.com/Action-Industrial-Strength-Programming-Techniques/dp/0201699486/ref=sr_1_1?crid=1BJUHHH2PO1L0&amp;keywords=C%252B%252B+In+Action%253A+Industrial+Strength+Programming+Techniques&amp;qid=1683655290&amp;s=books&amp;sprefix=c%252B%252B+in+action+industrial+strength+programming+techniques%252Cstripbooks-intl-ship%252C154&amp;sr=1-1&amp;_encoding=UTF8&amp;tag=sandordargo-20&amp;linkCode=ur2&amp;linkId=4818b2ac47747ebe901c75b163d8d3a6&amp;camp=1789&amp;creative=9325">C++ In Action: Industrial Strength Programming Techniques</a>. He shows that we should be able to write/recognize some algebraic data structures in C++ and implement <code class="language-plaintext highlighter-rouge">fmap</code> for them.</p><blockquote><p><code class="language-plaintext highlighter-rouge">fmap</code> is a higher-order function in functional programming that applies a given function to the elements of a container and returns a new container with the results.</p></blockquote><p>And here is his implementation for a <code class="language-plaintext highlighter-rouge">Tree</code> and <code class="language-plaintext highlighter-rouge">fmap()</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Tree</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="o">~</span><span class="n">Tree</span><span class="p">()</span> <span class="p">{};</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Leaf</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="n">T</span> <span class="n">_label</span><span class="p">;</span>
    <span class="n">Leaf</span><span class="p">(</span><span class="n">T</span> <span class="n">l</span><span class="p">)</span> <span class="o">:</span> <span class="n">_label</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">_left</span><span class="p">;</span>
   <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">_right</span><span class="p">;</span>
   <span class="n">Node</span><span class="p">(</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">_left</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">_right</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">A</span><span class="p">,</span> <span class="k">class</span> <span class="nc">B</span><span class="p">&gt;</span>
<span class="n">Tree</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="o">*</span> <span class="nf">fmap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Leaf</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">pl</span> <span class="o">=</span> <span class="k">dynamic_cast</span> <span class="o">&lt;</span><span class="n">Leaf</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pl</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Leaf</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span> <span class="p">(</span><span class="n">pl</span><span class="o">-&gt;</span><span class="n">_label</span><span class="p">));</span>
    <span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">pn</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;*&gt;</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pn</span><span class="p">)</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span> <span class="n">fmap</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">_left</span><span class="p">)</span>
                          <span class="p">,</span> <span class="n">fmap</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">pn</span><span class="o">-&gt;</span><span class="n">_right</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Is that a good implementation? What is good anyway? The author explicitly writes that he omitted resource and memory management and in production code, one should use smart pointers. I think it’s a meaningful simplification in a book or in a blog post.</p><p>Let’s concentrate on <code class="language-plaintext highlighter-rouge">fmap()</code> first and just take note that it’s probably an acceptable idea to return <code class="language-plaintext highlighter-rouge">nullptr</code> if both casts fail. I’d probably throw an exception instead if exceptions are allowed, otherwise, let’s say that this is fine.</p><p>But what about the <code class="language-plaintext highlighter-rouge">dynamic_cast</code>?</p><p>My first idea was that hey, we should replace the one “big” <code class="language-plaintext highlighter-rouge">fmap()</code> with 2 overloads:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">A</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">B</span><span class="p">&gt;</span>
<span class="n">Leaf</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;*</span> <span class="nf">fmap2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Leaf</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Leaf</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f2</span><span class="p">(</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">));</span>
<span class="p">}</span>

<span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">A</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">B</span><span class="p">&gt;</span>
<span class="n">Node</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;*</span> <span class="nf">fmap2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">new</span> <span class="n">Node</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="n">fmap2</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">_left</span><span class="p">),</span>
                        <span class="n">fmap2</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">_right</span><span class="p">));</span>
<span class="p">}</span>
</pre></table></code></div></div><p>But in this case, the compilation fails!</p><div class="language-plaintext highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
</pre><td class="rouge-code"><pre>&lt;source&gt;: In instantiation of 'Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*) [with A = int; B = float]':
&lt;source&gt;:82:28:   required from here
&lt;source&gt;:68:32: error: no matching function for call to 'fmap2&lt;int&gt;(std::function&lt;float(int)&gt;&amp;, Tree&lt;int&gt;*&amp;)'
   68 |     return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left),
      |                        ~~~~~~~~^~~~~~~~~~~~~
&lt;source&gt;:62:10: note: candidate: 'template&lt;class A, class B&gt; Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Leaf&lt;A&gt;*)'
   62 | Leaf&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Leaf&lt;A&gt;* t) {
      |          ^~~~~
&lt;source&gt;:62:10: note:   template argument deduction/substitution failed:
&lt;source&gt;:68:39: note:   cannot convert 't-&gt;Node&lt;int&gt;::_left' (type 'Tree&lt;int&gt;*') to type 'Leaf&lt;int&gt;*'
   68 |     return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left),
      |                                    ~~~^~~~~
&lt;source&gt;:67:10: note: candidate: 'template&lt;class A, class B&gt; Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt;, Node&lt;A&gt;*)'
   67 | Node&lt;B&gt;* fmap2(std::function&lt;B(A)&gt; f, Node&lt;A&gt;* t) {
      |          ^~~~~
&lt;source&gt;:67:10: note:   template argument deduction/substitution failed:
&lt;source&gt;:68:39: note:   cannot convert 't-&gt;Node&lt;int&gt;::_left' (type 'Tree&lt;int&gt;*') to type 'Node&lt;int&gt;*'
   68 |     return new Node&lt;B&gt;(fmap2&lt;A&gt;(f, t-&gt;_left),
      |                                    ~~~^~~~~
</pre></table></code></div></div><p>Of course! What if <code class="language-plaintext highlighter-rouge">t</code> is a <code class="language-plaintext highlighter-rouge">Tree&lt;A&gt;</code> and not a <code class="language-plaintext highlighter-rouge">Leaf</code> of a <code class="language-plaintext highlighter-rouge">Node</code>?! That shouldn’t happen, but even in the original code we have a case to handle that, so let’s just add:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
</pre><td class="rouge-code"><pre><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">A</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">B</span><span class="p">&gt;</span>
<span class="n">Tree</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;*</span> <span class="nf">fmap2</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">B</span><span class="p">(</span><span class="n">A</span><span class="p">)</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;*</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>Now the code compiles, but the executable returned <em>139</em>. In other words, we have a segmentation fault.</p><p>Right, <code class="language-plaintext highlighter-rouge">Node</code> has two pointers to <code class="language-plaintext highlighter-rouge">Tree</code> and instead of matching one of the overloads for <code class="language-plaintext highlighter-rouge">Leaf</code> or <code class="language-plaintext highlighter-rouge">Node</code>, the one for <code class="language-plaintext highlighter-rouge">Tree</code> is matched which returns a <code class="language-plaintext highlighter-rouge">nullptr</code> and when we try to print the labels we crash.</p><p>In case of function overloads the static type is matched. If we want runtime dispatching, we need <code class="language-plaintext highlighter-rouge">virtual</code> functions and overrides.</p><p>So what if we’d implement a <em>virtual</em> <code class="language-plaintext highlighter-rouge">clone</code> function? The initial idea might seem nice, but the problem is that we’d also have to either apply <code class="language-plaintext highlighter-rouge">f</code> on the member or just use its return type (marked by <code class="language-plaintext highlighter-rouge">typename B</code>). In order to do so, we could apply an extension of the prototype design pattern, where a <em>virtual</em> <code class="language-plaintext highlighter-rouge">clone()</code> method replaces a <em>virtual</em> constructor which doesn’t exist in C++. The only problem is that we would need to extend the pattern by passing the transformation function (<code class="language-plaintext highlighter-rouge">f</code>) to the <code class="language-plaintext highlighter-rouge">clone()</code> as a parameter. But <code class="language-plaintext highlighter-rouge">f</code> is a template type and we cannot combine a virtual function with a template.</p><p>We’d need to somehow erase <code class="language-plaintext highlighter-rouge">f</code>’s return type by the time we reach <code class="language-plaintext highlighter-rouge">clone()</code>. But you have to know where to stop and when going down the rabbit hole is not worth it - in my opinion.</p><p>Let’s just accept that <code class="language-plaintext highlighter-rouge">dynamic_cast</code> has its merit with <em>this</em> <code class="language-plaintext highlighter-rouge">Tree</code> implementation.</p><p>But do we really need it?</p><h2 id="prefer-composition-over-inheritance">Prefer composition over inheritance</h2><p>Probably we have all heard in many places that we should prefer composition over inheritance.</p><p>We are also probably familiar with the KISS principle which means that we should <em>keep things simple, stupid</em>.</p><p>Now let’s have a look at the above <code class="language-plaintext highlighter-rouge">Node</code> class once again:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="k">struct</span> <span class="nc">Node</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
   <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">_left</span><span class="p">;</span>
   <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">_right</span><span class="p">;</span>
   <span class="n">Node</span><span class="p">(</span><span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">*</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span> <span class="n">_left</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">_right</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{}</span>
<span class="p">};</span>
</pre></table></code></div></div><p>We have a derived class inheriting from a templated base class. This derived class stores two pointers to objects of the base class type. We use templates, composition and inheritance at the same time. That cannot be KISS.</p><p>I don’t think that it’s needed.</p><p>We do need templates given that we want the ability to store different types in the tree.</p><p>We also need composition, as in a node we want to store references to the underlying two trees.</p><p>To simplify the <code class="language-plaintext highlighter-rouge">Tree</code> class and also hope to remove the need for <code class="language-plaintext highlighter-rouge">dynamic_cast</code>, let’s get rid of the class hierarchy.</p><p><em>(I’m also omitting the issue of memory management as I want the two solutions to remain easily comparable)</em></p><p>What does that inheritance give us anyway?</p><p>Just by looking at the type, we know whether we deal with an intermediary node or a leaf in the tree. But we can know that in other ways too.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">V</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">Tree</span><span class="p">(</span><span class="n">Tree</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">Tree</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span><span class="o">:</span> <span class="n">left</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Tree</span><span class="p">(</span><span class="n">V</span> <span class="n">l</span><span class="p">)</span><span class="o">:</span> <span class="n">label</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{}</span>

 <span class="k">private</span><span class="o">:</span>
    <span class="n">Tree</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;*</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">Tree</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;*</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">label</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><p>In the above <code class="language-plaintext highlighter-rouge">Tree</code> class we have three members. Two pointers two other <code class="language-plaintext highlighter-rouge">Tree</code>s and we also store an optional label.</p><p>We expose two constructors:</p><ul><li>the one taking two pointers to <code class="language-plaintext highlighter-rouge">Tree</code>s initializes an object that corresponds to the former <code class="language-plaintext highlighter-rouge">Node</code> class<li>the other taking an instance of the template argument type initializes an object that will serve as a <code class="language-plaintext highlighter-rouge">Leaf</code></ul><p>As the members are private, we either use <code class="language-plaintext highlighter-rouge">Tree</code> one way or the other. By looking at the initialization, we’ll know which way it is used. If you really want to know it during runtime, we could query an additional member <code class="language-plaintext highlighter-rouge">bool is_leaf;</code> which would be initialized in the constructor call. But I don’t think that we need that knowledge. <em>(If the <code class="language-plaintext highlighter-rouge">label</code> cannot be <code class="language-plaintext highlighter-rouge">nullopt</code> in a leaf, we could also check the state of the optional <code class="language-plaintext highlighter-rouge">label</code>)</em></p><p>Also, we’d need to expose certain getters to the members of this class, but we don’t need them for the <code class="language-plaintext highlighter-rouge">fmap()</code> implementation. You might argue that if the accessors are non-<code class="language-plaintext highlighter-rouge">const</code> then people can misuse the class. And that’s a valid concern. But it takes extra effort (<em>why would you do that?</em>) and it strikes out in a pull request, it’s easy to spot such misuses (<em>why would you approve that?</em>).</p><p>The <code class="language-plaintext highlighter-rouge">fmap()</code> implementation is fairly simple:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">V</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">N</span><span class="p">&gt;</span>
<span class="n">Tree</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;*</span> <span class="nf">fmap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">N</span><span class="p">(</span><span class="n">V</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;*</span> <span class="n">t</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">t</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">nullptr</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">return</span> <span class="k">new</span> <span class="nf">Tree</span><span class="p">(</span><span class="n">fmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">left</span><span class="p">),</span>
                    <span class="n">fmap</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="n">t</span><span class="o">-&gt;</span><span class="n">right</span><span class="p">),</span>
                    <span class="n">t</span><span class="o">-&gt;</span><span class="n">label</span> <span class="o">?</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">t</span><span class="o">-&gt;</span><span class="n">label</span><span class="p">))</span> <span class="o">:</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">);</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If <code class="language-plaintext highlighter-rouge">t</code> is <code class="language-plaintext highlighter-rouge">nullptr</code> then we stop the recursion by returning <code class="language-plaintext highlighter-rouge">nullptr</code>. Otherwise, we return a new <code class="language-plaintext highlighter-rouge">Tree</code> using the mapped type (<code class="language-plaintext highlighter-rouge">V -&gt; N</code>).</p><p>In order to make this work, we need a new <code class="language-plaintext highlighter-rouge">Tree</code> constructor that can initialize all the members. But nobody else needs that so let’s make it <code class="language-plaintext highlighter-rouge">private</code> and make <code class="language-plaintext highlighter-rouge">fmap()</code> a <code class="language-plaintext highlighter-rouge">friend</code> of <code class="language-plaintext highlighter-rouge">Tree</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">V</span><span class="p">&gt;</span>
<span class="k">class</span> <span class="nc">Tree</span> <span class="p">{</span>
 <span class="nl">public:</span>
    <span class="n">Tree</span><span class="p">(</span><span class="n">Tree</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">Tree</span><span class="o">*</span> <span class="n">r</span><span class="p">)</span><span class="o">:</span> <span class="n">left</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">r</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">Tree</span><span class="p">(</span><span class="n">V</span> <span class="n">l</span><span class="p">)</span><span class="o">:</span> <span class="n">label</span><span class="p">(</span><span class="n">l</span><span class="p">)</span> <span class="p">{}</span>

 <span class="k">private</span><span class="o">:</span>
    <span class="n">Tree</span><span class="p">(</span><span class="n">Tree</span><span class="o">*</span> <span class="n">l</span><span class="p">,</span> <span class="n">Tree</span><span class="o">*</span> <span class="n">r</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">)</span><span class="o">:</span> <span class="n">left</span><span class="p">(</span><span class="n">l</span><span class="p">),</span> <span class="n">right</span><span class="p">(</span><span class="n">r</span><span class="p">),</span> <span class="n">label</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="p">{}</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">V2</span><span class="p">,</span> <span class="k">typename</span> <span class="nc">N</span><span class="p">&gt;</span>
    <span class="k">friend</span>
    <span class="n">Tree</span><span class="o">&lt;</span><span class="n">N</span><span class="o">&gt;*</span> <span class="nf">fmap</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">function</span><span class="o">&lt;</span><span class="n">N</span><span class="p">(</span><span class="n">V2</span><span class="p">)</span><span class="o">&gt;</span> <span class="n">f</span><span class="p">,</span> <span class="n">Tree</span><span class="o">&lt;</span><span class="n">V2</span><span class="o">&gt;*</span> <span class="n">t</span><span class="p">);</span>

    <span class="n">Tree</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;*</span> <span class="n">left</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">Tree</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;*</span> <span class="n">right</span> <span class="o">=</span> <span class="nb">nullptr</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">optional</span><span class="o">&lt;</span><span class="n">V</span><span class="o">&gt;</span> <span class="n">label</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">nullopt</span><span class="p">;</span>
<span class="p">};</span>
</pre></table></code></div></div><h2 id="which-one-is-better">Which one is better?</h2><p>I don’t have a clear answer.</p><p>In the original solution, you can see from the (dynamic) type whether you deal with a node or a leaf. But you also need a polymorphic structure and all the overhead that comes with it. You don’t only see this characteristic, but each type represents a clear role.</p><p>You might say that my solution is not complete because we need to expose the members, but there is a very high chance that the original <code class="language-plaintext highlighter-rouge">Tree</code> wouldn’t stay a <code class="language-plaintext highlighter-rouge">struct</code> and the members would be <code class="language-plaintext highlighter-rouge">private</code> in that too. But even in that case, the second solution (if the accessors are non-<code class="language-plaintext highlighter-rouge">const</code>) might be misused. Even though it’s not convenient and it is highly visible.</p><p>But what about performance?</p><p>We can expect that the second solution will have a bigger memory footprint as in every case each node of the <code class="language-plaintext highlighter-rouge">Tree</code> has 3 members. Two pointers and an optional <code class="language-plaintext highlighter-rouge">V</code>.</p><p>On the other hand, we can expect that the second solution will be faster, as there are no <code class="language-plaintext highlighter-rouge">virtual</code> functions, there is no dynamic dispatching of function calls and obviously no casting.</p><p>I created a small <code class="language-plaintext highlighter-rouge">Tree</code> of 8 integers and applied a function on it which multiplies each value by 2 and ran it 10,000 times. The static solution took a bit longer time to compile (~3%), and its executable was a tiny bit smaller (~2%), but it was executing much faster (~50%). Even though as expected, the memory consumption was 30% higher for the non-polymorphic version.</p><p>So the second solution is smaller, much faster, but it needs way more memory at runtime. It’s simpler, but in a way, it’s less expressive.</p><p>In most cases, there is no black or white. Only tradeoffs. In this case, we traded off memory for runtime. Simplicity for expressiveness.</p><h2 id="conclusion">Conclusion</h2><p>Today, we talked once again about when (not) to use <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. We looked into a tree implementation where <code class="language-plaintext highlighter-rouge">fmap()</code> needed to use <code class="language-plaintext highlighter-rouge">dynamic_cast</code>. Then we looked into another where it was not needed. The <code class="language-plaintext highlighter-rouge">dynamic_cast</code> version needs more time to execute but much less memory than the non-polymorphic version.</p><p>Programming, just like life, is about tradeoffs. In this case, the solution with <code class="language-plaintext highlighter-rouge">dynamic_cast</code> has its merits, but you might go with another solution depending on your constraints.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/dynamiccast/" class="post-tag no-text-decoration" >dynamiccast</a> <a href="/tags/virtual/" class="post-tag no-text-decoration" >virtual</a> <a href="/tags/polymorphism/" class="post-tag no-text-decoration" >polymorphism</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=Is this dynamic_cast needed? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=Is this dynamic_cast needed? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=Is this dynamic_cast needed? - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=Is this dynamic_cast needed? - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2018/07/05/cpp-override"><div class="card-body"> <span class="timeago small" > Jul 5, 2018 <i class="unloaded">2018-07-05T00:00:00+02:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>Why to use the override specifier in C++ 11?</h3><div class="text-muted small"><p> The override specifier was introduced to the language with C++11 and it is one of the easiest tool to significantly improve the maintainability of our codebases. override tells both the reader an...</p></div></div></a></div><div class="card"> <a href="/blog/2021/11/24/production-issues-part-i-undefined-behaviour"><div class="card-body"> <span class="timeago small" > Nov 24, 2021 <i class="unloaded">2021-11-24T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>I broke production 3 times in 3 weeks - Part I</h3><div class="text-muted small"><p> Are you a careful coder who barely introduces errors? How do you feel when still manage to bring production down? You might feel horrible, but I think you should take it as an opportunity. You can...</p></div></div></a></div><div class="card"> <a href="/blog/2021/12/01/production-issues-part-ii"><div class="card-body"> <span class="timeago small" > Dec 1, 2021 <i class="unloaded">2021-12-01T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>I broke production 3 times in 3 weeks - Part II</h3><div class="text-muted small"><p> Last week I shared with you that despite that I consider myself a careful coder, I managed to break production several times in a row. It can happen to anyone, though one shouldn’t forget about hi...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/05/03/variadic-functions-vs-variadic-templates" class="btn btn-outline-primary" prompt="Older"><p>Variadic functions vs variadic templates</p></a> <a href="/blog/2023/05/17/spoiled-or-abused" class="btn btn-outline-primary" prompt="Newer"><p>Are we - developers - spoiled or abused?</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'Is this dynamic_cast needed?'; this.page.url = 'https://www.sandordargo.com/blog/2023/05/10/is-this-dynamic-cast-needed'; this.page.identifier = '/blog/2023/05/10/is-this-dynamic-cast-needed'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
