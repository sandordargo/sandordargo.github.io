<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="C++23: The rise of new streams" /><meta property="og:locale" content="en_US" /><meta name="description" content="The main goal of this article is to share with you the new &lt;spanstream&gt; header, but we are going a bit beyond it. We won’t only discuss the motivations behind the proposal introducing this header (P0448R4), but we’ll check out an older proposal also from Peter Sommerlad (P0408R7) which modified std::basic_stringbuf back in C++20. The reason for covering both is that the author aims for the same purpose with the two proposals. One completes the other. strstreams are dead, long live the buffers and spans! While streams are one of the oldest parts of the C++ standard library they haven’t been keeping up with the winds of change since the release of C++11 and they required some updates. The motivation behind these two proposals is to have a stream that avoids unnecessary copies of buffers. In other words, the goal was to provide a stream that provides an efficient access to the underlying buffer uses a fixed-size pre-allocated buffer One of the problems is that up until P0408R7, there was no non-copying access to the internal buffer of a std::basic_stringbuf so getting the results of ostringstream always required a copy of the internal buffer, even if one doesn’t want to use the stream afterwards. P0408R7 solved this problem. With the acceptance of the other discussed paper, P0448R4, spanstreams provide us a stream whose internal storage can use a fixed-size, pre-allocated buffer. That can be something on the stack, for example, a non-owning array view, std::span&lt;T&gt;. By using std::span&lt;T&gt;, we can represent and pass a buffer for a new spanstream and avoid any dynamic (re)allocation which might not be acceptable for you depending on your use case. The first step towards removing the deprecated stream buffer In P0408R7, the author shares his belief that basic_strbuf should be removed from the [depr.str.strstreams] section of the standard as soon as the feature is completely replaced. The reason why strstream was deprecated in the first place is that it returned a char* which was difficult to manage and therefore it was prone to cause memory leaks. This difficulty came from the fact that it was nowhere stated how and where it had been allocated. The only satisfactory deallocation was via the std::strstream::freeze() function, but it was not obvious, hence lots of people got it wrong. On the other hand, stringstreams return std::strings which manage their own memory allocations. The first step towards that removal was to extend the API of basic_stringbuf (note the difference between basic_strbuf and basic_stringbuf). std::string_view was introduced by C++17 to provide efficient read-only access to continuous sequence of characters. A basic_stringbuf has similar characteristics so it was a natural and highly waited-for step forward to provide a string_view-like access to its internal buffer. P0408R7 brought the below changes to basic_stringbuf in C++20. Somewhat accidentally, it introduced allocator-aware construction. I’m using the word “accidentally” because the author of these papers shared with me, that this was not part of his original intentions. But the papers were proposed around when the standard library itself made allocator support more flexible with stateful allocators and std::pmr, etc. At the same time, basic_stringbuf is also benefiting from new constructor overloads taking an initial value by rvalue-reference which again is about avoiding unnecessary copies. basic_stringbuf::str() went through several changes. First, we must remind ourselves that basic_stringbuf::str() is both a getter and a setter depending on its return type and parameters. The getter str() now has an overload that is used when the underlying object is an lvalue and another form rvalues. When str() is called on an rvalue reference, it returns the underlying string by moving it away from the internal buffer. According to the author, this is probably the first ref-qualified member function in the standard library. Moreover, in this case, the standard clearly specifies how the moved-from object should look like. Its buffer becomes empty. str() also received an overload with an allocator which sets how to copy the underlying buffer into the returned string. Of course, this is only for the no-move overload. There is also a new method called view() that is both const and noexcept and returns a string_view so that you can have a no-copy, not-owning, read-only access to the contents of the internal buffer. 1 2 3 4 5 6 basic_string&lt;charT, traits, Allocator&gt; str() const &amp;; // The &amp; lvalue qualifier is new! template&lt;class SAlloc&gt; basic_string&lt;charT,traits,SAlloc&gt; str(const SAlloc&amp; sa) const; // this is a new overload basic_string&lt;charT, traits, Allocator&gt; str() &amp;&amp;; // this is a new overload basic_string_view&lt;charT, traits&gt; view() const noexcept; // this is a new method The setter str() methods also received two new overloads. The original one takes a string using the same allocator as the basic_stringbuf class and takes the string by const&amp;. There is a new overload that still takes the input string by const&amp; but with a different allocator and another one that takes the string by rvalue reference, so it moves it to the internal buffer. 1 2 3 4 5 void str(const basic_string&lt;charT, traits, Allocator&gt;&amp; s); // this was already there template&lt;class SAlloc&gt; void str(const basic_string&lt;charT, traits, SAlloc&gt;&amp; s); // this is a new overload void str(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; s); // this is a new overload There are several other changes in which we are not going into details, but it’s worth noting that basic_stringbuf::swap() became conditionally noexcept depending on the used allocator. Probably the most important change among the above is that now you can get the contents of basic_stringbuf without actually having to make a copy of the internal buffer. Either it will be moved if you use str() &amp;&amp; or you get a read-only view on it if you use view. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include &lt;sstream&gt; #include &lt;iostream&gt; int main() { std::stringbuf buf; std::string temp {&quot;Some content&quot;}; buf.str(std::move(temp)); // now temp is moved away from, who knows what&#39;s inside std::cout &lt;&lt; &quot;temp: &quot; &lt;&lt; temp &lt;&lt; &#39;\n&#39;; // no copy is needed to access the internal buffer std::string_view bufview = buf.view(); std::cout &lt;&lt; &quot;bufview: &quot; &lt;&lt; bufview &lt;&lt; &#39;\n&#39;; // no copy is needed to access the internal buffer which still contains the data we put in it std::string_view anotherView = buf.view(); std::cout &lt;&lt; &quot;anotherView: &quot; &lt;&lt; anotherView &lt;&lt; &#39;\n&#39;; // still no copy, buf is used as an rvalue-reference, the internal buffer is moved out std::string internalBufferMoved = std::move(buf).str(); std::cout &lt;&lt; &quot;internalBufferMoved: &quot; &lt;&lt; internalBufferMoved &lt;&lt; &#39;\n&#39;; // now buf is moved away from, who knows what&#39;s inside std::string_view viewOnMovedObject = buf.view(); std::cout &lt;&lt; &quot;viewOnMovedObject: &quot; &lt;&lt; viewOnMovedObject &lt;&lt; &#39;\n&#39;; return 0; } /* temp: bufview: Some content anotherView: Some content internalBufferMoved: Some content viewOnMovedObject: */ Notice in the above example, how efficiently views and moves are used in order to avoid expensive copy operations. Introducing the new &lt;spanstream&gt; header The second proposal, P0448R4, introduces a complete new header &lt;spanstream&gt; mainly with 4 class templates: std::basic_spanbuf std::basic_ispanstream std::basic_ospanstream std::basic_spanstream Basically what we get are the usual 3 streams and an externally provided memory buffer for them. spanstreams do not own the internal buffer, hence the name span, which is a non-owning view on an array of items. Therefore re-allocation is also not possible. If you need dynamic reallocation, you need to use stringstream et al. A stringstream has no-copy access to its contents since C++20. As a consequence of this hew header and the explained changes to basic_stringbuf, there is no more reason to keep the already deprecated strstream classes in the standard, and the [depr.str.strstreams] section is getting removed. Not surprisingly a basic_spanbuf uses a span of a sort of character (charT) as an internal buffer. It’s safe and cheap to provide access to it, as it requires no copy of the data. If you need an owning copy of the data, you can always convert the result of span() back to basic_string&lt;charT&gt; and as such copy it for yourself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; #include &lt;span&gt; #include &lt;spanstream&gt; #include &lt;cassert&gt; void printSpan(auto spanToPrint) { for (size_t i = 0; i &lt; spanToPrint.size(); ++i) { std::cout &lt;&lt; spanToPrint[i]; } } void useSpanbuf() { std::array&lt;char, 16&gt; charArray; std::span&lt;char, 16&gt; charArraySpan(charArray); std::spanbuf buf; char c = &#39;a&#39;; for (size_t i = 0; i &lt; 16; ++i) { charArraySpan[i] = c; ++c; } buf.span(charArraySpan); // we can easily print a span got from the buffer std::span bufview = buf.span(); std::cout &lt;&lt; &quot;bufview: &quot;; for (size_t i = 0; i &lt; 16; ++i) { std::cout &lt;&lt; bufview[i]; } std::cout &lt;&lt; &#39;\n&#39;; } void useSpanstream() { std::array&lt;char, 16&gt; charArray; std::ospanstream oss(charArray); oss &lt;&lt; &quot;Fortytwo is &quot; &lt;&lt; 42; // copying the contents to a span std::string s{oss.span().data(),size_t(oss.span().size())}; assert(s == &quot;Fortytwo is 42&quot;); } int main() { useSpanbuf(); useSpanstream(); return 0; } Conclusion In this post, we had a brief overview of how the world of buffers and streams has changed in C++20 and C++23 thanks to Peter Sommerlad and his two proposals, P0448R4, P0408R7. With P0408R7 we get non-copying access to the internal buffer of a std::basic_stringbuf which is a significant efficiency increase. With the acceptance of P0448R4 and the introduction of spanstreams, we get a stream that as an internal storage can use a fixed-size pre-allocated buffer. Special thanks to Peter who pointed out a couple of missing points and misunderstandings in the draft of this article and helped it become more informative. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="The main goal of this article is to share with you the new &lt;spanstream&gt; header, but we are going a bit beyond it. We won’t only discuss the motivations behind the proposal introducing this header (P0448R4), but we’ll check out an older proposal also from Peter Sommerlad (P0408R7) which modified std::basic_stringbuf back in C++20. The reason for covering both is that the author aims for the same purpose with the two proposals. One completes the other. strstreams are dead, long live the buffers and spans! While streams are one of the oldest parts of the C++ standard library they haven’t been keeping up with the winds of change since the release of C++11 and they required some updates. The motivation behind these two proposals is to have a stream that avoids unnecessary copies of buffers. In other words, the goal was to provide a stream that provides an efficient access to the underlying buffer uses a fixed-size pre-allocated buffer One of the problems is that up until P0408R7, there was no non-copying access to the internal buffer of a std::basic_stringbuf so getting the results of ostringstream always required a copy of the internal buffer, even if one doesn’t want to use the stream afterwards. P0408R7 solved this problem. With the acceptance of the other discussed paper, P0448R4, spanstreams provide us a stream whose internal storage can use a fixed-size, pre-allocated buffer. That can be something on the stack, for example, a non-owning array view, std::span&lt;T&gt;. By using std::span&lt;T&gt;, we can represent and pass a buffer for a new spanstream and avoid any dynamic (re)allocation which might not be acceptable for you depending on your use case. The first step towards removing the deprecated stream buffer In P0408R7, the author shares his belief that basic_strbuf should be removed from the [depr.str.strstreams] section of the standard as soon as the feature is completely replaced. The reason why strstream was deprecated in the first place is that it returned a char* which was difficult to manage and therefore it was prone to cause memory leaks. This difficulty came from the fact that it was nowhere stated how and where it had been allocated. The only satisfactory deallocation was via the std::strstream::freeze() function, but it was not obvious, hence lots of people got it wrong. On the other hand, stringstreams return std::strings which manage their own memory allocations. The first step towards that removal was to extend the API of basic_stringbuf (note the difference between basic_strbuf and basic_stringbuf). std::string_view was introduced by C++17 to provide efficient read-only access to continuous sequence of characters. A basic_stringbuf has similar characteristics so it was a natural and highly waited-for step forward to provide a string_view-like access to its internal buffer. P0408R7 brought the below changes to basic_stringbuf in C++20. Somewhat accidentally, it introduced allocator-aware construction. I’m using the word “accidentally” because the author of these papers shared with me, that this was not part of his original intentions. But the papers were proposed around when the standard library itself made allocator support more flexible with stateful allocators and std::pmr, etc. At the same time, basic_stringbuf is also benefiting from new constructor overloads taking an initial value by rvalue-reference which again is about avoiding unnecessary copies. basic_stringbuf::str() went through several changes. First, we must remind ourselves that basic_stringbuf::str() is both a getter and a setter depending on its return type and parameters. The getter str() now has an overload that is used when the underlying object is an lvalue and another form rvalues. When str() is called on an rvalue reference, it returns the underlying string by moving it away from the internal buffer. According to the author, this is probably the first ref-qualified member function in the standard library. Moreover, in this case, the standard clearly specifies how the moved-from object should look like. Its buffer becomes empty. str() also received an overload with an allocator which sets how to copy the underlying buffer into the returned string. Of course, this is only for the no-move overload. There is also a new method called view() that is both const and noexcept and returns a string_view so that you can have a no-copy, not-owning, read-only access to the contents of the internal buffer. 1 2 3 4 5 6 basic_string&lt;charT, traits, Allocator&gt; str() const &amp;; // The &amp; lvalue qualifier is new! template&lt;class SAlloc&gt; basic_string&lt;charT,traits,SAlloc&gt; str(const SAlloc&amp; sa) const; // this is a new overload basic_string&lt;charT, traits, Allocator&gt; str() &amp;&amp;; // this is a new overload basic_string_view&lt;charT, traits&gt; view() const noexcept; // this is a new method The setter str() methods also received two new overloads. The original one takes a string using the same allocator as the basic_stringbuf class and takes the string by const&amp;. There is a new overload that still takes the input string by const&amp; but with a different allocator and another one that takes the string by rvalue reference, so it moves it to the internal buffer. 1 2 3 4 5 void str(const basic_string&lt;charT, traits, Allocator&gt;&amp; s); // this was already there template&lt;class SAlloc&gt; void str(const basic_string&lt;charT, traits, SAlloc&gt;&amp; s); // this is a new overload void str(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; s); // this is a new overload There are several other changes in which we are not going into details, but it’s worth noting that basic_stringbuf::swap() became conditionally noexcept depending on the used allocator. Probably the most important change among the above is that now you can get the contents of basic_stringbuf without actually having to make a copy of the internal buffer. Either it will be moved if you use str() &amp;&amp; or you get a read-only view on it if you use view. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include &lt;sstream&gt; #include &lt;iostream&gt; int main() { std::stringbuf buf; std::string temp {&quot;Some content&quot;}; buf.str(std::move(temp)); // now temp is moved away from, who knows what&#39;s inside std::cout &lt;&lt; &quot;temp: &quot; &lt;&lt; temp &lt;&lt; &#39;\n&#39;; // no copy is needed to access the internal buffer std::string_view bufview = buf.view(); std::cout &lt;&lt; &quot;bufview: &quot; &lt;&lt; bufview &lt;&lt; &#39;\n&#39;; // no copy is needed to access the internal buffer which still contains the data we put in it std::string_view anotherView = buf.view(); std::cout &lt;&lt; &quot;anotherView: &quot; &lt;&lt; anotherView &lt;&lt; &#39;\n&#39;; // still no copy, buf is used as an rvalue-reference, the internal buffer is moved out std::string internalBufferMoved = std::move(buf).str(); std::cout &lt;&lt; &quot;internalBufferMoved: &quot; &lt;&lt; internalBufferMoved &lt;&lt; &#39;\n&#39;; // now buf is moved away from, who knows what&#39;s inside std::string_view viewOnMovedObject = buf.view(); std::cout &lt;&lt; &quot;viewOnMovedObject: &quot; &lt;&lt; viewOnMovedObject &lt;&lt; &#39;\n&#39;; return 0; } /* temp: bufview: Some content anotherView: Some content internalBufferMoved: Some content viewOnMovedObject: */ Notice in the above example, how efficiently views and moves are used in order to avoid expensive copy operations. Introducing the new &lt;spanstream&gt; header The second proposal, P0448R4, introduces a complete new header &lt;spanstream&gt; mainly with 4 class templates: std::basic_spanbuf std::basic_ispanstream std::basic_ospanstream std::basic_spanstream Basically what we get are the usual 3 streams and an externally provided memory buffer for them. spanstreams do not own the internal buffer, hence the name span, which is a non-owning view on an array of items. Therefore re-allocation is also not possible. If you need dynamic reallocation, you need to use stringstream et al. A stringstream has no-copy access to its contents since C++20. As a consequence of this hew header and the explained changes to basic_stringbuf, there is no more reason to keep the already deprecated strstream classes in the standard, and the [depr.str.strstreams] section is getting removed. Not surprisingly a basic_spanbuf uses a span of a sort of character (charT) as an internal buffer. It’s safe and cheap to provide access to it, as it requires no copy of the data. If you need an owning copy of the data, you can always convert the result of span() back to basic_string&lt;charT&gt; and as such copy it for yourself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; #include &lt;span&gt; #include &lt;spanstream&gt; #include &lt;cassert&gt; void printSpan(auto spanToPrint) { for (size_t i = 0; i &lt; spanToPrint.size(); ++i) { std::cout &lt;&lt; spanToPrint[i]; } } void useSpanbuf() { std::array&lt;char, 16&gt; charArray; std::span&lt;char, 16&gt; charArraySpan(charArray); std::spanbuf buf; char c = &#39;a&#39;; for (size_t i = 0; i &lt; 16; ++i) { charArraySpan[i] = c; ++c; } buf.span(charArraySpan); // we can easily print a span got from the buffer std::span bufview = buf.span(); std::cout &lt;&lt; &quot;bufview: &quot;; for (size_t i = 0; i &lt; 16; ++i) { std::cout &lt;&lt; bufview[i]; } std::cout &lt;&lt; &#39;\n&#39;; } void useSpanstream() { std::array&lt;char, 16&gt; charArray; std::ospanstream oss(charArray); oss &lt;&lt; &quot;Fortytwo is &quot; &lt;&lt; 42; // copying the contents to a span std::string s{oss.span().data(),size_t(oss.span().size())}; assert(s == &quot;Fortytwo is 42&quot;); } int main() { useSpanbuf(); useSpanstream(); return 0; } Conclusion In this post, we had a brief overview of how the world of buffers and streams has changed in C++20 and C++23 thanks to Peter Sommerlad and his two proposals, P0448R4, P0408R7. With P0408R7 we get non-copying access to the internal buffer of a std::basic_stringbuf which is a significant efficiency increase. With the acceptance of P0448R4 and the introduction of spanstreams, we get a stream that as an internal storage can use a fixed-size pre-allocated buffer. Special thanks to Peter who pointed out a couple of missing points and misunderstandings in the draft of this article and helped it become more informative. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-06T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="C++23: The rise of new streams" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2023-12-30T23:17:48+01:00","datePublished":"2023-12-06T00:00:00+01:00","description":"The main goal of this article is to share with you the new &lt;spanstream&gt; header, but we are going a bit beyond it. We won’t only discuss the motivations behind the proposal introducing this header (P0448R4), but we’ll check out an older proposal also from Peter Sommerlad (P0408R7) which modified std::basic_stringbuf back in C++20. The reason for covering both is that the author aims for the same purpose with the two proposals. One completes the other. strstreams are dead, long live the buffers and spans! While streams are one of the oldest parts of the C++ standard library they haven’t been keeping up with the winds of change since the release of C++11 and they required some updates. The motivation behind these two proposals is to have a stream that avoids unnecessary copies of buffers. In other words, the goal was to provide a stream that provides an efficient access to the underlying buffer uses a fixed-size pre-allocated buffer One of the problems is that up until P0408R7, there was no non-copying access to the internal buffer of a std::basic_stringbuf so getting the results of ostringstream always required a copy of the internal buffer, even if one doesn’t want to use the stream afterwards. P0408R7 solved this problem. With the acceptance of the other discussed paper, P0448R4, spanstreams provide us a stream whose internal storage can use a fixed-size, pre-allocated buffer. That can be something on the stack, for example, a non-owning array view, std::span&lt;T&gt;. By using std::span&lt;T&gt;, we can represent and pass a buffer for a new spanstream and avoid any dynamic (re)allocation which might not be acceptable for you depending on your use case. The first step towards removing the deprecated stream buffer In P0408R7, the author shares his belief that basic_strbuf should be removed from the [depr.str.strstreams] section of the standard as soon as the feature is completely replaced. The reason why strstream was deprecated in the first place is that it returned a char* which was difficult to manage and therefore it was prone to cause memory leaks. This difficulty came from the fact that it was nowhere stated how and where it had been allocated. The only satisfactory deallocation was via the std::strstream::freeze() function, but it was not obvious, hence lots of people got it wrong. On the other hand, stringstreams return std::strings which manage their own memory allocations. The first step towards that removal was to extend the API of basic_stringbuf (note the difference between basic_strbuf and basic_stringbuf). std::string_view was introduced by C++17 to provide efficient read-only access to continuous sequence of characters. A basic_stringbuf has similar characteristics so it was a natural and highly waited-for step forward to provide a string_view-like access to its internal buffer. P0408R7 brought the below changes to basic_stringbuf in C++20. Somewhat accidentally, it introduced allocator-aware construction. I’m using the word “accidentally” because the author of these papers shared with me, that this was not part of his original intentions. But the papers were proposed around when the standard library itself made allocator support more flexible with stateful allocators and std::pmr, etc. At the same time, basic_stringbuf is also benefiting from new constructor overloads taking an initial value by rvalue-reference which again is about avoiding unnecessary copies. basic_stringbuf::str() went through several changes. First, we must remind ourselves that basic_stringbuf::str() is both a getter and a setter depending on its return type and parameters. The getter str() now has an overload that is used when the underlying object is an lvalue and another form rvalues. When str() is called on an rvalue reference, it returns the underlying string by moving it away from the internal buffer. According to the author, this is probably the first ref-qualified member function in the standard library. Moreover, in this case, the standard clearly specifies how the moved-from object should look like. Its buffer becomes empty. str() also received an overload with an allocator which sets how to copy the underlying buffer into the returned string. Of course, this is only for the no-move overload. There is also a new method called view() that is both const and noexcept and returns a string_view so that you can have a no-copy, not-owning, read-only access to the contents of the internal buffer. 1 2 3 4 5 6 basic_string&lt;charT, traits, Allocator&gt; str() const &amp;; // The &amp; lvalue qualifier is new! template&lt;class SAlloc&gt; basic_string&lt;charT,traits,SAlloc&gt; str(const SAlloc&amp; sa) const; // this is a new overload basic_string&lt;charT, traits, Allocator&gt; str() &amp;&amp;; // this is a new overload basic_string_view&lt;charT, traits&gt; view() const noexcept; // this is a new method The setter str() methods also received two new overloads. The original one takes a string using the same allocator as the basic_stringbuf class and takes the string by const&amp;. There is a new overload that still takes the input string by const&amp; but with a different allocator and another one that takes the string by rvalue reference, so it moves it to the internal buffer. 1 2 3 4 5 void str(const basic_string&lt;charT, traits, Allocator&gt;&amp; s); // this was already there template&lt;class SAlloc&gt; void str(const basic_string&lt;charT, traits, SAlloc&gt;&amp; s); // this is a new overload void str(basic_string&lt;charT, traits, Allocator&gt;&amp;&amp; s); // this is a new overload There are several other changes in which we are not going into details, but it’s worth noting that basic_stringbuf::swap() became conditionally noexcept depending on the used allocator. Probably the most important change among the above is that now you can get the contents of basic_stringbuf without actually having to make a copy of the internal buffer. Either it will be moved if you use str() &amp;&amp; or you get a read-only view on it if you use view. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 #include &lt;sstream&gt; #include &lt;iostream&gt; int main() { std::stringbuf buf; std::string temp {&quot;Some content&quot;}; buf.str(std::move(temp)); // now temp is moved away from, who knows what&#39;s inside std::cout &lt;&lt; &quot;temp: &quot; &lt;&lt; temp &lt;&lt; &#39;\\n&#39;; // no copy is needed to access the internal buffer std::string_view bufview = buf.view(); std::cout &lt;&lt; &quot;bufview: &quot; &lt;&lt; bufview &lt;&lt; &#39;\\n&#39;; // no copy is needed to access the internal buffer which still contains the data we put in it std::string_view anotherView = buf.view(); std::cout &lt;&lt; &quot;anotherView: &quot; &lt;&lt; anotherView &lt;&lt; &#39;\\n&#39;; // still no copy, buf is used as an rvalue-reference, the internal buffer is moved out std::string internalBufferMoved = std::move(buf).str(); std::cout &lt;&lt; &quot;internalBufferMoved: &quot; &lt;&lt; internalBufferMoved &lt;&lt; &#39;\\n&#39;; // now buf is moved away from, who knows what&#39;s inside std::string_view viewOnMovedObject = buf.view(); std::cout &lt;&lt; &quot;viewOnMovedObject: &quot; &lt;&lt; viewOnMovedObject &lt;&lt; &#39;\\n&#39;; return 0; } /* temp: bufview: Some content anotherView: Some content internalBufferMoved: Some content viewOnMovedObject: */ Notice in the above example, how efficiently views and moves are used in order to avoid expensive copy operations. Introducing the new &lt;spanstream&gt; header The second proposal, P0448R4, introduces a complete new header &lt;spanstream&gt; mainly with 4 class templates: std::basic_spanbuf std::basic_ispanstream std::basic_ospanstream std::basic_spanstream Basically what we get are the usual 3 streams and an externally provided memory buffer for them. spanstreams do not own the internal buffer, hence the name span, which is a non-owning view on an array of items. Therefore re-allocation is also not possible. If you need dynamic reallocation, you need to use stringstream et al. A stringstream has no-copy access to its contents since C++20. As a consequence of this hew header and the explained changes to basic_stringbuf, there is no more reason to keep the already deprecated strstream classes in the standard, and the [depr.str.strstreams] section is getting removed. Not surprisingly a basic_spanbuf uses a span of a sort of character (charT) as an internal buffer. It’s safe and cheap to provide access to it, as it requires no copy of the data. If you need an owning copy of the data, you can always convert the result of span() back to basic_string&lt;charT&gt; and as such copy it for yourself. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 #include &lt;iostream&gt; #include &lt;span&gt; #include &lt;spanstream&gt; #include &lt;cassert&gt; void printSpan(auto spanToPrint) { for (size_t i = 0; i &lt; spanToPrint.size(); ++i) { std::cout &lt;&lt; spanToPrint[i]; } } void useSpanbuf() { std::array&lt;char, 16&gt; charArray; std::span&lt;char, 16&gt; charArraySpan(charArray); std::spanbuf buf; char c = &#39;a&#39;; for (size_t i = 0; i &lt; 16; ++i) { charArraySpan[i] = c; ++c; } buf.span(charArraySpan); // we can easily print a span got from the buffer std::span bufview = buf.span(); std::cout &lt;&lt; &quot;bufview: &quot;; for (size_t i = 0; i &lt; 16; ++i) { std::cout &lt;&lt; bufview[i]; } std::cout &lt;&lt; &#39;\\n&#39;; } void useSpanstream() { std::array&lt;char, 16&gt; charArray; std::ospanstream oss(charArray); oss &lt;&lt; &quot;Fortytwo is &quot; &lt;&lt; 42; // copying the contents to a span std::string s{oss.span().data(),size_t(oss.span().size())}; assert(s == &quot;Fortytwo is 42&quot;); } int main() { useSpanbuf(); useSpanstream(); return 0; } Conclusion In this post, we had a brief overview of how the world of buffers and streams has changed in C++20 and C++23 thanks to Peter Sommerlad and his two proposals, P0448R4, P0408R7. With P0408R7 we get non-copying access to the internal buffer of a std::basic_stringbuf which is a significant efficiency increase. With the acceptance of P0448R4 and the introduction of spanstreams, we get a stream that as an internal storage can use a fixed-size pre-allocated buffer. Special thanks to Peter who pointed out a couple of missing points and misunderstandings in the draft of this article and helped it become more informative. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"C++23: The rise of new streams","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement"},"url":"https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement"}</script><title>C++23: The rise of new streams | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/06"> 06 </a> </span> <span>C++23: The rise of new streams</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>C++23: The rise of new streams</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 6, 2023, 12:00 AM +0100" prep="on" > Dec 6, 2023 <i class="unloaded">2023-12-06T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Sat, Dec 30, 2023, 11:17 PM +0100" prefix="Updated " > Dec 30, 2023 <i class="unloaded">2023-12-30T23:17:48+01:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="1647 words">9 min</span></div></div><div class="post-content"><p>The main goal of this article is to share with you the new <code class="language-plaintext highlighter-rouge">&lt;spanstream&gt;</code> header, but we are going a bit beyond it. We won’t only discuss the motivations behind the proposal introducing this header (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf">P0448R4</a>), but we’ll check out an older proposal also from <a href="https://sommerlad.ch/">Peter Sommerlad</a> (<a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a>) which modified <code class="language-plaintext highlighter-rouge">std::basic_stringbuf</code> back in C++20. The reason for covering both is that the author aims for the same purpose with the two proposals. One completes the other.</p><h2 id="strstreams-are-dead-long-live-the-buffers-and-spans"><code class="language-plaintext highlighter-rouge">strstream</code>s are dead, long live the buffers and spans!</h2><p>While streams are one of the oldest parts of the C++ standard library they haven’t been keeping up with the winds of change since the release of C++11 and they required some updates.</p><p>The motivation behind these two proposals is to have a stream that avoids unnecessary copies of buffers. In other words, the goal was to provide a stream that</p><ul><li>provides an efficient access to the underlying buffer<li>uses a fixed-size pre-allocated buffer</ul><p>One of the problems is that up until <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a>, there was no non-copying access to the internal buffer of a <code class="language-plaintext highlighter-rouge">std::basic_stringbuf</code> so getting the results of <code class="language-plaintext highlighter-rouge">ostringstream</code> always required a copy of the internal buffer, even if one doesn’t want to use the stream afterwards. <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a> solved this problem.</p><p>With the acceptance of the other discussed paper, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf">P0448R4</a>, <em>spanstreams</em> provide us a stream whose internal storage can use a fixed-size, pre-allocated buffer. That can be something on the stack, for example, a non-owning array view, <code class="language-plaintext highlighter-rouge">std::span&lt;T&gt;</code>.</p><p>By using <code class="language-plaintext highlighter-rouge">std::span&lt;T&gt;</code>, we can represent and pass a buffer for a new <em>spanstream</em> and avoid any dynamic (re)allocation which might not be acceptable for you depending on your use case.</p><h2 id="the-first-step-towards-removing-the-deprecated-stream-buffer">The first step towards removing the deprecated stream buffer</h2><p>In <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a>, the author shares his belief that <code class="language-plaintext highlighter-rouge">basic_strbuf</code> should be removed from the <em>[depr.str.strstreams]</em> section of the standard as soon as the feature is completely replaced.</p><blockquote><p>The reason why <code class="language-plaintext highlighter-rouge">strstream</code> was deprecated in the first place is that it returned a <code class="language-plaintext highlighter-rouge">char*</code> which was difficult to manage and therefore it was prone to cause memory leaks. This difficulty came from the fact that it was nowhere stated how and where it had been allocated. The only satisfactory deallocation was via the <a href="https://en.cppreference.com/w/cpp/io/strstream/freeze"><code class="language-plaintext highlighter-rouge">std::strstream::freeze()</code> function</a>, but it was not obvious, hence lots of people got it wrong. On the other hand, <code class="language-plaintext highlighter-rouge">stringstream</code>s return <code class="language-plaintext highlighter-rouge">std::string</code>s which manage their own memory allocations.</p></blockquote><p>The first step towards that removal was to extend the API of <code class="language-plaintext highlighter-rouge">basic_stringbuf</code> (note the difference between <code class="language-plaintext highlighter-rouge">basic_strbuf</code> and <code class="language-plaintext highlighter-rouge">basic_stringbuf</code>). <code class="language-plaintext highlighter-rouge">std::string_view</code> was introduced by C++17 to provide efficient read-only access to continuous sequence of characters. A <code class="language-plaintext highlighter-rouge">basic_stringbuf</code> has similar characteristics so it was a natural and highly waited-for step forward to provide a <code class="language-plaintext highlighter-rouge">string_view</code>-like access to its internal buffer.</p><p><a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a> brought the below changes to <code class="language-plaintext highlighter-rouge">basic_stringbuf</code> in C++20.</p><p>Somewhat accidentally, it introduced allocator-aware construction. I’m using the word “accidentally” because the author of these papers shared with me, that this was not part of his original intentions. But the papers were proposed around when the standard library itself made allocator support more flexible with stateful allocators and <code class="language-plaintext highlighter-rouge">std::pmr</code>, etc.</p><p>At the same time, <code class="language-plaintext highlighter-rouge">basic_stringbuf</code> is also benefiting from new constructor overloads taking an initial value by rvalue-reference which again is about avoiding unnecessary copies.</p><p><code class="language-plaintext highlighter-rouge">basic_stringbuf::str()</code> went through several changes. First, we must remind ourselves that <code class="language-plaintext highlighter-rouge">basic_stringbuf::str()</code> is both a getter and a setter depending on its return type and parameters.</p><p>The getter <code class="language-plaintext highlighter-rouge">str()</code> now has an overload that is used when the underlying object is an lvalue and another form rvalues. When <code class="language-plaintext highlighter-rouge">str()</code> is <a href="https://www.sandordargo.com/blog/2018/11/25/override-r-and-l0-values#use--for-declaring-rvalue-references">called on an rvalue reference</a>, it returns the underlying string by moving it away from the internal buffer. According to the author, this is probably the first ref-qualified member function in the standard library. Moreover, in this case, the standard clearly specifies how the moved-from object should look like. Its buffer becomes empty.</p><p><code class="language-plaintext highlighter-rouge">str()</code> also received an overload with an allocator which sets how to copy the underlying buffer into the returned string. Of course, this is only for the no-move overload.</p><p>There is also a new method called <code class="language-plaintext highlighter-rouge">view()</code> that is both <code class="language-plaintext highlighter-rouge">const</code> and <code class="language-plaintext highlighter-rouge">noexcept</code> and returns a <code class="language-plaintext highlighter-rouge">string_view</code> so that you can have a no-copy, not-owning, read-only access to the contents of the internal buffer.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
</pre><td class="rouge-code"><pre><span class="n">basic_string</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span> <span class="n">str</span><span class="p">()</span> <span class="k">const</span> <span class="o">&amp;</span><span class="p">;</span> <span class="c1">// The &amp; lvalue qualifier is new!</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">SAlloc</span><span class="p">&gt;</span>
<span class="n">basic_string</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span><span class="n">traits</span><span class="p">,</span><span class="n">SAlloc</span><span class="o">&gt;</span> <span class="n">str</span><span class="p">(</span><span class="k">const</span> <span class="n">SAlloc</span><span class="o">&amp;</span> <span class="n">sa</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span> <span class="c1">// this is a new overload</span>
<span class="n">basic_string</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;</span> <span class="n">str</span><span class="p">()</span> <span class="o">&amp;&amp;</span><span class="p">;</span> <span class="c1">// this is a new overload</span>
<span class="n">basic_string_view</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="o">&gt;</span> <span class="n">view</span><span class="p">()</span> <span class="k">const</span> <span class="k">noexcept</span><span class="p">;</span> <span class="c1">// this is a new method</span>
</pre></table></code></div></div><p>The setter <code class="language-plaintext highlighter-rouge">str()</code> methods also received two new overloads. The original one takes a string using the same allocator as the <code class="language-plaintext highlighter-rouge">basic_stringbuf</code> class and takes the string by <code class="language-plaintext highlighter-rouge">const&amp;</code>. There is a new overload that still takes the input <code class="language-plaintext highlighter-rouge">string</code> by <code class="language-plaintext highlighter-rouge">const&amp;</code> but with a different allocator and another one that takes the <code class="language-plaintext highlighter-rouge">string</code> by rvalue reference, so it moves it to the internal buffer.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
</pre><td class="rouge-code"><pre><span class="kt">void</span> <span class="nf">str</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">);</span> <span class="c1">// this was already there</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">SAlloc</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">str</span><span class="p">(</span><span class="k">const</span> <span class="n">basic_string</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="p">,</span> <span class="n">SAlloc</span><span class="o">&gt;&amp;</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">// this is a new overload</span>
<span class="kt">void</span> <span class="nf">str</span><span class="p">(</span><span class="n">basic_string</span><span class="o">&lt;</span><span class="n">charT</span><span class="p">,</span> <span class="n">traits</span><span class="p">,</span> <span class="n">Allocator</span><span class="o">&gt;&amp;&amp;</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">// this is a new overload</span>
</pre></table></code></div></div><p>There are several other changes in which we are not going into details, but it’s worth noting that <code class="language-plaintext highlighter-rouge">basic_stringbuf::swap()</code> became conditionally <code class="language-plaintext highlighter-rouge">noexcept</code> depending on the used allocator.</p><p>Probably the most important change among the above is that now you can get the contents of <code class="language-plaintext highlighter-rouge">basic_stringbuf</code> without actually having to make a copy of the internal buffer. Either it will be moved if you use <code class="language-plaintext highlighter-rouge">str() &amp;&amp;</code> or you get a read-only view on it if you use <code class="language-plaintext highlighter-rouge">view</code>.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;sstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>

    <span class="n">std</span><span class="o">::</span><span class="n">stringbuf</span> <span class="n">buf</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">temp</span> <span class="p">{</span><span class="s">"Some content"</span><span class="p">};</span>
    <span class="n">buf</span><span class="p">.</span><span class="n">str</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">temp</span><span class="p">));</span>

    <span class="c1">// now temp is moved away from, who knows what's inside</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"temp: "</span> <span class="o">&lt;&lt;</span> <span class="n">temp</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="c1">// no copy is needed to access the internal buffer</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">bufview</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">view</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bufview: "</span> <span class="o">&lt;&lt;</span> <span class="n">bufview</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="c1">// no copy is needed to access the internal buffer which still contains the data we put in it</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">anotherView</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">view</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"anotherView: "</span> <span class="o">&lt;&lt;</span> <span class="n">anotherView</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="c1">// still no copy, buf is used as an rvalue-reference, the internal buffer is moved out</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">internalBufferMoved</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">buf</span><span class="p">).</span><span class="n">str</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"internalBufferMoved: "</span> <span class="o">&lt;&lt;</span> <span class="n">internalBufferMoved</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>

    <span class="c1">// now buf is moved away from, who knows what's inside</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string_view</span> <span class="n">viewOnMovedObject</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">view</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"viewOnMovedObject: "</span> <span class="o">&lt;&lt;</span> <span class="n">viewOnMovedObject</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*
temp: 
bufview: Some content
anotherView: Some content
internalBufferMoved: Some content
viewOnMovedObject: 
*/</span>
</pre></table></code></div></div><p>Notice in the above example, how efficiently views and moves are used in order to avoid expensive copy operations.</p><h2 id="introducing-the-new-spanstream-header">Introducing the new <code class="language-plaintext highlighter-rouge">&lt;spanstream&gt;</code> header</h2><p>The second proposal, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf">P0448R4</a>, introduces a complete new header <code class="language-plaintext highlighter-rouge">&lt;spanstream&gt;</code> mainly with 4 class templates:</p><ul><li><code class="language-plaintext highlighter-rouge">std::basic_spanbuf</code><li><code class="language-plaintext highlighter-rouge">std::basic_ispanstream</code><li><code class="language-plaintext highlighter-rouge">std::basic_ospanstream</code><li><code class="language-plaintext highlighter-rouge">std::basic_spanstream</code></ul><p>Basically what we get are the usual 3 streams and an externally provided memory buffer for them. <em>spanstreams</em> do not own the internal buffer, hence the name <em>span</em>, which is a non-owning view on an array of items. Therefore re-allocation is also not possible. If you need dynamic reallocation, you need to use <code class="language-plaintext highlighter-rouge">stringstream</code> et al. A <code class="language-plaintext highlighter-rouge">stringstream</code> has no-copy access to its contents since C++20.</p><p>As a consequence of this hew header and the explained changes to <code class="language-plaintext highlighter-rouge">basic_stringbuf</code>, there is no more reason to keep the already deprecated <code class="language-plaintext highlighter-rouge">strstream</code> classes in the standard, and the <em>[depr.str.strstreams]</em> section is getting removed.</p><p>Not surprisingly a <code class="language-plaintext highlighter-rouge">basic_spanbuf</code> uses a span of a sort of character (<code class="language-plaintext highlighter-rouge">charT</code>) as an internal buffer. It’s safe and cheap to provide access to it, as it requires no copy of the data. If you need an owning copy of the data, you can always convert the result of <code class="language-plaintext highlighter-rouge">span()</code> back to <code class="language-plaintext highlighter-rouge">basic_string&lt;charT&gt;</code> and as such copy it for yourself.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;span&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;spanstream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;cassert&gt;</span><span class="cp">
</span>
<span class="kt">void</span> <span class="nf">printSpan</span><span class="p">(</span><span class="k">auto</span> <span class="n">spanToPrint</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">spanToPrint</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">spanToPrint</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">useSpanbuf</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">charArray</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">charArraySpan</span><span class="p">(</span><span class="n">charArray</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">spanbuf</span> <span class="n">buf</span><span class="p">;</span>

    <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="sc">'a'</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">charArraySpan</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
        <span class="o">++</span><span class="n">c</span><span class="p">;</span>
    <span class="p">}</span>
    
    <span class="n">buf</span><span class="p">.</span><span class="n">span</span><span class="p">(</span><span class="n">charArraySpan</span><span class="p">);</span>

    <span class="c1">// we can easily print a span got from the buffer</span>
    <span class="n">std</span><span class="o">::</span><span class="n">span</span> <span class="n">bufview</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">span</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"bufview: "</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bufview</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">useSpanstream</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">array</span><span class="o">&lt;</span><span class="kt">char</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">charArray</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">ospanstream</span> <span class="n">oss</span><span class="p">(</span><span class="n">charArray</span><span class="p">);</span>

    <span class="n">oss</span> <span class="o">&lt;&lt;</span> <span class="s">"Fortytwo is "</span> <span class="o">&lt;&lt;</span> <span class="mi">42</span><span class="p">;</span>
    <span class="c1">// copying the contents to a span</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">{</span><span class="n">oss</span><span class="p">.</span><span class="n">span</span><span class="p">().</span><span class="n">data</span><span class="p">(),</span><span class="kt">size_t</span><span class="p">(</span><span class="n">oss</span><span class="p">.</span><span class="n">span</span><span class="p">().</span><span class="n">size</span><span class="p">())};</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="s">"Fortytwo is 42"</span><span class="p">);</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">useSpanbuf</span><span class="p">();</span>
    <span class="n">useSpanstream</span><span class="p">();</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h2 id="conclusion">Conclusion</h2><p>In this post, we had a brief overview of how the world of buffers and streams has changed in C++20 and C++23 thanks to Peter Sommerlad and his two proposals, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf">P0448R4</a>, <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a>.</p><p>With <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2019/p0408r7.pdf">P0408R7</a> we get non-copying access to the internal buffer of a <code class="language-plaintext highlighter-rouge">std::basic_stringbuf</code> which is a significant efficiency increase.</p><p>With the acceptance of <a href="https://www.open-std.org/jtc1/sc22/wg21/docs/papers/2021/p0448r4.pdf">P0448R4</a> and the introduction of <em>spanstreams</em>, we get a stream that as an internal storage can use a fixed-size pre-allocated buffer.</p><p>Special thanks to <a href="https://sommerlad.ch/">Peter</a> who pointed out a couple of missing points and misunderstandings in the draft of this article and helped it become more informative.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/streams/" class="post-tag no-text-decoration" >streams</a> <a href="/tags/spanstream/" class="post-tag no-text-decoration" >spanstream</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=C++23: The rise of new streams - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=C++23: The rise of new streams - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=C++23: The rise of new streams - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=C++23: The rise of new streams - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/11/29/cpp23-unicode-support" class="btn btn-outline-primary" prompt="Older"><p>C++23: Growing unicode support</p></a> <a href="/blog/2023/12/09/genghis-khan-by-jack-weatherford" class="btn btn-outline-primary" prompt="Newer"><p>Genghis Khan And The Making Of The Modern World by Jack Weatherford</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'C++23: The rise of new streams'; this.page.url = 'https://www.sandordargo.com/blog/2023/12/06/cpp23-strtream-strstream-replacement'; this.page.identifier = '/blog/2023/12/06/cpp23-strtream-strstream-replacement'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
