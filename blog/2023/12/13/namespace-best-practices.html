<!DOCTYPE html><html lang="en-US" ><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"><meta name="pv-cache-enabled" content="false"><meta name="generator" content="Jekyll v4.4.1" /><meta property="og:title" content="How to use your namespaces to their best" /><meta property="og:locale" content="en_US" /><meta name="description" content="Today, we are not going to discuss any novelty of the language. Instead, we are going to discuss something old, something that we take for granted and probably something we don’t even think about a lot. We are going to discuss namespaces, what they are and what are the related best practices, including some of the recommendations of the Core Guidelines. What are namespaces in the first place? In C++, a namespace is a mechanism for organizing and encapsulating functions, variables, and types. Namespaces help prevent naming conflicts and make it easier to manage and maintain large codebases. They allow you to define a scope within which you can declare identifiers (such as variables, functions, and classes) without worrying about naming collisions with identifiers in other parts of your code. Just like in the different classes, you can use methods or variables with the same name, in different namespaces, you can reuse the same symbol names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { constexpr int magic_number = 42; } namespace bar { constexpr float magic_number = 3.14; } int main() { std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; bar::magic_number &lt;&lt; &#39;\n&#39;; } There is no problem with having magic_number declared and defined in both namespaces, those are two different variables. We can use them either by fully qualifying their name or by importing their symbols from their enclosing namespaces. More on that later. Nested namespaces Namespaces can also be nested and as you can see in the below example, since C++17 we have a shortcut to declare nested namespaces with the help of :: so that we can save some typing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace consts { constexpr int magic_number = 42; } } namespace bar::consts { constexpr float magic_number = 3.14; } int main() { std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; bar::consts::magic_number &lt;&lt; &#39;\n&#39;; } A rarely used namespace feature: inline inline is an optional keyword that we can use alongside the namespace keyword. If a namespace is marked inline, then its members will be treated in many situations as if they are part of the enclosing namespace. Both the below calls are correct. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace consts { constexpr int magic_number = 42; } } int main() { std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } The inline attribute of a namespace is transitive, so if within an inline namespace there is another one, you can use the most nested member with the outermost namespace. As you can see, using nested inline namespaces can lead to quite a mess. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace bar { inline namespace consts { constexpr int magic_number = 42; } } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } At least the compiler is aware of it and it doesn’t let us turn the situation into a run-time nightmare: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace bar { inline namespace consts { constexpr int magic_number = 42; } constexpr float magic_number = 3.14; } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } /* &lt;source&gt;: In function &#39;int main()&#39;: &lt;source&gt;:15:28: error: reference to &#39;magic_number&#39; is ambiguous 15 | std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; | ^~~~~~~~~~~~ ... &lt;source&gt;:17:23: error: reference to &#39;magic_number&#39; is ambiguous 17 | std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; | ^~~~~~~~~~~~ */ Without the inline modifier, our code is perfectly valid: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace bar { namespace consts { constexpr int magic_number = 42; } constexpr float magic_number = 3.14; } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; // ERROR: without inlining, we cannot use such &quot;shortcuts&quot; // std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; // std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } /* 42 3.14 */ In my 11 years of C++ journey, I never directly used inline namespaces and up until recently I haven’t even encountered them. I found them while I was looking for a solution to some kind of a versioning issue and apparently, this feature is mostly used for library versioning. One can store the latest version of an API behind an inline nested namespace. Those who are on the latest version, they don’t have to use a version number. But those, who for some reason cannot migrate, they have the option to explicitly use an older version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace v1 { constexpr int magic_number = 42; } inline namespace v2 { constexpr float magic_number = 3.14; } } int main() { // using the latest version std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::v2::magic_number &lt;&lt; &#39;\n&#39;; // this also works // using an older version std::cout &lt;&lt; foo::v1::magic_number &lt;&lt; &#39;\n&#39;; } /* 3.14 3.14 42 */ You can find more details about this feature on Jonathan’s blog post called Inline Namespaces 101. Now let’s move on to discuss best practices. General C++ namespace best practices Using a namespace in general to organize a codebase is already a best practice. With that in mind, we should minimize the use of the global namespace. Allowing code to reside in the global namespace can lead to naming conflicts and make code maintenance more difficult than it should be. Instead, encapsulate your code in (well-)named namespaces. What names to use? First of all, use meaningful and descriptive names for namespaces. Well-chosen namespace names make the code easier to understand and easier to maintain. Then use a consistent style. A style that matches the rest of the project. If you are using something new, I recommend writing the namespace names in snake_case as that’s exactly what the standard library does (e.g. std::literals::string_literals) and that’s what the most widely used style guide, the Google Style Guide recommends as well. Try to avoid using abbreviations, unless they are evident. But more often than not even if you think that an abbreviation is straightforward, probably it’s not. Use using declarations as much as you need, but only in .cpp files The use of namespace using directives (e.g. using namespace std;) must be avoided in header files as they extend the surrounding namespace with the namespace being “used”. This can lead to naming conflicts and ambiguous lookups. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { using namespace std; // #F void func(string s) { // #D cout &lt;&lt; s &lt;&lt; &#39;\n&#39;; } } void func(std::string s) {. // #B std::cout &lt;&lt; &quot;global func &quot; &lt;&lt; s &lt;&lt; &#39;\n&#39;; } namespace bar { using namespace foo; // #C void fun() { string g{&quot;oh no&quot;}; // #E func(g); // #A } } int main() { bar::fun(); } If you look at the above example, first it will fail at #A, because calling func(std::string) is ambiguous. It can be the global func (#B), but after having the use namespace foo; using namespace directive at #C, it could be foo::func as well (#D). If we decide to remove using namespace foo at #C, we will face another compilation error, even earlier. string g{&quot;oh no}&quot; doesn’t compile anymore because by not using foo, we are not using std either (#F)… Though using namespace using directives is not so much of a problem in a .cpp file, it’s still better to avoid it as it can make it difficult to figure out for the readers where certain symbols come from. Instead of using directives, use using declarations (e.g., using namespace foo::const_member::magic_number;) to bring specific elements from a namespace into the current scope. This reduces ambiguity and clearly specifies which items you’re using. Still, only use this in .cpp files as just like using directives, they introduce the used namespace into the surrounding namespace and that might be propagated. If you still do it in the header, limit the scope and never use it in the global namespaces. What I write here is a bit stricter than what the Core Guidelines say at SF.6 and SF.7 as it mostly protects the global namespace, but I think it makes sense to go further and protect our user-defined namespaces as well - and that’s what we did in almost every project that I worked on. Avoid using namespace aliases, especially in header files It’s tempting to use alias namespaces (namespace foo::bar::baz = fbb;) in order to simplify long or complex names, but do so sparingly. While it can make code more concise, overusing aliases can lead to ambiguity and confusion. Like using directives and using declarations, aliases must also be avoided in header files, except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file. If alias namespaces are used in header files, we can easily end up with the same problem as namespaces try to solve: naming conflicts and ambiguity. If multiple namespaces or alias names are similar or if multiple aliases bring in the same names, it can lead to compilation errors and difficulties in determining the source of the referenced name. Besides, namespace aliases can also hinder code maintainability. When alias names are cryptic or excessively used, it becomes challenging for developers to understand where identifiers are defined, which namespace they belong to, and the relationships between different parts of the code. Moreover, when the structure of namespaces changes, alias names may become misleading or incorrect. If you rely heavily on alias names, adapting to changes in the underlying namespaces can be cumbersome. Always fully qualify namespaces in preprocessor macros While preprocessor macros seemingly might live within namespaces, that’s just a mirage. Macros are being replaced before the compilation and the preprocessor knows nothing about namespaces. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; namespace foo { #define MM(X) (X * magic_number) constexpr int magic_number = 42; int bar(int x) { return MM(x);} } int main() { std::cout &lt;&lt; foo::bar(42) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; MM(42) &lt;&lt; &#39;\n&#39;; // error: &#39;magic_number&#39; was not declared in this scope; } In the above example, MM is seemingly part of the namespace foo and therefore it should always know about foo::magic_number, but that’s not the case. If MM is used outside of foo, it won’t work. This means that to avoid potential issues with name lookups if you really want to use a macro, always fully qualify symbols in macros if they are public. 1 #define MM(X) (X * ::foo::magic_number) At the same time, we’d highly encourage anyone not using macros given that they are error-prone and with modern C++ techniques, there is barely any need for them. Oh, and I hope you didn’t even have the idea, but don’t use macros to create namespace aliases. 1 #define NS MyNamespace // Avoid using macros for this purpose Use internal linkage only in source files (SF.21, SF.22) When you have functions or variables that are not supposed to be used outside of a source file, give them internal linkage either by placing them in unnamed namespaces or by declaring them static. Don’t use these constructs in header files. There are various good reasons for avoiding that: Internal linkage is often used for implementation details. Let’s not expose implementation details via header files. The C++ One Definition Rule states that an entity should have only one definition in the entire program. When you include a header file with internal linkage in multiple source files, each translation unit gets its own version of the internal linkage entity. This can lead to violations of the ODR and result in linker errors. Avoid deep dependencies and use them together with physical separation of source files While organizing your code with namespaces is definitely a good idea, it matters how you do it. Just like with directories. If you end up having a too deep directory structure, it will become difficult to navigate, difficult to use and share paths. It’s similar with namespaces. Don’t have too deep nestings, names will be too long, your code will be difficult to read either because of the two long fully qualified names or because of the aliases and using declarations you’ll need to keep the code short. Based on experience, not having more than 3 levels of nested namespaces is a good solution. You might be tempted to follow your directory structure with the namespaces. I find it a good idea, even if they don’t follow exactly the same logic. If you organize your codebase around libraries and your namespaces help you identify the usage of your libraries, then dependency management becomes a little bit easier. Whenever you have to “open up” a foreign namespace (foreign to your current scope), you know that you’re dealing with a dependency that will both make your compilation longer and probably that will make your code recompile more frequently. So you can think about whether you really need that dependency or if there is a smarter way. But that’s beyond the scope of this article. What we should remember at this point is that use not too many nested namespaces and directories to organize your code and if they follow the organization of your deliverables, they will help you manage your dependencies. Conclusion In this article, we learned about namespaces. They help organise code in the first place and to have further options, there are also inline namespaces that really come in handy for versioning APIs. There are many best practices to keep in mind when it comes to using namespaces and related features. A big chunk of best practices is about avoiding namespace pollution. We should avoid using namespace declarations and even directives in the header as they are extending the enclosing namespaces. At the same time, we should not forget that namespaces are not the only way to organize code and we often use a physical separation as well by placing C++ code files into different directories. These different approaches should be used together in a coherent way to keep your codebase tidy both from a physical (file organization) and logical (namespace organization) standpoint. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><meta property="og:description" content="Today, we are not going to discuss any novelty of the language. Instead, we are going to discuss something old, something that we take for granted and probably something we don’t even think about a lot. We are going to discuss namespaces, what they are and what are the related best practices, including some of the recommendations of the Core Guidelines. What are namespaces in the first place? In C++, a namespace is a mechanism for organizing and encapsulating functions, variables, and types. Namespaces help prevent naming conflicts and make it easier to manage and maintain large codebases. They allow you to define a scope within which you can declare identifiers (such as variables, functions, and classes) without worrying about naming collisions with identifiers in other parts of your code. Just like in the different classes, you can use methods or variables with the same name, in different namespaces, you can reuse the same symbol names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { constexpr int magic_number = 42; } namespace bar { constexpr float magic_number = 3.14; } int main() { std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; bar::magic_number &lt;&lt; &#39;\n&#39;; } There is no problem with having magic_number declared and defined in both namespaces, those are two different variables. We can use them either by fully qualifying their name or by importing their symbols from their enclosing namespaces. More on that later. Nested namespaces Namespaces can also be nested and as you can see in the below example, since C++17 we have a shortcut to declare nested namespaces with the help of :: so that we can save some typing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace consts { constexpr int magic_number = 42; } } namespace bar::consts { constexpr float magic_number = 3.14; } int main() { std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; bar::consts::magic_number &lt;&lt; &#39;\n&#39;; } A rarely used namespace feature: inline inline is an optional keyword that we can use alongside the namespace keyword. If a namespace is marked inline, then its members will be treated in many situations as if they are part of the enclosing namespace. Both the below calls are correct. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace consts { constexpr int magic_number = 42; } } int main() { std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } The inline attribute of a namespace is transitive, so if within an inline namespace there is another one, you can use the most nested member with the outermost namespace. As you can see, using nested inline namespaces can lead to quite a mess. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace bar { inline namespace consts { constexpr int magic_number = 42; } } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } At least the compiler is aware of it and it doesn’t let us turn the situation into a run-time nightmare: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace bar { inline namespace consts { constexpr int magic_number = 42; } constexpr float magic_number = 3.14; } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } /* &lt;source&gt;: In function &#39;int main()&#39;: &lt;source&gt;:15:28: error: reference to &#39;magic_number&#39; is ambiguous 15 | std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; | ^~~~~~~~~~~~ ... &lt;source&gt;:17:23: error: reference to &#39;magic_number&#39; is ambiguous 17 | std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; | ^~~~~~~~~~~~ */ Without the inline modifier, our code is perfectly valid: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace bar { namespace consts { constexpr int magic_number = 42; } constexpr float magic_number = 3.14; } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\n&#39;; // ERROR: without inlining, we cannot use such &quot;shortcuts&quot; // std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\n&#39;; // std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; } /* 42 3.14 */ In my 11 years of C++ journey, I never directly used inline namespaces and up until recently I haven’t even encountered them. I found them while I was looking for a solution to some kind of a versioning issue and apparently, this feature is mostly used for library versioning. One can store the latest version of an API behind an inline nested namespace. Those who are on the latest version, they don’t have to use a version number. But those, who for some reason cannot migrate, they have the option to explicitly use an older version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace v1 { constexpr int magic_number = 42; } inline namespace v2 { constexpr float magic_number = 3.14; } } int main() { // using the latest version std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; foo::v2::magic_number &lt;&lt; &#39;\n&#39;; // this also works // using an older version std::cout &lt;&lt; foo::v1::magic_number &lt;&lt; &#39;\n&#39;; } /* 3.14 3.14 42 */ You can find more details about this feature on Jonathan’s blog post called Inline Namespaces 101. Now let’s move on to discuss best practices. General C++ namespace best practices Using a namespace in general to organize a codebase is already a best practice. With that in mind, we should minimize the use of the global namespace. Allowing code to reside in the global namespace can lead to naming conflicts and make code maintenance more difficult than it should be. Instead, encapsulate your code in (well-)named namespaces. What names to use? First of all, use meaningful and descriptive names for namespaces. Well-chosen namespace names make the code easier to understand and easier to maintain. Then use a consistent style. A style that matches the rest of the project. If you are using something new, I recommend writing the namespace names in snake_case as that’s exactly what the standard library does (e.g. std::literals::string_literals) and that’s what the most widely used style guide, the Google Style Guide recommends as well. Try to avoid using abbreviations, unless they are evident. But more often than not even if you think that an abbreviation is straightforward, probably it’s not. Use using declarations as much as you need, but only in .cpp files The use of namespace using directives (e.g. using namespace std;) must be avoided in header files as they extend the surrounding namespace with the namespace being “used”. This can lead to naming conflicts and ambiguous lookups. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { using namespace std; // #F void func(string s) { // #D cout &lt;&lt; s &lt;&lt; &#39;\n&#39;; } } void func(std::string s) {. // #B std::cout &lt;&lt; &quot;global func &quot; &lt;&lt; s &lt;&lt; &#39;\n&#39;; } namespace bar { using namespace foo; // #C void fun() { string g{&quot;oh no&quot;}; // #E func(g); // #A } } int main() { bar::fun(); } If you look at the above example, first it will fail at #A, because calling func(std::string) is ambiguous. It can be the global func (#B), but after having the use namespace foo; using namespace directive at #C, it could be foo::func as well (#D). If we decide to remove using namespace foo at #C, we will face another compilation error, even earlier. string g{&quot;oh no}&quot; doesn’t compile anymore because by not using foo, we are not using std either (#F)… Though using namespace using directives is not so much of a problem in a .cpp file, it’s still better to avoid it as it can make it difficult to figure out for the readers where certain symbols come from. Instead of using directives, use using declarations (e.g., using namespace foo::const_member::magic_number;) to bring specific elements from a namespace into the current scope. This reduces ambiguity and clearly specifies which items you’re using. Still, only use this in .cpp files as just like using directives, they introduce the used namespace into the surrounding namespace and that might be propagated. If you still do it in the header, limit the scope and never use it in the global namespaces. What I write here is a bit stricter than what the Core Guidelines say at SF.6 and SF.7 as it mostly protects the global namespace, but I think it makes sense to go further and protect our user-defined namespaces as well - and that’s what we did in almost every project that I worked on. Avoid using namespace aliases, especially in header files It’s tempting to use alias namespaces (namespace foo::bar::baz = fbb;) in order to simplify long or complex names, but do so sparingly. While it can make code more concise, overusing aliases can lead to ambiguity and confusion. Like using directives and using declarations, aliases must also be avoided in header files, except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file. If alias namespaces are used in header files, we can easily end up with the same problem as namespaces try to solve: naming conflicts and ambiguity. If multiple namespaces or alias names are similar or if multiple aliases bring in the same names, it can lead to compilation errors and difficulties in determining the source of the referenced name. Besides, namespace aliases can also hinder code maintainability. When alias names are cryptic or excessively used, it becomes challenging for developers to understand where identifiers are defined, which namespace they belong to, and the relationships between different parts of the code. Moreover, when the structure of namespaces changes, alias names may become misleading or incorrect. If you rely heavily on alias names, adapting to changes in the underlying namespaces can be cumbersome. Always fully qualify namespaces in preprocessor macros While preprocessor macros seemingly might live within namespaces, that’s just a mirage. Macros are being replaced before the compilation and the preprocessor knows nothing about namespaces. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; namespace foo { #define MM(X) (X * magic_number) constexpr int magic_number = 42; int bar(int x) { return MM(x);} } int main() { std::cout &lt;&lt; foo::bar(42) &lt;&lt; &#39;\n&#39;; std::cout &lt;&lt; MM(42) &lt;&lt; &#39;\n&#39;; // error: &#39;magic_number&#39; was not declared in this scope; } In the above example, MM is seemingly part of the namespace foo and therefore it should always know about foo::magic_number, but that’s not the case. If MM is used outside of foo, it won’t work. This means that to avoid potential issues with name lookups if you really want to use a macro, always fully qualify symbols in macros if they are public. 1 #define MM(X) (X * ::foo::magic_number) At the same time, we’d highly encourage anyone not using macros given that they are error-prone and with modern C++ techniques, there is barely any need for them. Oh, and I hope you didn’t even have the idea, but don’t use macros to create namespace aliases. 1 #define NS MyNamespace // Avoid using macros for this purpose Use internal linkage only in source files (SF.21, SF.22) When you have functions or variables that are not supposed to be used outside of a source file, give them internal linkage either by placing them in unnamed namespaces or by declaring them static. Don’t use these constructs in header files. There are various good reasons for avoiding that: Internal linkage is often used for implementation details. Let’s not expose implementation details via header files. The C++ One Definition Rule states that an entity should have only one definition in the entire program. When you include a header file with internal linkage in multiple source files, each translation unit gets its own version of the internal linkage entity. This can lead to violations of the ODR and result in linker errors. Avoid deep dependencies and use them together with physical separation of source files While organizing your code with namespaces is definitely a good idea, it matters how you do it. Just like with directories. If you end up having a too deep directory structure, it will become difficult to navigate, difficult to use and share paths. It’s similar with namespaces. Don’t have too deep nestings, names will be too long, your code will be difficult to read either because of the two long fully qualified names or because of the aliases and using declarations you’ll need to keep the code short. Based on experience, not having more than 3 levels of nested namespaces is a good solution. You might be tempted to follow your directory structure with the namespaces. I find it a good idea, even if they don’t follow exactly the same logic. If you organize your codebase around libraries and your namespaces help you identify the usage of your libraries, then dependency management becomes a little bit easier. Whenever you have to “open up” a foreign namespace (foreign to your current scope), you know that you’re dealing with a dependency that will both make your compilation longer and probably that will make your code recompile more frequently. So you can think about whether you really need that dependency or if there is a smarter way. But that’s beyond the scope of this article. What we should remember at this point is that use not too many nested namespaces and directories to organize your code and if they follow the organization of your deliverables, they will help you manage your dependencies. Conclusion In this article, we learned about namespaces. They help organise code in the first place and to have further options, there are also inline namespaces that really come in handy for versioning APIs. There are many best practices to keep in mind when it comes to using namespaces and related features. A big chunk of best practices is about avoiding namespace pollution. We should avoid using namespace declarations and even directives in the header as they are extending the enclosing namespaces. At the same time, we should not forget that namespaces are not the only way to organize code and we often use a physical separation as well by placing C++ code files into different directories. These different approaches should be used together in a coherent way to keep your codebase tidy both from a physical (file organization) and logical (namespace organization) standpoint. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!" /><link rel="canonical" href="https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices" /><meta property="og:url" content="https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices" /><meta property="og:site_name" content="Sandor Dargo’s Blog" /><meta property="og:type" content="article" /><meta property="article:published_time" content="2023-12-13T00:00:00+01:00" /><meta name="twitter:card" content="summary" /><meta property="twitter:title" content="How to use your namespaces to their best" /><meta name="twitter:site" content="@SandorDargo" /><meta name="google-site-verification" content="google_meta_tag_verification" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","dateModified":"2025-06-19T06:35:16+02:00","datePublished":"2023-12-13T00:00:00+01:00","description":"Today, we are not going to discuss any novelty of the language. Instead, we are going to discuss something old, something that we take for granted and probably something we don’t even think about a lot. We are going to discuss namespaces, what they are and what are the related best practices, including some of the recommendations of the Core Guidelines. What are namespaces in the first place? In C++, a namespace is a mechanism for organizing and encapsulating functions, variables, and types. Namespaces help prevent naming conflicts and make it easier to manage and maintain large codebases. They allow you to define a scope within which you can declare identifiers (such as variables, functions, and classes) without worrying about naming collisions with identifiers in other parts of your code. Just like in the different classes, you can use methods or variables with the same name, in different namespaces, you can reuse the same symbol names. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { constexpr int magic_number = 42; } namespace bar { constexpr float magic_number = 3.14; } int main() { std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; bar::magic_number &lt;&lt; &#39;\\n&#39;; } There is no problem with having magic_number declared and defined in both namespaces, those are two different variables. We can use them either by fully qualifying their name or by importing their symbols from their enclosing namespaces. More on that later. Nested namespaces Namespaces can also be nested and as you can see in the below example, since C++17 we have a shortcut to declare nested namespaces with the help of :: so that we can save some typing. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace consts { constexpr int magic_number = 42; } } namespace bar::consts { constexpr float magic_number = 3.14; } int main() { std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; bar::consts::magic_number &lt;&lt; &#39;\\n&#39;; } A rarely used namespace feature: inline inline is an optional keyword that we can use alongside the namespace keyword. If a namespace is marked inline, then its members will be treated in many situations as if they are part of the enclosing namespace. Both the below calls are correct. 1 2 3 4 5 6 7 8 9 10 11 12 13 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace consts { constexpr int magic_number = 42; } } int main() { std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; } The inline attribute of a namespace is transitive, so if within an inline namespace there is another one, you can use the most nested member with the outermost namespace. As you can see, using nested inline namespaces can lead to quite a mess. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace bar { inline namespace consts { constexpr int magic_number = 42; } } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; } At least the compiler is aware of it and it doesn’t let us turn the situation into a run-time nightmare: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { inline namespace bar { inline namespace consts { constexpr int magic_number = 42; } constexpr float magic_number = 3.14; } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; } /* &lt;source&gt;: In function &#39;int main()&#39;: &lt;source&gt;:15:28: error: reference to &#39;magic_number&#39; is ambiguous 15 | std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\\n&#39;; | ^~~~~~~~~~~~ ... &lt;source&gt;:17:23: error: reference to &#39;magic_number&#39; is ambiguous 17 | std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; | ^~~~~~~~~~~~ */ Without the inline modifier, our code is perfectly valid: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace bar { namespace consts { constexpr int magic_number = 42; } constexpr float magic_number = 3.14; } } int main() { std::cout &lt;&lt; foo::bar::consts::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; &#39;\\n&#39;; // ERROR: without inlining, we cannot use such &quot;shortcuts&quot; // std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; &#39;\\n&#39;; // std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; } /* 42 3.14 */ In my 11 years of C++ journey, I never directly used inline namespaces and up until recently I haven’t even encountered them. I found them while I was looking for a solution to some kind of a versioning issue and apparently, this feature is mostly used for library versioning. One can store the latest version of an API behind an inline nested namespace. Those who are on the latest version, they don’t have to use a version number. But those, who for some reason cannot migrate, they have the option to explicitly use an older version. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { namespace v1 { constexpr int magic_number = 42; } inline namespace v2 { constexpr float magic_number = 3.14; } } int main() { // using the latest version std::cout &lt;&lt; foo::magic_number &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; foo::v2::magic_number &lt;&lt; &#39;\\n&#39;; // this also works // using an older version std::cout &lt;&lt; foo::v1::magic_number &lt;&lt; &#39;\\n&#39;; } /* 3.14 3.14 42 */ You can find more details about this feature on Jonathan’s blog post called Inline Namespaces 101. Now let’s move on to discuss best practices. General C++ namespace best practices Using a namespace in general to organize a codebase is already a best practice. With that in mind, we should minimize the use of the global namespace. Allowing code to reside in the global namespace can lead to naming conflicts and make code maintenance more difficult than it should be. Instead, encapsulate your code in (well-)named namespaces. What names to use? First of all, use meaningful and descriptive names for namespaces. Well-chosen namespace names make the code easier to understand and easier to maintain. Then use a consistent style. A style that matches the rest of the project. If you are using something new, I recommend writing the namespace names in snake_case as that’s exactly what the standard library does (e.g. std::literals::string_literals) and that’s what the most widely used style guide, the Google Style Guide recommends as well. Try to avoid using abbreviations, unless they are evident. But more often than not even if you think that an abbreviation is straightforward, probably it’s not. Use using declarations as much as you need, but only in .cpp files The use of namespace using directives (e.g. using namespace std;) must be avoided in header files as they extend the surrounding namespace with the namespace being “used”. This can lead to naming conflicts and ambiguous lookups. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #include &lt;iostream&gt; #include &lt;string&gt; namespace foo { using namespace std; // #F void func(string s) { // #D cout &lt;&lt; s &lt;&lt; &#39;\\n&#39;; } } void func(std::string s) {. // #B std::cout &lt;&lt; &quot;global func &quot; &lt;&lt; s &lt;&lt; &#39;\\n&#39;; } namespace bar { using namespace foo; // #C void fun() { string g{&quot;oh no&quot;}; // #E func(g); // #A } } int main() { bar::fun(); } If you look at the above example, first it will fail at #A, because calling func(std::string) is ambiguous. It can be the global func (#B), but after having the use namespace foo; using namespace directive at #C, it could be foo::func as well (#D). If we decide to remove using namespace foo at #C, we will face another compilation error, even earlier. string g{&quot;oh no}&quot; doesn’t compile anymore because by not using foo, we are not using std either (#F)… Though using namespace using directives is not so much of a problem in a .cpp file, it’s still better to avoid it as it can make it difficult to figure out for the readers where certain symbols come from. Instead of using directives, use using declarations (e.g., using namespace foo::const_member::magic_number;) to bring specific elements from a namespace into the current scope. This reduces ambiguity and clearly specifies which items you’re using. Still, only use this in .cpp files as just like using directives, they introduce the used namespace into the surrounding namespace and that might be propagated. If you still do it in the header, limit the scope and never use it in the global namespaces. What I write here is a bit stricter than what the Core Guidelines say at SF.6 and SF.7 as it mostly protects the global namespace, but I think it makes sense to go further and protect our user-defined namespaces as well - and that’s what we did in almost every project that I worked on. Avoid using namespace aliases, especially in header files It’s tempting to use alias namespaces (namespace foo::bar::baz = fbb;) in order to simplify long or complex names, but do so sparingly. While it can make code more concise, overusing aliases can lead to ambiguity and confusion. Like using directives and using declarations, aliases must also be avoided in header files, except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file. If alias namespaces are used in header files, we can easily end up with the same problem as namespaces try to solve: naming conflicts and ambiguity. If multiple namespaces or alias names are similar or if multiple aliases bring in the same names, it can lead to compilation errors and difficulties in determining the source of the referenced name. Besides, namespace aliases can also hinder code maintainability. When alias names are cryptic or excessively used, it becomes challenging for developers to understand where identifiers are defined, which namespace they belong to, and the relationships between different parts of the code. Moreover, when the structure of namespaces changes, alias names may become misleading or incorrect. If you rely heavily on alias names, adapting to changes in the underlying namespaces can be cumbersome. Always fully qualify namespaces in preprocessor macros While preprocessor macros seemingly might live within namespaces, that’s just a mirage. Macros are being replaced before the compilation and the preprocessor knows nothing about namespaces. 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 #include &lt;iostream&gt; namespace foo { #define MM(X) (X * magic_number) constexpr int magic_number = 42; int bar(int x) { return MM(x);} } int main() { std::cout &lt;&lt; foo::bar(42) &lt;&lt; &#39;\\n&#39;; std::cout &lt;&lt; MM(42) &lt;&lt; &#39;\\n&#39;; // error: &#39;magic_number&#39; was not declared in this scope; } In the above example, MM is seemingly part of the namespace foo and therefore it should always know about foo::magic_number, but that’s not the case. If MM is used outside of foo, it won’t work. This means that to avoid potential issues with name lookups if you really want to use a macro, always fully qualify symbols in macros if they are public. 1 #define MM(X) (X * ::foo::magic_number) At the same time, we’d highly encourage anyone not using macros given that they are error-prone and with modern C++ techniques, there is barely any need for them. Oh, and I hope you didn’t even have the idea, but don’t use macros to create namespace aliases. 1 #define NS MyNamespace // Avoid using macros for this purpose Use internal linkage only in source files (SF.21, SF.22) When you have functions or variables that are not supposed to be used outside of a source file, give them internal linkage either by placing them in unnamed namespaces or by declaring them static. Don’t use these constructs in header files. There are various good reasons for avoiding that: Internal linkage is often used for implementation details. Let’s not expose implementation details via header files. The C++ One Definition Rule states that an entity should have only one definition in the entire program. When you include a header file with internal linkage in multiple source files, each translation unit gets its own version of the internal linkage entity. This can lead to violations of the ODR and result in linker errors. Avoid deep dependencies and use them together with physical separation of source files While organizing your code with namespaces is definitely a good idea, it matters how you do it. Just like with directories. If you end up having a too deep directory structure, it will become difficult to navigate, difficult to use and share paths. It’s similar with namespaces. Don’t have too deep nestings, names will be too long, your code will be difficult to read either because of the two long fully qualified names or because of the aliases and using declarations you’ll need to keep the code short. Based on experience, not having more than 3 levels of nested namespaces is a good solution. You might be tempted to follow your directory structure with the namespaces. I find it a good idea, even if they don’t follow exactly the same logic. If you organize your codebase around libraries and your namespaces help you identify the usage of your libraries, then dependency management becomes a little bit easier. Whenever you have to “open up” a foreign namespace (foreign to your current scope), you know that you’re dealing with a dependency that will both make your compilation longer and probably that will make your code recompile more frequently. So you can think about whether you really need that dependency or if there is a smarter way. But that’s beyond the scope of this article. What we should remember at this point is that use not too many nested namespaces and directories to organize your code and if they follow the organization of your deliverables, they will help you manage your dependencies. Conclusion In this article, we learned about namespaces. They help organise code in the first place and to have further options, there are also inline namespaces that really come in handy for versioning APIs. There are many best practices to keep in mind when it comes to using namespaces and related features. A big chunk of best practices is about avoiding namespace pollution. We should avoid using namespace declarations and even directives in the header as they are extending the enclosing namespaces. At the same time, we should not forget that namespaces are not the only way to organize code and we often use a physical separation as well by placing C++ code files into different directories. These different approaches should be used together in a coherent way to keep your codebase tidy both from a physical (file organization) and logical (namespace organization) standpoint. Connect deeper If you liked this article, please hit on the like button, subscribe to my newsletter and let’s connect on Twitter!","headline":"How to use your namespaces to their best","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices"},"url":"https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices"}</script><title>How to use your namespaces to their best | Sandor Dargo's Blog</title><link rel="shortcut icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="icon" href="/assets/img/favicons/favicon.ico" type="image/x-icon"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon.png"><link rel="apple-touch-icon" href="/assets/img/favicons/apple-icon-precomposed.png"><link rel="apple-touch-icon" sizes="57x57" href="/assets/img/favicons/apple-icon-57x57.png"><link rel="apple-touch-icon" sizes="60x60" href="/assets/img/favicons/apple-icon-60x60.png"><link rel="apple-touch-icon" sizes="72x72" href="/assets/img/favicons/apple-icon-72x72.png"><link rel="apple-touch-icon" sizes="76x76" href="/assets/img/favicons/apple-icon-76x76.png"><link rel="apple-touch-icon" sizes="114x114" href="/assets/img/favicons/apple-icon-114x114.png"><link rel="apple-touch-icon" sizes="120x120" href="/assets/img/favicons/apple-icon-120x120.png"><link rel="apple-touch-icon" sizes="144x144" href="/assets/img/favicons/apple-icon-144x144.png"><link rel="apple-touch-icon" sizes="152x152" href="/assets/img/favicons/apple-icon-152x152.png"><link rel="apple-touch-icon" sizes="180x180" href="/assets/img/favicons/apple-icon-180x180.png"><link rel="icon" type="image/png" sizes="192x192" href="/assets/img/favicons/android-icon-192x192.png"><link rel="icon" type="image/png" sizes="32x32" href="/assets/img/favicons/favicon-32x32.png"><link rel="icon" type="image/png" sizes="96x96" href="/assets/img/favicons/favicon-96x96.png"><link rel="icon" type="image/png" sizes="16x16" href="/assets/img/favicons/favicon-16x16.png"><link rel="manifest" href="/assets/img/favicons/manifest.json"><meta name='msapplication-config' content='/assets/img/favicons/browserconfig.xml'><meta name="msapplication-TileColor" content="#ffffff"><meta name="msapplication-TileImage" content="/assets/img/favicons/ms-icon-144x144.png"><meta name="theme-color" content="#ffffff"><link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://fonts.gstatic.com"><link rel="preconnect" href="https://www.google-analytics.com" crossorigin="use-credentials"><link rel="dns-prefetch" href="https://www.google-analytics.com"><link rel="preconnect" href="https://www.googletagmanager.com" crossorigin="anonymous"><link rel="dns-prefetch" href="https://www.googletagmanager.com"><link rel="preconnect" href="cdn.jsdelivr.net"><link rel="dns-prefetch" href="cdn.jsdelivr.net"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha256-LA89z+k9fjgMKQ/kq4OO2Mrf8VltYml/VES+Rg0fh20=" crossorigin="anonymous"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.11.2/css/all.min.css" integrity="sha256-+N4/V/SbAFiW1MPBCXnfnP9QSN3+Keu+NlB+0ev/YKQ=" crossorigin="anonymous"><link rel="stylesheet" href="/assets/css/style.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.css"> <script src="https://cdn.jsdelivr.net/npm/jquery@3/dist/jquery.min.js"></script> <script defer src="https://cdn.jsdelivr.net/combine/npm/popper.js@1.15.0,npm/bootstrap@4/dist/js/bootstrap.min.js"></script> <script defer src="/assets/js/dist/post.min.js"></script> <script defer src="/app.js"></script> <script defer src="https://www.googletagmanager.com/gtag/js?id=UA-89625019-1"></script> <script> document.addEventListener("DOMContentLoaded", function(event) { window.dataLayer = window.dataLayer || []; function gtag(){dataLayer.push(arguments);} gtag('js', new Date()); gtag('config', 'UA-89625019-1'); }); </script><body data-spy="scroll" data-target="#toc"><div id="sidebar" class="d-flex flex-column align-items-end"><div class="profile-wrapper text-center"><div id="avatar"> <a href="/" alt="avatar" class="mx-auto"> <img src="/assets/img/SANDOR_DARGO_ROUND.JPG" alt="avatar" onerror="this.style.display='none'"> </a></div><div class="site-title mt-3"> <a href="/">Sandor Dargo's Blog</a></div><div class="site-subtitle font-italic">On C++, software development and books</div></div><ul class="w-100"><li class="nav-item"> <a href="/" class="nav-link"> <i class="fa-fw fas fa-home ml-xl-3 mr-xl-3 unloaded"></i> <span>HOME</span> </a><li class="nav-item"> <a href="/tags/" class="nav-link"> <i class="fa-fw fas fa-tags ml-xl-3 mr-xl-3 unloaded"></i> <span>TAGS</span> </a><li class="nav-item"> <a href="/archives/" class="nav-link"> <i class="fa-fw fas fa-archive ml-xl-3 mr-xl-3 unloaded"></i> <span>ARCHIVES</span> </a><li class="nav-item"> <a href="/books/" class="nav-link"> <i class="fa-fw fas fa-book ml-xl-3 mr-xl-3 unloaded"></i> <span>BOOKS</span> </a><li class="nav-item"> <a href="/speaking/" class="nav-link"> <i class="fa-fw fas fa-microphone ml-xl-3 mr-xl-3 unloaded"></i> <span>SPEAKING</span> </a><li class="nav-item"> <a href="/dailycpp/" class="nav-link"> <i class="fa-fw fas fa-link ml-xl-3 mr-xl-3 unloaded"></i> <span>DAILY C++</span> </a><li class="nav-item"> <a href="/about/" class="nav-link"> <i class="fa-fw fas fa-info ml-xl-3 mr-xl-3 unloaded"></i> <span>HI...</span> </a></ul><ul class="w-100"><li class="nav-item"> <a href="https://www.patreon.com/sandordargo" class="nav-link"> <img src="https://c5.patreon.com/external/logo/become_a_patron_button.png"></a></ul><div class="sidebar-bottom mt-auto d-flex flex-wrap justify-content-center"> <a href="https://github.com/sandordargo" aria-label="github" class="order-3" target="_blank" rel="noopener"> <i class="fab fa-github-alt"></i> </a> <a href="https://twitter.com/SandorDargo" aria-label="twitter" class="order-4" target="_blank" rel="noopener"> <i class="fab fa-twitter"></i> </a> <a href=" javascript:location.href = 'mailto:' + ['sandor.dargo','gmail.com'].join('@')" aria-label="email" class="order-5" > <i class="fas fa-envelope"></i> </a> <a href="/feed.xml" aria-label="rss" class="order-6" > <i class="fas fa-rss"></i> </a> <span class="icon-border order-2"></span> <span id="mode-toggle-wrapper" class="order-1"> <i class="mode-toggle fas fa-adjust"></i> <script type="text/javascript"> class ModeToggle { static get MODE_KEY() { return "mode"; } static get DARK_MODE() { return "dark"; } static get LIGHT_MODE() { return "light"; } constructor() { if (this.hasMode) { if (this.isDarkMode) { if (!this.isSysDarkPrefer) { this.setDark(); } } else { if (this.isSysDarkPrefer) { this.setLight(); } } } var self = this; /* always follow the system prefers */ this.sysDarkPrefers.addListener(function() { if (self.hasMode) { if (self.isDarkMode) { if (!self.isSysDarkPrefer) { self.setDark(); } } else { if (self.isSysDarkPrefer) { self.setLight(); } } self.clearMode(); } self.updateMermaid(); }); } /* constructor() */ setDark() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.DARK_MODE); } setLight() { $('html').attr(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); sessionStorage.setItem(ModeToggle.MODE_KEY, ModeToggle.LIGHT_MODE); } clearMode() { $('html').removeAttr(ModeToggle.MODE_KEY); sessionStorage.removeItem(ModeToggle.MODE_KEY); } get sysDarkPrefers() { return window.matchMedia("(prefers-color-scheme: dark)"); } get isSysDarkPrefer() { return this.sysDarkPrefers.matches; } get isDarkMode() { return this.mode == ModeToggle.DARK_MODE; } get isLightMode() { return this.mode == ModeToggle.LIGHT_MODE; } get hasMode() { return this.mode != null; } get mode() { return sessionStorage.getItem(ModeToggle.MODE_KEY); } /* get the current mode on screen */ get modeStatus() { if (this.isDarkMode || (!this.hasMode && this.isSysDarkPrefer) ) { return ModeToggle.DARK_MODE; } else { return ModeToggle.LIGHT_MODE; } } updateMermaid() { if (typeof mermaid !== "undefined") { let expectedTheme = (this.modeStatus === ModeToggle.DARK_MODE? "dark" : "default"); let config = { theme: expectedTheme }; /* re-render the SVG › <https://github.com/mermaid-js/mermaid/issues/311#issuecomment-332557344> */ $(".mermaid").each(function() { let svgCode = $(this).prev().children().html(); $(this).removeAttr("data-processed"); $(this).html(svgCode); }); mermaid.initialize(config); mermaid.init(undefined, ".mermaid"); } } flipMode() { if (this.hasMode) { if (this.isSysDarkPrefer) { if (this.isLightMode) { this.clearMode(); } else { this.setLight(); } } else { if (this.isDarkMode) { this.clearMode(); } else { this.setDark(); } } } else { if (this.isSysDarkPrefer) { this.setLight(); } else { this.setDark(); } } this.updateMermaid(); } /* flipMode() */ } /* ModeToggle */ let toggle = new ModeToggle(); $(".mode-toggle").click(function() { toggle.flipMode(); }); </script> </span></div></div><div id="topbar-wrapper" class="row justify-content-center topbar-down"><div id="topbar" class="col-11 d-flex h-100 align-items-center justify-content-between"> <span id="breadcrumb"> <span> <a href="/blog"> Blog </a> </span> <span> <a href="/2023"> 2023 </a> </span> <span> <a href="/12"> 12 </a> </span> <span> <a href="/13"> 13 </a> </span> <span>How to use your namespaces to their best</span> </span> <i id="sidebar-trigger" class="fas fa-bars fa-fw"></i><div id="topbar-title"> Post</div><i id="search-trigger" class="fas fa-search fa-fw"></i> <span id="search-wrapper" class="align-items-center"> <i class="fas fa-search fa-fw"></i> <input class="form-control" id="search-input" type="search" aria-label="search" placeholder="Search..."> <i class="fa fa-times-circle fa-fw" id="search-cleaner"></i> </span> <span id="search-cancel" >Cancel</span></div></div><div id="main-wrapper"><div id="main"><div class="row"><div id="post-wrapper" class="col-12 col-lg-11 col-xl-8"><div class="post pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><h1 data-toc-skip>How to use your namespaces to their best</h1><div class="post-meta text-muted d-flex flex-column"><div> <span class="semi-bold"> Sandor Dargo </span> <span class="timeago " data-toggle="tooltip" data-placement="bottom" title="Wed, Dec 13, 2023, 12:00 AM +0100" prep="on" > Dec 13, 2023 <i class="unloaded">2023-12-13T00:00:00+01:00</i> </span></div><div> <span> <span class="timeago lastmod" data-toggle="tooltip" data-placement="bottom" title="Thu, Jun 19, 2025, 6:35 AM +0200" prefix="Updated " > Jun 19 <i class="unloaded">2025-06-19T06:35:16+02:00</i> </span> </span> <span class="readtime" data-toggle="tooltip" data-placement="bottom" title="2559 words">14 min</span></div></div><div class="post-content"><p>Today, we are not going to discuss any novelty of the language. Instead, we are going to discuss something old, something that we take for granted and probably something we don’t even think about a lot. We are going to discuss namespaces, what they are and what are the related best practices, including <em>some</em> of the recommendations of the <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines">Core Guidelines</a>.</p><h2 id="what-are-namespaces-in-the-first-place">What are namespaces in the first place?</h2><p>In C++, a <code class="language-plaintext highlighter-rouge">namespace</code> is a mechanism for organizing and encapsulating functions, variables, and types. Namespaces help prevent naming conflicts and make it easier to manage and maintain large codebases. They allow you to define a scope within which you can declare identifiers (such as variables, functions, and classes) without worrying about naming collisions with identifiers in other parts of your code.</p><p>Just like in the different classes, you can use methods or variables with the same name, in different namespaces, you can reuse the same symbol names.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

</pre></table></code></div></div><p>There is no problem with having <code class="language-plaintext highlighter-rouge">magic_number</code> declared and defined in both namespaces, those are two different variables. We can use them either by fully qualifying their name or by importing their symbols from their enclosing namespaces. More on that later.</p><h3 id="nested-namespaces">Nested namespaces</h3><p>Namespaces can also be nested and as you can see in the below example, since C++17 we have a shortcut to declare nested namespaces with the help of <code class="language-plaintext highlighter-rouge">::</code> so that we can save some typing.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">consts</span> <span class="p">{</span>
        <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">bar</span><span class="o">::</span><span class="n">consts</span> <span class="p">{</span>
    <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span>
<span class="p">}</span>


<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">bar</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><h3 id="a-rarely-used-namespace-feature-inline">A rarely used namespace feature: <code class="language-plaintext highlighter-rouge">inline</code></h3><p><code class="language-plaintext highlighter-rouge">inline</code> is an optional keyword that we can use alongside the <code class="language-plaintext highlighter-rouge">namespace</code> keyword. If a <code class="language-plaintext highlighter-rouge">namespace</code> is marked <code class="language-plaintext highlighter-rouge">inline</code>, then its members will be treated in many situations as if they are part of the enclosing namespace. Both the below calls are correct.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">consts</span> <span class="p">{</span>
        <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>The <code class="language-plaintext highlighter-rouge">inline</code> attribute of a namespace is transitive, so if within an <code class="language-plaintext highlighter-rouge">inline namespace</code> there is another one, you can use the most nested member with the outermost namespace. As you can see, using nested <code class="language-plaintext highlighter-rouge">inline</code> namespaces can lead to quite a mess.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
        <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">consts</span> <span class="p">{</span>
            <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>At least the compiler is aware of it and it doesn’t let us turn the situation into a run-time nightmare:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
        <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">consts</span> <span class="p">{</span>
            <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
&lt;source&gt;: In function 'int main()':
&lt;source&gt;:15:28: error: reference to 'magic_number' is ambiguous
   15 |     std::cout &lt;&lt; foo::bar::magic_number &lt;&lt; '\n';
      |                            ^~~~~~~~~~~~
...
&lt;source&gt;:17:23: error: reference to 'magic_number' is ambiguous
   17 |     std::cout &lt;&lt; foo::magic_number &lt;&lt; '\n';
      |                       ^~~~~~~~~~~~
*/</span>
</pre></table></code></div></div><p>Without the <code class="language-plaintext highlighter-rouge">inline</code> modifier, our code is perfectly valid:</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
        <span class="k">namespace</span> <span class="n">consts</span> <span class="p">{</span>
            <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
        <span class="p">}</span>
        <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">consts</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="c1">// ERROR: without inlining, we cannot use such "shortcuts"</span>
    <span class="c1">// std::cout &lt;&lt; foo::consts::magic_number &lt;&lt; '\n'; </span>
    <span class="c1">// std::cout &lt;&lt; foo::magic_number &lt;&lt; '\n';</span>
<span class="p">}</span>
<span class="cm">/*
42
3.14
*/</span>
</pre></table></code></div></div><p>In my 11 years of C++ journey, I never directly used <code class="language-plaintext highlighter-rouge">inline namespace</code>s and up until recently I haven’t even encountered them. I found them while I was looking for a solution to some kind of a versioning issue and apparently, this feature is mostly used for library versioning.</p><p>One can store the latest version of an API behind an <code class="language-plaintext highlighter-rouge">inline</code> nested namespace. Those who are on the latest version, they don’t have to use a version number. But those, who for some reason cannot migrate, they have the option to explicitly use an older version.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">namespace</span> <span class="n">v1</span> <span class="p">{</span>
        <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span> 
    <span class="p">}</span>
    <span class="kr">inline</span> <span class="k">namespace</span> <span class="n">v2</span> <span class="p">{</span>
        <span class="k">constexpr</span> <span class="kt">float</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mf">3.14</span><span class="p">;</span> 
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// using the latest version</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">v2</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// this also works</span>

    <span class="c1">// using an older version</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">v1</span><span class="o">::</span><span class="n">magic_number</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>
<span class="cm">/*
3.14
3.14
42
*/</span>
</pre></table></code></div></div><p>You can find more details about this feature <a href="https://www.foonathan.net/2018/11/inline-namespaces/">on Jonathan’s blog post called Inline Namespaces 101</a>.</p><p>Now let’s move on to discuss best practices.</p><h2 id="general-c-namespace-best-practices">General C++ namespace best practices</h2><p>Using a namespace in general to organize a codebase is already a best practice. With that in mind, we should minimize the use of the global namespace. Allowing code to reside in the global namespace can lead to naming conflicts and make code maintenance more difficult than it should be. Instead, encapsulate your code in (well-)named namespaces.</p><h3 id="what-names-to-use">What names to use?</h3><p>First of all, use meaningful and descriptive names for namespaces. Well-chosen namespace names make the code easier to understand and easier to maintain.</p><p>Then use a consistent style. A style that matches the rest of the project. If you are using something new, I recommend writing the namespace names in <em>snake_case</em> as that’s exactly what the standard library does (e.g. <code class="language-plaintext highlighter-rouge">std::literals::string_literals</code>) and that’s what the most widely used style guide, the <a href="https://google.github.io/styleguide/cppguide.html#Namespace_Names">Google Style Guide</a> recommends as well.</p><p>Try to avoid using abbreviations, unless they are evident. But more often than not even if you think that an abbreviation is straightforward, probably it’s not.</p><h3 id="use-using-declarations-as-much-as-you-need-but-only-in-cpp-files">Use <code class="language-plaintext highlighter-rouge">using</code> declarations as much as you need, but only in .cpp files</h3><p>The use of <em>namespace using directives</em> (e.g. <code class="language-plaintext highlighter-rouge">using namespace std;</code>) must be avoided in header files as <a href="https://godbolt.org/z/T9zsh3zha">they extend the surrounding namespace with the namespace being “used”</a>. This can lead to naming conflicts and ambiguous lookups.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
#include</span> <span class="cpf">&lt;string&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">std</span><span class="p">;</span>  <span class="c1">// #F</span>
    <span class="kt">void</span> <span class="n">func</span><span class="p">(</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// #D</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">func</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">s</span><span class="p">)</span> <span class="p">{.</span> <span class="c1">// #B</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"global func "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="n">bar</span> <span class="p">{</span>
    <span class="k">using</span> <span class="k">namespace</span> <span class="n">foo</span><span class="p">;</span> <span class="c1">// #C </span>

    <span class="kt">void</span> <span class="n">fun</span><span class="p">()</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">g</span><span class="p">{</span><span class="s">"oh no"</span><span class="p">};</span> <span class="c1">// #E</span>
        <span class="n">func</span><span class="p">(</span><span class="n">g</span><span class="p">);</span>  <span class="c1">// #A</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">bar</span><span class="o">::</span><span class="n">fun</span><span class="p">();</span>
<span class="p">}</span>
</pre></table></code></div></div><p>If you look at the above example, first it will fail at <em>#A</em>, because calling <code class="language-plaintext highlighter-rouge">func(std::string)</code> is ambiguous. It can be the global <code class="language-plaintext highlighter-rouge">func</code> (<em>#B</em>), but after having the <code class="language-plaintext highlighter-rouge">use namespace foo;</code> using namespace directive at <em>#C</em>, it could be <code class="language-plaintext highlighter-rouge">foo::func</code> as well (<em>#D</em>).</p><p>If we decide to remove <code class="language-plaintext highlighter-rouge">using namespace foo</code> at <em>#C</em>, we will face another compilation error, even earlier. <code class="language-plaintext highlighter-rouge">string g{"oh no}"</code> doesn’t compile anymore because by not using <code class="language-plaintext highlighter-rouge">foo</code>, we are not using <code class="language-plaintext highlighter-rouge">std</code> either (<em>#F</em>)…</p><p>Though using <em>namespace using directives</em> is not so much of a problem in a <code class="language-plaintext highlighter-rouge">.cpp</code> file, it’s still better to avoid it as it can make it difficult to figure out for the readers where certain symbols come from.</p><p>Instead of <em>using directives</em>, use <em>using declarations</em> (e.g., <code class="language-plaintext highlighter-rouge">using namespace foo::const_member::magic_number;</code>) to bring specific elements from a namespace into the current scope. This reduces ambiguity and clearly specifies which items you’re using. Still, only use this in <code class="language-plaintext highlighter-rouge">.cpp</code> files as just like using directives, they introduce the used namespace into the surrounding namespace and that might be propagated.</p><p>If you still do it in the header, limit the scope and never use it in the global namespaces.</p><p>What I write here is a bit stricter than what the Core Guidelines say at <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only">SF.6</a> and <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf6-use-using-namespace-directives-for-transition-for-foundation-libraries-such-as-std-or-within-a-local-scope-only">SF.7</a> as it mostly protects the global namespace, but I think it makes sense to go further and protect our user-defined namespaces as well - and that’s what we did in almost every project that I worked on.</p><h3 id="avoid-using-namespace-aliases-especially-in-header-files">Avoid using namespace aliases, especially in header files</h3><p>It’s tempting to use alias namespaces (<code class="language-plaintext highlighter-rouge">namespace foo::bar::baz = fbb;</code>) in order to simplify long or complex names, but do so sparingly. While it can make code more concise, overusing aliases can lead to ambiguity and confusion.</p><p>Like using directives and using declarations, aliases must also be avoided in header files, except in explicitly marked internal-only namespaces, because anything imported into a namespace in a header file becomes part of the public API exported by that file.</p><p>If alias namespaces are used in header files, we can easily end up with the same problem as namespaces try to solve: naming conflicts and ambiguity. If multiple namespaces or alias names are similar or if multiple aliases bring in the same names, it can lead to compilation errors and difficulties in determining the source of the referenced name.</p><p>Besides, namespace aliases can also hinder code maintainability. When alias names are cryptic or excessively used, it becomes challenging for developers to understand where identifiers are defined, which namespace they belong to, and the relationships between different parts of the code. Moreover, when the structure of namespaces changes, alias names may become misleading or incorrect. If you rely heavily on alias names, adapting to changes in the underlying namespaces can be cumbersome.</p><h3 id="always-fully-qualify-namespaces-in-preprocessor-macros">Always fully qualify namespaces in preprocessor macros</h3><p>While preprocessor macros seemingly might live within namespaces, that’s just a mirage. Macros are being replaced before the compilation and the preprocessor knows nothing about namespaces.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
</pre><td class="rouge-code"><pre><span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp">
</span>
<span class="k">namespace</span> <span class="n">foo</span> <span class="p">{</span>

    <span class="cp">#define MM(X) (X * magic_number)
</span>
    <span class="k">constexpr</span> <span class="kt">int</span> <span class="n">magic_number</span> <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">MM</span><span class="p">(</span><span class="n">x</span><span class="p">);}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">foo</span><span class="o">::</span><span class="n">bar</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">MM</span><span class="p">(</span><span class="mi">42</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span> <span class="c1">// error: 'magic_number' was not declared in this scope;</span>
<span class="p">}</span>
</pre></table></code></div></div><p>In the above example, <code class="language-plaintext highlighter-rouge">MM</code> is seemingly part of the namespace <code class="language-plaintext highlighter-rouge">foo</code> and therefore it should always know about <code class="language-plaintext highlighter-rouge">foo::magic_number</code>, but that’s not the case. If <code class="language-plaintext highlighter-rouge">MM</code> is used outside of <code class="language-plaintext highlighter-rouge">foo</code>, it won’t work.</p><p>This means that to avoid potential issues with name lookups if you really want to use a macro, always fully qualify symbols in macros if they are public.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define MM(X) (X * ::foo::magic_number)
</span></pre></table></code></div></div><p>At the same time, we’d highly encourage anyone <a href="https://arne-mertz.de/2019/03/macro-evil/">not using macros given that they are error-prone</a> and with modern C++ techniques, there is barely any need for them.</p><p>Oh, and I hope you didn’t even have the idea, but don’t use macros to create namespace aliases.</p><div class="language-cpp highlighter-rouge"><div class="highlight"><code><table class="rouge-table"><tbody><tr><td class="rouge-gutter gl"><pre class="lineno">1
</pre><td class="rouge-code"><pre><span class="cp">#define NS MyNamespace  // Avoid using macros for this purpose
</span></pre></table></code></div></div><h3 id="use-internal-linkage-only-in-source-files-sf21-sf22">Use internal linkage only in source files (<a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf21-dont-use-an-unnamed-anonymous-namespace-in-a-header">SF.21</a>, <a href="https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#sf22-use-an-unnamed-anonymous-namespace-for-all-internalnon-exported-entities">SF.22</a>)</h3><p>When you have functions or variables that are not supposed to be used outside of a source file, give them internal linkage either by placing them in unnamed namespaces or <a href="https://www.sandordargo.com/blog/2021/07/07/2-ways-to-use-static-with-functions-cpp">by declaring them <code class="language-plaintext highlighter-rouge">static</code></a>.</p><p>Don’t use these constructs in header files. There are various good reasons for avoiding that: Internal linkage is often used for implementation details. Let’s not expose implementation details via header files.</p><p>The <a href="https://en.wikipedia.org/wiki/One_Definition_Rule">C++ One Definition Rule</a> states that an entity should have only one definition in the entire program. When you include a header file with internal linkage in multiple source files, each translation unit gets its own version of the internal linkage entity. This can lead to violations of the ODR and result in linker errors.</p><h3 id="avoid-deep-dependencies-and-use-them-together-with-physical-separation-of-source-files">Avoid deep dependencies and use them together with physical separation of source files</h3><p>While organizing your code with namespaces is definitely a good idea, it matters how you do it. Just like with directories. If you end up having a too deep directory structure, it will become difficult to navigate, difficult to use and share paths. It’s similar with namespaces. Don’t have too deep nestings, names will be too long, your code will be difficult to read either because of the two long fully qualified names or because of the <em>aliases</em> and <em>using declarations</em> you’ll need to keep the code short.</p><p>Based on experience, not having more than 3 levels of nested namespaces is a good solution.</p><p>You might be tempted to follow your directory structure with the namespaces. I find it a good idea, even if they don’t follow exactly the same logic.</p><p>If you organize your codebase around libraries and your namespaces help you identify the usage of your libraries, then dependency management becomes a little bit easier. Whenever you have to “open up” a foreign namespace (foreign to your current scope), you know that you’re dealing with a dependency that will both make your compilation longer and probably that will make your code recompile more frequently. So you can think about whether you really need that dependency or if there is a smarter way. But that’s beyond the scope of this article.</p><p>What we should remember at this point is that use not too many nested namespaces and directories to organize your code and if they follow the organization of your deliverables, they will help you manage your dependencies.</p><h2 id="conclusion">Conclusion</h2><p>In this article, we learned about namespaces. They help organise code in the first place and to have further options, there are also inline namespaces that really come in handy for versioning APIs.</p><p>There are many best practices to keep in mind when it comes to using namespaces and related features. A big chunk of best practices is about avoiding namespace pollution. We should avoid using namespace declarations and even directives in the header as they are extending the enclosing namespaces.</p><p>At the same time, we should not forget that namespaces are not the only way to organize code and we often use a physical separation as well by placing C++ code files into different directories. These different approaches should be used together in a coherent way to keep your codebase tidy both from a physical (file organization) and logical (namespace organization) standpoint.</p><h2 id="connect-deeper">Connect deeper</h2><p>If you liked this article, please</p><ul><li>hit on the like button,<li><a href="http://eepurl.com/gvcv1j">subscribe to my newsletter</a><li>and let’s connect on <a href="https://twitter.com/SandorDargo">Twitter</a>!</ul><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a></div><div class="post-tail-wrapper text-muted"><div class="post-meta mb-3"> <i class="far fa-folder-open fa-fw mr-1"></i> <a href='/categories/dev/'>dev</a></div><div class="post-tags"> <i class="fa fa-tags fa-fw mr-1"></i> <a href="/tags/cpp/" class="post-tag no-text-decoration" >cpp</a> <a href="/tags/cpp23/" class="post-tag no-text-decoration" >cpp23</a> <a href="/tags/namespaces/" class="post-tag no-text-decoration" >namespaces</a> <a href="/tags/codeorganization/" class="post-tag no-text-decoration" >codeorganization</a></div><div class="post-tail-bottom d-flex justify-content-between align-items-center mt-3 pt-5 pb-2"><div class="license-wrapper"> This post is licensed under <a href="https://creativecommons.org/licenses/by/4.0/">CC BY 4.0</a> by the author.</div><a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a><div class="share-wrapper"> <a href="https://www.patreon.com/sandordargo" style="float: left; padding-left: 0;"><img src="data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" data-src="https://c5.patreon.com/external/logo/become_a_patron_button.png" style="float: left; padding-left: 0;"></a> <span class="share-label text-muted mr-1">Share</span> <span class="share-icons"> <a href="https://twitter.com/intent/tweet?text=How to use your namespaces to their best - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices" data-toggle="tooltip" data-placement="top" title="Twitter" target="_blank" rel="noopener" aria-label="Twitter"> <i class="fa-fw fab fa-twitter"></i> </a> <a href="https://www.facebook.com/sharer/sharer.php?title=How to use your namespaces to their best - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices" data-toggle="tooltip" data-placement="top" title="Facebook" target="_blank" rel="noopener" aria-label="Facebook"> <i class="fa-fw fab fa-facebook-square"></i> </a> <a href="https://telegram.me/share?text=How to use your namespaces to their best - Sandor Dargo's Blog&url=https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices" data-toggle="tooltip" data-placement="top" title="Telegram" target="_blank" rel="noopener" aria-label="Telegram"> <i class="fa-fw fab fa-telegram"></i> </a> <a href="https://news.ycombinator.com/submitlink?t=How to use your namespaces to their best - Sandor Dargo's Blog&u=https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices" data-toggle="tooltip" data-placement="top" title="HackerNews" target="_blank" rel="noopener" aria-label="HackerNews"> <i class="fa-fw fab fa-hacker-news"></i> </a> <i class="fa-fw fas fa-link small" onclick="copyLink()" data-toggle="tooltip" data-placement="top" title="Copy link"></i> </span></div></div></div></div></div><div id="panel-wrapper" class="col-xl-3 pl-2 text-muted topbar-down"><div class="access"><div id="access-lastmod" class="post"> <span>Recent Update</span><ul class="post-content pl-0 pb-1 ml-1 mt-2"><li><a href="/blog/2025/10/22/trip-report-budapest-cpp">Trip report: Budapest C++ - Breaking & Building C++</a><li><a href="/blog/2025/10/01/cpp26-optional-of-reference">C++26: std::optional&lt;T&amp;&gt;</a><li><a href="/blog/2025/09/24/trip-report-cppcon-2025">Trip report: CppCon 2025</a><li><a href="/blog/2025/07/23/format-your-own-type-part-1">Format your own type (Part 1)</a><li><a href="/blog/2025/07/02/cpponsea-trip-report">Trip report: C++ On Sea 2025</a></ul></div><div id="access-tags"> <span>Trending Tags</span><div class="d-flex flex-wrap mt-3 mb-1 mr-3"> <a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self-improvement</a> <a class="post-tag" href="/tags/management/">management</a></div></div></div><script src="https://cdn.jsdelivr.net/gh/afeld/bootstrap-toc@1.0.1/dist/bootstrap-toc.min.js"></script><div id="toc-wrapper" class="pl-0 pr-4 mb-5"> <span class="pl-3 pt-2 mb-2">Contents</span><nav id="toc" data-toggle="toc"></nav></div></div></div><div class="row"><div class="col-12 col-lg-11 col-xl-8"><div id="post-extend-wrapper" class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-md-4 pr-md-4"><div id="related-posts" class="mt-5 mb-2 mb-sm-4"><h3 class="pt-2 mt-1 mb-4 ml-1" data-toc-skip>Further Reading</h3><div class="card-deck mb-4"><div class="card"> <a href="/blog/2022/11/23/cpp23-changes-to-lambdas"><div class="card-body"> <span class="timeago small" > Nov 23, 2022 <i class="unloaded">2022-11-23T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: How lambdas are going to change?</h3><div class="text-muted small"><p> C++23 is coming soon and it will change how lambdas work in 3 different ways. They will not only become simpler in certain circumstances but they will be also aligned more with other features of th...</p></div></div></a></div><div class="card"> <a href="/blog/2022/11/30/cpp23-auto-and-decay-copy"><div class="card-body"> <span class="timeago small" > Nov 30, 2022 <i class="unloaded">2022-11-30T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: auto(x) and decay copy</h3><div class="text-muted small"><p> When I first saw auto I thought that woah, not so fast, how am I going to know the type of my variables? Then I started to understand that auto helps in so many different ways. It helps remove the ...</p></div></div></a></div><div class="card"> <a href="/blog/2022/12/07/inout_ptr-and-out_ptr"><div class="card-body"> <span class="timeago small" > Dec 7, 2022 <i class="unloaded">2022-12-07T00:00:00+01:00</i> </span><h3 class="pt-0 mt-1 mb-3" data-toc-skip>C++23: std::out_ptr and std::inout_ptr</h3><div class="text-muted small"><p> This week, let’s continue exploring the new world of C++23. We are going to discuss two new standard library functions and their outputs (std::out_ptr, std::inout_ptr), two new standard library typ...</p></div></div></a></div></div></div><div class="post-navigation d-flex justify-content-between"> <a href="/blog/2023/12/09/genghis-khan-by-jack-weatherford" class="btn btn-outline-primary" prompt="Older"><p>Genghis Khan And The Making Of The Modern World by Jack Weatherford</p></a> <a href="/blog/2023/12/16/psychology-of-money" class="btn btn-outline-primary" prompt="Newer"><p>The Psychology of Money: Timeless lessons on wealth, greed, and happiness by Morgan Housel</p></a></div><div id="disqus" class="pt-2 pb-2"><p class="text-center text-muted small pb-5"> Comments powered by <a href="https://disqus.com/">Disqus</a>.</p></div><script src="/assets/js/lib/jquery.disqusloader.min.js"></script> <script> const options = { scriptUrl: '//sandordargo-github-io.disqus.com/embed.js', disqusConfig: function() { this.page.title = 'How to use your namespaces to their best'; this.page.url = 'https://www.sandordargo.com/blog/2023/12/13/namespace-best-practices'; this.page.identifier = '/blog/2023/12/13/namespace-best-practices'; } }; $.disqusLoader('#disqus', options); </script></div></div></div><script type="text/javascript" src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script> <script type="text/javascript"> const imgs = document.querySelectorAll('.post-content img'); const observer = lozad(imgs); observer.observe(); </script><div id="amzn-assoc-ad-be5a767b-3346-40aa-bc00-2eff0ce33d2b"></div><script async src="//z-na.amazon-adsystem.com/widgets/onejs?MarketPlace=US&adInstanceId=be5a767b-3346-40aa-bc00-2eff0ce33d2b"></script> <script type="text/javascript" src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script> <script type="text/javascript" src="//downloads.mailchimp.com/js/signup-forms/popup/embed.js" data-dojo-config="usePlainJson: true, isDebug: false"></script><script type="text/javascript">require(["mojo/signup-forms/Loader"], function(L) { L.start({"baseUrl":"mc.us16.list-manage.com","uuid":"b073dbd5c29322302f59a8cd8","lid":"d26240427e"}) })</script><footer class="d-flex w-100 justify-content-center"><div class="d-flex justify-content-between align-items-center"><div class="footer-left"><p class="mb-0"> © 2025 <a href="https://twitter.com/SandorDargo">Sandor Dargo</a>. <span data-toggle="tooltip" data-placement="top" title="Except where otherwise noted, the blog posts on this site are licensed under the Creative Commons Attribution 4.0 International (CC BY 4.0) License by the author.">Some rights reserved.</span></p></div><div class="footer-right"><p class="mb-0"> Powered by <a href="https://jekyllrb.com" target="_blank" rel="noopener">Jekyll</a> with <a href="https://github.com/cotes2020/jekyll-theme-chirpy" target="_blank" rel="noopener">Chirpy</a> theme.</p></div></div></footer></div><div id="search-result-wrapper" class="d-flex justify-content-center unloaded"><div class="col-12 col-sm-11 post-content"><div id="search-hints"><h4 class="text-muted mb-4">Trending Tags</h4><a class="post-tag" href="/tags/cpp/">cpp</a> <a class="post-tag" href="/tags/books/">books</a> <a class="post-tag" href="/tags/watercooler/">watercooler</a> <a class="post-tag" href="/tags/career/">career</a> <a class="post-tag" href="/tags/tutorial/">tutorial</a> <a class="post-tag" href="/tags/cpp23/">cpp23</a> <a class="post-tag" href="/tags/stl/">stl</a> <a class="post-tag" href="/tags/algorithms/">algorithms</a> <a class="post-tag" href="/tags/self-improvement/">self improvement</a> <a class="post-tag" href="/tags/management/">management</a></div><div id="search-results" class="d-flex flex-wrap justify-content-center text-muted mt-3"></div></div></div></div><div id="mask"></div><a id="back-to-top" href="#" aria-label="back-to-top" class="btn btn-lg btn-box-shadow" role="button"> <i class="fas fa-angle-up"></i> </a> <script src="https://cdn.jsdelivr.net/npm/simple-jekyll-search@1.7.3/dest/simple-jekyll-search.min.js"></script> <script> SimpleJekyllSearch({ searchInput: document.getElementById('search-input'), resultsContainer: document.getElementById('search-results'), json: '/assets/js/data/search.json', searchResultTemplate: '<div class="pl-1 pr-1 pl-sm-2 pr-sm-2 pl-lg-4 pr-lg-4 pl-xl-0 pr-xl-0"> <a href="https://www.sandordargo.com{url}">{title}</a><div class="post-meta d-flex flex-column flex-sm-row text-muted mt-1 mb-1"> {categories} {tags}</div><p>{snippet}</p></div>', noResultsText: '<p class="mt-5">Oops! No result founds.</p>', templateMiddleware: function(prop, value, template) { if (prop === 'categories') { if (value === '') { return `${value}`; } else { return `<div class="mr-sm-4"><i class="far fa-folder fa-fw"></i>${value}</div>`; } } if (prop === 'tags') { if (value === '') { return `${value}`; } else { return `<div><i class="fa fa-tag fa-fw"></i>${value}</div>`; } } } }); </script>
